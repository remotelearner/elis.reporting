diff --git a/tag/lib.php b/tag/lib.php
index f6fe89a..2284a41 100644
--- a/tag/lib.php
+++ b/tag/lib.php
@@ -1,4 +1,19 @@
-<?php // $Id$
+<?php
+
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
 
 /**
  * Moodle tag library
@@ -28,11 +43,11 @@
  *
  * Tag set will create tags that need to be created.
  *
- * @version: $Id$
- * @licence http://www.gnu.org/copyleft/gpl.html GNU Public License
- * @package moodlecore
+ * @package    core
  * @subpackage tag
- * @see http://www.php.net/manual/en/function.rawurlencode.php
+ * @see http://www.php.net/manual/en/function.urlencode.php
+ * @copyright  2007 Luiz Cruz <luiz.laydner@gmail.com>
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
  */
 
 define('TAG_RETURN_ARRAY', 0);
@@ -47,8 +62,6 @@ define('TAG_RELATED_ALL', 0);
 define('TAG_RELATED_MANUAL', 1);
 define('TAG_RELATED_CORRELATED', 2);
 
-require_once($CFG->dirroot .'/tag/locallib.php');
-
 ///////////////////////////////////////////////////////
 /////////////////// PUBLIC TAG API ////////////////////
 
@@ -94,6 +107,10 @@ function tag_set($record_type, $record_id, $tags) {
         }
     }
 
+    if (empty($tags)) {
+        return true;
+    }
+
     foreach($tags as $ordering => $tag) {
         $tag = trim($tag);
         if (!$tag) {
@@ -173,10 +190,12 @@ function tag_set_delete($record_type, $record_id, $tag) {
  * @return true on success, false otherwise
  */
 function tag_type_set($tagid, $type) {
-    if ($tag = get_record('tag', 'id', $tagid, '', '', '', '', 'id')) {
-        $tag->tagtype = addslashes($type);
+    global $DB;
+
+    if ($tag = $DB->get_record('tag', array('id'=>$tagid), 'id')) {
+        $tag->tagtype = $type;
         $tag->timemodified = time();
-        return update_record('tag', $tag);
+        return $DB->update_record('tag', $tag);
     }
     return false;
 }
@@ -191,11 +210,13 @@ function tag_type_set($tagid, $type) {
  * @return true on success, false otherwise
  */
 function tag_description_set($tagid, $description, $descriptionformat) {
-    if ($tag = get_record('tag', 'id', $tagid, '', '', '', '', 'id')) {
-        $tag->description = addslashes($description);
-        $tag->descriptionformat = addslashes($descriptionformat);
+    global $DB;
+
+    if ($tag = $DB->get_record('tag', array('id'=>$tagid),'id')) {
+        $tag->description = $description;
+        $tag->descriptionformat = $descriptionformat;
         $tag->timemodified = time();
-        return update_record('tag', $tag);
+        return $DB->update_record('tag', $tag);
     }
     return false;
 }
@@ -217,50 +238,63 @@ function tag_description_set($tagid, $description, $descriptionformat) {
  *
  **/
 function tag_get($field, $value, $returnfields='id, name, rawname') {
+    global $DB;
+
     if ($field == 'name') {
-        $value = addslashes(moodle_strtolower($value));   // To cope with input that might just be wrong case
+        $value = moodle_strtolower($value);   // To cope with input that might just be wrong case
     }
-    return get_record('tag', $field, $value, '', '', '', '', $returnfields);
+    return $DB->get_record('tag', array($field=>$value), $returnfields);
 }
 
 
 /**
  * Get the array of db record of tags associated to a record (instances).  Use
  * tag_get_tags_csv to get the same information in a comma-separated string.
+ * This should really be called tag_get_tag_instances()
  *
  * @param string $record_type the record type for which we want to get the tags
  * @param int $record_id the record id for which we want to get the tags
  * @param string $type the tag type (either 'default' or 'official'). By default,
  *     all tags are returned.
+ * @param int $userid optional only required for course tagging
  * @return array the array of tags
  */
-function tag_get_tags($record_type, $record_id, $type=null) {
+function tag_get_tags($record_type, $record_id, $type=null, $userid=0) {
+    global $CFG, $DB;
 
-    global $CFG;
+    $params = array();
 
     if ($type) {
-        $type = "AND tg.tagtype = '$type'";
+        $sql_type = "AND tg.tagtype = :type";
+        $params['type'] = $type;
+    } else {
+        $sql_type = '';
+    }
+
+   $u = null;
+    if ($userid) {
+        $u =  "AND ti.tiuserid = :userid ";
+        $params['userid'] = $userid;
     }
 
+    $sql = "SELECT tg.id, tg.tagtype, tg.name, tg.rawname, tg.flag, ti.ordering
+              FROM {tag_instance} ti
+              JOIN {tag} tg ON tg.id = ti.tagid
+              WHERE ti.itemtype = :recordtype AND ti.itemid = :recordid $u $sql_type
+           ORDER BY ti.ordering ASC";
+    $params['recordtype'] = $record_type;
+    $params['recordid']   = $record_id;
+
     // if the fields in this query are changed, you need to do the same changes in tag_get_correlated_tags
-    $tags = get_records_sql("SELECT tg.id, tg.tagtype, tg.name, tg.rawname, tg.flag, ti.ordering ".
-        "FROM {$CFG->prefix}tag_instance ti INNER JOIN {$CFG->prefix}tag tg ON tg.id = ti.tagid ".
-        "WHERE ti.itemtype = '{$record_type}' AND ti.itemid = '{$record_id}' {$type} ".
-        "ORDER BY ti.ordering ASC");
+    return $DB->get_records_sql($sql, $params);
     // This version of the query, reversing the ON clause, "correctly" returns
     // a row with NULL values for instances that are still in the DB even though
     // the tag has been deleted.  This shouldn't happen, but if it did, using
     // this query could help "clean it up".  This causes bugs at this time.
-    //$tags = get_records_sql("SELECT ti.tagid, tg.tagtype, tg.name, tg.rawname, tg.flag, ti.ordering ".
-    //    "FROM {$CFG->prefix}tag_instance ti LEFT JOIN {$CFG->prefix}tag tg ON ti.tagid = tg.id ".
+    //$tags = $DB->get_records_sql("SELECT ti.tagid, tg.tagtype, tg.name, tg.rawname, tg.flag, ti.ordering ".
+    //    "FROM {tag_instance} ti LEFT JOIN {tag} tg ON ti.tagid = tg.id ".
     //    "WHERE ti.itemtype = '{$record_type}' AND ti.itemid = '{$record_id}' {$type} ".
     //    "ORDER BY ti.ordering ASC");
-
-    if (!$tags) {
-        return array();
-    } else {
-        return $tags;
-    }
 }
 
 /**
@@ -342,7 +376,8 @@ function tag_get_tags_ids($record_type, $record_id) {
  *     second parameter is null. No value for a key means the tag wasn't found.
  */
 function tag_get_id($tags, $return_value=null) {
-    global $CFG;
+    global $CFG, $DB;
+
     static $tag_id_cache = array();
 
     $return_an_int = false;
@@ -366,20 +401,25 @@ function tag_get_id($tags, $return_value=null) {
 
     $tags = array_values(tag_normalize($tags));
     foreach($tags as $key => $tag) {
-        $tags[$key] = addslashes(moodle_strtolower($tag));
+        $tags[$key] = moodle_strtolower($tag);
         $result[moodle_strtolower($tag)] = null; // key must exists : no value for a key means the tag wasn't found.
     }
-    $tag_string = "'". implode("', '", $tags) ."'";
 
-    if ($rs = get_recordset_sql("SELECT * FROM {$CFG->prefix}tag WHERE name in ({$tag_string}) order by name")) {
-        while ($record = rs_fetch_next_record($rs)) {
+    if (empty($tags)) {
+        return array();
+    }
+
+    list($tag_string, $params) = $DB->get_in_or_equal($tags);
+
+    $rs = $DB->get_recordset_sql("SELECT * FROM {tag} WHERE name $tag_string ORDER BY name", $params);
+    foreach ($rs as $record) {
             if ($return_value == TAG_RETURN_OBJECT) {
                 $result[$record->name] = $record;
             } else { // TAG_RETURN_ARRAY
                 $result[$record->name] = $record->id;
             }
         }
-    }
+    $rs->close();
 
     if ($return_an_int) {
         return array_pop($result);
@@ -456,6 +496,7 @@ function tag_get_related_tags_csv($related_tags, $html=TAG_RETURN_HTML) {
  * @return bool true on success, false otherwise
  */
 function tag_rename($tagid, $newrawname) {
+    global $DB;
 
     if (! $newrawname_clean = array_shift(tag_normalize($newrawname, TAG_CASE_ORIGINAL)) ) {
         return false;
@@ -473,10 +514,10 @@ function tag_rename($tagid, $newrawname) {
     }
 
     if ($tag = tag_get('id', $tagid, 'id, name, rawname')) {
-        $tag->rawname = addslashes($newrawname_clean);
-        $tag->name = addslashes($newname_clean);
+        $tag->rawname      = $newrawname_clean;
+        $tag->name         = $newname_clean;
         $tag->timemodified = time();
-        return update_record('tag', $tag);
+        return $DB->update_record('tag', $tag);
     }
     return false;
 }
@@ -489,21 +530,29 @@ function tag_rename($tagid, $newrawname) {
  * @return bool true on success, false otherwise
  */
 function tag_delete($tagids) {
+    global $DB;
 
     if (!is_array($tagids)) {
         $tagids = array($tagids);
     }
 
     $success = true;
+    $context = get_context_instance(CONTEXT_SYSTEM);
     foreach ($tagids as $tagid) {
         if (is_null($tagid)) { // can happen if tag doesn't exists
             continue;
         }
         // only delete the main entry if there were no problems deleting all the
         // instances - that (and the fact we won't often delete lots of tags)
-        // is the reason for not using delete_records_select()
-        if (delete_records('tag_instance', 'tagid', $tagid) && delete_records('tag_correlation', 'tagid', $tagid)) {
-            $success &= (bool) delete_records('tag', 'id', $tagid);
+        // is the reason for not using $DB->delete_records_select()
+        if ($DB->delete_records('tag_instance', array('tagid'=>$tagid)) && $DB->delete_records('tag_correlation', array('tagid' => $tagid))) {
+            $success &= (bool) $DB->delete_records('tag', array('id'=>$tagid));
+            // Delete all files associated with this tag
+            $fs = get_file_storage();
+            $files = $fs->get_area_files($context->id, 'tag', 'description', $tagid);
+            foreach ($files as $file) {
+                $file->delete();
+            }
         }
     }
 
@@ -520,15 +569,16 @@ function tag_delete($tagids) {
  * @return bool true on success, false otherwise
  */
 function tag_delete_instance($record_type, $record_id, $tagid) {
-    global $CFG;
+    global $CFG, $DB;
 
-    if ( delete_records('tag_instance', 'tagid', $tagid, 'itemtype', $record_type, 'itemid', $record_id) ) {
-        if ( !record_exists_sql("SELECT tg.id ".
-                                  "FROM {$CFG->prefix}tag tg ".
-                                 "WHERE tg.id = $tagid AND ( tg.tagtype = 'official' OR ".
+    if ($DB->delete_records('tag_instance', array('tagid'=>$tagid, 'itemtype'=>$record_type, 'itemid'=>$record_id))) {
+        if (!$DB->record_exists_sql("SELECT * ".
+                                      "FROM {tag} tg ".
+                                     "WHERE tg.id = ? AND ( tg.tagtype = 'official' OR ".
                                     "EXISTS (SELECT 1
-                                               FROM {$CFG->prefix}tag_instance ti
-                                              WHERE ti.tagid=$tagid) )") ) {
+                                                   FROM {tag_instance} ti
+                                                  WHERE ti.tagid = ?) )",
+                                     array($tagid, $tagid))) {
             return tag_delete($tagid);
         }
     } else {
@@ -584,8 +634,7 @@ function tag_display_name($tagobject, $html=TAG_RETURN_HTML) {
  * @return array of matching objects, indexed by record id, from the table containing the type requested
  */
 function tag_find_records($tag, $type, $limitfrom='', $limitnum='') {
-
-    global $CFG;
+    global $CFG, $DB;
 
     if (!$tag || !$type) {
         return array();
@@ -593,11 +642,12 @@ function tag_find_records($tag, $type, $limitfrom='', $limitnum='') {
 
     $tagid = tag_get_id($tag);
 
-    $query = "SELECT it.* ".
-        "FROM {$CFG->prefix}{$type} it INNER JOIN {$CFG->prefix}tag_instance tt ON it.id = tt.itemid ".
-        "WHERE tt.itemtype = '{$type}' AND tt.tagid = '{$tagid}'";
+    $query = "SELECT it.*
+                FROM {".$type."} it INNER JOIN {tag_instance} tt ON it.id = tt.itemid
+               WHERE tt.itemtype = ? AND tt.tagid = ?";
+    $params = array($type, $tagid);
 
-    return get_records_sql($query, $limitfrom, $limitnum);
+    return $DB->get_records_sql($query, $params, $limitfrom, $limitnum);
 }
 
 
@@ -618,9 +668,7 @@ function tag_find_records($tag, $type, $limitfrom='', $limitnum='') {
  *     Any boolean false in the array indicates an error while adding the tag.
  */
 function tag_add($tags, $type="default") {
-    global $USER;
-
-    require_capability('moodle/tag:create', get_context_instance(CONTEXT_SYSTEM));
+    global $USER, $DB;
 
     if (!is_array($tags)) {
         $tags = array($tags);
@@ -641,11 +689,11 @@ function tag_add($tags, $type="default") {
         } else {
             // note that the difference between rawname and name is only
             // capitalization : the rawname is NOT the same at the rawtag.
-            $tag_object->rawname = addslashes($tag);
+            $tag_object->rawname = $tag;
             $tag_name_lc = moodle_strtolower($tag);
-            $tag_object->name = addslashes($tag_name_lc);
+            $tag_object->name    = $tag_name_lc;
             //var_dump($tag_object);
-            $tags_ids[$tag_name_lc] = insert_record('tag', $tag_object);
+            $tags_ids[$tag_name_lc] = $DB->insert_record('tag', $tag_object);
         }
     }
 
@@ -660,16 +708,16 @@ function tag_add($tags, $type="default") {
  * @param int $record_id the id of the record that will be tagged
  * @param string $tagid the tag id to set on the record.
  * @param int $ordering the order of the instance for this record
+ * @param int $userid optional only required for course tagging
  * @return bool true on success, false otherwise
  */
-function tag_assign($record_type, $record_id, $tagid, $ordering) {
-
-    require_capability('moodle/tag:create', get_context_instance(CONTEXT_SYSTEM));
+function tag_assign($record_type, $record_id, $tagid, $ordering, $userid = 0) {
+    global $DB;
 
-    if ( $tag_instance_object = get_record('tag_instance', 'tagid', $tagid, 'itemtype', $record_type, 'itemid', $record_id, 'id') ) {
+    if ( $tag_instance_object = $DB->get_record('tag_instance', array('tagid'=>$tagid, 'itemtype'=>$record_type, 'itemid'=>$record_id, 'tiuserid'=>$userid), 'id')) {
         $tag_instance_object->ordering = $ordering;
         $tag_instance_object->timemodified = time();
-        return update_record('tag_instance', $tag_instance_object);
+        return $DB->update_record('tag_instance', $tag_instance_object);
     } else {
         $tag_instance_object = new StdClass;
         $tag_instance_object->tagid = $tagid;
@@ -677,7 +725,8 @@ function tag_assign($record_type, $record_id, $tagid, $ordering) {
         $tag_instance_object->itemtype = $record_type;
         $tag_instance_object->ordering = $ordering;
         $tag_instance_object->timemodified = time();
-        return insert_record('tag_instance', $tag_instance_object);
+        $tag_instance_object->tiuserid     = $userid;
+        return $DB->insert_record('tag_instance', $tag_instance_object);
     }
 }
 
@@ -688,8 +737,10 @@ function tag_assign($record_type, $record_id, $tagid, $ordering) {
  * @return mixed an array of objects, or false if no records were found or an error occured.
  */
 function tag_autocomplete($text) {
-    global $CFG;
-    return get_records_sql("SELECT tg.id, tg.name, tg.rawname FROM {$CFG->prefix}tag tg WHERE tg.name LIKE '". moodle_strtolower($text) ."%'");
+    global $DB;
+    return $DB->get_records_sql("SELECT tg.id, tg.name, tg.rawname
+                                   FROM {tag} tg
+                                  WHERE tg.name LIKE ?", array(moodle_strtolower($text)."%"));
 }
 
 /**
@@ -701,26 +752,26 @@ function tag_autocomplete($text) {
  * function to call: don't run at peak time.
  */
 function tag_cleanup() {
-    global $CFG;
+    global $DB;
 
-    $instances = get_recordset('tag_instance');
+    $instances = $DB->get_recordset('tag_instance');
 
     // cleanup tag instances
-    while ($instance = rs_fetch_next_record($instances)) {
+    foreach ($instances as $instance) {
         $delete = false;
 
-        if (!record_exists('tag', 'id', $instance->tagid)) {
+        if (!$DB->record_exists('tag', array('id'=>$instance->tagid))) {
             // if the tag has been removed, instance should be deleted.
             $delete = true;
         } else {
             switch ($instance->itemtype) {
                 case 'user': // users are marked as deleted, but not actually deleted
-                    if (record_exists('user', 'id', $instance->itemid, 'deleted', 1)) {
+                    if ($DB->record_exists('user', array('id'=>$instance->itemid, 'deleted'=>1))) {
                         $delete = true;
                     }
                     break;
                 default: // anything else, if the instance is not there, delete.
-                    if (!record_exists($instance->itemtype, 'id', $instance->itemid)) {
+                    if (!$DB->record_exists($instance->itemtype, array('id'=>$instance->itemid))) {
                         $delete = true;
                     }
                     break;
@@ -731,20 +782,26 @@ function tag_cleanup() {
             //debugging('deleting tag_instance #'. $instance->id .', linked to tag id #'. $instance->tagid, DEBUG_DEVELOPER);
         }
     }
-    rs_close($instances);
+    $instances->close();
 
     // TODO: this will only clean tags of type 'default'.  This is good as
     // it won't delete 'official' tags, but the day we get more than two
     // types, we need to fix this.
-    $unused_tags = get_recordset_sql("SELECT tg.id FROM {$CFG->prefix}tag tg WHERE tg.tagtype = 'default' AND NOT EXISTS (".
-        "SELECT 'x' FROM {$CFG->prefix}tag_instance ti WHERE ti.tagid = tg.id)");
+    $unused_tags = $DB->get_recordset_sql("SELECT tg.id
+                                             FROM {tag} tg
+                                            WHERE tg.tagtype = 'default'
+                                                  AND NOT EXISTS (
+                                                      SELECT 'x'
+                                                        FROM {tag_instance} ti
+                                                       WHERE ti.tagid = tg.id
+                                                  )");
 
     // cleanup tags
-    while ($unused_tag = rs_fetch_next_record($unused_tags)) {
+    foreach ($unused_tags as $unused_tag) {
         tag_delete($unused_tag->id);
         //debugging('deleting unused tag #'. $unused_tag->id,  DEBUG_DEVELOPER);
     }
-    rs_close($unused_tags);
+    $unused_tags->close();
 }
 
 /**
@@ -758,12 +815,14 @@ function tag_cleanup() {
  * It works as a cache for a potentially heavy load query done at the 'tag_instance' table.
  * So, the 'tag_correlation' table stores redundant information derived from the 'tag_instance' table.
  *
- * @param number $mincorrelation cutoff percentage (optional, default is 2)
+ * @global moodle_database $DB
+ * @param int $mincorrelation Only tags with more than $mincorrelation correlations will
+ *                             be identified.
+ * @return void
  */
 function tag_compute_correlations($mincorrelation = 2) {
-    global $CFG;
+    global $DB;
 
-    $mincorrelation = (int)$mincorrelation;
     // This mighty one line query fetches a row from the database for every
     // individual tag correlation. We then need to process the rows collecting
     // the correlations for each tag id.
@@ -774,17 +833,17 @@ function tag_compute_correlations($mincorrelation = 2) {
     //   correlationid : This is the id of the row in the tag_correlation table that
     //                   relates to the tagid field and will be NULL if there are no
     //                   existing correlations
-    $sql = "SELECT pairs.tagid, pairs.correlation, pairs.ocurrences, co.id AS correlationid
+    $sql = 'SELECT pairs.tagid, pairs.correlation, pairs.ocurrences, co.id AS correlationid
               FROM (
                        SELECT ta.tagid, tb.tagid AS correlation, COUNT(*) AS ocurrences
-                         FROM {$CFG->prefix}tag_instance ta
-                         JOIN {$CFG->prefix}tag_instance tb ON (ta.itemtype = tb.itemtype AND ta.itemid = tb.itemid AND ta.tagid <> tb.tagid)
+                         FROM {tag_instance} ta
+                         JOIN {tag_instance} tb ON (ta.itemtype = tb.itemtype AND ta.itemid = tb.itemid AND ta.tagid <> tb.tagid)
                      GROUP BY ta.tagid, tb.tagid
-                       HAVING COUNT(*) > $mincorrelation
+                       HAVING COUNT(*) > :mincorrelation
                    ) pairs
-         LEFT JOIN {$CFG->prefix}tag_correlation co ON co.tagid = pairs.tagid
-          ORDER BY pairs.tagid ASC, pairs.ocurrences DESC, pairs.correlation ASC";
-    $rs = get_recordset_sql($sql);
+         LEFT JOIN {tag_correlation} co ON co.tagid = pairs.tagid
+          ORDER BY pairs.tagid ASC, pairs.ocurrences DESC, pairs.correlation ASC';
+    $rs = $DB->get_recordset_sql($sql, array('mincorrelation' => $mincorrelation));
 
     // Set up an empty tag correlation object
     $tagcorrelation = new stdClass;
@@ -792,15 +851,16 @@ function tag_compute_correlations($mincorrelation = 2) {
     $tagcorrelation->tagid = null;
     $tagcorrelation->correlatedtags = array();
 
-    // We store each correction id in this array so we can remove any correlations
+    // We store each correlation id in this array so we can remove any correlations
     // that no longer exist.
     $correlations = array();
 
     // Iterate each row of the result set and build them into tag correlations.
-    while ($row = rs_fetch_next_record($rs)) {
+    // We add all of a tag's correlations to $tagcorrelation->correlatedtags[]
+    // then save the $tagcorrelation object
+    foreach ($rs as $row) {
         if ($row->tagid != $tagcorrelation->tagid) {
-            // The tag id has changed so its now time to process the tag
-            // correlation information we have.
+            // The tag id has changed so we have all of the correlations for this tag
             $tagcorrelationid = tag_process_computed_correlation($tagcorrelation);
             if ($tagcorrelationid) {
                 $correlations[] = $tagcorrelationid;
@@ -812,6 +872,7 @@ function tag_compute_correlations($mincorrelation = 2) {
             $tagcorrelation->tagid = $row->tagid;
             $tagcorrelation->correlatedtags = array();
         }
+        //Save the correlation on the tag correlation object
         $tagcorrelation->correlatedtags[] = $row->correlation;
     }
     // Update the current correlation after the last record.
@@ -820,15 +881,17 @@ function tag_compute_correlations($mincorrelation = 2) {
         $correlations[] = $tagcorrelationid;
     }
 
+
     // Close the recordset
-    rs_close($rs);
+    $rs->close();
 
     // Remove any correlations that weren't just identified
     if (empty($correlations)) {
-        //there are no correlations so delete any in the database
-        delete_records('tag_correlation');
+        //there are no tag correlations
+        $DB->delete_records('tag_correlation');
     } else {
-        delete_records_select('tag_correlation', 'id NOT IN ('.join(',', $correlations).')');
+        list($sql, $params) = $DB->get_in_or_equal($correlations, SQL_PARAMS_NAMED, 'param0000', false);
+        $DB->delete_records_select('tag_correlation', 'id '.$sql, $params);
     }
 }
 
@@ -842,23 +905,21 @@ function tag_compute_correlations($mincorrelation = 2) {
  * @param stdClass $tagcorrelation
  * @return int The id of the tag correlation that was just processed.
  */
-function tag_process_computed_correlation($tagcorrelation) {
+function tag_process_computed_correlation(stdClass $tagcorrelation) {
+    global $DB;
 
     // You must provide a tagid and correlatedtags must be set and be an array
     if (empty($tagcorrelation->tagid) || !isset($tagcorrelation->correlatedtags) || !is_array($tagcorrelation->correlatedtags)) {
         return false;
     }
 
-    // The row tagid doesn't match the current tag id which means we are onto
-    // the next tag. Before we switch over we need to either insert or update
-    // the correlation.
     $tagcorrelation->correlatedtags = join(',', $tagcorrelation->correlatedtags);
     if (!empty($tagcorrelation->id)) {
         // The tag correlation already exists so update it
-        update_record('tag_correlation', $tagcorrelation);
+        $DB->update_record('tag_correlation', $tagcorrelation);
     } else {
         // This is a new correlation to insert
-        $tagcorrelation->id = insert_record('tag_correlation', $tagcorrelation, true);
+        $tagcorrelation->id = $DB->insert_record('tag_correlation', $tagcorrelation);
     }
     return $tagcorrelation->id;
 }
@@ -881,23 +942,23 @@ function tag_cron() {
  * @return mixed an array of objects, or false if no records were found or an error occured.
  */
 function tag_find_tags($text, $ordered=true, $limitfrom='', $limitnum='') {
+    global $DB;
 
-    global $CFG;
-
-    $text = addslashes(array_shift(tag_normalize($text, TAG_CASE_LOWER)));
+    $text = array_shift(tag_normalize($text, TAG_CASE_LOWER));
 
     if ($ordered) {
-        $query = "SELECT tg.id, tg.name, tg.rawname, COUNT(ti.id) AS count ".
-            "FROM {$CFG->prefix}tag tg LEFT JOIN {$CFG->prefix}tag_instance ti ON tg.id = ti.tagid ".
-            "WHERE tg.name LIKE '%{$text}%' ".
-            "GROUP BY tg.id, tg.name, tg.rawname ".
-            "ORDER BY count DESC";
+        $query = "SELECT tg.id, tg.name, tg.rawname, COUNT(ti.id) AS count
+                    FROM {tag} tg LEFT JOIN {tag_instance} ti ON tg.id = ti.tagid
+                   WHERE tg.name LIKE ?
+                GROUP BY tg.id, tg.name, tg.rawname
+                ORDER BY count DESC";
     } else {
-        $query = "SELECT tg.id, tg.name, tg.rawname ".
-            "FROM {$CFG->prefix}tag tg ".
-            "WHERE tg.name LIKE '%{$text}%'";
+        $query = "SELECT tg.id, tg.name, tg.rawname
+                    FROM {tag} tg
+                   WHERE tg.name LIKE ?";
     }
-    return get_records_sql($query, $limitfrom , $limitnum);
+    $params = array("%{$text}%");
+    return $DB->get_records_sql($query, $params, $limitfrom , $limitnum);
 }
 
 /**
@@ -907,22 +968,20 @@ function tag_find_tags($text, $ordered=true, $limitfrom='', $limitnum='') {
  * @return mixed string name of one tag, or id-indexed array of strings
  */
 function tag_get_name($tagids) {
+    global $DB;
 
-    $return_a_string = false;
-    if ( !is_array($tagids) ) {
-        $return_a_string = true;
-        $tagids = array($tagids);
+    if (!is_array($tagids)) {
+        if ($tag = $DB->get_record('tag', array('id'=>$tagids))) {
+            return $tag->name;
+        }
+        return false;
     }
 
     $tag_names = array();
-    foreach(get_records_list('tag', 'id', implode(',', $tagids)) as $tag) {
+    foreach($DB->get_records_list('tag', 'id', $tagids) as $tag) {
         $tag_names[$tag->id] = $tag->name;
     }
 
-    if ($return_a_string) {
-        return array_pop($tag_names);
-    }
-
     return $tag_names;
 }
 
@@ -935,20 +994,20 @@ function tag_get_name($tagids) {
  * @return array an array of tag objects, empty if no correlated tags are found
  */
 function tag_get_correlated($tag_id, $limitnum=null) {
-    global $CFG;
+    global $DB;
 
-    $tag_correlation = get_record('tag_correlation', 'tagid', $tag_id);
+    $tag_correlation = $DB->get_record('tag_correlation', array('tagid'=>$tag_id));
 
     if (!$tag_correlation || empty($tag_correlation->correlatedtags)) {
         return array();
     }
 
     // this is (and has to) return the same fields as the query in tag_get_tags
-    $sql = "SELECT tg.id, tg.tagtype, tg.name, tg.rawname, tg.flag, ti.ordering
-              FROM {$CFG->prefix}tag tg
-        INNER JOIN {$CFG->prefix}tag_instance ti ON tg.id = ti.tagid
+    $sql = "SELECT DISTINCT tg.id, tg.tagtype, tg.name, tg.rawname, tg.flag, ti.ordering
+              FROM {tag} tg
+        INNER JOIN {tag_instance} ti ON tg.id = ti.tagid
              WHERE tg.id IN ({$tag_correlation->correlatedtags})";
-    $result = get_records_sql($sql);
+    $result = $DB->get_records_sql($sql);
     if (!$result) {
         return array();
     }
@@ -1003,7 +1062,8 @@ function tag_normalize($rawtags, $case = TAG_CASE_LOWER) {
  * @return int number of mathing tags.
  */
 function tag_record_count($record_type, $tagid) {
-    return count_records('tag_instance', 'itemtype', $record_type, 'tagid', $tagid);
+    global $DB;
+    return $DB->count_records('tag_instance', array('itemtype'=>$record_type, 'tagid'=>$tagid));
 }
 
 /**
@@ -1015,8 +1075,9 @@ function tag_record_count($record_type, $tagid) {
  * @return bool true if it is tagged, false otherwise
  */
 function tag_record_tagged_with($record_type, $record_id, $tag) {
+    global $DB;
     if ($tagid = tag_get_id($tag)) {
-        return count_records('tag_instance', 'itemtype', $record_type, 'itemid', $record_id, 'tagid', $tagid);
+        return $DB->count_records('tag_instance', array('itemtype'=>$record_type, 'itemid'=>$record_id, 'tagid'=>$tagid));
     } else {
         return 0; // tag doesn't exist
     }
@@ -1029,14 +1090,14 @@ function tag_record_tagged_with($record_type, $record_id, $tag) {
  * @return void
  */
 function tag_set_flag($tagids) {
-    if ( !is_array($tagids) ) {
-        $tagids = array($tagids);
-    }
+    global $DB;
+
+    $tagids = (array)$tagids;
     foreach ($tagids as $tagid) {
-        $tag = get_record('tag', 'id', $tagid, '', '', '', '', 'id, flag');
+        $tag = $DB->get_record('tag', array('id'=>$tagid), 'id, flag');
         $tag->flag++;
         $tag->timemodified = time();
-        update_record('tag', $tag);
+        $DB->update_record('tag', $tag);
     }
 }
 
@@ -1047,13 +1108,27 @@ function tag_set_flag($tagids) {
  * @return bool true if function succeeds, false otherwise
  */
 function tag_unset_flag($tagids) {
-    global $CFG;
+    global $DB;
 
     if ( is_array($tagids) ) {
         $tagids = implode(',', $tagids);
     }
     $timemodified = time();
-    return execute_sql("UPDATE {$CFG->prefix}tag SET flag = 0, timemodified = $timemodified WHERE id IN ($tagids)", false);
+    return $DB->execute("UPDATE {tag} SET flag = 0, timemodified = ? WHERE id IN ($tagids)", array($timemodified));
 }
 
-?>
+
+/**
+ * Return a list of page types
+ * @param string $pagetype current page type
+ * @param stdClass $parentcontext Block's parent context
+ * @param stdClass $currentcontext Current context of block
+ */
+function tag_page_type_list($pagetype, $parentcontext, $currentcontext) {
+    return array(
+        'tag-*'=>get_string('page-tag-x', 'tag'),
+        'tag-index'=>get_string('page-tag-index', 'tag'),
+        'tag-search'=>get_string('page-tag-search', 'tag'),
+        'tag-manage'=>get_string('page-tag-manage', 'tag')
+    );
+}
