diff --git a/lib/grade/grade_category.php b/lib/grade/grade_category.php
index e4b52cc..abe6120 100644
--- a/lib/grade/grade_category.php
+++ b/lib/grade/grade_category.php
@@ -1,152 +1,162 @@
-<?php // $Id$
-
-///////////////////////////////////////////////////////////////////////////
-//                                                                       //
-// NOTICE OF COPYRIGHT                                                   //
-//                                                                       //
-// Moodle - Modular Object-Oriented Dynamic Learning Environment         //
-//          http://moodle.com                                            //
-//                                                                       //
-// Copyright (C) 1999 onwards Martin Dougiamas  http://dougiamas.com     //
-//                                                                       //
-// This program is free software; you can redistribute it and/or modify  //
-// it under the terms of the GNU General Public License as published by  //
-// the Free Software Foundation; either version 2 of the License, or     //
-// (at your option) any later version.                                   //
-//                                                                       //
-// This program is distributed in the hope that it will be useful,       //
-// but WITHOUT ANY WARRANTY; without even the implied warranty of        //
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
-// GNU General Public License for more details:                          //
-//                                                                       //
-//          http://www.gnu.org/copyleft/gpl.html                         //
-//                                                                       //
-///////////////////////////////////////////////////////////////////////////
+<?php
+
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+/**
+ * Definitions of constants for gradebook
+ *
+ * @package    core
+ * @subpackage grade
+ * @copyright  2006 Nicolas Connault
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
 
 require_once('grade_object.php');
 
+/**
+ * Grade_Category is an object mapped to DB table {prefix}grade_categories
+ *
+ * @package    moodlecore
+ * @subpackage grade
+ * @copyright  2007 Nicolas Connault
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
 class grade_category extends grade_object {
     /**
      * The DB table.
      * @var string $table
      */
-    var $table = 'grade_categories';
+    public $table = 'grade_categories';
 
     /**
      * Array of required table fields, must start with 'id'.
      * @var array $required_fields
      */
-    var $required_fields = array('id', 'courseid', 'parent', 'depth', 'path', 'fullname', 'aggregation',
+    public $required_fields = array('id', 'courseid', 'parent', 'depth', 'path', 'fullname', 'aggregation',
                                  'keephigh', 'droplow', 'aggregateonlygraded', 'aggregateoutcomes',
-                                 'aggregatesubcats', 'timecreated', 'timemodified');
+                                 'aggregatesubcats', 'timecreated', 'timemodified', 'hidden');
 
     /**
      * The course this category belongs to.
      * @var int $courseid
      */
-    var $courseid;
+    public $courseid;
 
     /**
      * The category this category belongs to (optional).
      * @var int $parent
      */
-    var $parent;
+    public $parent;
 
     /**
      * The grade_category object referenced by $this->parent (PK).
      * @var object $parent_category
      */
-    var $parent_category;
+    public $parent_category;
 
     /**
      * The number of parents this category has.
      * @var int $depth
      */
-    var $depth = 0;
+    public $depth = 0;
 
     /**
      * Shows the hierarchical path for this category as /1/2/3/ (like course_categories), the last number being
      * this category's autoincrement ID number.
      * @var string $path
      */
-    var $path;
+    public $path;
 
     /**
      * The name of this category.
      * @var string $fullname
      */
-    var $fullname;
+    public $fullname;
 
     /**
      * A constant pointing to one of the predefined aggregation strategies (none, mean, median, sum etc) .
      * @var int $aggregation
      */
-    var $aggregation = GRADE_AGGREGATE_MEAN;
+    public $aggregation = GRADE_AGGREGATE_MEAN;
 
     /**
      * Keep only the X highest items.
      * @var int $keephigh
      */
-    var $keephigh = 0;
+    public $keephigh = 0;
 
     /**
      * Drop the X lowest items.
      * @var int $droplow
      */
-    var $droplow = 0;
+    public $droplow = 0;
 
     /**
      * Aggregate only graded items
      * @var int $aggregateonlygraded
      */
-    var $aggregateonlygraded = 0;
+    public $aggregateonlygraded = 0;
 
     /**
      * Aggregate outcomes together with normal items
      * @var int $aggregateoutcomes
      */
-    var $aggregateoutcomes = 0;
+    public $aggregateoutcomes = 0;
 
     /**
      * Ignore subcategories when aggregating
      * @var int $aggregatesubcats
      */
-    var $aggregatesubcats = 0;
+    public $aggregatesubcats = 0;
 
     /**
      * Array of grade_items or grade_categories nested exactly 1 level below this category
      * @var array $children
      */
-    var $children;
+    public $children;
 
     /**
      * A hierarchical array of all children below this category. This is stored separately from
      * $children because it is more memory-intensive and may not be used as often.
      * @var array $all_children
      */
-    var $all_children;
+    public $all_children;
 
     /**
      * An associated grade_item object, with itemtype=category, used to calculate and cache a set of grade values
      * for this category.
      * @var object $grade_item
      */
-    var $grade_item;
+    public $grade_item;
 
     /**
      * Temporary sortorder for speedup of children resorting
      */
-    var $sortorder;
+    public $sortorder;
 
     /**
      * List of options which can be "forced" from site settings.
      */
-    var $forceable = array('aggregation', 'keephigh', 'droplow', 'aggregateonlygraded', 'aggregateoutcomes', 'aggregatesubcats');
+    public $forceable = array('aggregation', 'keephigh', 'droplow', 'aggregateonlygraded', 'aggregateoutcomes', 'aggregatesubcats');
 
     /**
      * String representing the aggregation coefficient. Variable is used as cache.
      */
-    var $coefstring = null;
+    public $coefstring = null;
 
     /**
      * Builds this category's path string based on its parents (if any) and its own id number.
@@ -154,15 +164,18 @@ class grade_category extends grade_object {
      * or when a new parent is added or changed. It is a recursive function: once the calling
      * object no longer has a parent, the path is complete.
      *
-     * @static
-     * @param object $grade_category
+     * @param object $grade_category A Grade_Category object
      * @return int The depth of this category (2 means there is one parent)
+     * @static
      */
-    function build_path($grade_category) {
+    public static function build_path($grade_category) {
+        global $DB;
+
         if (empty($grade_category->parent)) {
             return '/'.$grade_category->id.'/';
+
         } else {
-            $parent = get_record('grade_categories', 'id', $grade_category->parent);
+            $parent = $DB->get_record('grade_categories', array('id' => $grade_category->parent));
             return grade_category::build_path($parent).$grade_category->id.'/';
         }
     }
@@ -174,7 +187,7 @@ class grade_category extends grade_object {
      * @param array $params associative arrays varname=>value
      * @return object grade_category instance or false if none found.
      */
-    function fetch($params) {
+    public static function fetch($params) {
         return grade_object::fetch_helper('grade_categories', 'grade_category', $params);
     }
 
@@ -185,7 +198,7 @@ class grade_category extends grade_object {
      * @param array $params associative arrays varname=>value
      * @return array array of grade_category insatnces or false if none found.
      */
-    function fetch_all($params) {
+    public static function fetch_all($params) {
         return grade_object::fetch_all_helper('grade_categories', 'grade_category', $params);
     }
 
@@ -194,7 +207,7 @@ class grade_category extends grade_object {
      * @param string $source from where was the object updated (mod/forum, manual, etc.)
      * @return boolean success
      */
-    function update($source=null) {
+    public function update($source=null) {
         // load the grade item or create a new one
         $this->load_grade_item();
 
@@ -203,6 +216,7 @@ class grade_category extends grade_object {
             $this->path  = grade_category::build_path($this);
             $this->depth = substr_count($this->path, '/') - 1;
             $updatechildren = true;
+
         } else {
             $updatechildren = false;
         }
@@ -212,6 +226,7 @@ class grade_category extends grade_object {
 		// these are exclusive
         if ($this->droplow > 0) {
             $this->keephigh = 0;
+
         } else if ($this->keephigh > 0) {
             $this->droplow = 0;
         }
@@ -227,7 +242,9 @@ class grade_category extends grade_object {
 
         // now update paths in all child categories
         if ($result and $updatechildren) {
+
             if ($children = grade_category::fetch_all(array('parent'=>$this->id))) {
+
                 foreach ($children as $child) {
                     $child->path  = null;
                     $child->depth = 0;
@@ -244,12 +261,15 @@ class grade_category extends grade_object {
      * @param string $source from where was the object deleted (mod/forum, manual, etc.)
      * @return boolean success
      */
-    function delete($source=null) {
+    public function delete($source=null) {
         $grade_item = $this->load_grade_item();
 
         if ($this->is_course_category()) {
+
             if ($categories = grade_category::fetch_all(array('courseid'=>$this->courseid))) {
+
                 foreach ($categories as $category) {
+
                     if ($category->id == $this->id) {
                         continue; // do not delete course category yet
                     }
@@ -258,7 +278,9 @@ class grade_category extends grade_object {
             }
 
             if ($items = grade_item::fetch_all(array('courseid'=>$this->courseid))) {
+
                 foreach ($items as $item) {
+
                     if ($item->id == $grade_item->id) {
                         continue; // do not delete course item yet
                     }
@@ -277,6 +299,7 @@ class grade_category extends grade_object {
                     $child->set_parent($parent->id);
                 }
             }
+
             if ($children = grade_category::fetch_all(array('parent'=>$this->id))) {
                 foreach ($children as $child) {
                     $child->set_parent($parent->id);
@@ -300,10 +323,10 @@ class grade_category extends grade_object {
      * @param string $source from where was the object inserted (mod/forum, manual, etc.)
      * @return int PK ID if successful, false otherwise
      */
-    function insert($source=null) {
+    public function insert($source=null) {
 
         if (empty($this->courseid)) {
-            error('Can not insert grade category without course id!');
+            print_error('cannotinsertgrade');
         }
 
         if (empty($this->parent)) {
@@ -331,10 +354,12 @@ class grade_category extends grade_object {
     /**
      * Internal function - used only from fetch_course_category()
      * Normal insert() can not be used for course category
-     * @param int $courseid
+     *
+     * @param int $courseid The course ID
+     *
      * @return bool success
      */
-    function insert_course_category($courseid) {
+    public function insert_course_category($courseid) {
         $this->courseid    = $courseid;
         $this->fullname    = '?';
         $this->path        = null;
@@ -363,7 +388,7 @@ class grade_category extends grade_object {
      * This assumes that this object has an id number and a matching record in DB. If not, it will return false.
      * @return boolean
      */
-    function qualifies_for_regrading() {
+    public function qualifies_for_regrading() {
         if (empty($this->id)) {
             debugging("Can not regrade non existing category");
             return false;
@@ -385,7 +410,7 @@ class grade_category extends grade_object {
      * Marks the category and course item as needing update - categories are always regraded.
      * @return void
      */
-    function force_regrading() {
+    public function force_regrading() {
         $grade_item = $this->load_grade_item();
         $grade_item->force_regrading();
     }
@@ -404,9 +429,13 @@ class grade_category extends grade_object {
      *  1. Get final grades from immediate children
      *  3. Aggregate these grades
      *  4. Save them in final grades of associated category grade item
+     *
+     * @param int $userid The user ID
+     *
+     * @return bool
      */
-    function generate_grades($userid=null) {
-        global $CFG;
+    public function generate_grades($userid=null) {
+        global $CFG, $DB;
 
         $this->load_grade_item();
 
@@ -419,40 +448,48 @@ class grade_category extends grade_object {
 
         if (empty($depends_on)) {
             $items = false;
+
         } else {
-            $gis = implode(',', $depends_on);
+            list($usql, $params) = $DB->get_in_or_equal($depends_on);
             $sql = "SELECT *
-                      FROM {$CFG->prefix}grade_items
-                     WHERE id IN ($gis)";
-            $items = get_records_sql($sql);
+                      FROM {grade_items}
+                     WHERE id $usql";
+            $items = $DB->get_records_sql($sql, $params);
         }
 
         // needed mostly for SUM agg type
         $this->auto_update_max($items);
 
+        $grade_inst = new grade_grade();
+        $fields = 'g.'.implode(',g.', $grade_inst->required_fields);
+
+        // where to look for final grades - include grade of this item too, we will store the results there
+        $gis = array_merge($depends_on, array($this->grade_item->id));
+        list($usql, $params) = $DB->get_in_or_equal($gis);
+
         if ($userid) {
-            $usersql = "AND g.userid=$userid";
+            $usersql = "AND g.userid=?";
+            $params[] = $userid;
+
         } else {
             $usersql = "";
         }
 
-        $grade_inst = new grade_grade();
-        $fields = 'g.'.implode(',g.', $grade_inst->required_fields);
-
-        // where to look for final grades - include grade of this item too, we will store the results there
-        $gis = implode(',', array_merge($depends_on, array($this->grade_item->id)));
         $sql = "SELECT $fields
-                  FROM {$CFG->prefix}grade_grades g, {$CFG->prefix}grade_items gi
-                 WHERE gi.id = g.itemid AND gi.id IN ($gis) $usersql
+                  FROM {grade_grades} g, {grade_items} gi
+                 WHERE gi.id = g.itemid AND gi.id $usql $usersql
               ORDER BY g.userid";
 
         // group the results by userid and aggregate the grades for this user
-        if ($rs = get_recordset_sql($sql)) {
+        $rs = $DB->get_recordset_sql($sql, $params);
+        if ($rs->valid()) {
             $prevuser = 0;
             $grade_values = array();
             $excluded     = array();
             $oldgrade     = null;
-            while ($used = rs_fetch_next_record($rs)) {
+
+            foreach ($rs as $used) {
+
                 if ($used->userid != $prevuser) {
                     $this->aggregate_grades($prevuser, $items, $grade_values, $oldgrade, $excluded);
                     $prevuser = $used->userid;
@@ -461,16 +498,18 @@ class grade_category extends grade_object {
                     $oldgrade     = null;
                 }
                 $grade_values[$used->itemid] = $used->finalgrade;
+
                 if ($used->excluded) {
                     $excluded[] = $used->itemid;
                 }
+
                 if ($this->grade_item->id == $used->itemid) {
                     $oldgrade = $used;
                 }
             }
             $this->aggregate_grades($prevuser, $items, $grade_values, $oldgrade, $excluded);//the last one
-            rs_close($rs);
         }
+        $rs->close();
 
         return true;
     }
@@ -478,14 +517,16 @@ class grade_category extends grade_object {
     /**
      * internal function for category grades aggregation
      *
-     * @param int $userid
-     * @param array $items
-     * @param array $grade_values
-     * @param object $oldgrade
-     * @param bool $excluded
+     * @param int    $userid The User ID
+     * @param array  $items Grade items
+     * @param array  $grade_values Array of grade values
+     * @param object $oldgrade Old grade
+     * @param array  $excluded Excluded
+     *
      * @return boolean (just plain return;)
+     * @todo Document correctly
      */
-    function aggregate_grades($userid, $items, $grade_values, $oldgrade, $excluded) {
+    private function aggregate_grades($userid, $items, $grade_values, $oldgrade, $excluded) {
         global $CFG;
         if (empty($userid)) {
             //ignore first call
@@ -514,7 +555,7 @@ class grade_category extends grade_object {
         unset($grade_values[$this->grade_item->id]);
 
 
-    /// sum is a special aggregation types - it adjusts the min max, does not use relative values
+        // sum is a special aggregation types - it adjusts the min max, does not use relative values
         if ($this->aggregation == GRADE_AGGREGATE_SUM) {
             $this->sum_grades($grade, $oldfinalgrade, $items, $grade_values, $excluded);
             return;
@@ -523,19 +564,22 @@ class grade_category extends grade_object {
         // if no grades calculation possible or grading not allowed clear final grade
         if (empty($grade_values) or empty($items) or ($this->grade_item->gradetype != GRADE_TYPE_VALUE and $this->grade_item->gradetype != GRADE_TYPE_SCALE)) {
             $grade->finalgrade = null;
+
             if (!is_null($oldfinalgrade)) {
                 $grade->update('aggregation');
             }
             return;
         }
 
-    /// normalize the grades first - all will have value 0...1
+        // normalize the grades first - all will have value 0...1
         // ungraded items are not used in aggregation
         foreach ($grade_values as $itemid=>$v) {
+
             if (is_null($v)) {
                 // null means no grade
                 unset($grade_values[$itemid]);
                 continue;
+
             } else if (in_array($itemid, $excluded)) {
                 unset($grade_values[$itemid]);
                 continue;
@@ -545,7 +589,9 @@ class grade_category extends grade_object {
 
         // use min grade if grade missing for these types
         if (!$this->aggregateonlygraded) {
-            foreach($items as $itemid=>$value) {
+
+            foreach ($items as $itemid=>$value) {
+
                 if (!isset($grade_values[$itemid]) and !in_array($itemid, $excluded)) {
                     $grade_values[$itemid] = 0;
                 }
@@ -560,6 +606,7 @@ class grade_category extends grade_object {
         if (count($grade_values) == 0) {
             // not enough attempts yet
             $grade->finalgrade = null;
+
             if (!is_null($oldfinalgrade)) {
                 $grade->update('aggregation');
             }
@@ -584,14 +631,23 @@ class grade_category extends grade_object {
 
     /**
      * Internal function - aggregation maths.
+     * Must be public: used by grade_grade::get_hiding_affected()
+     *
+     * @param array $grade_values The values being aggregated
+     * @param array $items The array of grade_items
+     *
+     * @return float
      */
-    function aggregate_values($grade_values, $items) {
+    public function aggregate_values($grade_values, $items) {
         switch ($this->aggregation) {
+
             case GRADE_AGGREGATE_MEDIAN: // Middle point value in the set: ignores frequencies
                 $num = count($grade_values);
                 $grades = array_values($grade_values);
+
                 if ($num % 2 == 0) {
                     $agg_grade = ($grades[intval($num/2)-1] + $grades[intval($num/2)]) / 2;
+
                 } else {
                     $agg_grade = $grades[intval(($num/2)-0.5)];
                 }
@@ -610,8 +666,10 @@ class grade_category extends grade_object {
                 $converted_grade_values = array();
 
                 foreach ($grade_values as $k => $gv) {
+
                     if (!is_int($gv) && !is_string($gv)) {
                         $converted_grade_values[$k] = (string) $gv;
+
                     } else {
                         $converted_grade_values[$k] = $gv;
                     }
@@ -621,22 +679,26 @@ class grade_category extends grade_object {
                 arsort($freq);                      // sort by frequency keeping keys
                 $top = reset($freq);               // highest frequency count
                 $modes = array_keys($freq, $top);  // search for all modes (have the same highest count)
-                rsort($modes, SORT_NUMERIC);       // get highes mode
+                rsort($modes, SORT_NUMERIC);       // get highest mode
                 $agg_grade = reset($modes);
                 break;
 
             case GRADE_AGGREGATE_WEIGHTED_MEAN: // Weighted average of all existing final grades, weight specified in coef
                 $weightsum = 0;
                 $sum       = 0;
-                foreach($grade_values as $itemid=>$grade_value) {
+
+                foreach ($grade_values as $itemid=>$grade_value) {
+
                     if ($items[$itemid]->aggregationcoef <= 0) {
                         continue;
                     }
                     $weightsum += $items[$itemid]->aggregationcoef;
                     $sum       += $items[$itemid]->aggregationcoef * $grade_value;
                 }
+
                 if ($weightsum == 0) {
                     $agg_grade = null;
+
                 } else {
                     $agg_grade = $sum / $weightsum;
                 }
@@ -644,21 +706,26 @@ class grade_category extends grade_object {
 
             case GRADE_AGGREGATE_WEIGHTED_MEAN2:
                 // Weighted average of all existing final grades with optional extra credit flag,
-                // weight is the range of grade (ususally grademax)
+                // weight is the range of grade (usually grademax)
                 $weightsum = 0;
                 $sum       = null;
-                foreach($grade_values as $itemid=>$grade_value) {
+
+                foreach ($grade_values as $itemid=>$grade_value) {
                     $weight = $items[$itemid]->grademax - $items[$itemid]->grademin;
+
                     if ($weight <= 0) {
                         continue;
                     }
+
                     if ($items[$itemid]->aggregationcoef == 0) {
                         $weightsum += $weight;
                     }
                     $sum += $weight * $grade_value;
                 }
+
                 if ($weightsum == 0) {
                     $agg_grade = $sum; // only extra credits
+
                 } else {
                     $agg_grade = $sum / $weightsum;
                 }
@@ -667,16 +734,21 @@ class grade_category extends grade_object {
             case GRADE_AGGREGATE_EXTRACREDIT_MEAN: // special average
                 $num = 0;
                 $sum = null;
-                foreach($grade_values as $itemid=>$grade_value) {
+
+                foreach ($grade_values as $itemid=>$grade_value) {
+
                     if ($items[$itemid]->aggregationcoef == 0) {
                         $num += 1;
                         $sum += $grade_value;
+
                     } else if ($items[$itemid]->aggregationcoef > 0) {
                         $sum += $items[$itemid]->aggregationcoef * $grade_value;
                     }
                 }
+
                 if ($num == 0) {
                     $agg_grade = $sum; // only extra credits or wrong coefs
+
                 } else {
                     $agg_grade = $sum / $num;
                 }
@@ -694,17 +766,18 @@ class grade_category extends grade_object {
     }
 
     /**
-     * Some aggregation tpyes may update max grade
+     * Some aggregation types may update max grade
      * @param array $items sub items
      * @return void
      */
-    function auto_update_max($items) {
+    private function auto_update_max($items) {
         if ($this->aggregation != GRADE_AGGREGATE_SUM) {
             // not needed at all
             return;
         }
 
         if (!$items) {
+
             if ($this->grade_item->grademax != 0 or $this->grade_item->gradetype != GRADE_TYPE_VALUE) {
                 $this->grade_item->grademax  = 0;
                 $this->grade_item->grademin  = 0;
@@ -716,13 +789,17 @@ class grade_category extends grade_object {
 
         //find max grade possible
         $maxes = array();
+
         foreach ($items as $item) {
+
             if ($item->aggregationcoef > 0) {
                 // extra credit from this activity - does not affect total
                 continue;
             }
+
             if ($item->gradetype == GRADE_TYPE_VALUE) {
                 $maxes[$item->id] = $item->grademax;
+
             } else if ($item->gradetype == GRADE_TYPE_SCALE) {
                 $maxes[$item->id] = $item->grademax; // 0 = nograde, 1 = first scale item, 2 = second scale item
             }
@@ -743,23 +820,25 @@ class grade_category extends grade_object {
     /**
      * internal function for category grades summing
      *
-     * @param object $grade
-     * @param int $userid
-     * @param float $oldfinalgrade
-     * @param array $items
-     * @param array $grade_values
-     * @param bool $excluded
+     * @param grade_grade &$grade The grade item
+     * @param float      $oldfinalgrade Old Final grade?
+     * @param array      $items Grade items
+     * @param array      $grade_values Grade values
+     * @param array      $excluded Excluded
+     *
      * @return boolean (just plain return;)
      */
-    function sum_grades(&$grade, $oldfinalgrade, $items, $grade_values, $excluded) {
+    private function sum_grades(&$grade, $oldfinalgrade, $items, $grade_values, $excluded) {
         if (empty($items)) {
             return null;
         }
 
-        // ungraded and exluded items are not used in aggregation
+        // ungraded and excluded items are not used in aggregation
         foreach ($grade_values as $itemid=>$v) {
+
             if (is_null($v)) {
                 unset($grade_values[$itemid]);
+
             } else if (in_array($itemid, $excluded)) {
                 unset($grade_values[$itemid]);
             }
@@ -767,7 +846,9 @@ class grade_category extends grade_object {
 
         // use 0 if grade missing, droplow used and aggregating all items
         if (!$this->aggregateonlygraded and !empty($this->droplow)) {
-            foreach($items as $itemid=>$value) {
+
+            foreach ($items as $itemid=>$value) {
+
                 if (!isset($grade_values[$itemid]) and !in_array($itemid, $excluded)) {
                     $grade_values[$itemid] = 0;
                 }
@@ -790,24 +871,31 @@ class grade_category extends grade_object {
     /**
      * Given an array of grade values (numerical indices), applies droplow or keephigh
      * rules to limit the final array.
-     * @param array $grade_values itemid=>$grade_value float
-     * @param array $items grade titem objects
+     *
+     * @param array &$grade_values itemid=>$grade_value float
+     * @param array $items grade item objects
+     *
      * @return array Limited grades.
      */
-    function apply_limit_rules(&$grade_values, $items) {
+    public function apply_limit_rules(&$grade_values, $items) {
         $extraused = $this->is_extracredit_used();
 
         if (!empty($this->droplow)) {
             asort($grade_values, SORT_NUMERIC);
             $dropped = 0;
+
             foreach ($grade_values as $itemid=>$value) {
+
                 if ($dropped < $this->droplow) {
+
                     if ($extraused and $items[$itemid]->aggregationcoef > 0) {
                         // no drop low for extra credits
+
                     } else {
                         unset($grade_values[$itemid]);
                         $dropped++;
                     }
+
                 } else {
                     // we have dropped enough
                     break;
@@ -817,11 +905,15 @@ class grade_category extends grade_object {
         } else if (!empty($this->keephigh)) {
             arsort($grade_values, SORT_NUMERIC);
             $kept = 0;
+
             foreach ($grade_values as $itemid=>$value) {
+
                 if ($extraused and $items[$itemid]->aggregationcoef > 0) {
                     // we keep all extra credits
+
                 } else if ($kept < $this->keephigh) {
                     $kept++;
+
                 } else {
                     unset($grade_values[$itemid]);
                 }
@@ -831,6 +923,7 @@ class grade_category extends grade_object {
 
     /**
      * Returns true if category uses extra credit of any kind
+     *
      * @return boolean true if extra credit used
      */
     function is_extracredit_used() {
@@ -840,10 +933,11 @@ class grade_category extends grade_object {
     }
 
     /**
-     * Returns true if category uses special aggregation coeficient
-     * @return boolean true if coeficient used
+     * Returns true if category uses special aggregation coefficient
+     *
+     * @return boolean true if coefficient used
      */
-    function is_aggregationcoef_used() {
+    public function is_aggregationcoef_used() {
         return ($this->aggregation == GRADE_AGGREGATE_WEIGHTED_MEAN
              or $this->aggregation == GRADE_AGGREGATE_WEIGHTED_MEAN2
              or $this->aggregation == GRADE_AGGREGATE_EXTRACREDIT_MEAN
@@ -854,10 +948,12 @@ class grade_category extends grade_object {
     /**
      * Recursive function to find which weight/extra credit field to use in the grade item form. Inherits from a parent category
      * if that category has aggregatesubcats set to true.
-     * @param string $coefstring
-     * @return string $coefstring
+     *
+     * @param string $first Whether or not this is the first item in the recursion
+     *
+     * @return string
      */
-    function get_coefstring($first=true) {
+    public function get_coefstring($first=true) {
         if (!is_null($this->coefstring)) {
             return $this->coefstring;
         }
@@ -866,13 +962,18 @@ class grade_category extends grade_object {
 
         // Stop recursing upwards if this category aggregates subcats or has no parent
         if (!$first && !$this->aggregatesubcats) {
+
             if ($parent_category = $this->load_parent_category()) {
                 return $parent_category->get_coefstring(false);
+
             } else {
                 return null;
             }
-        } elseif ($first) {
+
+        } else if ($first) {
+
             if (!$this->aggregatesubcats) {
+
                 if ($parent_category = $this->load_parent_category()) {
                     $overriding_coefstring = $parent_category->get_coefstring(false);
                 }
@@ -887,12 +988,16 @@ class grade_category extends grade_object {
         // No parent category is overriding this category's aggregation, return its string
         if ($this->aggregation == GRADE_AGGREGATE_WEIGHTED_MEAN) {
             $this->coefstring = 'aggregationcoefweight';
+
         } else if ($this->aggregation == GRADE_AGGREGATE_WEIGHTED_MEAN2) {
             $this->coefstring = 'aggregationcoefextrasum';
+
         } else if ($this->aggregation == GRADE_AGGREGATE_EXTRACREDIT_MEAN) {
-            $this->coefstring = 'aggregationcoefextra';
+            $this->coefstring = 'aggregationcoefextraweight';
+
         } else if ($this->aggregation == GRADE_AGGREGATE_SUM) {
             $this->coefstring = 'aggregationcoefextrasum';
+
         } else {
             $this->coefstring = 'aggregationcoef';
         }
@@ -901,25 +1006,41 @@ class grade_category extends grade_object {
 
     /**
      * Returns tree with all grade_items and categories as elements
-     * @static
-     * @param int $courseid
+     *
+     * @param int $courseid The course ID
      * @param boolean $include_category_items as category children
+     *
      * @return array
+     * @static
      */
-    function fetch_course_tree($courseid, $include_category_items=false) {
+    public static function fetch_course_tree($courseid, $include_category_items=false) {
         $course_category = grade_category::fetch_course_category($courseid);
         $category_array = array('object'=>$course_category, 'type'=>'category', 'depth'=>1,
                                 'children'=>$course_category->get_children($include_category_items));
-        $sortorder = 1;
-        $course_category->set_sortorder($sortorder);
-        $course_category->sortorder = $sortorder;
-        return grade_category::_fetch_course_tree_recursion($category_array, $sortorder);
+
+        $course_category->sortorder = $course_category->get_sortorder();
+        return grade_category::_fetch_course_tree_recursion($category_array, $course_category->get_sortorder());
     }
 
-    function _fetch_course_tree_recursion($category_array, &$sortorder) {
+    /**
+     * Needs documenting
+     *
+     * @param array $category_array The seed of the recursion
+     * @param int   &$sortorder The current sortorder
+     *
+     * @return array
+     * @static
+     * @todo Document
+     */
+    static private function _fetch_course_tree_recursion($category_array, &$sortorder) {
         // update the sortorder in db if needed
-        if ($category_array['object']->sortorder != $sortorder) {
-            $category_array['object']->set_sortorder($sortorder);
+        //NOTE: This leads to us resetting sort orders every time the categories and items page is viewed :(
+        //if ($category_array['object']->sortorder != $sortorder) {
+            //$category_array['object']->set_sortorder($sortorder);
+        //}
+
+        if (isset($category_array['object']->gradetype) && $category_array['object']->gradetype==GRADE_TYPE_NONE) {
+            return null;
         }
 
         // store the grade_item or grade_category instance with extra info
@@ -934,15 +1055,25 @@ class grade_category extends grade_object {
         if (!empty($category_array['children'])) {
             $result['children'] = array();
             //process the category item first
-            $cat_item_id = null;
-            foreach($category_array['children'] as $oldorder=>$child_array) {
+            $child = null;
+
+            foreach ($category_array['children'] as $oldorder=>$child_array) {
+
                 if ($child_array['type'] == 'courseitem' or $child_array['type'] == 'categoryitem') {
-                    $result['children'][$sortorder] = grade_category::_fetch_course_tree_recursion($child_array, $sortorder);
+                    $child = grade_category::_fetch_course_tree_recursion($child_array, $sortorder);
+                    if (!empty($child)) {
+                        $result['children'][$sortorder] = $child;
+                    }
                 }
             }
-            foreach($category_array['children'] as $oldorder=>$child_array) {
+
+            foreach ($category_array['children'] as $oldorder=>$child_array) {
+
                 if ($child_array['type'] != 'courseitem' and $child_array['type'] != 'categoryitem') {
-                    $result['children'][++$sortorder] = grade_category::_fetch_course_tree_recursion($child_array, $sortorder);
+                    $child = grade_category::_fetch_course_tree_recursion($child_array, $sortorder);
+                    if (!empty($child)) {
+                        $result['children'][++$sortorder] = $child;
+                    }
                 }
             }
         }
@@ -954,16 +1085,20 @@ class grade_category extends grade_object {
      * Fetches and returns all the children categories and/or grade_items belonging to this category.
      * By default only returns the immediate children (depth=1), but deeper levels can be requested,
      * as well as all levels (0). The elements are indexed by sort order.
+     *
+     * @param bool $include_category_items Whether or not to include category grade_items in the children array
+     *
      * @return array Array of child objects (grade_category and grade_item).
      */
-    function get_children($include_category_items=false) {
+    public function get_children($include_category_items=false) {
+        global $DB;
 
         // This function must be as fast as possible ;-)
         // fetch all course grade items and categories into memory - we do not expect hundreds of these in course
         // we have to limit the number of queries though, because it will be used often in grade reports
 
-        $cats  = get_records('grade_categories', 'courseid', $this->courseid);
-        $items = get_records('grade_items', 'courseid', $this->courseid);
+        $cats  = $DB->get_records('grade_categories', array('courseid' => $this->courseid));
+        $items = $DB->get_records('grade_items', array('courseid' => $this->courseid));
 
         // init children array first
         foreach ($cats as $catid=>$cat) {
@@ -972,6 +1107,7 @@ class grade_category extends grade_object {
 
         //first attach items to cats and add category sortorder
         foreach ($items as $item) {
+
             if ($item->itemtype == 'course' or $item->itemtype == 'category') {
                 $cats[$item->iteminstance]->sortorder = $item->sortorder;
 
@@ -979,13 +1115,15 @@ class grade_category extends grade_object {
                     continue;
                 }
                 $categoryid = $item->iteminstance;
+
             } else {
                 $categoryid = $item->categoryid;
             }
 
             // prevent problems with duplicate sortorders in db
             $sortorder = $item->sortorder;
-            while(array_key_exists($sortorder, $cats[$categoryid]->children)) {
+
+            while (array_key_exists($sortorder, $cats[$categoryid]->children)) {
                 //debugging("$sortorder exists in item loop");
                 $sortorder++;
             }
@@ -996,8 +1134,11 @@ class grade_category extends grade_object {
 
         // now find the requested category and connect categories as children
         $category = false;
+
         foreach ($cats as $catid=>$cat) {
+
             if (empty($cat->parent)) {
+
                 if ($cat->path !== '/'.$cat->id.'/') {
                     $grade_category = new grade_category($cat, false);
                     $grade_category->path  = '/'.$cat->id.'/';
@@ -1005,11 +1146,14 @@ class grade_category extends grade_object {
                     $grade_category->update('system');
                     return $this->get_children($include_category_items);
                 }
+
             } else {
+
                 if (empty($cat->path) or !preg_match('|/'.$cat->parent.'/'.$cat->id.'/$|', $cat->path)) {
                     //fix paths and depts
                     static $recursioncounter = 0; // prevents infinite recursion
                     $recursioncounter++;
+
                     if ($recursioncounter < 5) {
                         // fix paths and depths!
                         $grade_category = new grade_category($cat, false);
@@ -1021,7 +1165,8 @@ class grade_category extends grade_object {
                 }
                 // prevent problems with duplicate sortorders in db
                 $sortorder = $cat->sortorder;
-                while(array_key_exists($sortorder, $cats[$cat->parent]->children)) {
+
+                while (array_key_exists($sortorder, $cats[$cat->parent]->children)) {
                     //debugging("$sortorder exists in cat loop");
                     $sortorder++;
                 }
@@ -1045,15 +1190,25 @@ class grade_category extends grade_object {
 
     }
 
-    function _get_children_recursion($category) {
+    /**
+     * Private method used to retrieve all children of this category recursively
+     *
+     * @param grade_category $category Source of current recursion
+     *
+     * @return array
+     */
+    private static function _get_children_recursion($category) {
 
         $children_array = array();
-        foreach($category->children as $sortorder=>$child) {
+        foreach ($category->children as $sortorder=>$child) {
+
             if (array_key_exists('itemtype', $child)) {
                 $grade_item = new grade_item($child, false);
+
                 if (in_array($grade_item->itemtype, array('course', 'category'))) {
                     $type  = $grade_item->itemtype.'item';
                     $depth = $category->depth;
+
                 } else {
                     $type  = 'item';
                     $depth = $category->depth; // we use this to set the same colour
@@ -1063,6 +1218,7 @@ class grade_category extends grade_object {
             } else {
                 $children = grade_category::_get_children_recursion($child);
                 $grade_category = new grade_category($child, false);
+
                 if (empty($children)) {
                     $children = array();
                 }
@@ -1080,7 +1236,7 @@ class grade_category extends grade_object {
      * Uses get_grade_item to load or create a grade_item, then saves it as $this->grade_item.
      * @return object Grade_item
      */
-    function load_grade_item() {
+    public function load_grade_item() {
         if (empty($this->grade_item)) {
             $this->grade_item = $this->get_grade_item();
         }
@@ -1092,7 +1248,7 @@ class grade_category extends grade_object {
      * If no grade_item exists yet, create one.
      * @return object Grade_item
      */
-    function get_grade_item() {
+    public function get_grade_item() {
         if (empty($this->id)) {
             debugging("Attempt to obtain a grade_category's associated grade_item without the category's ID being set.");
             return false;
@@ -1111,7 +1267,7 @@ class grade_category extends grade_object {
             $grade_item->gradetype = GRADE_TYPE_VALUE;
             $grade_item->insert('system');
 
-        } else if (count($grade_items) == 1){
+        } else if (count($grade_items) == 1) {
             // found existing one
             $grade_item = reset($grade_items);
 
@@ -1129,7 +1285,7 @@ class grade_category extends grade_object {
      * referenced record in the DB.
      * @return object Parent_category
      */
-    function load_parent_category() {
+    public function load_parent_category() {
         if (empty($this->parent_category) && !empty($this->parent)) {
             $this->parent_category = $this->get_parent_category();
         }
@@ -1140,7 +1296,7 @@ class grade_category extends grade_object {
      * Uses $this->parent to instantiate and return a grade_category object.
      * @return object Parent_category
      */
-    function get_parent_category() {
+    public function get_parent_category() {
         if (!empty($this->parent)) {
             $parent_category = new grade_category(array('id' => $this->parent));
             return $parent_category;
@@ -1152,13 +1308,16 @@ class grade_category extends grade_object {
     /**
      * Returns the most descriptive field for this object. This is a standard method used
      * when we do not know the exact type of an object.
+     *
      * @return string name
      */
-    function get_name() {
+    public function get_name() {
+        global $DB;
         // For a course category, we return the course name if the fullname is set to '?' in the DB (empty in the category edit form)
         if (empty($this->parent) && $this->fullname == '?') {
-            $course = get_record('course', 'id', $this->courseid);
+            $course = $DB->get_record('course', array('id'=> $this->courseid));
             return format_string($course->fullname);
+
         } else {
             return $this->fullname;
         }
@@ -1166,20 +1325,23 @@ class grade_category extends grade_object {
 
     /**
      * Sets this category's parent id. A generic method shared by objects that have a parent id of some kind.
-     * @param int parentid
+     *
+     * @param int            $parentid The ID of the category parent to $this
+     * @param grade_category $source An optional grade_category to use as the source for the parent
+     *
      * @return boolean success
      */
-    function set_parent($parentid, $source=null) {
+    public function set_parent($parentid, $source=null) {
         if ($this->parent == $parentid) {
             return true;
         }
 
         if ($parentid == $this->id) {
-            error('Can not assign self as parent!');
+            print_error('cannotassignselfasparent');
         }
 
         if (empty($this->parent) and $this->is_course_category()) {
-            error('Course category can not have parent!');
+            print_error('cannothaveparentcate');
         }
 
         // find parent and check course id
@@ -1201,10 +1363,12 @@ class grade_category extends grade_object {
 
     /**
      * Returns the final values for this grade category.
+     *
      * @param int $userid Optional: to retrieve a single final grade
+     *
      * @return mixed An array of all final_grades (stdClass objects) for this grade_item, or a single final_grade.
      */
-    function get_final($userid=NULL) {
+    public function get_final($userid=null) {
         $this->load_grade_item();
         return $this->grade_item->get_final($userid);
     }
@@ -1212,9 +1376,10 @@ class grade_category extends grade_object {
     /**
      * Returns the sortorder of the associated grade_item. This method is also available in
      * grade_item, for cases where the object type is not known.
+     *
      * @return int Sort order
      */
-    function get_sortorder() {
+    public function get_sortorder() {
         $this->load_grade_item();
         return $this->grade_item->get_sortorder();
     }
@@ -1222,9 +1387,10 @@ class grade_category extends grade_object {
     /**
      * Returns the idnumber of the associated grade_item. This method is also available in
      * grade_item, for cases where the object type is not known.
+     *
      * @return string idnumber
      */
-    function get_idnumber() {
+    public function get_idnumber() {
         $this->load_grade_item();
         return $this->grade_item->get_idnumber();
     }
@@ -1232,38 +1398,47 @@ class grade_category extends grade_object {
     /**
      * Sets sortorder variable for this category.
      * This method is also available in grade_item, for cases where the object type is not know.
-     * @param int $sortorder
+     *
+     * @param int $sortorder The sortorder to assign to this category
+     *
      * @return void
      */
-    function set_sortorder($sortorder) {
+    public function set_sortorder($sortorder) {
         $this->load_grade_item();
         $this->grade_item->set_sortorder($sortorder);
     }
 
     /**
      * Move this category after the given sortorder - does not change the parent
-     * @param int $sortorder to place after
+     *
+     * @param int $sortorder to place after.
+     *
+     * @return void
      */
-    function move_after_sortorder($sortorder) {
+    public function move_after_sortorder($sortorder) {
         $this->load_grade_item();
         $this->grade_item->move_after_sortorder($sortorder);
     }
 
     /**
      * Return true if this is the top most category that represents the total course grade.
+     *
      * @return boolean
      */
-    function is_course_category() {
+    public function is_course_category() {
         $this->load_grade_item();
         return $this->grade_item->is_course_item();
     }
 
     /**
      * Return the top most course category.
-     * @static
+     *
+     * @param int $courseid The Course ID
+     *
      * @return object grade_category instance for course grade
+     * @static
      */
-    function fetch_course_category($courseid) {
+    public static function fetch_course_category($courseid) {
         if (empty($courseid)) {
             debugging('Missing course id!');
             return false;
@@ -1283,9 +1458,10 @@ class grade_category extends grade_object {
 
     /**
      * Is grading object editable?
+     *
      * @return boolean
      */
-    function is_editable() {
+    public function is_editable() {
         return true;
     }
 
@@ -1294,7 +1470,7 @@ class grade_category extends grade_object {
      * grade_item, for cases where the object type is not known.
      * @return boolean
      */
-    function is_locked() {
+    public function is_locked() {
         $this->load_grade_item();
         return $this->grade_item->is_locked();
     }
@@ -1302,12 +1478,14 @@ class grade_category extends grade_object {
     /**
      * Sets the grade_item's locked variable and updates the grade_item.
      * Method named after grade_item::set_locked().
-     * @param int $locked 0, 1 or a timestamp int(10) after which date the item will be locked.
-     * @param boolean $cascade lock/unlock child objects too
-     * @param boolean $refresh refresh grades when unlocking
+     *
+     * @param int  $lockedstate 0, 1 or a timestamp int(10) after which date the item will be locked.
+     * @param bool $cascade lock/unlock child objects too
+     * @param bool $refresh refresh grades when unlocking
+     *
      * @return boolean success if category locked (not all children mayb be locked though)
      */
-    function set_locked($lockedstate, $cascade=false, $refresh=true) {
+    public function set_locked($lockedstate, $cascade=false, $refresh=true) {
         $this->load_grade_item();
 
         $result = $this->grade_item->set_locked($lockedstate, $cascade, true);
@@ -1315,16 +1493,20 @@ class grade_category extends grade_object {
         if ($cascade) {
             //process all children - items and categories
             if ($children = grade_item::fetch_all(array('categoryid'=>$this->id))) {
-                foreach($children as $child) {
+
+                foreach ($children as $child) {
                     $child->set_locked($lockedstate, true, false);
+
                     if (empty($lockedstate) and $refresh) {
                         //refresh when unlocking
                         $child->refresh_grades();
                     }
                 }
             }
+
             if ($children = grade_category::fetch_all(array('parent'=>$this->id))) {
-                foreach($children as $child) {
+
+                foreach ($children as $child) {
                     $child->set_locked($lockedstate, true, true);
                 }
             }
@@ -1333,23 +1515,37 @@ class grade_category extends grade_object {
         return $result;
     }
 
-    /**
-     * Returns the hidden state/date of the associated grade_item. This method is also available in
-     * grade_item.
-     * @return boolean
-     */
-    function is_hidden() {
-        $this->load_grade_item();
-        return $this->grade_item->is_hidden();
+    public static function set_properties(&$instance, $params) {
+        global $DB;
+
+        parent::set_properties($instance, $params);
+
+        //if they've changed aggregation type we made need to do some fiddling to provide appropriate defaults
+        if (!empty($params->aggregation)) {
+
+            //weight and extra credit share a column :( Would like a default of 1 for weight and 0 for extra credit
+            //Flip from the default of 0 to 1 (or vice versa) if ALL items in the category are still set to the old default.
+            if ($params->aggregation==GRADE_AGGREGATE_WEIGHTED_MEAN || $params->aggregation==GRADE_AGGREGATE_EXTRACREDIT_MEAN) {
+                $sql = $defaultaggregationcoef = null;
+
+                if ($params->aggregation==GRADE_AGGREGATE_WEIGHTED_MEAN) {
+                    //if all items in this category have aggregation coefficient of 0 we can change it to 1 ie evenly weighted
+                    $sql = "select count(id) from {grade_items} where categoryid=:categoryid and aggregationcoef!=0";
+                    $defaultaggregationcoef = 1;
+                } else if ($params->aggregation==GRADE_AGGREGATE_EXTRACREDIT_MEAN) {
+                    //if all items in this category have aggregation coefficient of 1 we can change it to 0 ie no extra credit
+                    $sql = "select count(id) from {grade_items} where categoryid=:categoryid and aggregationcoef!=1";
+                    $defaultaggregationcoef = 0;
     }
 
-    /**
-     * Check grade hidden status. Uses data from both grade item and grade.
-     * @return boolean true if hiddenuntil, false if not
-     */
-    function is_hiddenuntil() {
-        $this->load_grade_item();
-        return $this->grade_item->is_hiddenuntil();
+                $params = array('categoryid'=>$instance->id);
+                $count = $DB->count_records_sql($sql, $params);
+                if ($count===0) { //category is either empty or all items are set to a default value so we can switch defaults
+                    $params['aggregationcoef'] = $defaultaggregationcoef;
+                    $DB->execute("update {grade_items} set aggregationcoef=:aggregationcoef where categoryid=:categoryid",$params);
+                }
+            }
+        }
     }
 
     /**
@@ -1359,17 +1555,25 @@ class grade_category extends grade_object {
      * @param boolean $cascade apply to child objects too
      * @return void
      */
-    function set_hidden($hidden, $cascade=false) {
+    public function set_hidden($hidden, $cascade=false) {
         $this->load_grade_item();
-        $this->grade_item->set_hidden($hidden);
+        //this hides the associated grade item (the course total)
+        $this->grade_item->set_hidden($hidden, $cascade);
+        //this hides the category itself and everything it contains
+        parent::set_hidden($hidden, $cascade);
+
         if ($cascade) {
+
             if ($children = grade_item::fetch_all(array('categoryid'=>$this->id))) {
-                foreach($children as $child) {
+
+                foreach ($children as $child) {
                     $child->set_hidden($hidden, $cascade);
                 }
             }
+
             if ($children = grade_category::fetch_all(array('parent'=>$this->id))) {
-                foreach($children as $child) {
+
+                foreach ($children as $child) {
                     $child->set_hidden($hidden, $cascade);
                 }
             }
@@ -1392,11 +1596,13 @@ class grade_category extends grade_object {
      * Applies default settings on this category
      * @return bool true if anything changed
      */
-    function apply_default_settings() {
+    public function apply_default_settings() {
         global $CFG;
 
         foreach ($this->forceable as $property) {
+
             if (isset($CFG->{"grade_$property"})) {
+
                 if ($CFG->{"grade_$property"} == -1) {
                     continue; //temporary bc before version bump
                 }
@@ -1409,12 +1615,16 @@ class grade_category extends grade_object {
      * Applies forced settings on this category
      * @return bool true if anything changed
      */
-    function apply_forced_settings() {
+    public function apply_forced_settings() {
         global $CFG;
 
         $updated = false;
+
         foreach ($this->forceable as $property) {
-            if (isset($CFG->{"grade_$property"}) and isset($CFG->{"grade_{$property}_flag"}) and ((int)$CFG->{"grade_{$property}_flag"} & 1)) {
+
+            if (isset($CFG->{"grade_$property"}) and isset($CFG->{"grade_{$property}_flag"}) and
+                                                    ((int) $CFG->{"grade_{$property}_flag"} & 1)) {
+
                 if ($CFG->{"grade_$property"} == -1) {
                     continue; //temporary bc before version bump
                 }
@@ -1428,12 +1638,14 @@ class grade_category extends grade_object {
 
     /**
      * Notification of change in forced category settings.
+     *
+     * @return void
      * @static
      */
-    function updated_forced_settings() {
-        global $CFG;
-        $sql = "UPDATE {$CFG->prefix}grade_items SET needsupdate=1 WHERE itemtype='course' or itemtype='category'";
-        execute_sql($sql, false);
+    public static function updated_forced_settings() {
+        global $CFG, $DB;
+        $params = array(1, 'course', 'category');
+        $sql = "UPDATE {grade_items} SET needsupdate=? WHERE itemtype=? or itemtype=?";
+        $DB->execute($sql, $params);
     }
 }
-?>
