diff --git a/lib/datalib.php b/lib/datalib.php
index 2a96bae..ad26f8a 100644
--- a/lib/datalib.php
+++ b/lib/datalib.php
@@ -1,133 +1,91 @@
-<?php // $Id$
+<?php
+
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
 /**
  * Library of functions for database manipulation.
  *
  * Other main libraries:
  * - weblib.php - functions that produce web output
  * - moodlelib.php - general-purpose Moodle functions
- * @author Martin Dougiamas and many others
- * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
- * @package moodlecore
+ *
+ * @package    core
+ * @subpackage lib
+ * @copyright  1999 onwards Martin Dougiamas  {@link http://moodle.com}
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
  */
 
- /// Some constants
- define('LASTACCESS_UPDATE_SECS', 60); /// Number of seconds to wait before
-                                       /// updating lastaccess information in DB.
+defined('MOODLE_INTERNAL') || die();
 
 /**
- * Escape all dangerous characters in a data record
- *
- * $dataobject is an object containing needed data
- * Run over each field exectuting addslashes() function
- * to escape SQL unfriendly characters (e.g. quotes)
- * Handy when writing back data read from the database
- *
- * @param $dataobject Object containing the database record
- * @return object Same object with neccessary characters escaped
+ * The maximum courses in a category
+ * MAX_COURSES_IN_CATEGORY * MAX_COURSE_CATEGORIES must not be more than max integer!
  */
-function addslashes_object( $dataobject ) {
-    $a = get_object_vars( $dataobject);
-    foreach ($a as $key=>$value) {
-      $a[$key] = addslashes( $value );
-    }
-    return (object)$a;
-}
+define('MAX_COURSES_IN_CATEGORY', 10000);
 
-/// USER DATABASE ////////////////////////////////////////////////
+/**
+  * The maximum number of course categories
+  * MAX_COURSES_IN_CATEGORY * MAX_COURSE_CATEGORIES must not be more than max integer!
+  */
+define('MAX_COURSE_CATEGORIES', 10000);
+
+/**
+ * Number of seconds to wait before updating lastaccess information in DB.
+ */
+define('LASTACCESS_UPDATE_SECS', 60);
 
 /**
  * Returns $user object of the main admin user
  * primary admin = admin with lowest role_assignment id among admins
- * @uses $CFG
- * @return object(admin) An associative array representing the admin user.
+ *
+ * @static stdClass $mainadmin
+ * @return stdClass {@link $USER} record from DB, false if not found
  */
-function get_admin () {
-    static $myadmin;
+function get_admin() {
+    static $mainadmin = null;
 
-    if (! isset($admin)) {
+    if (!isset($mainadmin)) {
         if (! $admins = get_admins()) {
             return false;
         }
-        $admin = reset($admins);//reset returns first element
+        //TODO: add some admin setting for specifying of THE main admin
+        //      for now return the first assigned admin
+        $mainadmin = reset($admins);
     }
-    return $admin;
+    // we must clone this otherwise code outside can break the static var
+    return clone($mainadmin);
 }
 
 /**
- * Returns list of all admins, using 1 DB query. It depends on DB schema v1.7
- * but does not depend on the v1.9 datastructures (context.path, etc).
+ * Returns list of all admins, using 1 DB query
  *
- * @uses $CFG
- * @return object
+ * @return array
  */
 function get_admins() {
+    global $DB, $CFG;
 
-    global $CFG;
-
-    $sql = "SELECT ra.userid, SUM(rc.permission) AS permission, MIN(ra.id) AS adminid
-            FROM " . $CFG->prefix . "role_capabilities rc
-            JOIN " . $CFG->prefix . "context ctx
-              ON ctx.id=rc.contextid
-            JOIN " . $CFG->prefix . "role_assignments ra
-              ON ra.roleid=rc.roleid AND ra.contextid=ctx.id
-            WHERE ctx.contextlevel=10
-              AND rc.capability IN ('moodle/site:config',
-                                    'moodle/legacy:admin',
-                                    'moodle/site:doanything')       
-            GROUP BY ra.userid
-            HAVING SUM(rc.permission) > 0";
-
-    $sql = "SELECT u.*, ra.adminid
-            FROM  " . $CFG->prefix . "user u
-            JOIN ($sql) ra
-              ON u.id=ra.userid
-            ORDER BY ra.adminid ASC";
-
-    return get_records_sql($sql);
-}
-
-
-function get_courses_in_metacourse($metacourseid) {
-    global $CFG;
-
-    $sql = "SELECT c.id,c.shortname,c.fullname FROM {$CFG->prefix}course c, {$CFG->prefix}course_meta mc WHERE mc.parent_course = $metacourseid
-        AND mc.child_course = c.id ORDER BY c.shortname";
-
-    return get_records_sql($sql);
-}
-
-function get_courses_notin_metacourse($metacourseid,$count=false) {
-
-    global $CFG;
-
-    if ($count) {
-        $sql  = "SELECT COUNT(c.id)";
-    } else {
-        $sql = "SELECT c.id,c.shortname,c.fullname";
+    if (empty($CFG->siteadmins)) {  // Should not happen on an ordinary site
+        return array();
     }
 
-    $alreadycourses = get_courses_in_metacourse($metacourseid);
-
-    $sql .= " FROM {$CFG->prefix}course c WHERE ".((!empty($alreadycourses)) ? "c.id NOT IN (".implode(',',array_keys($alreadycourses)).")
-    AND " : "")." c.id !=$metacourseid and c.id != ".SITEID." and c.metacourse != 1 ".((empty($count)) ? " ORDER BY c.shortname" : "");
+    $sql = "SELECT u.*
+              FROM {user} u
+             WHERE u.deleted = 0 AND u.id IN ($CFG->siteadmins)";
 
-    return get_records_sql($sql);
-}
-
-function count_courses_notin_metacourse($metacourseid) {
-    global $CFG;
-
-    $alreadycourses = get_courses_in_metacourse($metacourseid);
-
-    $sql = "SELECT COUNT(c.id) AS notin FROM {$CFG->prefix}course c
-             WHERE ".((!empty($alreadycourses)) ? "c.id NOT IN (".implode(',',array_keys($alreadycourses)).")
-              AND " : "")." c.id !=$metacourseid and c.id != ".SITEID." and c.metacourse != 1";
-
-    if (!$count = get_record_sql($sql)) {
-        return 0;
-    }
-
-    return $count->notin;
+    return $DB->get_records_sql($sql);
 }
 
 /**
@@ -136,104 +94,96 @@ function count_courses_notin_metacourse($metacourseid) {
  * If $coursid specifies the site course then this function searches
  * through all undeleted and confirmed users
  *
- * @uses $CFG
+ * @global object
  * @uses SITEID
+ * @uses SQL_PARAMS_NAMED
+ * @uses CONTEXT_COURSE
  * @param int $courseid The course in question.
  * @param int $groupid The group in question.
- * @param string $searchtext ?
- * @param string $sort ?
- * @param string $exceptions ?
- * @return object
+ * @param string $searchtext The string to search for
+ * @param string $sort A field to sort by
+ * @param array $exceptions A list of IDs to ignore, eg 2,4,5,8,9,10
+ * @return array
  */
-function search_users($courseid, $groupid, $searchtext, $sort='', $exceptions='') {
-    global $CFG;
+function search_users($courseid, $groupid, $searchtext, $sort='', array $exceptions=null) {
+    global $DB;
 
-    $LIKE      = sql_ilike();
-    $fullname  = sql_fullname('u.firstname', 'u.lastname');
+    $fullname  = $DB->sql_fullname('u.firstname', 'u.lastname');
 
     if (!empty($exceptions)) {
-        $except = ' AND u.id NOT IN ('. $exceptions .') ';
+        list($exceptions, $params) = $DB->get_in_or_equal($exceptions, SQL_PARAMS_NAMED, 'ex', false);
+        $except = "AND u.id $exceptions";
     } else {
-        $except = '';
+        $except = "";
+        $params = array();
     }
 
     if (!empty($sort)) {
-        $order = ' ORDER BY '. $sort;
+        $order = "ORDER BY $sort";
     } else {
-        $order = '';
+        $order = "";
     }
 
-    $select = 'u.deleted = \'0\' AND u.confirmed = \'1\'';
+    $select = "u.deleted = 0 AND u.confirmed = 1 AND (".$DB->sql_like($fullname, ':search1', false)." OR ".$DB->sql_like('u.email', ':search2', false).")";
+    $params['search1'] = "%$searchtext%";
+    $params['search2'] = "%$searchtext%";
 
     if (!$courseid or $courseid == SITEID) {
-        return get_records_sql("SELECT u.id, u.firstname, u.lastname, u.email
-                      FROM {$CFG->prefix}user u
+        $sql = "SELECT u.id, u.firstname, u.lastname, u.email
+                  FROM {user} u
                       WHERE $select
-                          AND ($fullname $LIKE '%$searchtext%' OR u.email $LIKE '%$searchtext%')
-                          $except $order");
-    } else {
+                       $except
+                $order";
+        return $DB->get_records_sql($sql, $params);
 
+    } else {
         if ($groupid) {
-//TODO:check. Remove group DB dependencies.
-            return get_records_sql("SELECT u.id, u.firstname, u.lastname, u.email
-                          FROM {$CFG->prefix}user u,
-                               {$CFG->prefix}groups_members gm
-                          WHERE $select AND gm.groupid = '$groupid' AND gm.userid = u.id
-                              AND ($fullname $LIKE '%$searchtext%' OR u.email $LIKE '%$searchtext%')
-                              $except $order");
+            $sql = "SELECT u.id, u.firstname, u.lastname, u.email
+                      FROM {user} u
+                      JOIN {groups_members} gm ON gm.userid = u.id
+                     WHERE $select AND gm.groupid = :groupid
+                           $except
+                     $order";
+            $params['groupid'] = $groupid;
+            return $DB->get_records_sql($sql, $params);
+
         } else {
             $context = get_context_instance(CONTEXT_COURSE, $courseid);
             $contextlists = get_related_contexts_string($context);
-            $users = get_records_sql("SELECT u.id, u.firstname, u.lastname, u.email
-                          FROM {$CFG->prefix}user u,
-                               {$CFG->prefix}role_assignments ra
-                          WHERE $select AND ra.contextid $contextlists AND ra.userid = u.id
-                              AND ($fullname $LIKE '%$searchtext%' OR u.email $LIKE '%$searchtext%')
-                              $except $order");
+
+            $sql = "SELECT u.id, u.firstname, u.lastname, u.email
+                      FROM {user} u
+                      JOIN {role_assignments} ra ON ra.userid = u.id
+                     WHERE $select AND ra.contextid $contextlists
+                           $except
+                    $order";
+            return $DB->get_records_sql($sql, $params);
         }
-        return $users;
     }
 }
 
-
-/**
- * Returns a list of all site users
- * Obsolete, just calls get_course_users(SITEID)
- *
- * @uses SITEID
- * @deprecated Use {@link get_course_users()} instead.
- * @param string $fields A comma separated list of fields to be returned from the chosen table.
- * @param string $exceptions A comma separated list of user->id to be skiped in the result returned by the function
- * @param int $limitfrom return a subset of records, starting at this point (optional, required if $limitnum is set).
- * @param int $limitnum return a subset comprising this many records (optional, required if $limitfrom is set).
- * @return object|false  {@link $USER} records or false if error.
- */
-function get_site_users($sort='u.lastaccess DESC', $fields='*', $exceptions='', $limitfrom='', $limitnum='') {
-
-    return get_course_users(SITEID, $sort, $exceptions, $fields, $limitfrom, $limitnum);
-}
-
-
 /**
  * Returns a subset of users
  *
- * @uses $CFG
+ * @global object
+ * @uses DEBUG_DEVELOPER
+ * @uses SQL_PARAMS_NAMED
  * @param bool $get If false then only a count of the records is returned
  * @param string $search A simple string to search for
  * @param bool $confirmed A switch to allow/disallow unconfirmed users
- * @param array(int) $exceptions A list of IDs to ignore, eg 2,4,5,8,9,10
+ * @param array $exceptions A list of IDs to ignore, eg 2,4,5,8,9,10
  * @param string $sort A SQL snippet for the sorting criteria to use
- * @param string $firstinitial ?
- * @param string $lastinitial ?
- * @param string $page ?
- * @param string $recordsperpage ?
+ * @param string $firstinitial Users whose first name starts with $firstinitial
+ * @param string $lastinitial Users whose last name starts with $lastinitial
+ * @param string $page The page or records to return
+ * @param string $recordsperpage The number of records to return per page
  * @param string $fields A comma separated list of fields to be returned from the chosen table.
- * @return object|false|int  {@link $USER} records unless get is false in which case the integer count of the records found is returned. False is returned if an error is encountered.
+ * @return array|int|bool  {@link $USER} records unless get is false in which case the integer count of the records found is returned.
+  *                        False is returned if an error is encountered.
  */
-function get_users($get=true, $search='', $confirmed=false, $exceptions='', $sort='firstname ASC',
-                   $firstinitial='', $lastinitial='', $page='', $recordsperpage='', $fields='*', $extraselect='') {
-
-    global $CFG;
+function get_users($get=true, $search='', $confirmed=false, array $exceptions=null, $sort='firstname ASC',
+                   $firstinitial='', $lastinitial='', $page='', $recordsperpage='', $fields='*', $extraselect='', array $extraparams=null) {
+    global $DB, $CFG;
 
     if ($get && !$recordsperpage) {
         debugging('Call to get_users with $get = true no $recordsperpage limit. ' .
@@ -242,95 +192,108 @@ function get_users($get=true, $search='', $confirmed=false, $exceptions='', $sor
                 'load so much data into memory.', DEBUG_DEVELOPER);
     }
 
-    $LIKE      = sql_ilike();
-    $fullname  = sql_fullname();
+    $fullname  = $DB->sql_fullname();
 
-    $select = 'username <> \'guest\' AND deleted = 0';
+    $select = " id <> :guestid AND deleted = 0";
+    $params = array('guestid'=>$CFG->siteguest);
 
     if (!empty($search)){
         $search = trim($search);
-        $select .= " AND ($fullname $LIKE '%$search%' OR email $LIKE '%$search%') ";
+        $select .= " AND (".$DB->sql_like($fullname, ':search1', false)." OR ".$DB->sql_like('email', ':search2', false)." OR username = :search3)";
+        $params['search1'] = "%$search%";
+        $params['search2'] = "%$search%";
+        $params['search3'] = "$search";
     }
 
     if ($confirmed) {
-        $select .= ' AND confirmed = \'1\' ';
+        $select .= " AND confirmed = 1";
     }
 
     if ($exceptions) {
-        $select .= ' AND id NOT IN ('. $exceptions .') ';
+        list($exceptions, $eparams) = $DB->get_in_or_equal($exceptions, SQL_PARAMS_NAMED, 'ex', false);
+        $params = $params + $eparams;
+        $except = " AND id $exceptions";
     }
 
     if ($firstinitial) {
-        $select .= ' AND firstname '. $LIKE .' \''. $firstinitial .'%\'';
+        $select .= " AND ".$DB->sql_like('firstname', ':fni', false, false);
+        $params['fni'] = "$firstinitial%";
     }
     if ($lastinitial) {
-        $select .= ' AND lastname '. $LIKE .' \''. $lastinitial .'%\'';
+        $select .= " AND ".$DB->sql_like('lastname', ':lni', false, false);
+        $params['lni'] = "$lastinitial%";
     }
 
     if ($extraselect) {
-        $select .= " AND $extraselect ";
+        $select .= " AND $extraselect";
+        $params = $params + (array)$extraparams;
     }
 
     if ($get) {
-        return get_records_select('user', $select, $sort, $fields, $page, $recordsperpage);
+        return $DB->get_records_select('user', $select, $params, $sort, $fields, $page, $recordsperpage);
     } else {
-        return count_records_select('user', $select);
+        return $DB->count_records_select('user', $select, $params);
     }
 }
 
 
 /**
- * shortdesc (optional)
- *
- * longdesc
- *
- * @uses $CFG
- * @param string $sort ?
- * @param string $dir ?
- * @param int $categoryid ?
- * @param int $categoryid ?
- * @param string $search ?
- * @param string $firstinitial ?
- * @param string $lastinitial ?
- * @returnobject {@link $USER} records
  * @todo Finish documenting this function
+ *
+ * @param string $sort An SQL field to sort by
+ * @param string $dir The sort direction ASC|DESC
+ * @param int $page The page or records to return
+ * @param int $recordsperpage The number of records to return per page
+ * @param string $search A simple string to search for
+ * @param string $firstinitial Users whose first name starts with $firstinitial
+ * @param string $lastinitial Users whose last name starts with $lastinitial
+ * @param string $extraselect An additional SQL select statement to append to the query
+ * @param array $extraparams Additional parameters to use for the above $extraselect
+ * @return array Array of {@link $USER} records
  */
 
 function get_users_listing($sort='lastaccess', $dir='ASC', $page=0, $recordsperpage=0,
-                           $search='', $firstinitial='', $lastinitial='', $extraselect='') {
+                           $search='', $firstinitial='', $lastinitial='', $extraselect='', array $extraparams=null) {
+    global $DB;
 
-    global $CFG;
+    $fullname  = $DB->sql_fullname();
 
-    $LIKE      = sql_ilike();
-    $fullname  = sql_fullname();
-
-    $select = "deleted <> '1'";
+    $select = "deleted <> 1";
+    $params = array();
 
     if (!empty($search)) {
         $search = trim($search);
-        $select .= " AND ($fullname $LIKE '%$search%' OR email $LIKE '%$search%' OR username='$search') ";
+        $select .= " AND (". $DB->sql_like($fullname, ':search1', false, false).
+                   " OR ". $DB->sql_like('email', ':search2', false, false).
+                   " OR username = :search3)";
+        $params['search1'] = "%$search%";
+        $params['search2'] = "%$search%";
+        $params['search3'] = "$search";
     }
 
     if ($firstinitial) {
-        $select .= ' AND firstname '. $LIKE .' \''. $firstinitial .'%\' ';
+        $select .= " AND ". $DB->sql_like('firstname', ':fni', false, false);
+        $params['fni'] = "$firstinitial%";
     }
-
     if ($lastinitial) {
-        $select .= ' AND lastname '. $LIKE .' \''. $lastinitial .'%\' ';
+        $select .= " AND ". $DB->sql_like('lastname', ':lni', false, false);
+        $params['lni'] = "$lastinitial%";
     }
 
     if ($extraselect) {
-        $select .= " AND $extraselect ";
+        $select .= " AND $extraselect";
+        $params = $params + (array)$extraparams;
     }
 
     if ($sort) {
-        $sort = ' ORDER BY '. $sort .' '. $dir;
+        $sort = " ORDER BY $sort $dir";
     }
 
 /// warning: will return UNCONFIRMED USERS
-    return get_records_sql("SELECT id, username, email, firstname, lastname, city, country, lastaccess, confirmed, mnethostid
-                              FROM {$CFG->prefix}user
-                             WHERE $select $sort", $page, $recordsperpage);
+    return $DB->get_records_sql("SELECT id, username, email, firstname, lastname, city, country, lastaccess, confirmed, mnethostid
+                                   FROM {user}
+                                  WHERE $select
+                                  $sort", $params, $page, $recordsperpage);
 
 }
 
@@ -338,16 +301,14 @@ function get_users_listing($sort='lastaccess', $dir='ASC', $page=0, $recordsperp
 /**
  * Full list of users that have confirmed their accounts.
  *
- * @uses $CFG
- * @return object
+ * @global object
+ * @return array of unconfirmed users
  */
 function get_users_confirmed() {
-    global $CFG;
-    return get_records_sql("SELECT *
-                              FROM {$CFG->prefix}user
-                             WHERE confirmed = 1
-                               AND deleted = 0
-                               AND username <> 'guest'");
+    global $DB, $CFG;
+    return $DB->get_records_sql("SELECT *
+                                   FROM {user}
+                                  WHERE confirmed = 1 AND deleted = 0 AND id <> ?", array($CFG->siteguest));
 }
 
 
@@ -357,20 +318,21 @@ function get_users_confirmed() {
 /**
  * Returns $course object of the top-level site.
  *
- * @return course  A {@link $COURSE} object for the site
+ * @return object A {@link $COURSE} object for the site, exception if not found
  */
 function get_site() {
-
-    global $SITE;
+    global $SITE, $DB;
 
     if (!empty($SITE->id)) {   // We already have a global to use, so return that
         return $SITE;
     }
 
-    if ($course = get_record('course', 'category', 0)) {
+    if ($course = $DB->get_record('course', array('category'=>0))) {
         return $course;
     } else {
-        return false;
+        // course table exists, but the site is not there,
+        // unfortunately there is no automatic way to recover
+        throw new moodle_exception('nosite', 'error');
     }
 }
 
@@ -382,15 +344,24 @@ function get_site() {
  *            we are using distinct. You almost _NEVER_ need all the fields
  *            in such a large SELECT
  *
- * @param    type description
- *
+ * @global object
+ * @global object
+ * @global object
+ * @uses CONTEXT_COURSE
+ * @param string|int $categoryid Either a category id or 'all' for everything
+ * @param string $sort A field and direction to sort by
+ * @param string $fields The additional fields to return
+ * @return array Array of courses
  */
 function get_courses($categoryid="all", $sort="c.sortorder ASC", $fields="c.*") {
 
-    global $USER, $CFG;
+    global $USER, $CFG, $DB;
 
-    if ($categoryid != "all" && is_numeric($categoryid)) {
-        $categoryselect = "WHERE c.category = '$categoryid'";
+    $params = array();
+
+    if ($categoryid !== "all" && is_numeric($categoryid)) {
+        $categoryselect = "WHERE c.category = :catid";
+        $params['catid'] = $categoryid;
     } else {
         $categoryselect = "";
     }
@@ -403,62 +374,31 @@ function get_courses($categoryid="all", $sort="c.sortorder ASC", $fields="c.*")
 
     $visiblecourses = array();
 
-    // pull out all course matching the cat
-    if ($courses = get_records_sql("SELECT $fields,
-                                    ctx.id AS ctxid, ctx.path AS ctxpath,
-                                    ctx.depth AS ctxdepth, ctx.contextlevel AS ctxlevel
-                                    FROM {$CFG->prefix}course c
-                                    JOIN {$CFG->prefix}context ctx
-                                      ON (c.id = ctx.instanceid 
-                                          AND ctx.contextlevel=".CONTEXT_COURSE.")
+    list($ccselect, $ccjoin) = context_instance_preload_sql('c.id', CONTEXT_COURSE, 'ctx');
+
+    $sql = "SELECT $fields $ccselect
+              FROM {course} c
+           $ccjoin
                                     $categoryselect
-                                    $sortstatement")) {
+              $sortstatement";
+
+    // pull out all course matching the cat
+    if ($courses = $DB->get_records_sql($sql, $params)) {
 
         // loop throught them
         foreach ($courses as $course) {
-            $course = make_context_subobj($course);
+            context_instance_preload($course);
             if (isset($course->visible) && $course->visible <= 0) {
                 // for hidden courses, require visibility check
-                if (has_capability('moodle/course:viewhiddencourses', $course->context)) {
-                    $visiblecourses [] = $course;
+                if (has_capability('moodle/course:viewhiddencourses', get_context_instance(CONTEXT_COURSE, $course->id))) {
+                    $visiblecourses [$course->id] = $course;
                 }
             } else {
-                $visiblecourses [] = $course;
+                $visiblecourses [$course->id] = $course;
             }
         }
     }
     return $visiblecourses;
-
-/*
-    $teachertable = "";
-    $visiblecourses = "";
-    $sqland = "";
-    if (!empty($categoryselect)) {
-        $sqland = "AND ";
-    }
-    if (!empty($USER->id)) {  // May need to check they are a teacher
-        if (!has_capability('moodle/course:create', get_context_instance(CONTEXT_SYSTEM))) {
-            $visiblecourses = "$sqland ((c.visible > 0) OR t.userid = '$USER->id')";
-            $teachertable = "LEFT JOIN {$CFG->prefix}user_teachers t ON t.course = c.id";
-        }
-    } else {
-        $visiblecourses = "$sqland c.visible > 0";
-    }
-
-    if ($categoryselect or $visiblecourses) {
-        $selectsql = "{$CFG->prefix}course c $teachertable WHERE $categoryselect $visiblecourses";
-    } else {
-        $selectsql = "{$CFG->prefix}course c $teachertable";
-    }
-
-    $extrafield = str_replace('ASC','',$sort);
-    $extrafield = str_replace('DESC','',$extrafield);
-    $extrafield = trim($extrafield);
-    if (!empty($extrafield)) {
-        $extrafield = ','.$extrafield;
-    }
-    return get_records_sql("SELECT ".((!empty($teachertable)) ? " DISTINCT " : "")." $fields $extrafield FROM $selectsql ".((!empty($sort)) ? "ORDER BY $sort" : ""));
-    */
 }
 
 
@@ -470,107 +410,91 @@ function get_courses($categoryid="all", $sort="c.sortorder ASC", $fields="c.*")
  *            we are using distinct. You almost _NEVER_ need all the fields
  *            in such a large SELECT
  *
- * @param    type description
- *
+ * @global object
+ * @global object
+ * @global object
+ * @uses CONTEXT_COURSE
+ * @param string|int $categoryid Either a category id or 'all' for everything
+ * @param string $sort A field and direction to sort by
+ * @param string $fields The additional fields to return
+ * @param int $totalcount Reference for the number of courses
+ * @param string $limitfrom The course to start from
+ * @param string $limitnum The number of courses to limit to
+ * @return array Array of courses
  */
 function get_courses_page($categoryid="all", $sort="c.sortorder ASC", $fields="c.*",
                           &$totalcount, $limitfrom="", $limitnum="") {
+    global $USER, $CFG, $DB;
 
-    global $USER, $CFG;
+    $params = array();
 
     $categoryselect = "";
     if ($categoryid != "all" && is_numeric($categoryid)) {
-        $categoryselect = "WHERE c.category = '$categoryid'";
+        $categoryselect = "WHERE c.category = :catid";
+        $params['catid'] = $categoryid;
     } else {
         $categoryselect = "";
     }
 
-    // pull out all course matching the cat
-    $visiblecourses = array();
-    if (!($rs = get_recordset_sql("SELECT $fields,
-                                          ctx.id AS ctxid, ctx.path AS ctxpath,
-                                          ctx.depth AS ctxdepth, ctx.contextlevel AS ctxlevel
-                                   FROM {$CFG->prefix}course c
-                                   JOIN {$CFG->prefix}context ctx
-                                     ON (c.id = ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSE.")
-                                   $categoryselect
-                                   ORDER BY $sort"))) {
-        return $visiblecourses;
-    }
-    $totalcount = 0;
+    list($ccselect, $ccjoin) = context_instance_preload_sql('c.id', CONTEXT_COURSE, 'ctx');
 
+    $totalcount = 0;
     if (!$limitfrom) {
         $limitfrom = 0;
     }
+    $visiblecourses = array();
 
+    $sql = "SELECT $fields $ccselect
+              FROM {course} c
+              $ccjoin
+           $categoryselect
+          ORDER BY $sort";
+
+    // pull out all course matching the cat
+    $rs = $DB->get_recordset_sql($sql, $params);
     // iteration will have to be done inside loop to keep track of the limitfrom and limitnum
-    while ($course = rs_fetch_next_record($rs)) {
-        $course = make_context_subobj($course);
+    foreach($rs as $course) {
+        context_instance_preload($course);
         if ($course->visible <= 0) {
             // for hidden courses, require visibility check
-            if (has_capability('moodle/course:viewhiddencourses', $course->context)) {
+            if (has_capability('moodle/course:viewhiddencourses', get_context_instance(CONTEXT_COURSE, $course->id))) {
                 $totalcount++;
                 if ($totalcount > $limitfrom && (!$limitnum or count($visiblecourses) < $limitnum)) {
-                    $visiblecourses [] = $course;
+                    $visiblecourses [$course->id] = $course;
                 }
             }
         } else {
             $totalcount++;
             if ($totalcount > $limitfrom && (!$limitnum or count($visiblecourses) < $limitnum)) {
-                $visiblecourses [] = $course;
+                $visiblecourses [$course->id] = $course;
             }
         }
     }
-    rs_close($rs);
+    $rs->close();
     return $visiblecourses;
-
-/**
-
-    $categoryselect = "";
-    if ($categoryid != "all" && is_numeric($categoryid)) {
-        $categoryselect = "c.category = '$categoryid'";
-    }
-
-    $teachertable = "";
-    $visiblecourses = "";
-    $sqland = "";
-    if (!empty($categoryselect)) {
-        $sqland = "AND ";
-    }
-    if (!empty($USER) and !empty($USER->id)) {  // May need to check they are a teacher
-        if (!has_capability('moodle/course:create', get_context_instance(CONTEXT_SYSTEM))) {
-            $visiblecourses = "$sqland ((c.visible > 0) OR t.userid = '$USER->id')";
-            $teachertable = "LEFT JOIN {$CFG->prefix}user_teachers t ON t.course=c.id";
-        }
-    } else {
-        $visiblecourses = "$sqland c.visible > 0";
-    }
-
-    if ($limitfrom !== "") {
-        $limit = sql_paging_limit($limitfrom, $limitnum);
-    } else {
-        $limit = "";
-    }
-
-    $selectsql = "{$CFG->prefix}course c $teachertable WHERE $categoryselect $visiblecourses";
-
-    $totalcount = count_records_sql("SELECT COUNT(DISTINCT c.id) FROM $selectsql");
-
-    return get_records_sql("SELECT $fields FROM $selectsql ".((!empty($sort)) ? "ORDER BY $sort" : "")." $limit");
-    */
 }
 
-/*
+/**
  * Retrieve course records with the course managers and other related records
  * that we need for print_course(). This allows print_courses() to do its job
  * in a constant number of DB queries, regardless of the number of courses,
  * role assignments, etc.
  *
  * The returned array is indexed on c.id, and each course will have
- * - $course->context - a context obj
  * - $course->managers - array containing RA objects that include a $user obj
  *                       with the minimal fields needed for fullname()
  *
+ * @global object
+ * @global object
+ * @global object
+ * @uses CONTEXT_COURSE
+ * @uses CONTEXT_SYSTEM
+ * @uses CONTEXT_COURSECAT
+ * @uses SITEID
+ * @param int|string $categoryid Either the categoryid for the courses or 'all'
+ * @param string $sort A SQL sort field and direction
+ * @param array $fields An array of additional fields to fetch
+ * @return array
  */
 function get_courses_wmanagers($categoryid=0, $sort="c.sortorder ASC", $fields=array()) {
     /*
@@ -588,14 +512,16 @@ function get_courses_wmanagers($categoryid=0, $sort="c.sortorder ASC", $fields=a
      * So this should _never_ get called with 'all' on a large site.
      *
      */
-    global $USER, $CFG;
+    global $USER, $CFG, $DB;
 
+    $params = array();
     $allcats = false; // bool flag
     if ($categoryid === 'all') {
         $categoryclause   = '';
         $allcats = true;
     } elseif (is_numeric($categoryid)) {
-        $categoryclause = "c.category = $categoryid";
+        $categoryclause = "c.category = :catid";
+        $params['catid'] = $categoryid;
     } else {
         debugging("Could not recognise categoryid = $categoryid");
         $categoryclause = '';
@@ -603,10 +529,8 @@ function get_courses_wmanagers($categoryid=0, $sort="c.sortorder ASC", $fields=a
 
     $basefields = array('id', 'category', 'sortorder',
                         'shortname', 'fullname', 'idnumber',
-                        'teacher', 'teachers', 'student', 'students',
-                        'guest', 'startdate', 'visible',
-                        'newsitems',  'cost', 'enrol',
-                        'groupmode', 'groupmodeforce');
+                        'startdate', 'visible',
+                        'newsitems', 'groupmode', 'groupmodeforce');
 
     if (!is_null($fields) && is_string($fields)) {
         if (empty($fields)) {
@@ -635,45 +559,45 @@ function get_courses_wmanagers($categoryid=0, $sort="c.sortorder ASC", $fields=a
     }
 
     // pull out all courses matching the cat
-    $sql = "SELECT $coursefields,
-                   ctx.id AS ctxid, ctx.path AS ctxpath,
-                   ctx.depth AS ctxdepth, ctx.contextlevel AS ctxlevel
-            FROM {$CFG->prefix}course c
-            JOIN {$CFG->prefix}context ctx
-                 ON (c.id=ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSE.")
+    list($ccselect, $ccjoin) = context_instance_preload_sql('c.id', CONTEXT_COURSE, 'ctx');
+    $sql = "SELECT $coursefields $ccselect
+              FROM {course} c
+           $ccjoin
                  $where
                  $sortstatement";
 
     $catpaths = array();
     $catpath  = NULL;
-    if ($courses = get_records_sql($sql)) {
+    if ($courses = $DB->get_records_sql($sql, $params)) {
         // loop on courses materialising
         // the context, and prepping data to fetch the
         // managers efficiently later...
         foreach ($courses as $k => $course) {
-            $courses[$k] = make_context_subobj($courses[$k]);
+            context_instance_preload($course);
+            $coursecontext = get_context_instance(CONTEXT_COURSE, $course->id);
+            $courses[$k] = $course;
             $courses[$k]->managers = array();
             if ($allcats === false) {
                 // single cat, so take just the first one...
                 if ($catpath === NULL) {
-                    $catpath = preg_replace(':/\d+$:', '',$courses[$k]->context->path);
+                    $catpath = preg_replace(':/\d+$:', '', $coursecontext->path);
                 }
             } else {
                 // chop off the contextid of the course itself
                 // like dirname() does...
-                $catpaths[] = preg_replace(':/\d+$:', '',$courses[$k]->context->path);
+                $catpaths[] = preg_replace(':/\d+$:', '', $coursecontext->path);
             }
         }
     } else {
         return array(); // no courses!
     }
 
-    $CFG->coursemanager = trim($CFG->coursemanager);
-    if (empty($CFG->coursemanager)) {
+    $CFG->coursecontact = trim($CFG->coursecontact);
+    if (empty($CFG->coursecontact)) {
         return $courses;
     }
 
-    $managerroles = split(',', $CFG->coursemanager);
+    $managerroles = explode(',', $CFG->coursecontact);
     $catctxids = '';
     if (count($managerroles)) {
         if ($allcats === true) {
@@ -706,17 +630,13 @@ function get_courses_wmanagers($categoryid=0, $sort="c.sortorder ASC", $fields=a
          *
          */
         $sql = "SELECT ctx.path, ctx.instanceid, ctx.contextlevel,
-                       ra.hidden,
                        r.id AS roleid, r.name as rolename,
                        u.id AS userid, u.firstname, u.lastname
-                FROM {$CFG->prefix}role_assignments ra
-                JOIN {$CFG->prefix}context ctx
-                  ON ra.contextid = ctx.id
-                JOIN {$CFG->prefix}user u
-                  ON ra.userid = u.id
-                JOIN {$CFG->prefix}role r
-                  ON ra.roleid = r.id
-                LEFT OUTER JOIN {$CFG->prefix}course c
+                  FROM {role_assignments} ra
+                  JOIN {context} ctx ON ra.contextid = ctx.id
+                  JOIN {user} u ON ra.userid = u.id
+                  JOIN {role} r ON ra.roleid = r.id
+                  LEFT OUTER JOIN {course} c
                   ON (ctx.instanceid=c.id AND ctx.contextlevel=".CONTEXT_COURSE.")
                 WHERE ( c.id IS NOT NULL";
         // under certain conditions, $catctxids is NULL
@@ -726,15 +646,15 @@ function get_courses_wmanagers($categoryid=0, $sort="c.sortorder ASC", $fields=a
             $sql .= " OR ra.contextid  IN ($catctxids) )";
         }
 
-        $sql .= "AND ra.roleid IN ({$CFG->coursemanager})
+        $sql .= "AND ra.roleid IN ({$CFG->coursecontact})
                       $categoryclause
                 ORDER BY r.sortorder ASC, ctx.contextlevel ASC, ra.sortorder ASC";
-        $rs = get_recordset_sql($sql);
+        $rs = $DB->get_recordset_sql($sql, $params);
 
         // This loop is fairly stupid as it stands - might get better
         // results doing an initial pass clustering RAs by path.
-        while ($ra = rs_fetch_next_record($rs)) {
-            $user = new StdClass;
+        foreach($rs as $ra) {
+            $user = new stdClass;
             $user->id        = $ra->userid;    unset($ra->userid);
             $user->firstname = $ra->firstname; unset($ra->firstname);
             $user->lastname  = $ra->lastname;  unset($ra->lastname);
@@ -743,7 +663,7 @@ function get_courses_wmanagers($categoryid=0, $sort="c.sortorder ASC", $fields=a
                 foreach ($courses as $k => $course) {
                     $courses[$k]->managers[] = $ra;
                 }
-            } elseif ($ra->contextlevel == CONTEXT_COURSECAT) {
+            } else if ($ra->contextlevel == CONTEXT_COURSECAT) {
                 if ($allcats === false) {
                     // It always applies
                     foreach ($courses as $k => $course) {
@@ -751,432 +671,130 @@ function get_courses_wmanagers($categoryid=0, $sort="c.sortorder ASC", $fields=a
                     }
                 } else {
                     foreach ($courses as $k => $course) {
+                        $coursecontext = get_context_instance(CONTEXT_COURSE, $course->id);
                         // Note that strpos() returns 0 as "matched at pos 0"
-                        if (strpos($course->context->path, $ra->path.'/')===0) {
+                        if (strpos($coursecontext->path, $ra->path.'/') === 0) {
                             // Only add it to subpaths
                             $courses[$k]->managers[] = $ra;
                         }
                     }
                 }
             } else { // course-level
-                if(!array_key_exists($ra->instanceid, $courses)) {
+                if (!array_key_exists($ra->instanceid, $courses)) {
                     //this course is not in a list, probably a frontpage course
                     continue;
                 }
                 $courses[$ra->instanceid]->managers[] = $ra;
             }
         }
-        rs_close($rs);
+        $rs->close();
     }
 
     return $courses;
 }
 
 /**
- * Convenience function - lists courses that a user has access to view.
- *
- * For admins and others with access to "every" course in the system, we should
- * try to get courses with explicit RAs.
- *
- * NOTE: this function is heavily geared towards the perspective of the user
- *       passed in $userid. So it will hide courses that the user cannot see
- *       (for any reason) even if called from cron or from another $USER's
- *       perspective.
- *
- *       If you really want to know what courses are assigned to the user,
- *       without any hiding or scheming, call the lower-level
- *       get_user_courses_bycap().
- *
- *
- * Notes inherited from get_user_courses_bycap():
- *
- * - $fields is an array of fieldnames to ADD
- *   so name the fields you really need, which will
- *   be added and uniq'd
- *
- * - the course records have $c->context which is a fully
- *   valid context object. Saves you a query per course!
- *
- * @uses $CFG,$USER
- * @param int $userid The user of interest
- * @param string $sort the sortorder in the course table
- * @param array $fields - names of _additional_ fields to return (also accepts a string)
- * @param bool $doanything True if using the doanything flag
- * @param int $limit Maximum number of records to return, or 0 for unlimited
- * @return array {@link $COURSE} of course objects
- */
-function get_my_courses($userid, $sort='visible DESC,sortorder ASC', $fields=NULL, $doanything=false,$limit=0) {
-
-    global $CFG,$USER;
-
-    // Guest's do not have any courses
-    $sitecontext = get_context_instance(CONTEXT_SYSTEM);
-    if (has_capability('moodle/legacy:guest',$sitecontext,$userid,false)) {
-        return(array());
-    }
-
-    $basefields = array('id', 'category', 'sortorder',
-                        'shortname', 'fullname', 'idnumber',
-                        'teacher', 'teachers', 'student', 'students',
-                        'guest', 'startdate', 'visible',
-                        'newsitems',  'cost', 'enrol',
-                        'groupmode', 'groupmodeforce');
-
-    if (!is_null($fields) && is_string($fields)) {
-        if (empty($fields)) {
-            $fields = $basefields;
-        } else {
-            // turn the fields from a string to an array that
-            // get_user_courses_bycap() will like...
-            $fields = explode(',',$fields);
-            $fields = array_map('trim', $fields);
-            $fields = array_unique(array_merge($basefields, $fields));
-        }
-    } elseif (is_array($fields)) {
-        $fields = array_unique(array_merge($basefields, $fields));
-    } else {
-        $fields = $basefields;
-    }
-
-    $orderby = '';
-    $sort    = trim($sort);
-    if (!empty($sort)) {
-        $rawsorts = explode(',', $sort);
-        $sorts = array();
-        foreach ($rawsorts as $rawsort) {
-            $rawsort = trim($rawsort);
-            if (strpos($rawsort, 'c.') === 0) {
-                $rawsort = substr($rawsort, 2);
-            }
-            $sorts[] = trim($rawsort);
-        }
-        $sort = 'c.'.implode(',c.', $sorts);
-        $orderby = "ORDER BY $sort";
-    }
-
-    //
-    // Logged-in user - Check cached courses
-    //
-    // NOTE! it's a _string_ because
-    // - it's all we'll ever use
-    // - it serialises much more compact than an array
-    //   this a big concern here - cost of serialise
-    //   and unserialise gets huge as the session grows
-    //
-    // If the courses are too many - it won't be set
-    // for large numbers of courses, caching in the session
-    // has marginal benefits (costs too much, not
-    // worthwhile...) and we may hit SQL parser limits
-    // because we use IN()
-    //
-    if ($userid === $USER->id) {
-        if (isset($USER->loginascontext)
-            && $USER->loginascontext->contextlevel == CONTEXT_COURSE) {
-            // list _only_ this course
-            // anything else is asking for trouble...
-            $courseids = $USER->loginascontext->instanceid;
-        } elseif (isset($USER->mycourses)
-                  && is_string($USER->mycourses)) {
-            if ($USER->mycourses === '') {
-                // empty str means: user has no courses
-                // ... so do the easy thing...
-                return array();
-            } else {
-                $courseids = $USER->mycourses;
-            }
-        }
-        if (isset($courseids)) {
-            // The data massaging here MUST be kept in sync with
-            // get_user_courses_bycap() so we return
-            // the same...
-            // (but here we don't need to check has_cap)
-            $coursefields = 'c.' .join(',c.', $fields);
-            $sql = "SELECT $coursefields,
-                           ctx.id AS ctxid, ctx.path AS ctxpath,
-                           ctx.depth as ctxdepth, ctx.contextlevel AS ctxlevel,
-                           cc.path AS categorypath
-                    FROM {$CFG->prefix}course c
-                    JOIN {$CFG->prefix}course_categories cc
-                      ON c.category=cc.id
-                    JOIN {$CFG->prefix}context ctx
-                      ON (c.id=ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSE.")
-                    WHERE c.id IN ($courseids)
-                    $orderby";
-            $rs = get_recordset_sql($sql);
-            $courses = array();
-            $cc = 0; // keep count
-            while ($c = rs_fetch_next_record($rs)) {
-                // build the context obj
-                $c = make_context_subobj($c);
-
-                if ($limit > 0 && $cc >= $limit) {
-                    break;
-                }
-                
-                $courses[$c->id] = $c;
-                $cc++;
-            }
-            rs_close($rs);
-            return $courses;
-        }
-    }
-
-    // Non-cached - get accessinfo
-    if ($userid === $USER->id && isset($USER->access)) {
-        $accessinfo = $USER->access;
-    } else {
-        $accessinfo = get_user_access_sitewide($userid);
-    }
-
-
-    $courses = get_user_courses_bycap($userid, 'moodle/course:view', $accessinfo,
-                                      $doanything, $sort, $fields,
-                                      $limit);
-
-    $cats = NULL;
-    // If we have to walk category visibility
-    // to eval course visibility, get the categories
-    if (empty($CFG->allowvisiblecoursesinhiddencategories)) {
-        $sql = "SELECT cc.id, cc.path, cc.visible,
-                       ctx.id AS ctxid, ctx.path AS ctxpath,
-                       ctx.depth as ctxdepth, ctx.contextlevel AS ctxlevel
-                 FROM {$CFG->prefix}course_categories cc
-                 JOIN {$CFG->prefix}context ctx ON (cc.id = ctx.instanceid)
-                WHERE ctx.contextlevel = ".CONTEXT_COURSECAT."
-             ORDER BY cc.id";
-        $rs = get_recordset_sql($sql);
-
-        // Using a temporary array instead of $cats here, to avoid a "true" result when isnull($cats) further down
-        $categories = array();
-        while ($course_cat = rs_fetch_next_record($rs)) {
-            // build the context obj
-            $course_cat = make_context_subobj($course_cat);
-            $categories[$course_cat->id] = $course_cat;
-        }
-        rs_close($rs);
-
-        if (!empty($categories)) {
-            $cats = $categories;
-        }
-
-        unset($course_cat);
-    }
-    //
-    // Strangely, get_my_courses() is expected to return the
-    // array keyed on id, which messes up the sorting
-    // So do that, and also cache the ids in the session if appropriate
-    //
-    $kcourses = array();
-    $courses_count = count($courses);
-    $cacheids = NULL;
-    $vcatpaths = array();
-    if ($userid === $USER->id && $courses_count < 500) {
-        $cacheids = array();
-    }
-    for ($n=0; $n<$courses_count; $n++) {
-
-        //
-        // Check whether $USER (not $userid) can _actually_ see them
-        // Easy if $CFG->allowvisiblecoursesinhiddencategories
-        // is set, and we don't have to care about categories.
-        // Lots of work otherwise... (all in mem though!)
-        //
-        $cansee = false;
-        if (is_null($cats)) { // easy rules!
-            if ($courses[$n]->visible == true) {
-                $cansee = true;
-            } elseif (has_capability('moodle/course:viewhiddencourses',
-                                     $courses[$n]->context, $USER->id)) {
-                $cansee = true;
-            }
-        } else {
-            //
-            // Is the cat visible?
-            // we have to assume it _is_ visible
-            // so we can shortcut when we find a hidden one
-            //
-            $viscat = true;
-            $cpath = $courses[$n]->categorypath;
-            if (isset($vcatpaths[$cpath])) {
-                $viscat = $vcatpaths[$cpath];
-            } else {
-                $cpath = substr($cpath,1); // kill leading slash
-                $cpath = explode('/',$cpath);
-                $ccct  = count($cpath);
-                for ($m=0;$m<$ccct;$m++) {
-                    $ccid = $cpath[$m];
-                    if ($cats[$ccid]->visible==false) {
-                        $viscat = false;
-                        break;
-                    }
-                }
-                $vcatpaths[$courses[$n]->categorypath] = $viscat;
-            }
-
-            //
-            // Perhaps it's actually visible to $USER
-            // check moodle/category:viewhiddencategories
-            //
-            // The name isn't obvious, but the description says
-            // "See hidden categories" so the user shall see...
-            // But also check if the allowvisiblecoursesinhiddencategories setting is true, and check for course visibility
-            if ($viscat === false) {
-                $catctx = $cats[$courses[$n]->category]->context;
-                if (has_capability('moodle/category:viewhiddencategories', $catctx, $USER->id)) {
-                    $vcatpaths[$courses[$n]->categorypath] = true;
-                    $viscat = true;
-                } elseif ($CFG->allowvisiblecoursesinhiddencategories && $courses[$n]->visible == true) {
-                    $viscat = true;
-                }
-            }
-
-            //
-            // Decision matrix
-            //
-            if ($viscat === true) {
-                if ($courses[$n]->visible == true) {
-                    $cansee = true;
-                } elseif (has_capability('moodle/course:viewhiddencourses',
-                                        $courses[$n]->context, $USER->id)) {
-                    $cansee = true;
-                }
-            }
-        }
-        if ($cansee === true) {
-            $kcourses[$courses[$n]->id] = $courses[$n];
-            if (is_array($cacheids)) {
-                $cacheids[] = $courses[$n]->id;
-            }
-        }
-    }
-    if (is_array($cacheids)) {
-        // Only happens
-        // - for the logged in user
-        // - below the threshold (500)
-        // empty string is _valid_
-        $USER->mycourses = join(',',$cacheids);
-    } elseif ($userid === $USER->id && isset($USER->mycourses)) {
-        // cheap sanity check
-        unset($USER->mycourses);
-    }
-
-    return $kcourses;
-}
-
-/**
  * A list of courses that match a search
  *
- * @uses $CFG
- * @param array $searchterms ?
- * @param string $sort ?
- * @param int $page ?
- * @param int $recordsperpage ?
- * @param int $totalcount Passed in by reference. ?
+ * @global object
+ * @global object
+ * @param array $searchterms An array of search criteria
+ * @param string $sort A field and direction to sort by
+ * @param int $page The page number to get
+ * @param int $recordsperpage The number of records per page
+ * @param int $totalcount Passed in by reference.
  * @return object {@link $COURSE} records
  */
 function get_courses_search($searchterms, $sort='fullname ASC', $page=0, $recordsperpage=50, &$totalcount) {
+    global $CFG, $DB;
 
-    global $CFG;
+    if ($DB->sql_regex_supported()) {
+        $REGEXP    = $DB->sql_regex(true);
+        $NOTREGEXP = $DB->sql_regex(false);
+    }
+
+    $searchcond = array();
+    $params     = array();
+    $i = 0;
 
-    //to allow case-insensitive search for postgesql
-    if ($CFG->dbfamily == 'postgres') {
-        $LIKE = 'ILIKE';
-        $NOTLIKE = 'NOT ILIKE';   // case-insensitive
-        $REGEXP = '~*';
-        $NOTREGEXP = '!~*';
+    // Thanks Oracle for your non-ansi concat and type limits in coalesce. MDL-29912
+    if ($DB->get_dbfamily() == 'oracle') {
+        $concat = $DB->sql_concat('c.summary', "' '", 'c.fullname', "' '", 'c.idnumber', "' '", 'c.shortname');
     } else {
-        $LIKE = 'LIKE';
-        $NOTLIKE = 'NOT LIKE';
-        $REGEXP = 'REGEXP';
-        $NOTREGEXP = 'NOT REGEXP';
+        $concat = $DB->sql_concat("COALESCE(c.summary, '". $DB->sql_empty() ."')", "' '", 'c.fullname', "' '", 'c.idnumber', "' '", 'c.shortname');
     }
 
-    $fullnamesearch = '';
-    $summarysearch = '';
-    $idnumbersearch = '';
-    $shortnamesearch = '';
-
     foreach ($searchterms as $searchterm) {
+        $i++;
 
-        $NOT = ''; /// Initially we aren't going to perform NOT LIKE searches, only MSSQL and Oracle
+        $NOT = false; /// Initially we aren't going to perform NOT LIKE searches, only MSSQL and Oracle
                    /// will use it to simulate the "-" operator with LIKE clause
 
     /// Under Oracle and MSSQL, trim the + and - operators and perform
     /// simpler LIKE (or NOT LIKE) queries
-        if ($CFG->dbfamily == 'oracle' || $CFG->dbfamily == 'mssql') {
+        if (!$DB->sql_regex_supported()) {
             if (substr($searchterm, 0, 1) == '-') {
-                $NOT = ' NOT ';
+                $NOT = true;
             }
             $searchterm = trim($searchterm, '+-');
         }
 
-        if ($fullnamesearch) {
-            $fullnamesearch .= ' AND ';
-        }
-        if ($summarysearch) {
-            $summarysearch .= ' AND ';
-        }
-        if ($idnumbersearch) {
-            $idnumbersearch .= ' AND ';
-        }
-        if ($shortnamesearch) {
-            $shortnamesearch .= ' AND ';
-        }
+        // TODO: +- may not work for non latin languages
 
         if (substr($searchterm,0,1) == '+') {
-            $searchterm      = substr($searchterm,1);
-            $summarysearch  .= " c.summary $REGEXP '(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)' ";
-            $fullnamesearch .= " c.fullname $REGEXP '(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)' ";
-            $idnumbersearch  .= " c.idnumber $REGEXP '(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)' ";
-            $shortnamesearch  .= " c.shortname $REGEXP '(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)' ";
+            $searchterm = trim($searchterm, '+-');
+            $searchterm = preg_quote($searchterm, '|');
+            $searchcond[] = "$concat $REGEXP :ss$i";
+            $params['ss'.$i] = "(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)";
+
         } else if (substr($searchterm,0,1) == "-") {
-            $searchterm      = substr($searchterm,1);
-            $summarysearch  .= " c.summary $NOTREGEXP '(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)' ";
-            $fullnamesearch .= " c.fullname $NOTREGEXP '(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)' ";
-            $idnumbersearch .= " c.idnumber $NOTREGEXP '(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)' ";
-            $shortnamesearch .= " c.shortname $NOTREGEXP '(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)' ";
+            $searchterm = trim($searchterm, '+-');
+            $searchterm = preg_quote($searchterm, '|');
+            $searchcond[] = "$concat $NOTREGEXP :ss$i";
+            $params['ss'.$i] = "(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)";
+
         } else {
-            $summarysearch .= ' summary '. $NOT . $LIKE .' \'%'. $searchterm .'%\' ';
-            $fullnamesearch .= ' fullname '. $NOT . $LIKE .' \'%'. $searchterm .'%\' ';
-            $idnumbersearch .= ' idnumber '. $NOT . $LIKE .' \'%'. $searchterm .'%\' ';
-            $shortnamesearch .= ' shortname '. $NOT . $LIKE .' \'%'. $searchterm .'%\' ';
+            $searchcond[] = $DB->sql_like($concat,":ss$i", false, true, $NOT);
+            $params['ss'.$i] = "%$searchterm%";
+        }
         }
 
+    if (empty($searchcond)) {
+        $totalcount = 0;
+        return array();
     }
 
-    $sql = "SELECT c.*,
-                   ctx.id AS ctxid, ctx.path AS ctxpath,
-                   ctx.depth AS ctxdepth, ctx.contextlevel AS ctxlevel
-            FROM {$CFG->prefix}course c
-            JOIN {$CFG->prefix}context ctx
-             ON (c.id = ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSE.")
-            WHERE (( $fullnamesearch ) OR ( $summarysearch ) OR ( $idnumbersearch ) OR ( $shortnamesearch ))
-                  AND category > 0
-            ORDER BY " . $sort;
+    $searchcond = implode(" AND ", $searchcond);
 
     $courses = array();
-
-    if ($rs = get_recordset_sql($sql)) {
-
+    $c = 0; // counts how many visible courses we've seen
 
         // Tiki pagination
         $limitfrom = $page * $recordsperpage;
         $limitto   = $limitfrom + $recordsperpage;
-        $c = 0; // counts how many visible courses we've seen
 
-        while ($course = rs_fetch_next_record($rs)) {
-            $course = make_context_subobj($course);
-            if ($course->visible || has_capability('moodle/course:viewhiddencourses', $course->context)) {
+    list($ccselect, $ccjoin) = context_instance_preload_sql('c.id', CONTEXT_COURSE, 'ctx');
+    $sql = "SELECT c.* $ccselect
+              FROM {course} c
+           $ccjoin
+             WHERE $searchcond AND c.id <> ".SITEID."
+          ORDER BY $sort";
+
+    $rs = $DB->get_recordset_sql($sql, $params);
+    foreach($rs as $course) {
+        context_instance_preload($course);
+        $coursecontext = get_context_instance(CONTEXT_COURSE, $course->id);
+        if ($course->visible || has_capability('moodle/course:viewhiddencourses', $coursecontext)) {
                 // Don't exit this loop till the end
                 // we need to count all the visible courses
                 // to update $totalcount
                 if ($c >= $limitfrom && $c < $limitto) {
-                    $courses[] = $course;
+                $courses[$course->id] = $course;
                 }
                 $c++;
             }
         }
-    }
+    $rs->close();
 
     // our caller expects 2 bits of data - our return
     // array, and an updated $totalcount
@@ -1194,14 +812,15 @@ function get_courses_search($searchterms, $sort='fullname ASC', $page=0, $record
  * a "shallow" resultset. Pass false to $shallow and it will return all
  * the child categories as well.
  *
- *
+ * @global object
+ * @uses CONTEXT_COURSECAT
  * @param string $parent The parent category if any
  * @param string $sort the sortorder
  * @param bool   $shallow - set to false to get the children too
  * @return array of categories
  */
 function get_categories($parent='none', $sort=NULL, $shallow=true) {
-    global $CFG;
+    global $DB;
 
     if ($sort === NULL) {
         $sort = 'ORDER BY cc.sortorder ASC';
@@ -1211,47 +830,44 @@ function get_categories($parent='none', $sort=NULL, $shallow=true) {
         $sort = "ORDER BY $sort";
     }
 
+    list($ccselect, $ccjoin) = context_instance_preload_sql('cc.id', CONTEXT_COURSECAT, 'ctx');
+
     if ($parent === 'none') {
-        $sql = "SELECT cc.*,
-                      ctx.id AS ctxid, ctx.path AS ctxpath,
-                      ctx.depth AS ctxdepth, ctx.contextlevel AS ctxlevel
-                FROM {$CFG->prefix}course_categories cc
-                JOIN {$CFG->prefix}context ctx
-                  ON cc.id=ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSECAT."
+        $sql = "SELECT cc.* $ccselect
+                  FROM {course_categories} cc
+               $ccjoin
                 $sort";
+        $params = array();
+
     } elseif ($shallow) {
-        $parent = (int)$parent;
-        $sql = "SELECT cc.*,
-                       ctx.id AS ctxid, ctx.path AS ctxpath,
-                       ctx.depth AS ctxdepth, ctx.contextlevel AS ctxlevel
-                FROM {$CFG->prefix}course_categories cc
-                JOIN {$CFG->prefix}context ctx
-                  ON cc.id=ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSECAT."
-                WHERE cc.parent=$parent
+        $sql = "SELECT cc.* $ccselect
+                  FROM {course_categories} cc
+               $ccjoin
+                 WHERE cc.parent=?
                 $sort";
+        $params = array($parent);
+
     } else {
-        $parent = (int)$parent;
-        $sql = "SELECT cc.*,
-                       ctx.id AS ctxid, ctx.path AS ctxpath,
-                       ctx.depth AS ctxdepth, ctx.contextlevel AS ctxlevel
-                FROM {$CFG->prefix}course_categories cc
-                JOIN {$CFG->prefix}context ctx
-                  ON cc.id=ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSECAT."
-                JOIN {$CFG->prefix}course_categories ccp
-                     ON ((cc.parent=ccp.id) OR (cc.path LIKE ".sql_concat('ccp.path',"'/%'")."))
-                WHERE ccp.id=$parent
+        $sql = "SELECT cc.* $ccselect
+                  FROM {course_categories} cc
+               $ccjoin
+                  JOIN {course_categories} ccp
+                       ON ((cc.parent = ccp.id) OR (cc.path LIKE ".$DB->sql_concat('ccp.path',"'/%'")."))
+                 WHERE ccp.id=?
                 $sort";
+        $params = array($parent);
     }
     $categories = array();
 
-    if( $rs = get_recordset_sql($sql) ){
-        while ($cat = rs_fetch_next_record($rs)) {
-            $cat = make_context_subobj($cat);
-            if ($cat->visible || has_capability('moodle/category:viewhiddencategories',$cat->context)) {
+    $rs = $DB->get_recordset_sql($sql, $params);
+    foreach($rs as $cat) {
+        context_instance_preload($cat);
+        $catcontext = get_context_instance(CONTEXT_COURSECAT, $cat->id);
+        if ($cat->visible || has_capability('moodle/category:viewhiddencategories', $catcontext)) {
                 $categories[$cat->id] = $cat;
             }
         }
-    }
+    $rs->close();
     return $categories;
 }
 
@@ -1259,14 +875,17 @@ function get_categories($parent='none', $sort=NULL, $shallow=true) {
 /**
  * Returns an array of category ids of all the subcategories for a given
  * category.
- * @param $catid - The id of the category whose subcategories we want to find.
+ *
+ * @global object
+ * @param int $catid - The id of the category whose subcategories we want to find.
  * @return array of category ids.
  */
 function get_all_subcategories($catid) {
+    global $DB;
 
     $subcats = array();
 
-    if ($categories = get_records('course_categories', 'parent', $catid)) {
+    if ($categories = $DB->get_records('course_categories', array('parent'=>$catid))) {
         foreach ($categories as $cat) {
             array_push($subcats, $cat->id);
             $subcats = array_merge($subcats, get_all_subcategories($cat->id));
@@ -1275,221 +894,316 @@ function get_all_subcategories($catid) {
     return $subcats;
 }
 
+/**
+ * Return specified category, default if given does not exist
+ *
+ * @global object
+ * @uses MAX_COURSES_IN_CATEGORY
+ * @uses CONTEXT_COURSECAT
+ * @uses SYSCONTEXTID
+ * @param int $catid course category id
+ * @return object caregory
+ */
+function get_course_category($catid=0) {
+    global $DB;
+
+    $category = false;
+
+    if (!empty($catid)) {
+        $category = $DB->get_record('course_categories', array('id'=>$catid));
+    }
+
+    if (!$category) {
+        // the first category is considered default for now
+        if ($category = $DB->get_records('course_categories', null, 'sortorder', '*', 0, 1)) {
+            $category = reset($category);
+
+        } else {
+            $cat = new stdClass();
+            $cat->name         = get_string('miscellaneous');
+            $cat->depth        = 1;
+            $cat->sortorder    = MAX_COURSES_IN_CATEGORY;
+            $cat->timemodified = time();
+            $catid = $DB->insert_record('course_categories', $cat);
+            // make sure category context exists
+            get_context_instance(CONTEXT_COURSECAT, $catid);
+            mark_context_dirty('/'.SYSCONTEXTID);
+            fix_course_sortorder(); // Required to build course_categories.depth and .path.
+            $category = $DB->get_record('course_categories', array('id'=>$catid));
+        }
+    }
+
+    return $category;
+}
 
 /**
-* This recursive function makes sure that the courseorder is consecutive
-*
-* @param    type description
-*
-* $n is the starting point, offered only for compatilibity -- will be ignored!
-* $safe (bool) prevents it from assuming category-sortorder is unique, used to upgrade
-*       safely from 1.4 to 1.5
-*/
-function fix_course_sortorder($categoryid=0, $n=0, $safe=0, $depth=0, $path='') {
-
-    global $CFG;
-
-    $count = 0;
-
-    $catgap    = 1000; // "standard" category gap
-    $tolerance = 200;  // how "close" categories can get
-
-    if ($categoryid > 0){
-        // update depth and path
-        $cat   = get_record('course_categories', 'id', $categoryid);
-        if ($cat->parent == 0) {
-            $depth = 0;
-            $path  = '';
-        } else if ($depth == 0 ) { // doesn't make sense; get from DB
-            // this is only called if the $depth parameter looks dodgy
-            $parent = get_record('course_categories', 'id', $cat->parent);
-            $path  = $parent->path;
-            $depth = $parent->depth;
-        }
-        $path  = $path . '/' . $categoryid;
-        $depth = $depth + 1;
-
-        if ($cat->path !== $path) {
-            set_field('course_categories', 'path',  addslashes($path),  'id', $categoryid);
-        }
-        if ($cat->depth != $depth) {
-            set_field('course_categories', 'depth', $depth, 'id', $categoryid);
-        }
-    }
-
-    // get some basic info about courses in the category
-    $info = get_record_sql('SELECT MIN(sortorder) AS min,
-                                   MAX(sortorder) AS max,
-                                   COUNT(sortorder)  AS count
-                            FROM ' . $CFG->prefix . 'course
-                            WHERE category=' . $categoryid);
-    if (is_object($info)) { // no courses?
-        $max   = $info->max;
-        $count = $info->count;
-        $min   = $info->min;
-        unset($info);
-    }
-
-    if ($categoryid > 0 && $n==0) { // only passed category so don't shift it
-        $n = $min;
-    }
-
-    // $hasgap flag indicates whether there's a gap in the sequence
-    $hasgap    = false;
-    if ($max-$min+1 != $count) {
-        $hasgap = true;
-    }
-
-    // $mustshift indicates whether the sequence must be shifted to
-    // meet its range
-    $mustshift = false;
-    if ($min < $n-$tolerance || $min > $n+$tolerance+$catgap ) {
-        $mustshift = true;
-    }
-
-    // actually sort only if there are courses,
-    // and we meet one ofthe triggers:
-    //  - safe flag
-    //  - they are not in a continuos block
-    //  - they are too close to the 'bottom'
-    if ($count && ( $safe || $hasgap || $mustshift ) ) {
-        // special, optimized case where all we need is to shift
-        if ( $mustshift && !$safe && !$hasgap) {
-            $shift = $n + $catgap - $min;
-            if ($shift < $count) {
-                $shift = $count + $catgap;
-            }
-            // UPDATE course SET sortorder=sortorder+$shift
-            execute_sql("UPDATE {$CFG->prefix}course
-                         SET sortorder=sortorder+$shift
-                         WHERE category=$categoryid", 0);
-            $n = $n + $catgap + $count;
-
-        } else { // do it slowly
-            $n = $n + $catgap;
-            // if the new sequence overlaps the current sequence, lack of transactions
-            // will stop us -- shift things aside for a moment...
-            if ($safe || ($n >= $min && $n+$count+1 < $min && $CFG->dbfamily==='mysql')) {
-                $shift = $max + $n + 1000;
-                execute_sql("UPDATE {$CFG->prefix}course
-                         SET sortorder=sortorder+$shift
-                         WHERE category=$categoryid", 0);
-            }
-
-            $courses = get_courses($categoryid, 'c.sortorder ASC', 'c.id,c.sortorder');
-            begin_sql();
-            $tx = true; // transaction sanity
-            foreach ($courses as $course) {
-                if ($tx && $course->sortorder != $n ) { // save db traffic
-                    $tx = $tx && set_field('course', 'sortorder', $n,
-                                           'id', $course->id);
+ * Fixes course category and course sortorder, also verifies category and course parents and paths.
+ * (circular references are not fixed)
+ *
+ * @global object
+ * @global object
+ * @uses MAX_COURSES_IN_CATEGORY
+ * @uses MAX_COURSE_CATEGORIES
+ * @uses SITEID
+ * @uses CONTEXT_COURSE
+ * @return void
+ */
+function fix_course_sortorder() {
+    global $DB, $SITE;
+
+    //WARNING: this is PHP5 only code!
+
+    if ($unsorted = $DB->get_records('course_categories', array('sortorder'=>0))) {
+        //move all categories that are not sorted yet to the end
+        $DB->set_field('course_categories', 'sortorder', MAX_COURSES_IN_CATEGORY*MAX_COURSE_CATEGORIES, array('sortorder'=>0));
                 }
-                $n++;
+
+    $allcats = $DB->get_records('course_categories', null, 'sortorder, id', 'id, sortorder, parent, depth, path');
+    $topcats    = array();
+    $brokencats = array();
+    foreach ($allcats as $cat) {
+        $sortorder = (int)$cat->sortorder;
+        if (!$cat->parent) {
+            while(isset($topcats[$sortorder])) {
+                $sortorder++;
             }
-            if ($tx) {
-                commit_sql();
-            } else {
-                rollback_sql();
-                if (!$safe) {
-                    // if we failed when called with !safe, try
-                    // to recover calling self with safe=true
-                    return fix_course_sortorder($categoryid, $n, true, $depth, $path);
+            $topcats[$sortorder] = $cat;
+            continue;
                 }
+        if (!isset($allcats[$cat->parent])) {
+            $brokencats[] = $cat;
+            continue;
+        }
+        if (!isset($allcats[$cat->parent]->children)) {
+            $allcats[$cat->parent]->children = array();
             }
+        while(isset($allcats[$cat->parent]->children[$sortorder])) {
+            $sortorder++;
         }
+        $allcats[$cat->parent]->children[$sortorder] = $cat;
     }
-    set_field('course_categories', 'coursecount', $count, 'id', $categoryid);
+    unset($allcats);
 
-    // $n could need updating
-    $max = get_field_sql("SELECT MAX(sortorder) from {$CFG->prefix}course WHERE category=$categoryid");
-    if ($max > $n) {
-        $n = $max;
+    // add broken cats to category tree
+    if ($brokencats) {
+        $defaultcat = reset($topcats);
+        foreach ($brokencats as $cat) {
+            $topcats[] = $cat;
+        }
     }
 
-    if ($categories = get_categories($categoryid)) {
-        foreach ($categories as $category) {
-            $n = fix_course_sortorder($category->id, $n, $safe, $depth, $path);
+    // now walk recursively the tree and fix any problems found
+    $sortorder = 0;
+    $fixcontexts = array();
+    _fix_course_cats($topcats, $sortorder, 0, 0, '', $fixcontexts);
+
+    // detect if there are "multiple" frontpage courses and fix them if needed
+    $frontcourses = $DB->get_records('course', array('category'=>0), 'id');
+    if (count($frontcourses) > 1) {
+        if (isset($frontcourses[SITEID])) {
+            $frontcourse = $frontcourses[SITEID];
+            unset($frontcourses[SITEID]);
+        } else {
+            $frontcourse = array_shift($frontcourses);
+        }
+        $defaultcat = reset($topcats);
+        foreach ($frontcourses as $course) {
+            $DB->set_field('course', 'category', $defaultcat->id, array('id'=>$course->id));
+            $context = get_context_instance(CONTEXT_COURSE, $course->id);
+            $fixcontexts[$context->id] = $context;
         }
+        unset($frontcourses);
+    } else {
+        $frontcourse = reset($frontcourses);
     }
 
-    return $n+1;
-}
+    // now fix the paths and depths in context table if needed
+    if ($fixcontexts) {
+        rebuild_contexts($fixcontexts);
+    }
 
-/**
- * Ensure all courses have a valid course category
- * useful if a category has been removed manually
- **/
-function fix_coursecategory_orphans() {
+    // release memory
+    unset($topcats);
+    unset($brokencats);
+    unset($fixcontexts);
 
-    global $CFG;
+    // fix frontpage course sortorder
+    if ($frontcourse->sortorder != 1) {
+        $DB->set_field('course', 'sortorder', 1, array('id'=>$frontcourse->id));
+    }
 
-    // Note: the handling of sortorder here is arguably
-    // open to race conditions. Hard to fix here, unlikely
-    // to hit anyone in production.
+    // now fix the course counts in category records if needed
+    $sql = "SELECT cc.id, cc.coursecount, COUNT(c.id) AS newcount
+              FROM {course_categories} cc
+              LEFT JOIN {course} c ON c.category = cc.id
+          GROUP BY cc.id, cc.coursecount
+            HAVING cc.coursecount <> COUNT(c.id)";
 
-    $sql = "SELECT c.id, c.category, c.shortname
-            FROM {$CFG->prefix}course c
-            LEFT OUTER JOIN {$CFG->prefix}course_categories cc ON c.category=cc.id
-            WHERE cc.id IS NULL AND c.id != " . SITEID;
+    if ($updatecounts = $DB->get_records_sql($sql)) {
+        // categories with more courses than MAX_COURSES_IN_CATEGORY
+        $categories = array();
+        foreach ($updatecounts as $cat) {
+            $cat->coursecount = $cat->newcount;
+            if ($cat->coursecount >= MAX_COURSES_IN_CATEGORY) {
+                $categories[] = $cat->id;
+            }
+            unset($cat->newcount);
+            $DB->update_record_raw('course_categories', $cat, true);
+        }
+        if (!empty($categories)) {
+            $str = implode(', ', $categories);
+            debugging("The number of courses (category id: $str) has reached MAX_COURSES_IN_CATEGORY (" . MAX_COURSES_IN_CATEGORY . "), it will cause a sorting performance issue, please increase the value of MAX_COURSES_IN_CATEGORY in lib/datalib.php file. See tracker issue: MDL-25669", DEBUG_DEVELOPER);
+        }
+    }
+
+    // now make sure that sortorders in course table are withing the category sortorder ranges
+    $sql = "SELECT DISTINCT cc.id, cc.sortorder
+              FROM {course_categories} cc
+              JOIN {course} c ON c.category = cc.id
+             WHERE c.sortorder < cc.sortorder OR c.sortorder > cc.sortorder + ".MAX_COURSES_IN_CATEGORY;
+
+    if ($fixcategories = $DB->get_records_sql($sql)) {
+        //fix the course sortorder ranges
+        foreach ($fixcategories as $cat) {
+            $sql = "UPDATE {course}
+                       SET sortorder = ".$DB->sql_modulo('sortorder', MAX_COURSES_IN_CATEGORY)." + ?
+                     WHERE category = ?";
+            $DB->execute($sql, array($cat->sortorder, $cat->id));
+        }
+    }
+    unset($fixcategories);
+
+    // categories having courses with sortorder duplicates or having gaps in sortorder
+    $sql = "SELECT DISTINCT c1.category AS id , cc.sortorder
+              FROM {course} c1
+              JOIN {course} c2 ON c1.sortorder = c2.sortorder
+              JOIN {course_categories} cc ON (c1.category = cc.id)
+             WHERE c1.id <> c2.id";
+    $fixcategories = $DB->get_records_sql($sql);
+
+    $sql = "SELECT cc.id, cc.sortorder, cc.coursecount, MAX(c.sortorder) AS maxsort, MIN(c.sortorder) AS minsort
+              FROM {course_categories} cc
+              JOIN {course} c ON c.category = cc.id
+          GROUP BY cc.id, cc.sortorder, cc.coursecount
+            HAVING (MAX(c.sortorder) <>  cc.sortorder + cc.coursecount) OR (MIN(c.sortorder) <>  cc.sortorder + 1)";
+    $gapcategories = $DB->get_records_sql($sql);
+
+    foreach ($gapcategories as $cat) {
+        if (isset($fixcategories[$cat->id])) {
+            // duplicates detected already
+
+        } else if ($cat->minsort == $cat->sortorder and $cat->maxsort == $cat->sortorder + $cat->coursecount - 1) {
+            // easy - new course inserted with sortorder 0, the rest is ok
+            $sql = "UPDATE {course}
+                       SET sortorder = sortorder + 1
+                     WHERE category = ?";
+            $DB->execute($sql, array($cat->id));
 
-    $rs = get_recordset_sql($sql);
+        } else {
+            // it needs full resorting
+            $fixcategories[$cat->id] = $cat;
+        }
+    }
+    unset($gapcategories);
 
-    if (!rs_EOF($rs)) { // we have some orphans
+    // fix course sortorders in problematic categories only
+    foreach ($fixcategories as $cat) {
+        $i = 1;
+        $courses = $DB->get_records('course', array('category'=>$cat->id), 'sortorder ASC, id DESC', 'id, sortorder');
+        foreach ($courses as $course) {
+            if ($course->sortorder != $cat->sortorder + $i) {
+                $course->sortorder = $cat->sortorder + $i;
+                $DB->update_record_raw('course', $course, true);
+            }
+            $i++;
+        }
+    }
+}
+
+/**
+ * Internal recursive category verification function, do not use directly!
+ *
+ * @todo Document the arguments of this function better
+ *
+ * @global object
+ * @uses MAX_COURSES_IN_CATEGORY
+ * @uses CONTEXT_COURSECAT
+ * @param array $children
+ * @param int $sortorder
+ * @param string $parent
+ * @param int $depth
+ * @param string $path
+ * @param array $fixcontexts
+ * @return void
+ */
+function _fix_course_cats($children, &$sortorder, $parent, $depth, $path, &$fixcontexts) {
+    global $DB;
 
-        // the "default" category is the lowest numbered...
-        $default   = get_field_sql("SELECT MIN(id)
-                                    FROM {$CFG->prefix}course_categories");
-        $sortorder = get_field_sql("SELECT MAX(sortorder)
-                                    FROM {$CFG->prefix}course
-                                    WHERE category=$default");
+    $depth++;
 
+    foreach ($children as $cat) {
+        $sortorder = $sortorder + MAX_COURSES_IN_CATEGORY;
+        $update = false;
+        if ($parent != $cat->parent or $depth != $cat->depth or $path.'/'.$cat->id != $cat->path) {
+            $cat->parent = $parent;
+            $cat->depth  = $depth;
+            $cat->path   = $path.'/'.$cat->id;
+            $update = true;
 
-        begin_sql();
-        $tx = true;
-        while ($tx && $course = rs_fetch_next_record($rs)) {
-            $tx = $tx && set_field('course', 'category',  $default,     'id', $course->id);
-            $tx = $tx && set_field('course', 'sortorder', ++$sortorder, 'id', $course->id);
+            // make sure context caches are rebuild and dirty contexts marked
+            $context = get_context_instance(CONTEXT_COURSECAT, $cat->id);
+            $fixcontexts[$context->id] = $context;
         }
-        if ($tx) {
-            commit_sql();
-        } else {
-            rollback_sql();
+        if ($cat->sortorder != $sortorder) {
+            $cat->sortorder = $sortorder;
+            $update = true;
+        }
+        if ($update) {
+            $DB->update_record('course_categories', $cat, true);
+        }
+        if (isset($cat->children)) {
+            _fix_course_cats($cat->children, $sortorder, $cat->id, $cat->depth, $cat->path, $fixcontexts);
         }
     }
-    rs_close($rs);
 }
 
 /**
  * List of remote courses that a user has access to via MNET.
  * Works only on the IDP
  *
- * @uses $CFG, $USER
- * @return array {@link $COURSE} of course objects
+ * @global object
+ * @global object
+ * @param int @userid The user id to get remote courses for
+ * @return array Array of {@link $COURSE} of course objects
  */
 function get_my_remotecourses($userid=0) {
-    global $CFG, $USER;
+    global $DB, $USER;
 
     if (empty($userid)) {
         $userid = $USER->id;
     }
 
+    // we can not use SELECT DISTINCT + text field (summary) because of MS SQL and Oracle, subselect used therefore
     $sql = "SELECT c.id, c.remoteid, c.shortname, c.fullname,
-                   c.hostid, c.summary, c.cat_name,
+                   c.hostid, c.summary, c.summaryformat, c.categoryname AS cat_name,
                    h.name AS hostname
-            FROM   {$CFG->prefix}mnet_enrol_course c
-            JOIN   {$CFG->prefix}mnet_enrol_assignments a ON c.id=a.courseid
-            JOIN   {$CFG->prefix}mnet_host h        ON c.hostid=h.id
-            WHERE  a.userid={$userid}";
-
-    return get_records_sql($sql);
+              FROM {mnetservice_enrol_courses} c
+              JOIN (SELECT DISTINCT hostid, remotecourseid
+                      FROM {mnetservice_enrol_enrolments}
+                     WHERE userid = ?
+                   ) e ON (e.hostid = c.hostid AND e.remotecourseid = c.remoteid)
+              JOIN {mnet_host} h ON h.id = c.hostid";
+
+    return $DB->get_records_sql($sql, array($userid));
 }
 
 /**
  * List of remote hosts that a user has access to via MNET.
  * Works on the SP
  *
- * @uses $CFG, $USER
- * @return array of host objects
+ * @global object
+ * @global object
+ * @return array|bool Array of host objects or false
  */
 function get_my_remotehosts() {
     global $CFG, $USER;
@@ -1512,71 +1226,50 @@ function get_my_remotehosts() {
  * need to maintain backward compatibility with many different
  * existing language translations and older sites.
  *
- * @uses $CFG
+ * @global object
+ * @return void
  */
 function make_default_scale() {
-
-    global $CFG;
+    global $DB;
 
     $defaultscale = NULL;
     $defaultscale->courseid = 0;
     $defaultscale->userid = 0;
     $defaultscale->name  = get_string('separateandconnected');
+    $defaultscale->description = get_string('separateandconnectedinfo');
     $defaultscale->scale = get_string('postrating1', 'forum').','.
                            get_string('postrating2', 'forum').','.
                            get_string('postrating3', 'forum');
     $defaultscale->timemodified = time();
 
-    /// Read in the big description from the file.  Note this is not
-    /// HTML (despite the file extension) but Moodle format text.
-    $parentlang = get_string('parentlanguage');
-    if ($parentlang[0] == '[') {
-        $parentlang = '';
-    }
-    if (is_readable($CFG->dataroot .'/lang/'. $CFG->lang .'/help/forum/ratings.html')) {
-        $file = file($CFG->dataroot .'/lang/'. $CFG->lang .'/help/forum/ratings.html');
-    } else if (is_readable($CFG->dirroot .'/lang/'. $CFG->lang .'/help/forum/ratings.html')) {
-        $file = file($CFG->dirroot .'/lang/'. $CFG->lang .'/help/forum/ratings.html');
-    } else if ($parentlang and is_readable($CFG->dataroot .'/lang/'. $parentlang .'/help/forum/ratings.html')) {
-        $file = file($CFG->dataroot .'/lang/'. $parentlang .'/help/forum/ratings.html');
-    } else if ($parentlang and is_readable($CFG->dirroot .'/lang/'. $parentlang .'/help/forum/ratings.html')) {
-        $file = file($CFG->dirroot .'/lang/'. $parentlang .'/help/forum/ratings.html');
-    } else if (is_readable($CFG->dirroot .'/lang/en_utf8/help/forum/ratings.html')) {
-        $file = file($CFG->dirroot .'/lang/en_utf8/help/forum/ratings.html');
-    } else {
-        $file = '';
-    }
-
-    $defaultscale->description = addslashes(implode('', $file));
-
-    if ($defaultscale->id = insert_record('scale', $defaultscale)) {
-        execute_sql('UPDATE '. $CFG->prefix .'forum SET scale = \''. $defaultscale->id .'\'', false);
-    }
+    $defaultscale->id = $DB->insert_record('scale', $defaultscale);
+    $DB->execute("UPDATE {forum} SET scale = ?", array($defaultscale->id));
 }
 
 
 /**
  * Returns a menu of all available scales from the site as well as the given course
  *
- * @uses $CFG
+ * @global object
  * @param int $courseid The id of the course as found in the 'course' table.
- * @return object
+ * @return array
  */
 function get_scales_menu($courseid=0) {
+    global $DB;
 
-    global $CFG;
-
-    $sql = "SELECT id, name FROM {$CFG->prefix}scale
-             WHERE courseid = '0' or courseid = '$courseid'
+    $sql = "SELECT id, name
+              FROM {scale}
+             WHERE courseid = 0 or courseid = ?
           ORDER BY courseid ASC, name ASC";
+    $params = array($courseid);
 
-    if ($scales = get_records_sql_menu($sql)) {
+    if ($scales = $DB->get_records_sql_menu($sql, $params)) {
         return $scales;
     }
 
     make_default_scale();
 
-    return get_records_sql_menu($sql);
+    return $DB->get_records_sql_menu($sql, $params);
 }
 
 
@@ -1584,23 +1277,22 @@ function get_scales_menu($courseid=0) {
 /**
  * Given a set of timezone records, put them in the database,  replacing what is there
  *
- * @uses $CFG
+ * @global object
  * @param array $timezones An array of timezone records
+ * @return void
  */
 function update_timezone_records($timezones) {
-/// Given a set of timezone records, put them in the database
-
-    global $CFG;
+    global $DB;
 
 /// Clear out all the old stuff
-    execute_sql('TRUNCATE TABLE '.$CFG->prefix.'timezone', false);
+    $DB->delete_records('timezone');
 
 /// Insert all the new stuff
     foreach ($timezones as $timezone) {
         if (is_array($timezone)) {
             $timezone = (object)$timezone;
         }
-        insert_record('timezone', $timezone);
+        $DB->insert_record('timezone', $timezone);
     }
 }
 
@@ -1610,97 +1302,146 @@ function update_timezone_records($timezones) {
 /**
  * Just gets a raw list of all modules in a course
  *
- * @uses $CFG
+ * @global object
  * @param int $courseid The id of the course as found in the 'course' table.
- * @return object
+ * @return array
  */
 function get_course_mods($courseid) {
-    global $CFG;
+    global $DB;
 
     if (empty($courseid)) {
         return false; // avoid warnings
     }
 
-    return get_records_sql("SELECT cm.*, m.name as modname
-                            FROM {$CFG->prefix}modules m,
-                                 {$CFG->prefix}course_modules cm
-                            WHERE cm.course = ".intval($courseid)."
-                            AND cm.module = m.id AND m.visible = 1"); // no disabled mods
+    return $DB->get_records_sql("SELECT cm.*, m.name as modname
+                                   FROM {modules} m, {course_modules} cm
+                                  WHERE cm.course = ? AND cm.module = m.id AND m.visible = 1",
+                                array($courseid)); // no disabled mods
 }
 
 
 /**
  * Given an id of a course module, finds the coursemodule description
  *
- * @param string $modulename name of module type, eg. resource, assignment,...
+ * @global object
+ * @param string $modulename name of module type, eg. resource, assignment,... (optional, slower and less safe if not specified)
  * @param int $cmid course module id (id in course_modules table)
  * @param int $courseid optional course id for extra validation
- * @return object course module instance with instance and module name
+ * @param bool $sectionnum include relative section number (0,1,2 ...)
+ * @param int $strictness IGNORE_MISSING means compatible mode, false returned if record not found, debug message if more found;
+ *                        IGNORE_MULTIPLE means return first, ignore multiple records found(not recommended);
+ *                        MUST_EXIST means throw exception if no record or multiple records found
+ * @return stdClass
  */
-function get_coursemodule_from_id($modulename, $cmid, $courseid=0) {
+function get_coursemodule_from_id($modulename, $cmid, $courseid=0, $sectionnum=false, $strictness=IGNORE_MISSING) {
+    global $DB;
+
+    $params = array('cmid'=>$cmid);
 
-    global $CFG;
+    if (!$modulename) {
+        if (!$modulename = $DB->get_field_sql("SELECT md.name
+                                                 FROM {modules} md
+                                                 JOIN {course_modules} cm ON cm.module = md.id
+                                                WHERE cm.id = :cmid", $params, $strictness)) {
+            return false;
+        }
+    }
 
-    $courseselect = ($courseid) ? 'cm.course = '.intval($courseid).' AND ' : '';
+    $params['modulename'] = $modulename;
 
-    return get_record_sql("SELECT cm.*, m.name, md.name as modname
-                           FROM {$CFG->prefix}course_modules cm,
-                                {$CFG->prefix}modules md,
-                                {$CFG->prefix}$modulename m
-                           WHERE $courseselect
-                                 cm.id = ".intval($cmid)." AND
-                                 cm.instance = m.id AND
-                                 md.name = '$modulename' AND
-                                 md.id = cm.module");
+    $courseselect = "";
+    $sectionfield = "";
+    $sectionjoin  = "";
+
+    if ($courseid) {
+        $courseselect = "AND cm.course = :courseid";
+        $params['courseid'] = $courseid;
+    }
+
+    if ($sectionnum) {
+        $sectionfield = ", cw.section AS sectionnum";
+        $sectionjoin  = "LEFT JOIN {course_sections} cw ON cw.id = cm.section";
+    }
+
+    $sql = "SELECT cm.*, m.name, md.name AS modname $sectionfield
+              FROM {course_modules} cm
+                   JOIN {modules} md ON md.id = cm.module
+                   JOIN {".$modulename."} m ON m.id = cm.instance
+                   $sectionjoin
+             WHERE cm.id = :cmid AND md.name = :modulename
+                   $courseselect";
+
+    return $DB->get_record_sql($sql, $params, $strictness);
 }
 
 /**
  * Given an instance number of a module, finds the coursemodule description
  *
+ * @global object
  * @param string $modulename name of module type, eg. resource, assignment,...
  * @param int $instance module instance number (id in resource, assignment etc. table)
  * @param int $courseid optional course id for extra validation
- * @return object course module instance with instance and module name
+ * @param bool $sectionnum include relative section number (0,1,2 ...)
+ * @param int $strictness IGNORE_MISSING means compatible mode, false returned if record not found, debug message if more found;
+ *                        IGNORE_MULTIPLE means return first, ignore multiple records found(not recommended);
+ *                        MUST_EXIST means throw exception if no record or multiple records found
+ * @return stdClass
  */
-function get_coursemodule_from_instance($modulename, $instance, $courseid=0) {
+function get_coursemodule_from_instance($modulename, $instance, $courseid=0, $sectionnum=false, $strictness=IGNORE_MISSING) {
+    global $DB;
 
-    global $CFG;
+    $params = array('instance'=>$instance, 'modulename'=>$modulename);
 
-    $courseselect = ($courseid) ? 'cm.course = '.intval($courseid).' AND ' : '';
+    $courseselect = "";
+    $sectionfield = "";
+    $sectionjoin  = "";
 
-    return get_record_sql("SELECT cm.*, m.name, md.name as modname
-                           FROM {$CFG->prefix}course_modules cm,
-                                {$CFG->prefix}modules md,
-                                {$CFG->prefix}$modulename m
-                           WHERE $courseselect
-                                 cm.instance = m.id AND
-                                 md.name = '$modulename' AND
-                                 md.id = cm.module AND
-                                 m.id = ".intval($instance));
+    if ($courseid) {
+        $courseselect = "AND cm.course = :courseid";
+        $params['courseid'] = $courseid;
+    }
+
+    if ($sectionnum) {
+        $sectionfield = ", cw.section AS sectionnum";
+        $sectionjoin  = "LEFT JOIN {course_sections} cw ON cw.id = cm.section";
+    }
+
+    $sql = "SELECT cm.*, m.name, md.name AS modname $sectionfield
+              FROM {course_modules} cm
+                   JOIN {modules} md ON md.id = cm.module
+                   JOIN {".$modulename."} m ON m.id = cm.instance
+                   $sectionjoin
+             WHERE m.id = :instance AND md.name = :modulename
+                   $courseselect";
 
+    return $DB->get_record_sql($sql, $params, $strictness);
 }
 
 /**
  * Returns all course modules of given activity in course
- * @param string $modulename (forum, quiz, etc.)
- * @param int $courseid
+ *
+ * @param string $modulename The module name (forum, quiz, etc.)
+ * @param int $courseid The course id to get modules for
  * @param string $extrafields extra fields starting with m.
- * @return array of cm objects, false if not found or error
+ * @return array Array of results
  */
 function get_coursemodules_in_course($modulename, $courseid, $extrafields='') {
-    global $CFG;
+    global $DB;
 
     if (!empty($extrafields)) {
         $extrafields = ", $extrafields";
     }
-    return get_records_sql("SELECT cm.*, m.name, md.name as modname $extrafields
-                              FROM {$CFG->prefix}course_modules cm,
-                                   {$CFG->prefix}modules md,
-                                   {$CFG->prefix}$modulename m
-                             WHERE cm.course = $courseid AND
+    $params = array();
+    $params['courseid'] = $courseid;
+    $params['modulename'] = $modulename;
+
+
+    return $DB->get_records_sql("SELECT cm.*, m.name, md.name as modname $extrafields
+                                   FROM {course_modules} cm, {modules} md, {".$modulename."} m
+                                  WHERE cm.course = :courseid AND
                                    cm.instance = m.id AND
-                                   md.name = '$modulename' AND
-                                   md.id = cm.module");
+                                        md.name = :modulename AND
+                                        md.id = cm.module", $params);
 }
 
 /**
@@ -1713,13 +1454,17 @@ function get_coursemodules_in_course($modulename, $courseid, $extrafields='') {
  * The returned objects includle the columns cw.section, cm.visible,
  * cm.groupmode and cm.groupingid, cm.groupmembersonly, and are indexed by cm.id.
  *
+ * @global object
+ * @global object
  * @param string $modulename The name of the module to get instances for
  * @param array $courses an array of course objects.
+ * @param int $userid
+ * @param int $includeinvisible
  * @return array of module instance objects, including some extra fields from the course_modules
  *          and course_sections tables, or an empty array if an error occurred.
  */
 function get_all_instances_in_courses($modulename, $courses, $userid=NULL, $includeinvisible=false) {
-    global $CFG;
+    global $CFG, $DB;
 
     $outputarray = array();
 
@@ -1727,22 +1472,21 @@ function get_all_instances_in_courses($modulename, $courses, $userid=NULL, $incl
         return $outputarray;
     }
 
-    if (!$rawmods = get_records_sql("SELECT cm.id AS coursemodule, m.*, cw.section, cm.visible AS visible,
+    list($coursessql, $params) = $DB->get_in_or_equal(array_keys($courses), SQL_PARAMS_NAMED, 'c0');
+    $params['modulename'] = $modulename;
+
+    if (!$rawmods = $DB->get_records_sql("SELECT cm.id AS coursemodule, m.*, cw.section, cm.visible AS visible,
                                             cm.groupmode, cm.groupingid, cm.groupmembersonly
-                                       FROM {$CFG->prefix}course_modules cm,
-                                            {$CFG->prefix}course_sections cw,
-                                            {$CFG->prefix}modules md,
-                                            {$CFG->prefix}$modulename m
-                                      WHERE cm.course IN (".implode(',',array_keys($courses)).") AND
+                                            FROM {course_modules} cm, {course_sections} cw, {modules} md,
+                                                 {".$modulename."} m
+                                           WHERE cm.course $coursessql AND
                                             cm.instance = m.id AND
                                             cm.section = cw.id AND
-                                            md.name = '$modulename' AND
-                                            md.id = cm.module")) {
+                                                 md.name = :modulename AND
+                                                 md.id = cm.module", $params)) {
         return $outputarray;
     }
 
-    require_once($CFG->dirroot.'/course/lib.php');
-
     foreach ($courses as $course) {
         $modinfo = get_fast_modinfo($course, $userid);
 
@@ -1759,7 +1503,7 @@ function get_all_instances_in_courses($modulename, $courses, $userid=NULL, $incl
             }
             $instance = $rawmods[$cm->id];
             if (!empty($cm->extra)) {
-                $instance->extra = urlencode($cm->extra); // bc compatibility
+                $instance->extra = $cm->extra;
             }
             $outputarray[] = $instance;
         }
@@ -1779,10 +1523,14 @@ function get_all_instances_in_courses($modulename, $courses, $userid=NULL, $incl
  * The returned objects includle the columns cw.section, cm.visible,
  * cm.groupmode and cm.groupingid, cm.groupmembersonly, and are indexed by cm.id.
  *
+ * Simply calls {@link all_instances_in_courses()} with a single provided course
+ *
  * @param string $modulename The name of the module to get instances for
  * @param object $course The course obect.
  * @return array of module instance objects, including some extra fields from the course_modules
  *          and course_sections tables, or an empty array if an error occurred.
+ * @param int $userid
+ * @param int $includeinvisible
  */
 function get_all_instances_in_course($modulename, $course, $userid=NULL, $includeinvisible=false) {
     return get_all_instances_in_courses($modulename, array($course->id => $course), $userid, $includeinvisible);
@@ -1796,23 +1544,23 @@ function get_all_instances_in_course($modulename, $course, $userid=NULL, $includ
  * and the module's type (eg "forum") returns whether the object
  * is visible or not, groupmembersonly visibility not tested
  *
- * @uses $CFG
+ * @global object
+
  * @param $moduletype Name of the module eg 'forum'
  * @param $module Object which is the instance of the module
- * @return bool
+ * @return bool Success
  */
 function instance_is_visible($moduletype, $module) {
-
-    global $CFG;
+    global $DB;
 
     if (!empty($module->id)) {
-        if ($records = get_records_sql("SELECT cm.instance, cm.visible, cm.groupingid, cm.id, cm.groupmembersonly, cm.course
-                                        FROM {$CFG->prefix}course_modules cm,
-                                             {$CFG->prefix}modules m
-                                       WHERE cm.course = '$module->course' AND
+        $params = array('courseid'=>$module->course, 'moduletype'=>$moduletype, 'moduleid'=>$module->id);
+        if ($records = $DB->get_records_sql("SELECT cm.instance, cm.visible, cm.groupingid, cm.id, cm.groupmembersonly, cm.course
+                                               FROM {course_modules} cm, {modules} m
+                                              WHERE cm.course = :courseid AND
                                              cm.module = m.id AND
-                                             m.name = '$moduletype' AND
-                                             cm.instance = '$module->id'")) {
+                                                    m.name = :moduletype AND
+                                                    cm.instance = :moduleid", $params)) {
 
             foreach ($records as $record) { // there should only be one - use the first one
                 return $record->visible;
@@ -1826,12 +1574,17 @@ function instance_is_visible($moduletype, $module) {
  * Determine whether a course module is visible within a course,
  * this is different from instance_is_visible() - faster and visibility for user
  *
+ * @global object
+ * @global object
+ * @uses DEBUG_DEVELOPER
+ * @uses CONTEXT_MODULE
+ * @uses CONDITION_MISSING_EXTRATABLE
  * @param object $cm object
  * @param int $userid empty means current user
- * @return bool
+ * @return bool Success
  */
 function coursemodule_visible_for_user($cm, $userid=0) {
-    global $USER;
+    global $USER,$CFG;
 
     if (empty($cm->id)) {
         debugging("Incorrect course module parameter!", DEBUG_DEVELOPER);
@@ -1843,6 +1596,15 @@ function coursemodule_visible_for_user($cm, $userid=0) {
     if (!$cm->visible and !has_capability('moodle/course:viewhiddenactivities', get_context_instance(CONTEXT_MODULE, $cm->id), $userid)) {
         return false;
     }
+    if ($CFG->enableavailability) {
+        require_once($CFG->libdir.'/conditionlib.php');
+        $ci=new condition_info($cm,CONDITION_MISSING_EXTRATABLE);
+        if(!$ci->is_available($cm->availableinfo,false,$userid) and
+            !has_capability('moodle/course:viewhiddenactivities',
+                get_context_instance(CONTEXT_MODULE, $cm->id), $userid)) {
+            return false;
+        }
+    }
     return groups_course_module_visible($cm, $userid);
 }
 
@@ -1859,11 +1621,12 @@ function coursemodule_visible_for_user($cm, $userid=0) {
  * than web server hits, and provide a way to easily reconstruct what
  * any particular student has been doing.
  *
- * @uses $CFG
- * @uses $USER
- * @uses $db
- * @uses $REMOTE_ADDR
+ * @global object
+ * @global object
+ * @global object
  * @uses SITEID
+ * @uses DEBUG_DEVELOPER
+ * @uses DEBUG_ALL
  * @param    int     $courseid  The course id
  * @param    string  $module  The module name - e.g. forum, journal, resource, course, user etc
  * @param    string  $action  'view', 'update', 'add' or 'delete', possibly followed by another word to clarify.
@@ -1871,110 +1634,102 @@ function coursemodule_visible_for_user($cm, $userid=0) {
  * @param    string  $info    Additional description information
  * @param    string  $cm      The course_module->id if there is one
  * @param    string  $user    If log regards $user other than $USER
+ * @return void
  */
 function add_to_log($courseid, $module, $action, $url='', $info='', $cm=0, $user=0) {
     // Note that this function intentionally does not follow the normal Moodle DB access idioms.
     // This is for a good reason: it is the most frequently used DB update function,
     // so it has been optimised for speed.
-    global $db, $CFG, $USER;
+    global $DB, $CFG, $USER;
 
-    // sanitize all incoming data
-    $courseid = clean_param($courseid, PARAM_INT);
-    $module   = clean_param($module, PARAM_SAFEDIR);
-    $action   = addslashes($action);
-    // url cleaned bellow
-    // info cleaned bellow
-    $cm       = clean_param($cm, PARAM_INT);
-    $user     = clean_param($user, PARAM_INT);
+    if ($cm === '' || is_null($cm)) { // postgres won't translate empty string to its default
+        $cm = 0;
+    }
 
     if ($user) {
         $userid = $user;
     } else {
-        if (!empty($USER->realuser)) {  // Don't log
+        if (session_is_loggedinas()) {  // Don't log
             return;
         }
         $userid = empty($USER->id) ? '0' : $USER->id;
     }
 
-    $REMOTE_ADDR = getremoteaddr();
-    if (empty($REMOTE_ADDR)) {
-        $REMOTE_ADDR = '0.0.0.0';
+    if (isset($CFG->logguests) and !$CFG->logguests) {
+        if (!$userid or isguestuser($userid)) {
+            return;
+        }
     }
 
+    $REMOTE_ADDR = getremoteaddr();
+
     $timenow = time();
+    $info = $info;
     if (!empty($url)) { // could break doing html_entity_decode on an empty var.
-        $url = html_entity_decode($url); // for php < 4.3.0 this is defined in moodlelib.php
+        $url = html_entity_decode($url);
+    } else {
+        $url = '';
     }
 
     // Restrict length of log lines to the space actually available in the
     // database so that it doesn't cause a DB error. Log a warning so that
     // developers can avoid doing things which are likely to cause this on a
     // routine basis.
-    $tl=textlib_get_instance();
+    $tl = textlib_get_instance();
     if(!empty($info) && $tl->strlen($info)>255) {
-        $info=$tl->substr($info,0,252).'...';
+        $info = $tl->substr($info,0,252).'...';
         debugging('Warning: logged very long info',DEBUG_DEVELOPER);
     }
-    $info = addslashes($info);
-    // Note: Unlike $info, URL appears to be already slashed before this function
-    // is called. Since database limits are for the data before slashes, we need
-    // to remove them...
-    $url=stripslashes($url);
+
     // If the 100 field size is changed, also need to alter print_log in course/lib.php
     if(!empty($url) && $tl->strlen($url)>100) {
         $url=$tl->substr($url,0,97).'...';
         debugging('Warning: logged very long URL',DEBUG_DEVELOPER);
     }
-    $url=addslashes($url);
 
-    if (defined('MDL_PERFDB')) { global $PERF ; $PERF->dbqueries++; $PERF->logwrites++;};
+    if (defined('MDL_PERFDB')) { global $PERF ; $PERF->logwrites++;};
 
-    $info = empty($info) ? sql_empty() : $info; // Use proper empties for each database
-    $url  = empty($url)  ? sql_empty() : $url;
-    $sql ='INSERT INTO '. $CFG->prefix .'log (time, userid, course, ip, module, cmid, action, url, info)
-        VALUES (' . "'$timenow', '$userid', '$courseid', '$REMOTE_ADDR', '$module', '$cm', '$action', '$url', '$info')";
-
-    $result = $db->Execute($sql);
+    $log = array('time'=>$timenow, 'userid'=>$userid, 'course'=>$courseid, 'ip'=>$REMOTE_ADDR, 'module'=>$module,
+                 'cmid'=>$cm, 'action'=>$action, 'url'=>$url, 'info'=>$info);
 
+    try {
+        $DB->insert_record_raw('log', $log, false);
+    } catch (dml_write_exception $e) {
+        debugging('Error: Could not insert a new entry to the Moodle log', DEBUG_ALL);
     // MDL-11893, alert $CFG->supportemail if insert into log failed
-    if (!$result && $CFG->supportemail) {
+        if ($CFG->supportemail and empty($CFG->noemailever)) {
+            // email_to_user is not usable because email_to_user tries to write to the logs table,
+            // and this will get caught in an infinite loop, if disk is full
         $site = get_site();
         $subject = 'Insert into log failed at your moodle site '.$site->fullname;
         $message = "Insert into log table failed at ". date('l dS \of F Y h:i:s A') .".\n It is possible that your disk is full.\n\n";
-        $message .= "The failed SQL is:\n\n" . $sql;
+            $message .= "The failed query parameters are:\n\n" . var_export($log, true);
 
-        // email_to_user is not usable because email_to_user tries to write to the logs table,
-        // and this will get caught in an infinite loop, if disk is full
-        if (empty($CFG->noemailever)) {
             $lasttime = get_config('admin', 'lastloginserterrormail');
             if(empty($lasttime) || time() - $lasttime > 60*60*24) { // limit to 1 email per day
+                //using email directly rather than messaging as they may not be able to log in to access a message
                 mail($CFG->supportemail, $subject, $message);
                 set_config('lastloginserterrormail', time(), 'admin');
             }
         }
     }
-
-    if (!$result) {
-        debugging('Error: Could not insert a new entry to the Moodle log', DEBUG_ALL);
-    }
-
 }
 
 /**
  * Store user last access times - called when use enters a course or site
  *
- * Note: we use ADOdb code directly in this function to save some CPU
- * cycles here and there. They are simple operations not needing any
- * of the postprocessing performed by dmllib.php
- *
+ * @global object
+ * @global object
+ * @global object
+ * @uses LASTACCESS_UPDATE_SECS
+ * @uses SITEID
  * @param int $courseid, empty means site
  * @return void
  */
 function user_accesstime_log($courseid=0) {
+    global $USER, $CFG, $DB;
 
-    global $USER, $CFG, $PERF, $db;
-
-    if (!isloggedin() or !empty($USER->realuser)) {
+    if (!isloggedin() or session_is_loggedinas()) {
         // no access tracking
         return;
     }
@@ -1989,22 +1744,13 @@ function user_accesstime_log($courseid=0) {
     if ($timenow - $USER->lastaccess > LASTACCESS_UPDATE_SECS) {
     /// Update $USER->lastaccess for next checks
         $USER->lastaccess = $timenow;
-        if (defined('MDL_PERFDB')) { global $PERF ; $PERF->dbqueries++;};
 
-        $remoteaddr = getremoteaddr();
-        if (empty($remoteaddr)) {
-            $remoteaddr = '0.0.0.0';
-        }
-        if ($db->Execute("UPDATE {$CFG->prefix}user
-                             SET lastip = '$remoteaddr', lastaccess = $timenow
-                           WHERE id = $USER->id")) {
-        } else {
-            debugging('Error: Could not update global user lastaccess information');  // Don't throw an error
-        }
-    /// Remove this record from record cache since it will change
-        if (!empty($CFG->rcache)) {
-            rcache_unset('user', $USER->id);
-        }
+        $last = new stdClass();
+        $last->id         = $USER->id;
+        $last->lastip     = getremoteaddr();
+        $last->lastaccess = $timenow;
+
+        $DB->update_record_raw('user', $last);
     }
 
     if ($courseid == SITEID) {
@@ -2014,43 +1760,27 @@ function user_accesstime_log($courseid=0) {
 
 /// Store course lastaccess times for the current user
     if (empty($USER->currentcourseaccess[$courseid]) or ($timenow - $USER->currentcourseaccess[$courseid] > LASTACCESS_UPDATE_SECS)) {
-        if (defined('MDL_PERFDB')) { global $PERF ; $PERF->dbqueries++; };
-
-        $exists = false; // To detect if the user_lastaccess record exists or no
-        if ($rs = $db->Execute("SELECT timeaccess
-                                  FROM {$CFG->prefix}user_lastaccess
-                                 WHERE userid = $USER->id AND courseid = $courseid")) {
-            if (!$rs->EOF) {
-                $exists = true;
-                $lastaccess = reset($rs->fields);
-                if ($timenow - $lastaccess <  LASTACCESS_UPDATE_SECS) {
-                /// no need to update now, it was updated recently in concurrent login ;-)
-                    $rs->Close();
-                    return;
-                }
-            }
-            $rs->Close();
-        }
 
-    /// Update course lastaccess for next checks
+        $lastaccess = $DB->get_field('user_lastaccess', 'timeaccess', array('userid'=>$USER->id, 'courseid'=>$courseid));
+
+        if ($lastaccess === false) {
+            // Update course lastaccess for next checks
         $USER->currentcourseaccess[$courseid] = $timenow;
-        if (defined('MDL_PERFDB')) { global $PERF ; $PERF->dbqueries++; };
 
-        if ($exists) { // user_lastaccess record exists, update it
-            if ($db->Execute("UPDATE {$CFG->prefix}user_lastaccess
-                                 SET timeaccess = $timenow
-                               WHERE userid = $USER->id AND courseid = $courseid")) {
-            } else {
-                debugging('Error: Could not update course user lastacess information');  // Don't throw an error
-            }
+            $last = new stdClass();
+            $last->userid     = $USER->id;
+            $last->courseid   = $courseid;
+            $last->timeaccess = $timenow;
+            $DB->insert_record_raw('user_lastaccess', $last, false);
+
+        } else if ($timenow - $lastaccess <  LASTACCESS_UPDATE_SECS) {
+            // no need to update now, it was updated recently in concurrent login ;-)
 
-        } else { // user lastaccess record doesn't exist, insert it
-            if ($db->Execute("INSERT INTO {$CFG->prefix}user_lastaccess
-                                     (userid, courseid, timeaccess)
-                              VALUES ($USER->id, $courseid, $timenow)")) {
             } else {
-                debugging('Error: Could not insert course user lastaccess information');  // Don't throw an error
-            }
+            // Update course lastaccess for next checks
+            $USER->currentcourseaccess[$courseid] = $timenow;
+
+            $DB->set_field('user_lastaccess', 'timeaccess', $timenow, array('userid'=>$USER->id, 'courseid'=>$courseid));
         }
     }
 }
@@ -2058,83 +1788,105 @@ function user_accesstime_log($courseid=0) {
 /**
  * Select all log records based on SQL criteria
  *
- * @uses $CFG
+ * @todo Finish documenting this function
+ *
+ * @global object
  * @param string $select SQL select criteria
+ * @param array $params named sql type params
  * @param string $order SQL order by clause to sort the records returned
  * @param string $limitfrom ?
  * @param int $limitnum ?
  * @param int $totalcount Passed in by reference.
  * @return object
- * @todo Finish documenting this function
  */
-function get_logs($select, $order='l.time DESC', $limitfrom='', $limitnum='', &$totalcount) {
-    global $CFG;
+function get_logs($select, array $params=null, $order='l.time DESC', $limitfrom='', $limitnum='', &$totalcount) {
+    global $DB;
 
     if ($order) {
-        $order = 'ORDER BY '. $order;
+        $order = "ORDER BY $order";
     }
 
-    $selectsql = $CFG->prefix .'log l LEFT JOIN '. $CFG->prefix .'user u ON l.userid = u.id '. ((strlen($select) > 0) ? 'WHERE '. $select : '');
-    $countsql = $CFG->prefix.'log l '.((strlen($select) > 0) ? ' WHERE '. $select : '');
+    $selectsql = "";
+    $countsql  = "";
+
+    if ($select) {
+        $select = "WHERE $select";
+    }
 
-    $totalcount = count_records_sql("SELECT COUNT(*) FROM $countsql");
+    $sql = "SELECT COUNT(*)
+              FROM {log} l
+           $select";
 
-    return get_records_sql('SELECT l.*, u.firstname, u.lastname, u.picture
-                                FROM '. $selectsql .' '. $order, $limitfrom, $limitnum) ;
+    $totalcount = $DB->count_records_sql($sql, $params);
+
+    $sql = "SELECT l.*, u.firstname, u.lastname, u.picture
+              FROM {log} l
+              LEFT JOIN {user} u ON l.userid = u.id
+           $select
+            $order";
+
+    return $DB->get_records_sql($sql, $params, $limitfrom, $limitnum) ;
 }
 
 
 /**
  * Select all log records for a given course and user
  *
- * @uses $CFG
+ * @todo Finish documenting this function
+ *
+ * @global object
  * @uses DAYSECS
  * @param int $userid The id of the user as found in the 'user' table.
  * @param int $courseid The id of the course as found in the 'course' table.
  * @param string $coursestart ?
- * @todo Finish documenting this function
  */
 function get_logs_usercourse($userid, $courseid, $coursestart) {
-    global $CFG;
+    global $DB;
+
+    $params = array();
 
-    if ($courseid) {
-        $courseselect = ' AND course = \''. $courseid .'\' ';
-    } else {
         $courseselect = '';
+    if ($courseid) {
+        $courseselect = "AND course = :courseid";
+        $params['courseid'] = $courseid;
     }
+    $params['userid'] = $userid;
+    $$coursestart = (int)$coursestart; // note: unfortunately pg complains if you use name parameter or column alias in GROUP BY
 
-    return get_records_sql("SELECT floor((time - $coursestart)/". DAYSECS .") as day, count(*) as num
-                            FROM {$CFG->prefix}log
-                           WHERE userid = '$userid'
-                             AND time > '$coursestart' $courseselect
-                        GROUP BY floor((time - $coursestart)/". DAYSECS .") ");
+    return $DB->get_records_sql("SELECT FLOOR((time - $coursestart)/". DAYSECS .") AS day, COUNT(*) AS num
+                                   FROM {log}
+                                  WHERE userid = :userid
+                                        AND time > $coursestart $courseselect
+                               GROUP BY FLOOR((time - $coursestart)/". DAYSECS .")", $params);
 }
 
 /**
  * Select all log records for a given course, user, and day
  *
- * @uses $CFG
+ * @global object
  * @uses HOURSECS
  * @param int $userid The id of the user as found in the 'user' table.
  * @param int $courseid The id of the course as found in the 'course' table.
  * @param string $daystart ?
  * @return object
- * @todo Finish documenting this function
  */
 function get_logs_userday($userid, $courseid, $daystart) {
-    global $CFG;
+    global $DB;
+
+    $params = array('userid'=>$userid);
 
-    if ($courseid) {
-        $courseselect = ' AND course = \''. $courseid .'\' ';
-    } else {
         $courseselect = '';
+    if ($courseid) {
+        $courseselect = "AND course = :courseid";
+        $params['courseid'] = $courseid;
     }
+    $daystart = (int)$daystart; // note: unfortunately pg complains if you use name parameter or column alias in GROUP BY
 
-    return get_records_sql("SELECT floor((time - $daystart)/". HOURSECS .") as hour, count(*) as num
-                            FROM {$CFG->prefix}log
-                           WHERE userid = '$userid'
-                             AND time > '$daystart' $courseselect
-                        GROUP BY floor((time - $daystart)/". HOURSECS .") ");
+    return $DB->get_records_sql("SELECT FLOOR((time - $daystart)/". HOURSECS .") AS hour, COUNT(*) AS num
+                                   FROM {log}
+                                  WHERE userid = :userid
+                                        AND time > $daystart $courseselect
+                               GROUP BY FLOOR((time - $daystart)/". HOURSECS .") ", $params);
 }
 
 /**
@@ -2145,22 +1897,28 @@ function get_logs_userday($userid, $courseid, $daystart) {
  * number of accounts.  For non-admins, only the attempts on the given user
  * are shown.
  *
- * @param string $mode Either 'admin', 'teacher' or 'everybody'
+ * @global object
+ * @uses CONTEXT_SYSTEM
+ * @param string $mode Either 'admin' or 'everybody'
  * @param string $username The username we are searching for
  * @param string $lastlogin The date from which we are searching
  * @return int
  */
 function count_login_failures($mode, $username, $lastlogin) {
+    global $DB;
+
+    $params = array('mode'=>$mode, 'username'=>$username, 'lastlogin'=>$lastlogin);
+    $select = "module='login' AND action='error' AND time > :lastlogin";
 
-    $select = 'module=\'login\' AND action=\'error\' AND time > '. $lastlogin;
+    $count = new stdClass();
 
-    if (has_capability('moodle/site:config', get_context_instance(CONTEXT_SYSTEM))) {    // Return information about all accounts
-        if ($count->attempts = count_records_select('log', $select)) {
-            $count->accounts = count_records_select('log', $select, 'COUNT(DISTINCT info)');
+    if (is_siteadmin()) {
+        if ($count->attempts = $DB->count_records_select('log', $select, $params)) {
+            $count->accounts = $DB->count_records_select('log', $select, $params, 'COUNT(DISTINCT info)');
             return $count;
         }
-    } else if ($mode == 'everybody' or ($mode == 'teacher' and isteacherinanycourse())) {
-        if ($count->attempts = count_records_select('log', $select .' AND info = \''. $username .'\'')) {
+    } else if ($mode == 'everybody') {
+        if ($count->attempts = $DB->count_records_select('log', "$select AND info = :username", $params)) {
             return $count;
         }
     }
@@ -2176,76 +1934,14 @@ function count_login_failures($mode, $username, $lastlogin) {
  * Mostly just used for debugging.
  *
  * @param mixed $object The data to be printed
+ * @return void OUtput is echo'd
  */
 function print_object($object) {
-    echo '<pre class="notifytiny">' . htmlspecialchars(print_r($object,true)) . '</pre>';
-}
-
-/*
- * Check whether a course is visible through its parents
- * path.
- *
- * Notes:
- *
- * - All we need from the course is ->category. _However_
- *   if the course object has a categorypath property,
- *   we'll save a dbquery
- *
- * - If we return false, you'll still need to check if
- *   the user can has the 'moodle/category:viewhiddencategories'
- *   capability...
- *
- * - Will generate 2 DB calls.
- *
- * - It does have a small local cache, however...
- *
- * - Do NOT call this over many courses as it'll generate
- *   DB traffic. Instead, see what get_my_courses() does.
- *
- * @param mixed $object A course object
- * @return bool
- */
-function course_parent_visible($course = null) {
-    global $CFG;
-    //return true;
-    static $mycache;
-
-    if (!is_object($course)) {
-        return true;
-    }
-    if (!empty($CFG->allowvisiblecoursesinhiddencategories)) {
-        return true;
-    }
-
-    if (!isset($mycache)) {
-        $mycache = array();
-    } else {
-        // cast to force assoc array
-        $k = (string)$course->category;
-        if (isset($mycache[$k])) {
-            return $mycache[$k];
-        }
-    }
-
-    if (isset($course->categorypath)) {
-        $path = $course->categorypath;
-    } else {
-        $path = get_field('course_categories', 'path',
-                          'id', $course->category);
-    }
-    $catids = substr($path,1); // strip leading slash
-    $catids = str_replace('/',',',$catids);
-
-    $sql = "SELECT MIN(visible)
-            FROM {$CFG->prefix}course_categories
-            WHERE id IN ($catids)";
-    $vis = get_field_sql($sql);
-
-    // cast to force assoc array
-    $k = (string)$course->category;
-    $mycache[$k] = $vis;
-
-    return $vis;
+    echo '<pre class="notifytiny">';
+    // we may need a lot of memory here
+    raise_memory_limit(MEMORY_EXTRA);
+    echo s(print_r($object, true));
+    echo '</pre>';
 }
 
 /**
@@ -2255,8 +1951,9 @@ function course_parent_visible($course = null) {
  * Any script can avoid calls to this function by defining XMLDB_SKIP_DEBUG_HOOK before
  * using XMLDB classes. Obviously, also, if this function doesn't exist, it isn't invoked ;-)
  *
- * @param $message string contains the error message
- * @param $object object XMLDB object that fired the debug
+ * @uses DEBUG_DEVELOPER
+ * @param string $message string contains the error message
+ * @param object $object object XMLDB object that fired the debug
  */
 function xmldb_debug($message, $object) {
 
@@ -2264,25 +1961,19 @@ function xmldb_debug($message, $object) {
 }
 
 /**
- * true or false function to see if user can create any courses at all
- * @return bool
+ * @global object
+ * @uses CONTEXT_COURSECAT
+ * @return boolean Whether the user can create courses in any category in the system.
  */
 function user_can_create_courses() {
-    global $USER;
-    // if user has course creation capability at any site or course cat, then return true;
-
-    if (has_capability('moodle/course:create', get_context_instance(CONTEXT_SYSTEM))) {
-        return true;
-    }
-    if ($cats = get_records('course_categories')) {
-        foreach ($cats as $cat) {
+    global $DB;
+    $catsrs = $DB->get_recordset('course_categories');
+    foreach ($catsrs as $cat) {
             if (has_capability('moodle/course:create', get_context_instance(CONTEXT_COURSECAT, $cat->id))) {
+            $catsrs->close();
                 return true;
             }
         }
-    }
+    $catsrs->close();
     return false;
 }
-
-// vim:autoindent:expandtab:shiftwidth=4:tabstop=4:tw=140:
-?>
