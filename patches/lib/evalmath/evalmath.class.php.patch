diff --git a/lib/evalmath/evalmath.class.php b/lib/evalmath/evalmath.class.php
index 5af8398..aa5539f 100644
--- a/lib/evalmath/evalmath.class.php
+++ b/lib/evalmath/evalmath.class.php
@@ -94,6 +94,9 @@ LICENSE
 
 class EvalMath {
 
+    /** @var string Pattern used for a valid function or variable name. Note, var and func names are case insensitive.*/
+    private static $namepat = '[a-z][a-z0-9_]*';
+
     var $suppress_errors = false;
     var $last_error = null;
     
@@ -104,14 +107,22 @@ class EvalMath {
         'sin','sinh','arcsin','asin','arcsinh','asinh',
         'cos','cosh','arccos','acos','arccosh','acosh',
         'tan','tanh','arctan','atan','arctanh','atanh',
-        'sqrt','abs','ln','log','exp');
+        'sqrt','abs','ln','log','exp','floor','ceil','round');
 
     var $fc = array( // calc functions emulation
         'average'=>array(-1), 'max'=>array(-1),  'min'=>array(-1),
         'mod'=>array(2),      'pi'=>array(0),    'power'=>array(2),
-        'round'=>array(1, 2), 'sum'=>array(-1));
+        'round'=>array(1, 2), 'sum'=>array(-1), 'rand_int'=>array(2),
+        'rand_float'=>array(0));
+
+    var $allowimplicitmultiplication;
     
-    function EvalMath() {
+    function EvalMath($allowconstants = false, $allowimplicitmultiplication = false) {
+        if ($allowconstants){
+            $this->v['pi'] = pi();
+            $this->v['e'] = exp(1);
+        }
+        $this->allowimplicitmultiplication = $allowimplicitmultiplication;
     }
     
     function e($expr) {
@@ -124,29 +135,29 @@ class EvalMath {
         if (substr($expr, -1, 1) == ';') $expr = substr($expr, 0, strlen($expr)-1); // strip semicolons at the end
         //===============
         // is it a variable assignment?
-        if (preg_match('/^\s*([a-z][a-z0-9]*)\s*=\s*(.+)$/', $expr, $matches)) {
+        if (preg_match('/^\s*('.self::$namepat.')\s*=\s*(.+)$/', $expr, $matches)) {
             if (in_array($matches[1], $this->vb)) { // make sure we're not assigning to a constant
-                return $this->trigger("cannot assign to constant '$matches[1]'");
+                return $this->trigger(get_string('cannotassigntoconstant', 'mathslib', $matches[1]));
             }
             if (($tmp = $this->pfx($this->nfx($matches[2]))) === false) return false; // get the result and make sure it's good
             $this->v[$matches[1]] = $tmp; // if so, stick it in the variable array
             return $this->v[$matches[1]]; // and return the resulting value
         //===============
         // is it a function assignment?
-        } elseif (preg_match('/^\s*([a-z][a-z0-9]*)\s*\(\s*([a-z][a-z0-9]*(?:\s*,\s*[a-z][a-z0-9]*)*)\s*\)\s*=\s*(.+)$/', $expr, $matches)) {
+        } elseif (preg_match('/^\s*('.self::$namepat.')\s*\(\s*('.self::$namepat.'(?:\s*,\s*'.self::$namepat.')*)\s*\)\s*=\s*(.+)$/', $expr, $matches)) {
             $fnn = $matches[1]; // get the function name
             if (in_array($matches[1], $this->fb)) { // make sure it isn't built in
-                return $this->trigger("cannot redefine built-in function '$matches[1]()'");
+                return $this->trigger(get_string('cannotredefinebuiltinfunction', 'mathslib', $matches[1]));
             }
             $args = explode(",", preg_replace("/\s+/", "", $matches[2])); // get the arguments
             if (($stack = $this->nfx($matches[3])) === false) return false; // see if it can be converted to postfix
             for ($i = 0; $i<count($stack); $i++) { // freeze the state of the non-argument variables
                 $token = $stack[$i];
-                if (preg_match('/^[a-z][a-z0-9]*$/', $token) and !in_array($token, $args)) {
+                if (preg_match('/^'.self::$namepat.'$/', $token) and !in_array($token, $args)) {
                     if (array_key_exists($token, $this->v)) {
                         $stack[$i] = $this->v[$token];
                     } else {
-                        return $this->trigger("undefined variable '$token' in function definition");
+                        return $this->trigger(get_string('undefinedvariableinfunctiondefinition', 'mathslib', $token));
                     }
                 }
             }
@@ -169,6 +180,14 @@ class EvalMath {
         return $output;
     }
 
+    /**
+     * @param string $name
+     * @return boolean Is this a valid var or function name?
+     */
+    public static function is_valid_var_or_func_name($name){
+        return preg_match('/'.self::$namepat.'$/iA', $name);
+    }
+
     //===================== HERE BE INTERNAL METHODS ====================\\
 
     // Convert infix to postfix notation
@@ -187,24 +206,28 @@ class EvalMath {
                                // and determining when a - is a negation
     
         if (preg_match("/[^\w\s+*^\/()\.,-]/", $expr, $matches)) { // make sure the characters are all good
-            return $this->trigger("illegal character '{$matches[0]}'");
+            return $this->trigger(get_string('illegalcharactergeneral', 'mathslib', $matches[0]));
         }
     
         while(1) { // 1 Infinite Loop ;)
             $op = substr($expr, $index, 1); // get the first character at the current index
             // find out if we're currently at the beginning of a number/variable/function/parenthesis/operand
-            $ex = preg_match('/^([a-z][a-z0-9]*\(?|\d+(?:\.\d*)?|\.\d+|\()/', substr($expr, $index), $match);
+            $ex = preg_match('/^('.self::$namepat.'\(?|\d+(?:\.\d*)?(?:(e[+-]?)\d*)?|\.\d+|\()/', substr($expr, $index), $match);
             //===============
             if ($op == '-' and !$expecting_op) { // is it a negation instead of a minus?
                 $stack->push('_'); // put a negation on the stack
                 $index++;
             } elseif ($op == '_') { // we have to explicitly deny this, because it's legal on the stack 
-                return $this->trigger("illegal character '_'"); // but not in the input expression
+                return $this->trigger(get_string('illegalcharacterunderscore', 'mathslib')); // but not in the input expression
             //===============
             } elseif ((in_array($op, $ops) or $ex) and $expecting_op) { // are we putting an operator on the stack?
                 if ($ex) { // are we expecting an operator but have a number/variable/function/opening parethesis?
-                    return $this->trigger("expecting operand");
-                    //$op = '*'; $index--; // it's an implicit multiplication
+                    if (!$this->allowimplicitmultiplication){
+                        return $this->trigger(get_string('implicitmultiplicationnotallowed', 'mathslib'));
+                    } else {// it's an implicit multiplication
+                        $op = '*';
+                        $index--;
+                    }
                 }
                 // heart of the algorithm:
                 while($stack->count > 0 and ($o2 = $stack->last()) and in_array($o2, $ops) and ($ops_r[$op] ? $ops_p[$op] < $ops_p[$o2] : $ops_p[$op] <= $ops_p[$o2])) {
@@ -217,39 +240,51 @@ class EvalMath {
             //===============
             } elseif ($op == ')' and $expecting_op) { // ready to close a parenthesis?
                 while (($o2 = $stack->pop()) != '(') { // pop off the stack back to the last (
-                    if (is_null($o2)) return $this->trigger("unexpected ')'");
+                    if (is_null($o2)) return $this->trigger(get_string('unexpectedclosingbracket', 'mathslib'));
                     else $output[] = $o2;
                 }
-                if (preg_match("/^([a-z][a-z0-9]*)\($/", $stack->last(2), $matches)) { // did we just close a function?
+                if (preg_match('/^('.self::$namepat.')\($/', $stack->last(2), $matches)) { // did we just close a function?
                     $fnn = $matches[1]; // get the function name
                     $arg_count = $stack->pop(); // see how many arguments there were (cleverly stored on the stack, thank you)
                     $fn = $stack->pop();
                     $output[] = array('fn'=>$fn, 'fnn'=>$fnn, 'argcount'=>$arg_count); // send function to output
                     if (in_array($fnn, $this->fb)) { // check the argument count
-                        if($arg_count > 1)
-                            return $this->trigger("too many arguments ($arg_count given, 1 expected)");
+                        if($arg_count > 1) {
+                            $a= new stdClass();
+                            $a->expected = 1;
+                            $a->given = $arg_count;
+                            return $this->trigger(get_string('wrongnumberofarguments', 'mathslib', $a));
+                        }
                     } elseif (array_key_exists($fnn, $this->fc)) {
                         $counts = $this->fc[$fnn];
                         if (in_array(-1, $counts) and $arg_count > 0) {}
-                        elseif (!in_array($arg_count, $counts))
-                            return $this->trigger("wrong number of arguments ($arg_count given, " . implode('/',$this->fc[$fnn]) . " expected)");
+                        elseif (!in_array($arg_count, $counts)) {
+                            $a= new stdClass();
+                            $a->expected = implode('/',$this->fc[$fnn]);
+                            $a->given = $arg_count;
+                            return $this->trigger(get_string('wrongnumberofarguments', 'mathslib', $a));
+                        }
                     } elseif (array_key_exists($fnn, $this->f)) {
-                        if ($arg_count != count($this->f[$fnn]['args']))
-                            return $this->trigger("wrong number of arguments ($arg_count given, " . count($this->f[$fnn]['args']) . " expected)");
+                        if ($arg_count != count($this->f[$fnn]['args'])) {
+                            $a= new stdClass();
+                            $a->expected = count($this->f[$fnn]['args']);
+                            $a->given = $arg_count;
+                            return $this->trigger(get_string('wrongnumberofarguments', 'mathslib', $a));
+                        }
                     } else { // did we somehow push a non-function on the stack? this should never happen
-                        return $this->trigger("internal error");
+                        return $this->trigger(get_string('internalerror', 'mathslib'));
                     }
                 }
                 $index++;
             //===============
             } elseif ($op == ',' and $expecting_op) { // did we just finish a function argument?
                 while (($o2 = $stack->pop()) != '(') { 
-                    if (is_null($o2)) return $this->trigger("unexpected ','"); // oops, never had a (
+                    if (is_null($o2)) return $this->trigger(get_string('unexpectedcomma', 'mathslib')); // oops, never had a (
                     else $output[] = $o2; // pop the argument expression stuff and push onto the output
                 }
                 // make sure there was a function
-                if (!preg_match("/^([a-z][a-z0-9]*)\($/", $stack->last(2), $matches))
-                    return $this->trigger("unexpected ','");
+                if (!preg_match('/^('.self::$namepat.')\($/', $stack->last(2), $matches))
+                    return $this->trigger(get_string('unexpectedcomma', 'mathslib'));
                 $stack->push($stack->pop()+1); // increment the argument count
                 $stack->push('('); // put the ( back on, we'll need to pop back to it again
                 $index++;
@@ -263,7 +298,7 @@ class EvalMath {
             } elseif ($ex and !$expecting_op) { // do we now have a function/variable/number?
                 $expecting_op = true;
                 $val = $match[1];
-                if (preg_match("/^([a-z][a-z0-9]*)\($/", $val, $matches)) { // may be func, or variable w/ implicit multiplication against parentheses...
+                if (preg_match('/^('.self::$namepat.')\($/', $val, $matches)) { // may be func, or variable w/ implicit multiplication against parentheses...
                     if (in_array($matches[1], $this->fb) or array_key_exists($matches[1], $this->f) or array_key_exists($matches[1], $this->fc)) { // it's a func
                         $stack->push($val);
                         $stack->push(1);
@@ -280,29 +315,34 @@ class EvalMath {
             //===============
             } elseif ($op == ')') {
                 //it could be only custom function with no params or general error
-                if ($stack->last() != '(' or $stack->last(2) != 1) return $this->trigger("unexpected ')'");
-                if (preg_match("/^([a-z][a-z0-9]*)\($/", $stack->last(3), $matches)) { // did we just close a function?
+                if ($stack->last() != '(' or $stack->last(2) != 1) return $this->trigger(get_string('unexpectedclosingbracket', 'mathslib'));
+                if (preg_match('/^('.self::$namepat.')\($/', $stack->last(3), $matches)) { // did we just close a function?
                     $stack->pop();// (
                     $stack->pop();// 1
                     $fn = $stack->pop();
                     $fnn = $matches[1]; // get the function name
                     $counts = $this->fc[$fnn];
-                    if (!in_array(0, $counts))
-                        return $this->trigger("wrong number of arguments ($arg_count given, " . implode('/',$this->fc[$fnn]) . " expected)");
+                    if (!in_array(0, $counts)){
+                        $a= new stdClass();
+                        $a->expected = $this->fc[$fnn];
+                        $a->given = 0;
+                        return $this->trigger(get_string('wrongnumberofarguments', 'mathslib', $a));
+                    }
                     $output[] = array('fn'=>$fn, 'fnn'=>$fnn, 'argcount'=>0); // send function to output
                     $index++;
+                    $expecting_op = true;
                 } else {
-                    return $this->trigger("unexpected ')'");
+                    return $this->trigger(get_string('unexpectedclosingbracket', 'mathslib'));
                 }
             //===============
             } elseif (in_array($op, $ops) and !$expecting_op) { // miscellaneous error checking
-                return $this->trigger("unexpected operator '$op'");
+                return $this->trigger(get_string('unexpectedoperator', 'mathslib', $op));
             } else { // I don't even want to know what you did to get here
-                return $this->trigger("an unexpected error occured");
+                return $this->trigger(get_string('anunexpectederroroccured', 'mathslib'));
             }
             if ($index == strlen($expr)) {
                 if (in_array($op, $ops)) { // did we end with an operator? bad.
-                    return $this->trigger("operator '$op' lacks operand");
+                    return $this->trigger(get_string('operatorlacksoperand', 'mathslib', $op));
                 } else {
                     break;
                 }
@@ -313,7 +353,7 @@ class EvalMath {
         
         } 
         while (!is_null($op = $stack->pop())) { // pop everything off the stack and push onto output
-            if ($op == '(') return $this->trigger("expecting ')'"); // if there are (s on the stack, ()s were unbalanced
+            if ($op == '(') return $this->trigger(get_string('expectingaclosingbracket', 'mathslib')); // if there are (s on the stack, ()s were unbalanced
             $output[] = $op;
         }
         return $output;
@@ -333,7 +373,7 @@ class EvalMath {
                 $fnn = $token['fnn'];
                 $count = $token['argcount'];
                 if (in_array($fnn, $this->fb)) { // built-in function:
-                    if (is_null($op1 = $stack->pop())) return $this->trigger("internal error");
+                    if (is_null($op1 = $stack->pop())) return $this->trigger(get_string('internalerror', 'mathslib'));
                     $fnn = preg_replace("/^arc/", "a", $fnn); // for the 'arc' trig synonyms
                     if ($fnn == 'ln') $fnn = 'log';
                     eval('$stack->push(' . $fnn . '($op1));'); // perfectly safe eval()
@@ -341,25 +381,25 @@ class EvalMath {
                     // get args
                     $args = array();
                     for ($i = $count-1; $i >= 0; $i--) {
-                        if (is_null($args[] = $stack->pop())) return $this->trigger("internal error");
+                        if (is_null($args[] = $stack->pop())) return $this->trigger(get_string('internalerror', 'mathslib'));
                     }
-                    $res = call_user_func(array('EvalMathCalcEmul', $fnn), $args);
+                    $res = call_user_func_array(array('EvalMathFuncs', $fnn), array_reverse($args));
                     if ($res === FALSE) {
-                        return $this->trigger("internal error");
+                        return $this->trigger(get_string('internalerror', 'mathslib'));
                     }
                     $stack->push($res);
                 } elseif (array_key_exists($fnn, $this->f)) { // user function
                     // get args
                     $args = array();
                     for ($i = count($this->f[$fnn]['args'])-1; $i >= 0; $i--) {
-                        if (is_null($args[$this->f[$fnn]['args'][$i]] = $stack->pop())) return $this->trigger("internal error");
+                        if (is_null($args[$this->f[$fnn]['args'][$i]] = $stack->pop())) return $this->trigger(get_string('internalerror', 'mathslib'));
                     }
                     $stack->push($this->pfx($this->f[$fnn]['func'], $args)); // yay... recursion!!!!
                 }
             // if the token is a binary operator, pop two values off the stack, do the operation, and push the result back on
             } elseif (in_array($token, array('+', '-', '*', '/', '^'), true)) {
-                if (is_null($op2 = $stack->pop())) return $this->trigger("internal error");
-                if (is_null($op1 = $stack->pop())) return $this->trigger("internal error");
+                if (is_null($op2 = $stack->pop())) return $this->trigger(get_string('internalerror', 'mathslib'));
+                if (is_null($op1 = $stack->pop())) return $this->trigger(get_string('internalerror', 'mathslib'));
                 switch ($token) {
                     case '+':
                         $stack->push($op1+$op2); break;
@@ -368,7 +408,7 @@ class EvalMath {
                     case '*':
                         $stack->push($op1*$op2); break;
                     case '/':
-                        if ($op2 == 0) return $this->trigger("division by zero");
+                        if ($op2 == 0) return $this->trigger(get_string('divisionbyzero', 'mathslib'));
                         $stack->push($op1/$op2); break;
                     case '^':
                         $stack->push(pow($op1, $op2)); break;
@@ -385,12 +425,12 @@ class EvalMath {
                 } elseif (array_key_exists($token, $vars)) {
                     $stack->push($vars[$token]);
                 } else {
-                    return $this->trigger("undefined variable '$token'");
+                    return $this->trigger(get_string('undefinedvariable', 'mathslib', $token));
                 }
             }
         }
         // when we're out of tokens, the stack should have a single element, the final result
-        if ($stack->count != 1) return $this->trigger("internal error");
+        if ($stack->count != 1) return $this->trigger(get_string('internalerror', 'mathslib'));
         return $stack->pop();
     }
     
@@ -400,6 +440,7 @@ class EvalMath {
         if (!$this->suppress_errors) trigger_error($msg, E_USER_WARNING);
         return false;
     }
+
 }
 
 // for internal use
@@ -429,15 +470,17 @@ class EvalMathStack {
     }
 }
 
-// spreadsheed functions emulation
-// watch out for reversed args!!
-class EvalMathCalcEmul {
 
-    function average($args) {
-        return (EvalMathCalcEmul::sum($args)/count($args));
+// spreadsheet functions emulation
+class EvalMathFuncs {
+
+    static function average() {
+        $args = func_get_args();
+        return (call_user_func_array(array('self', 'sum'), $args) / count($args));
     }
 
-    function max($args) {
+    static function max() {
+        $args = func_get_args();
         $res = array_pop($args);
         foreach($args as $a) {
             if ($res < $a) {
@@ -447,7 +490,8 @@ class EvalMathCalcEmul {
         return $res;
     }
 
-    function min($args) {
+    static function min() {
+        $args = func_get_args();
         $res = array_pop($args);
         foreach($args as $a) {
             if ($res > $a) {
@@ -457,31 +501,65 @@ class EvalMathCalcEmul {
         return $res;
     }
 
-    function mod($args) {
-        return $args[1] % $args[0];
+    static function mod($op1, $op2) {
+        return $op1 % $op2;
     }
 
-    function pi($args) {
+    static function pi() {
         return pi();
     }
 
-    function power($args) {
-        return $args[1]^$args[0];
+    static function power($op1, $op2) {
+        return pow($op1, $op2);
     }
 
-    function round($args) {
-        if (count($args)==1) {
-            return round($args[0]);
-        } else {
-            return round($args[1], $args[0]);
-        }
+    static function round($val, $precision = 0) {
+        return round($val, $precision);
     }
 
-    function sum($args) {
+    static function sum() {
+        $args = func_get_args();
         $res = 0;
         foreach($args as $a) {
            $res += $a;
         }
         return $res;
     }
+
+    protected static $randomseed = null;
+
+    static function set_random_seed($randomseed) {
+        self::$randomseed = $randomseed;
+    }
+
+    static function get_random_seed() {
+        if (is_null(self::$randomseed)){
+            return microtime();
+        } else {
+            return self::$randomseed;
+        }
+    }
+
+    static function rand_int($min, $max){
+        if ($min >= $max) {
+            return false; //error
+        }
+        $noofchars = ceil(log($max + 1 - $min, '16'));
+        $md5string = md5(self::get_random_seed());
+        $stringoffset = 0;
+        do {
+            while (($stringoffset + $noofchars) > strlen($md5string)){
+                $md5string .= md5($md5string);
+            }
+            $randomno = hexdec(substr($md5string, $stringoffset, $noofchars));
+            $stringoffset += $noofchars;
+        } while (($min + $randomno) > $max);
+        return $min + $randomno;
+    }
+
+    static function rand_float(){
+        $randomvalue = array_shift(unpack('v', md5(self::get_random_seed(), true)));
+        return $randomvalue / 65536;
+    }
+
 }
