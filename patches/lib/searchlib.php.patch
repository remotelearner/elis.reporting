diff --git a/lib/searchlib.php b/lib/searchlib.php
index 4fee4b4..75baa49 100644
--- a/lib/searchlib.php
+++ b/lib/searchlib.php
@@ -1,8 +1,33 @@
-<?php  // $Id$
+<?php
 
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * @package    core
+ * @subpackage search
+ * @copyright  1999 onwards Martin Dougiamas  {@link http://moodle.com}
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+
+defined('MOODLE_INTERNAL') || die();
+
+/** @see lexer.php */
 require_once($CFG->libdir.'/lexer.php');
 
-// Constants for the various types of tokens
+/** Constants for the various types of tokens */
 
 define("TOKEN_USER","0");
 define("TOKEN_META","1");
@@ -14,11 +39,17 @@ define("TOKEN_DATEFROM","6");
 define("TOKEN_DATETO","7");
 define("TOKEN_INSTANCE","8");
 
-// Class to hold token/value pairs after they're parsed.
-
+/**
+ * Class to hold token/value pairs after they're parsed.
+ *
+ * @package   moodlecore
+ * @copyright 1999 onwards Martin Dougiamas  {@link http://moodle.com}
+ * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
 class search_token {
-  var $value;
-  var $type;
+  private $value;
+  private $type;
+
   function search_token($type,$value){
     $this->type = $type;
     $this->value = $this->sanitize($value);
@@ -29,7 +60,7 @@ class search_token {
   // Need to think about this some more. 
 
   function sanitize($userstring){
-    return htmlspecialchars(addslashes($userstring));
+    return htmlspecialchars($userstring);
   }
   function getValue(){  
     return $this->value;
@@ -40,11 +71,15 @@ class search_token {
 }
 
 
-
-// This class does the heavy lifting of lexing the search string into tokens.
-// Using a full-blown lexer is probably overkill for this application, but 
-// might be useful for other tasks.
-
+/**
+ * This class does the heavy lifting of lexing the search string into tokens.
+ * Using a full-blown lexer is probably overkill for this application, but
+ * might be useful for other tasks.
+ *
+ * @package   moodlecore
+ * @copyright 1999 onwards Martin Dougiamas  {@link http://moodle.com}
+ * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
 class search_lexer extends Lexer{
 
   function search_lexer(&$parser){
@@ -162,15 +197,18 @@ class search_lexer extends Lexer{
 
 
 
-
-// This class takes care of sticking the proper token type/value pairs into
-// the parsed token  array.
-// Most functions in this class should only be called by the lexer, the
-// one exception being getParseArray() which returns the result.
-
+/**
+ * This class takes care of sticking the proper token type/value pairs into
+ * the parsed token  array.
+ * Most functions in this class should only be called by the lexer, the
+ * one exception being getParseArray() which returns the result.
+ *
+ * @package   moodlecore
+ * @copyright 1999 onwards Martin Dougiamas  {@link http://moodle.com}
+ * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
 class search_parser {
-    var $tokens;
-
+    private $tokens;
 
     // This function is called by the code that's interested in the result of the parse operation.
     function get_parsed_array(){
@@ -302,28 +340,34 @@ class search_parser {
     } 
 }
 
-// Primitive function to generate a SQL string from a parse tree
-// using TEXT indexes. If searches aren't suitable to use TEXT
-// this function calls the default search_generate_SQL() one.
-//      
-// $parsetree should be a parse tree generated by a 
-// search_lexer/search_parser combination. 
-// Other fields are database table names to search.
+/**
+ * Primitive function to generate a SQL string from a parse tree
+ * using TEXT indexes. If searches aren't suitable to use TEXT
+ * this function calls the default search_generate_SQL() one.
+ *
+ * $parsetree should be a parse tree generated by a
+ * search_lexer/search_parser combination.
+ * Other fields are database table names to search.
+ *
+ * @global object
+ * @global object
+ */
 function search_generate_text_SQL($parsetree, $datafield, $metafield, $mainidfield, $useridfield,
                              $userfirstnamefield, $userlastnamefield, $timefield, $instancefield) {
-    global $CFG;
+    global $CFG, $DB;
+    static $p = 0;
 
 /// First of all, search for reasons to switch to standard SQL generation
 /// Only mysql are supported for now
-    if ($CFG->dbfamily != 'mysql') {
+    if ($DB->get_db_family() != 'mysql') {
         return search_generate_SQL($parsetree, $datafield, $metafield, $mainidfield, $useridfield,
                                    $userfirstnamefield, $userlastnamefield, $timefield, $instancefield);
     }
 
 /// Some languages don't have "word separators" and MySQL FULLTEXT doesn't perform well with them, so
 /// switch to standard SQL search generation
-    if ($CFG->dbfamily == 'mysql') {
-        $nonseparatedlangs = array('ja_utf8', 'th_utf8', 'zh_cn_utf8', 'zh_tw_utf8');
+    if ($DB->get_db_family() == 'mysql') {
+        $nonseparatedlangs = array('ja', 'th', 'zh_cn', 'zh_tw');
         if (in_array(current_language(), $nonseparatedlangs)) {
             return search_generate_SQL($parsetree, $datafield, $metafield, $mainidfield, $useridfield,
                                        $userfirstnamefield, $userlastnamefield, $timefield, $instancefield);
@@ -332,6 +376,7 @@ function search_generate_text_SQL($parsetree, $datafield, $metafield, $mainidfie
 
 /// Here we'll acumulate non-textual tokens
     $non_text_tokens = array();
+    $params = array();
 
     $ntokens = count($parsetree);
     if ($ntokens == 0) {
@@ -386,8 +431,9 @@ function search_generate_text_SQL($parsetree, $datafield, $metafield, $mainidfie
 
 /// Call to standard search for pending tokens
     if (!empty($non_text_tokens)) {
-        $SQLString = search_generate_SQL($non_text_tokens, $datafield, $metafield, $mainidfield, $useridfield,
+        list($SQLString, $sparams) = search_generate_SQL($non_text_tokens, $datafield, $metafield, $mainidfield, $useridfield,
                                          $userfirstnamefield, $userlastnamefield, $timefield, $instancefield);
+        $params = array_merge($params, $sparams);
     }
 /// Build the final SQL clause
     if (!empty($datasearch_clause)) {
@@ -401,7 +447,8 @@ function search_generate_text_SQL($parsetree, $datafield, $metafield, $mainidfie
         /// Begin with the AGAINST clause
             $text_sql_string .= ') AGAINST (' . "'";
         /// Add the search terms
-            $text_sql_string .= trim($datasearch_clause);
+            $text_sql_string .= ':sgt'.$p;
+            $params['sgt'.$p++] = trim($datasearch_clause);
         /// Close AGAINST clause
             $text_sql_string .= "' IN BOOLEAN MODE)";
         }
@@ -418,7 +465,8 @@ function search_generate_text_SQL($parsetree, $datafield, $metafield, $mainidfie
         /// Begin with the AGAINST clause
             $text_sql_string .= ') AGAINST (' . "'";
         /// Add the search terms
-            $text_sql_string .= trim($metasearch_clause);
+            $text_sql_string .= ':sgt'.$p;
+            $params['sgt'.$p++] = trim($metasearch_clause);
         /// Close AGAINST clause
             $text_sql_string .= "' IN BOOLEAN MODE)";
         }
@@ -432,30 +480,32 @@ function search_generate_text_SQL($parsetree, $datafield, $metafield, $mainidfie
         $text_sql_string .= $SQLString;
     }
 
-    return $text_sql_string;
+    return array($text_sql_string, $params);
 }
 
-// Primitive function to generate a SQL string from a parse tree. 
-// Parameters: 
-//
-// $parsetree should be a parse tree generated by a 
-// search_lexer/search_parser combination. 
-// Other fields are database table names to search.
-
+/**
+ * Primitive function to generate a SQL string from a parse tree.
+ * Parameters:
+ *
+ * $parsetree should be a parse tree generated by a
+ * search_lexer/search_parser combination.
+ * Other fields are database table names to search.
+ *
+ * @global object
+ * @global object
+ */
 function search_generate_SQL($parsetree, $datafield, $metafield, $mainidfield, $useridfield,
                              $userfirstnamefield, $userlastnamefield, $timefield, $instancefield) {
-    global $CFG;
+    global $CFG, $DB;
+    static $p = 0;
 
-    $LIKE = sql_ilike();
-    $NOTLIKE = 'NOT ' . $LIKE;
-    if ($CFG->dbfamily == "postgres") {
-        $REGEXP = "~*";
-        $NOTREGEXP = "!~*";
-    } else {
-        $REGEXP = "REGEXP";
-        $NOTREGEXP = "NOT REGEXP";
+    if ($DB->sql_regex_supported()) {
+        $REGEXP    = $DB->sql_regex(true);
+        $NOTREGEXP = $DB->sql_regex(false);
     }
 
+    $params = array();
+
     $ntokens = count($parsetree);
     if ($ntokens == 0) {
         return "";
@@ -472,50 +522,63 @@ function search_generate_SQL($parsetree, $datafield, $metafield, $mainidfield, $
         $value = $parsetree[$i]->getValue();
 
     /// Under Oracle and MSSQL, transform TOKEN searches into STRING searches and trim +- chars
-        if ($CFG->dbfamily == 'oracle' || $CFG->dbfamily == 'mssql') {
+        if (!$DB->sql_regex_supported()) {
             $value = trim($value, '+-');
             if ($type == TOKEN_EXACT) {
                 $type = TOKEN_STRING;
             }
         }
 
+        $name1 = 'sq'.$p++;
+        $name2 = 'sq'.$p++;
+
         switch($type){
             case TOKEN_STRING: 
-                $SQLString .= "(($datafield $LIKE '%$value%') OR ($metafield $LIKE '%$value%') )";
+                $SQLString .= "((".$DB->sql_like($datafield, ":$name1", false).") OR (".$DB->sql_like($metafield, ":$name2", false)."))";
+                $params[$name1] =  "%$value%";
+                $params[$name2] =  "%$value%";
                 break;
             case TOKEN_EXACT: 
-                $SQLString .= "(($datafield $REGEXP '[[:<:]]".$value."[[:>:]]') OR ($metafield $REGEXP '[[:<:]]".$value."[[:>:]]'))";
+                $SQLString .= "(($datafield $REGEXP :$name1) OR ($metafield $REGEXP :$name2))";
+                $params[$name1] =  "[[:<:]]".$value."[[:>:]]";
+                $params[$name2] =  "[[:<:]]".$value."[[:>:]]";
                 break; 
             case TOKEN_META: 
                 if ($metafield != '') {
-                    $SQLString .= "($metafield $LIKE '%$value%')";
+                    $SQLString .= "(".$DB->sql_like($metafield, ":$name1", false).")";
+                    $params[$name1] =  "%$value%";
                 }
                 break;
             case TOKEN_USER: 
-                $SQLString .= "(($mainidfield = $useridfield) AND (($userfirstnamefield $LIKE '%$value%') OR ($userlastnamefield $LIKE '%$value%')))";
+                $SQLString .= "(($mainidfield = $useridfield) AND ((".$DB->sql_like($userfirstnamefield, ":$name1", false).") OR (".$DB->sql_like($userlastnamefield, ":$name2", false).")))";
+                $params[$name1] =  "%$value%";
+                $params[$name2] =  "%$value%";
                 break; 
             case TOKEN_USERID: 
-                $SQLString .= "($useridfield = $value)";
+                $SQLString .= "($useridfield = :$name1)";
+                $params[$name1] =  $value;
                 break; 
             case TOKEN_INSTANCE: 
-                $SQLString .= "($instancefield = $value)";
+                $SQLString .= "($instancefield = :$name1)";
+                $params[$name1] =  $value;
                 break; 
             case TOKEN_DATETO: 
-                $SQLString .= "($timefield <= $value)";
+                $SQLString .= "($timefield <= :$name1)";
+                $params[$name1] =  $value;
                 break; 
             case TOKEN_DATEFROM: 
-                $SQLString .= "($timefield >= $value)";
+                $SQLString .= "($timefield >= :$name1)";
+                $params[$name1] =  $value;
                 break; 
             case TOKEN_NEGATE: 
-                $SQLString .= "(NOT (($datafield  $LIKE '%$value%') OR ($metafield  $LIKE '%$value%')))";
+                $SQLString .= "(NOT ((".$DB->sql_like($datafield, ":$name1", false).") OR (".$DB->sql_like($metafield, ":$name2", false).")))";
+                $params[$name1] =  "%$value%";
+                $params[$name2] =  "%$value%";
                 break; 
             default:
                 return '';
 
         } 
     } 
-    return $SQLString;
+    return array($SQLString, $params);
 }
-
-
-?>
