diff --git a/lib/moodlelib.php b/lib/moodlelib.php
index 3711b5f..01e7941 100644
--- a/lib/moodlelib.php
+++ b/lib/moodlelib.php
@@ -1,27 +1,19 @@
-<?php // $Id$
-
-///////////////////////////////////////////////////////////////////////////
-//                                                                       //
-// NOTICE OF COPYRIGHT                                                   //
-//                                                                       //
-// Moodle - Modular Object-Oriented Dynamic Learning Environment         //
-//          http://moodle.org                                            //
-//                                                                       //
-// Copyright (C) 1999 onwards Martin Dougiamas  http://dougiamas.com     //
-//                                                                       //
-// This program is free software; you can redistribute it and/or modify  //
-// it under the terms of the GNU General Public License as published by  //
-// the Free Software Foundation; either version 2 of the License, or     //
-// (at your option) any later version.                                   //
-//                                                                       //
-// This program is distributed in the hope that it will be useful,       //
-// but WITHOUT ANY WARRANTY; without even the implied warranty of        //
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
-// GNU General Public License for more details:                          //
-//                                                                       //
-//          http://www.gnu.org/copyleft/gpl.html                         //
-//                                                                       //
-///////////////////////////////////////////////////////////////////////////
+<?php
+
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
 
 /**
  * moodlelib.php - Moodle main library
@@ -30,23 +22,21 @@
  * Other main libraries:
  *  - weblib.php      - functions that produce web output
  *  - datalib.php     - functions that access the database
- * @author Martin Dougiamas
- * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
- * @package moodlecore
+ *
+ * @package    core
+ * @subpackage lib
+ * @copyright  1999 onwards Martin Dougiamas  http://dougiamas.com
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
  */
 
-/// CONSTANTS (Encased in phpdoc proper comments)/////////////////////////
+defined('MOODLE_INTERNAL') || die();
 
-/**
- * Used by some scripts to check they are being called by Moodle
- */
-define('MOODLE_INTERNAL', true);
+/// CONSTANTS (Encased in phpdoc proper comments)/////////////////////////
 
 /// Date and time constants ///
 /**
  * Time constant - the number of seconds in a year
  */
-
 define('YEARSECS', 31536000);
 
 /**
@@ -82,151 +72,244 @@ define('HOURMINS', 60);
 /// Parameter constants - every call to optional_param(), required_param()  ///
 /// or clean_param() should have a specified type of parameter.  //////////////
 
+
+
 /**
- * PARAM_RAW specifies a parameter that is not cleaned/processed in any way;
- * originally was 0, but changed because we need to detect unknown
- * parameter types and swiched order in clean_param().
+ * PARAM_ALPHA - contains only english ascii letters a-zA-Z.
  */
-define('PARAM_RAW', 666);
+define('PARAM_ALPHA',    'alpha');
 
 /**
- * PARAM_CLEAN - obsoleted, please try to use more specific type of parameter.
- * It was one of the first types, that is why it is abused so much ;-)
+ * PARAM_ALPHAEXT the same contents as PARAM_ALPHA plus the chars in quotes: "_-" allowed
+ * NOTE: originally this allowed "/" too, please use PARAM_SAFEPATH if "/" needed
  */
-define('PARAM_CLEAN',    0x0001);
+define('PARAM_ALPHAEXT', 'alphaext');
 
 /**
- * PARAM_INT - integers only, use when expecting only numbers.
+ * PARAM_ALPHANUM - expected numbers and letters only.
  */
-define('PARAM_INT',      0x0002);
+define('PARAM_ALPHANUM', 'alphanum');
 
 /**
- * PARAM_INTEGER - an alias for PARAM_INT
+ * PARAM_ALPHANUMEXT - expected numbers, letters only and _-.
  */
-define('PARAM_INTEGER',  0x0002);
+define('PARAM_ALPHANUMEXT', 'alphanumext');
 
 /**
- * PARAM_NUMBER - a real/floating point number.
+ * PARAM_AUTH - actually checks to make sure the string is a valid auth plugin
  */
-define('PARAM_NUMBER',  0x000a);
+define('PARAM_AUTH',  'auth');
 
 /**
- * PARAM_ALPHA - contains only english letters.
+ * PARAM_BASE64 - Base 64 encoded format
  */
-define('PARAM_ALPHA',    0x0004);
+define('PARAM_BASE64',   'base64');
 
 /**
- * PARAM_ACTION - an alias for PARAM_ALPHA, use for various actions in formas and urls
- * @TODO: should we alias it to PARAM_ALPHANUM ?
+ * PARAM_BOOL - converts input into 0 or 1, use for switches in forms and urls.
  */
-define('PARAM_ACTION',   0x0004);
+define('PARAM_BOOL',     'bool');
 
 /**
- * PARAM_FORMAT - an alias for PARAM_ALPHA, use for names of plugins, formats, etc.
- * @TODO: should we alias it to PARAM_ALPHANUM ?
+ * PARAM_CAPABILITY - A capability name, like 'moodle/role:manage'. Actually
+ * checked against the list of capabilities in the database.
  */
-define('PARAM_FORMAT',   0x0004);
+define('PARAM_CAPABILITY',   'capability');
 
 /**
- * PARAM_NOTAGS - all html tags are stripped from the text. Do not abuse this type.
+ * PARAM_CLEANHTML - cleans submitted HTML code. use only for text in HTML format. This cleaning may fix xhtml strictness too.
  */
-define('PARAM_NOTAGS',   0x0008);
+define('PARAM_CLEANHTML', 'cleanhtml');
 
- /**
- * PARAM_MULTILANG - alias of PARAM_TEXT.
+/**
+ * PARAM_EMAIL - an email address following the RFC
  */
-define('PARAM_MULTILANG',  0x0009);
+define('PARAM_EMAIL',   'email');
 
- /**
- * PARAM_TEXT - general plain text compatible with multilang filter, no other html tags.
+/**
+ * PARAM_FILE - safe file name, all dangerous chars are stripped, protects against XSS, SQL injections and directory traversals
  */
-define('PARAM_TEXT',  0x0009);
+define('PARAM_FILE',   'file');
 
 /**
- * PARAM_FILE - safe file name, all dangerous chars are stripped, protects against XSS, SQL injections and directory traversals
+ * PARAM_FLOAT - a real/floating point number.
  */
-define('PARAM_FILE',     0x0010);
+define('PARAM_FLOAT',  'float');
 
 /**
- * PARAM_TAG - one tag (interests, blogs, etc.) - mostly international alphanumeric with spaces
+ * PARAM_HOST - expected fully qualified domain name (FQDN) or an IPv4 dotted quad (IP address)
  */
-define('PARAM_TAG',   0x0011);
+define('PARAM_HOST',     'host');
 
 /**
- * PARAM_TAGLIST - list of tags separated by commas (interests, blogs, etc.)
+ * PARAM_INT - integers only, use when expecting only numbers.
+ */
+define('PARAM_INT',      'int');
+
+/**
+ * PARAM_LANG - checks to see if the string is a valid installed language in the current site.
+ */
+define('PARAM_LANG',  'lang');
+
+/**
+ * PARAM_LOCALURL - expected properly formatted URL as well as one that refers to the local server itself. (NOT orthogonal to the others! Implies PARAM_URL!)
+ */
+define('PARAM_LOCALURL', 'localurl');
+
+/**
+ * PARAM_NOTAGS - all html tags are stripped from the text. Do not abuse this type.
  */
-define('PARAM_TAGLIST',   0x0012);
+define('PARAM_NOTAGS',   'notags');
 
 /**
  * PARAM_PATH - safe relative path name, all dangerous chars are stripped, protects against XSS, SQL injections and directory traversals
  * note: the leading slash is not removed, window drive letter is not allowed
  */
-define('PARAM_PATH',     0x0020);
+define('PARAM_PATH',     'path');
 
 /**
- * PARAM_HOST - expected fully qualified domain name (FQDN) or an IPv4 dotted quad (IP address)
+ * PARAM_PEM - Privacy Enhanced Mail format
  */
-define('PARAM_HOST',     0x0040);
+define('PARAM_PEM',      'pem');
 
 /**
- * PARAM_URL - expected properly formatted URL. Please note that domain part is required, http://localhost/ is not acceppted but http://localhost.localdomain/ is ok.
+ * PARAM_PERMISSION - A permission, one of CAP_INHERIT, CAP_ALLOW, CAP_PREVENT or CAP_PROHIBIT.
  */
-define('PARAM_URL',      0x0080);
+define('PARAM_PERMISSION',   'permission');
 
 /**
- * PARAM_LOCALURL - expected properly formatted URL as well as one that refers to the local server itself. (NOT orthogonal to the others! Implies PARAM_URL!)
+ * PARAM_RAW specifies a parameter that is not cleaned/processed in any way
  */
-define('PARAM_LOCALURL', 0x0180);
+define('PARAM_RAW', 'raw');
 
 /**
- * PARAM_CLEANFILE - safe file name, all dangerous and regional chars are removed,
- * use when you want to store a new file submitted by students
+ * PARAM_RAW_TRIMMED like PARAM_RAW but leading and trailing whitespace is stripped.
  */
-define('PARAM_CLEANFILE',0x0200);
+define('PARAM_RAW_TRIMMED', 'raw_trimmed');
 
 /**
- * PARAM_ALPHANUM - expected numbers and letters only.
+ * PARAM_SAFEDIR - safe directory name, suitable for include() and require()
  */
-define('PARAM_ALPHANUM', 0x0400);
+define('PARAM_SAFEDIR',  'safedir');
 
 /**
- * PARAM_BOOL - converts input into 0 or 1, use for switches in forms and urls.
+ * PARAM_SAFEPATH - several PARAM_SAFEDIR joined by "/", suitable for include() and require(), plugin paths, etc.
  */
-define('PARAM_BOOL',     0x0800);
+define('PARAM_SAFEPATH',  'safepath');
 
 /**
- * PARAM_CLEANHTML - cleans submitted HTML code and removes slashes
- * note: do not forget to addslashes() before storing into database!
+ * PARAM_SEQUENCE - expects a sequence of numbers like 8 to 1,5,6,4,6,8,9.  Numbers and comma only.
  */
-define('PARAM_CLEANHTML',0x1000);
+define('PARAM_SEQUENCE',  'sequence');
 
 /**
- * PARAM_ALPHAEXT the same contents as PARAM_ALPHA plus the chars in quotes: "/-_" allowed,
- * suitable for include() and require()
- * @TODO: should we rename this function to PARAM_SAFEDIRS??
+ * PARAM_TAG - one tag (interests, blogs, etc.) - mostly international characters and space, <> not supported
  */
-define('PARAM_ALPHAEXT', 0x2000);
+define('PARAM_TAG',   'tag');
 
 /**
- * PARAM_SAFEDIR - safe directory name, suitable for include() and require()
+ * PARAM_TAGLIST - list of tags separated by commas (interests, blogs, etc.)
  */
-define('PARAM_SAFEDIR',  0x4000);
+define('PARAM_TAGLIST',   'taglist');
 
 /**
- * PARAM_SEQUENCE - expects a sequence of numbers like 8 to 1,5,6,4,6,8,9.  Numbers and comma only.
+ * PARAM_TEXT - general plain text compatible with multilang filter, no other html tags. Please note '<', or '>' are allowed here.
  */
-define('PARAM_SEQUENCE',  0x8000);
+define('PARAM_TEXT',  'text');
 
 /**
- * PARAM_PEM - Privacy Enhanced Mail format
+ * PARAM_THEME - Checks to see if the string is a valid theme name in the current site
  */
-define('PARAM_PEM',      0x10000);
+define('PARAM_THEME',  'theme');
 
 /**
- * PARAM_BASE64 - Base 64 encoded format
+ * PARAM_URL - expected properly formatted URL. Please note that domain part is required, http://localhost/ is not accepted but http://localhost.localdomain/ is ok.
+ */
+define('PARAM_URL',      'url');
+
+/**
+ * PARAM_USERNAME - Clean username to only contains allowed characters. This is to be used ONLY when manually creating user accounts, do NOT use when syncing with external systems!!
+ */
+define('PARAM_USERNAME',    'username');
+
+/**
+ * PARAM_STRINGID - used to check if the given string is valid string identifier for get_string()
+ */
+define('PARAM_STRINGID',    'stringid');
+
+///// DEPRECATED PARAM TYPES OR ALIASES - DO NOT USE FOR NEW CODE  /////
+/**
+ * PARAM_CLEAN - obsoleted, please use a more specific type of parameter.
+ * It was one of the first types, that is why it is abused so much ;-)
+ * @deprecated since 2.0
+ */
+define('PARAM_CLEAN',    'clean');
+
+/**
+ * PARAM_INTEGER - deprecated alias for PARAM_INT
+ */
+define('PARAM_INTEGER',  'int');
+
+/**
+ * PARAM_NUMBER - deprecated alias of PARAM_FLOAT
+ */
+define('PARAM_NUMBER',  'float');
+
+/**
+ * PARAM_ACTION - deprecated alias for PARAM_ALPHANUMEXT, use for various actions in forms and urls
+ * NOTE: originally alias for PARAM_APLHA
+ */
+define('PARAM_ACTION',   'alphanumext');
+
+/**
+ * PARAM_FORMAT - deprecated alias for PARAM_ALPHANUMEXT, use for names of plugins, formats, etc.
+ * NOTE: originally alias for PARAM_APLHA
+ */
+define('PARAM_FORMAT',   'alphanumext');
+
+/**
+ * PARAM_MULTILANG - deprecated alias of PARAM_TEXT.
+ */
+define('PARAM_MULTILANG',  'text');
+
+/**
+ * PARAM_TIMEZONE - expected timezone. Timezone can be int +-(0-13) or float +-(0.5-12.5) or
+ * string seperated by '/' and can have '-' &/ '_' (eg. America/North_Dakota/New_Salem
+ * America/Port-au-Prince)
+ */
+define('PARAM_TIMEZONE', 'timezone');
+
+/**
+ * PARAM_CLEANFILE - deprecated alias of PARAM_FILE; originally was removing regional chars too
+ */
+define('PARAM_CLEANFILE', 'file');
+
+/// Web Services ///
+
+/**
+ * VALUE_REQUIRED - if the parameter is not supplied, there is an error
+ */
+define('VALUE_REQUIRED', 1);
+
+/**
+ * VALUE_OPTIONAL - if the parameter is not supplied, then the param has no value
+ */
+define('VALUE_OPTIONAL', 2);
+
+/**
+ * VALUE_DEFAULT - if the parameter is not supplied, then the default value is used
  */
-define('PARAM_BASE64',   0x20000);
+define('VALUE_DEFAULT', 0);
 
+/**
+ * NULL_NOT_ALLOWED - the parameter can not be set to null in the database
+ */
+define('NULL_NOT_ALLOWED', false);
+
+/**
+ * NULL_ALLOWED - the parameter can be set to null in the database
+ */
+define('NULL_ALLOWED', true);
 
 /// Page types ///
 /**
@@ -234,46 +317,124 @@ define('PARAM_BASE64',   0x20000);
  */
 define('PAGE_COURSE_VIEW', 'course-view');
 
-/// Debug levels ///
-/** no warnings at all */
-define ('DEBUG_NONE', 0);
-/** E_ERROR | E_PARSE */
-define ('DEBUG_MINIMAL', 5);
-/** E_ERROR | E_PARSE | E_WARNING | E_NOTICE */
-define ('DEBUG_NORMAL', 15);
-/** E_ALL without E_STRICT for now, do show recoverable fatal errors */
-define ('DEBUG_ALL', 6143);
-/** DEBUG_ALL with extra Moodle debug messages - (DEBUG_ALL | 32768) */
-define ('DEBUG_DEVELOPER', 38911);
+/** Get remote addr constant */
+define('GETREMOTEADDR_SKIP_HTTP_CLIENT_IP', '1');
+/** Get remote addr constant */
+define('GETREMOTEADDR_SKIP_HTTP_X_FORWARDED_FOR', '2');
 
-/**
- * Blog access level constant declaration
- */
+/// Blog access level constant declaration ///
 define ('BLOG_USER_LEVEL', 1);
 define ('BLOG_GROUP_LEVEL', 2);
 define ('BLOG_COURSE_LEVEL', 3);
 define ('BLOG_SITE_LEVEL', 4);
 define ('BLOG_GLOBAL_LEVEL', 5);
 
+
+///Tag constants///
 /**
- * Tag constanst
+ * To prevent problems with multibytes strings,Flag updating in nav not working on the review page. this should not exceed the
+ * length of "varchar(255) / 3 (bytes / utf-8 character) = 85".
+ * TODO: this is not correct, varchar(255) are 255 unicode chars ;-)
+ *
+ * @todo define(TAG_MAX_LENGTH) this is not correct, varchar(255) are 255 unicode chars ;-)
  */
-//To prevent problems with multibytes strings, this should not exceed the
-//length of "varchar(255) / 3 (bytes / utf-8 character) = 85".
 define('TAG_MAX_LENGTH', 50);
 
-/**
- * Password policy constants
- */
+/// Password policy constants ///
 define ('PASSWORD_LOWER', 'abcdefghijklmnopqrstuvwxyz');
 define ('PASSWORD_UPPER', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
 define ('PASSWORD_DIGITS', '0123456789');
 define ('PASSWORD_NONALPHANUM', '.,;:!?_-+/*@#&$');
 
-if (!defined('SORT_LOCALE_STRING')) { // PHP < 4.4.0 - TODO: remove in 2.0
-    define('SORT_LOCALE_STRING', SORT_STRING);
-}
+/// Feature constants ///
+// Used for plugin_supports() to report features that are, or are not, supported by a module.
+
+/** True if module can provide a grade */
+define('FEATURE_GRADE_HAS_GRADE', 'grade_has_grade');
+/** True if module supports outcomes */
+define('FEATURE_GRADE_OUTCOMES', 'outcomes');
+
+/** True if module has code to track whether somebody viewed it */
+define('FEATURE_COMPLETION_TRACKS_VIEWS', 'completion_tracks_views');
+/** True if module has custom completion rules */
+define('FEATURE_COMPLETION_HAS_RULES', 'completion_has_rules');
+
+/** True if module has no 'view' page (like label) */
+define('FEATURE_NO_VIEW_LINK', 'viewlink');
+/** True if module supports outcomes */
+define('FEATURE_IDNUMBER', 'idnumber');
+/** True if module supports groups */
+define('FEATURE_GROUPS', 'groups');
+/** True if module supports groupings */
+define('FEATURE_GROUPINGS', 'groupings');
+/** True if module supports groupmembersonly */
+define('FEATURE_GROUPMEMBERSONLY', 'groupmembersonly');
+
+/** Type of module */
+define('FEATURE_MOD_ARCHETYPE', 'mod_archetype');
+/** True if module supports intro editor */
+define('FEATURE_MOD_INTRO', 'mod_intro');
+/** True if module has default completion */
+define('FEATURE_MODEDIT_DEFAULT_COMPLETION', 'modedit_default_completion');
+
+define('FEATURE_COMMENT', 'comment');
+
+define('FEATURE_RATE', 'rate');
+/** True if module supports backup/restore of moodle2 format */
+define('FEATURE_BACKUP_MOODLE2', 'backup_moodle2');
+
+/** Unspecified module archetype */
+define('MOD_ARCHETYPE_OTHER', 0);
+/** Resource-like type module */
+define('MOD_ARCHETYPE_RESOURCE', 1);
+/** Assignment module archetype */
+define('MOD_ARCHETYPE_ASSIGNMENT', 2);
+
+/**
+ * Security token used for allowing access
+ * from external application such as web services.
+ * Scripts do not use any session, performance is relatively
+ * low because we need to load access info in each request.
+ * Scripts are executed in parallel.
+ */
+define('EXTERNAL_TOKEN_PERMANENT', 0);
+
+/**
+ * Security token used for allowing access
+ * of embedded applications, the code is executed in the
+ * active user session. Token is invalidated after user logs out.
+ * Scripts are executed serially - normal session locking is used.
+ */
+define('EXTERNAL_TOKEN_EMBEDDED', 1);
+
+/**
+ * The home page should be the site home
+ */
+define('HOMEPAGE_SITE', 0);
+/**
+ * The home page should be the users my page
+ */
+define('HOMEPAGE_MY', 1);
+/**
+ * The home page can be chosen by the user
+ */
+define('HOMEPAGE_USER', 2);
+
+/**
+ * Hub directory url (should be moodle.org)
+ */
+define('HUB_HUBDIRECTORYURL', "http://hubdirectory.moodle.org");
+
+
+/**
+ * Moodle.org url (should be moodle.org)
+ */
+define('HUB_MOODLEORGHUBURL', "http://hub.moodle.org");
 
+/**
+ * Moodle mobile app service name
+ */
+define('MOODLE_OFFICIAL_MOBILE_SERVICE', 'moodle_mobile_app');
 
 /// PARAMETER HANDLING ////////////////////////////////////////////////////
 
@@ -285,27 +446,26 @@ if (!defined('SORT_LOCALE_STRING')) { // PHP < 4.4.0 - TODO: remove in 2.0
  * This function should be used to initialise all required values
  * in a script that are based on parameters.  Usually it will be
  * used like this:
- *    $id = required_param('id');
+ *    $id = required_param('id', PARAM_INT);
+ *
+ * Please note the $type parameter is now required,
+ * for now PARAM_CLEAN is used for backwards compatibility only.
  *
  * @param string $parname the name of the page parameter we want
- * @param int $type expected type of parameter
+ * @param string $type expected type of parameter
  * @return mixed
  */
-function required_param($parname, $type=PARAM_CLEAN) {
-
-    // detect_unchecked_vars addition
-    global $CFG;
-    if (!empty($CFG->detect_unchecked_vars)) {
-        global $UNCHECKED_VARS;
-        unset ($UNCHECKED_VARS->vars[$parname]);
+function required_param($parname, $type) {
+    if (!isset($type)) {
+        debugging('required_param() requires $type to be specified.');
+        $type = PARAM_CLEAN; // for now let's use this deprecated type
     }
-
     if (isset($_POST[$parname])) {       // POST has precedence
         $param = $_POST[$parname];
     } else if (isset($_GET[$parname])) {
         $param = $_GET[$parname];
     } else {
-        error('A required parameter ('.$parname.') was missing');
+        print_error('missingparam', '', '', $parname);
     }
 
     return clean_param($param, $type);
@@ -318,20 +478,23 @@ function required_param($parname, $type=PARAM_CLEAN) {
  * This function should be used to initialise all optional values
  * in a script that are based on parameters.  Usually it will be
  * used like this:
- *    $name = optional_param('name', 'Fred');
+ *    $name = optional_param('name', 'Fred', PARAM_TEXT);
+ *
+ * Please note $default and $type parameters are now required,
+ * for now PARAM_CLEAN is used for backwards compatibility only.
  *
  * @param string $parname the name of the page parameter we want
  * @param mixed  $default the default value to return if nothing is found
- * @param int $type expected type of parameter
+ * @param string $type expected type of parameter
  * @return mixed
  */
-function optional_param($parname, $default=NULL, $type=PARAM_CLEAN) {
-
-    // detect_unchecked_vars addition
-    global $CFG;
-    if (!empty($CFG->detect_unchecked_vars)) {
-        global $UNCHECKED_VARS;
-        unset ($UNCHECKED_VARS->vars[$parname]);
+function optional_param($parname, $default, $type) {
+    if (!isset($type)) {
+        debugging('optional_param() requires $default and $type to be specified.');
+        $type = PARAM_CLEAN; // for now let's use this deprecated type
+    }
+    if (!isset($default)) {
+        $default = null;
     }
 
     if (isset($_POST[$parname])) {       // POST has precedence
@@ -346,40 +509,50 @@ function optional_param($parname, $default=NULL, $type=PARAM_CLEAN) {
 }
 
 /**
+ * Strict validation of parameter values, the values are only converted
+ * to requested PHP type. Internally it is using clean_param, the values
+ * before and after cleaning must be equal - otherwise
+ * an invalid_parameter_exception is thrown.
+ * Objects and classes are not accepted.
+ *
+ * @param mixed $param
+ * @param int $type PARAM_ constant
+ * @param bool $allownull are nulls valid value?
+ * @param string $debuginfo optional debug information
+ * @return mixed the $param value converted to PHP type or invalid_parameter_exception
+ */
+function validate_param($param, $type, $allownull=NULL_NOT_ALLOWED, $debuginfo='') {
+    if (is_null($param)) {
+        if ($allownull == NULL_ALLOWED) {
+            return null;
+        } else {
+            throw new invalid_parameter_exception($debuginfo);
+        }
+    }
+    if (is_array($param) or is_object($param)) {
+        throw new invalid_parameter_exception($debuginfo);
+    }
+
+    $cleaned = clean_param($param, $type);
+    if ((string)$param !== (string)$cleaned) {
+        // conversion to string is usually lossless
+        throw new invalid_parameter_exception($debuginfo);
+    }
+
+    return $cleaned;
+}
+
+/**
  * Used by {@link optional_param()} and {@link required_param()} to
  * clean the variables and/or cast to specific types, based on
  * an options field.
  * <code>
  * $course->format = clean_param($course->format, PARAM_ALPHA);
- * $selectedgrade_item = clean_param($selectedgrade_item, PARAM_CLEAN);
+ * $selectedgrade_item = clean_param($selectedgrade_item, PARAM_INT);
  * </code>
  *
- * @uses $CFG
- * @uses PARAM_RAW
- * @uses PARAM_CLEAN
- * @uses PARAM_CLEANHTML
- * @uses PARAM_INT
- * @uses PARAM_NUMBER
- * @uses PARAM_ALPHA
- * @uses PARAM_ALPHANUM
- * @uses PARAM_ALPHAEXT
- * @uses PARAM_SEQUENCE
- * @uses PARAM_BOOL
- * @uses PARAM_NOTAGS
- * @uses PARAM_TEXT
- * @uses PARAM_SAFEDIR
- * @uses PARAM_CLEANFILE
- * @uses PARAM_FILE
- * @uses PARAM_PATH
- * @uses PARAM_HOST
- * @uses PARAM_URL
- * @uses PARAM_LOCALURL
- * @uses PARAM_PEM
- * @uses PARAM_BASE64
- * @uses PARAM_TAG
- * @uses PARAM_SEQUENCE
  * @param mixed $param the variable we are cleaning
- * @param int $type expected format of param after cleaning.
+ * @param string $type expected format of param after cleaning.
  * @return mixed
  */
 function clean_param($param, $type) {
@@ -398,42 +571,47 @@ function clean_param($param, $type) {
         case PARAM_RAW:          // no cleaning at all
             return $param;
 
+        case PARAM_RAW_TRIMMED:         // no cleaning, but strip leading and trailing whitespace.
+            return trim($param);
+
         case PARAM_CLEAN:        // General HTML cleaning, try to use more specific type if possible
+            // this is deprecated!, please use more specific type instead
             if (is_numeric($param)) {
                 return $param;
             }
-            $param = stripslashes($param);   // Needed for kses to work fine
-            $param = clean_text($param);     // Sweep for scripts, etc
-            return addslashes($param);       // Restore original request parameter slashes
+            return clean_text($param);     // Sweep for scripts, etc
 
-        case PARAM_CLEANHTML:    // prepare html fragment for display, do not store it into db!!
-            $param = stripslashes($param);   // Remove any slashes
-            $param = clean_text($param);     // Sweep for scripts, etc
+        case PARAM_CLEANHTML:    // clean html fragment
+            $param = clean_text($param, FORMAT_HTML);     // Sweep for scripts, etc
             return trim($param);
 
         case PARAM_INT:
             return (int)$param;  // Convert to integer
 
+        case PARAM_FLOAT:
         case PARAM_NUMBER:
-            return (float)$param;  // Convert to integer
+            return (float)$param;  // Convert to float
 
         case PARAM_ALPHA:        // Remove everything not a-z
             return preg_replace('/[^a-zA-Z]/i', '', $param);
 
+        case PARAM_ALPHAEXT:     // Remove everything not a-zA-Z_- (originally allowed "/" too)
+            return preg_replace('/[^a-zA-Z_-]/i', '', $param);
+
         case PARAM_ALPHANUM:     // Remove everything not a-zA-Z0-9
             return preg_replace('/[^A-Za-z0-9]/i', '', $param);
 
-        case PARAM_ALPHAEXT:     // Remove everything not a-zA-Z/_-
-            return preg_replace('/[^a-zA-Z\/_-]/i', '', $param);
+        case PARAM_ALPHANUMEXT:     // Remove everything not a-zA-Z0-9_-
+            return preg_replace('/[^A-Za-z0-9_-]/i', '', $param);
 
         case PARAM_SEQUENCE:     // Remove everything not 0-9,
             return preg_replace('/[^0-9,]/i', '', $param);
 
         case PARAM_BOOL:         // Convert to 1 or 0
             $tempstr = strtolower($param);
-            if ($tempstr == 'on' or $tempstr == 'yes' ) {
+            if ($tempstr === 'on' or $tempstr === 'yes' or $tempstr === 'true') {
                 $param = 1;
-            } else if ($tempstr == 'off' or $tempstr == 'no') {
+            } else if ($tempstr === 'off' or $tempstr === 'no'  or $tempstr === 'false') {
                 $param = 0;
             } else {
                 $param = empty($param) ? 0 : 1;
@@ -444,13 +622,73 @@ function clean_param($param, $type) {
             return strip_tags($param);
 
         case PARAM_TEXT:    // leave only tags needed for multilang
-            return clean_param(strip_tags($param, '<lang><span>'), PARAM_CLEAN);
+            // if the multilang syntax is not correct we strip all tags
+            // because it would break xhtml strict which is required for accessibility standards
+            // please note this cleaning does not strip unbalanced '>' for BC compatibility reasons
+            do {
+                if (strpos($param, '</lang>') !== false) {
+                    // old and future mutilang syntax
+                    $param = strip_tags($param, '<lang>');
+                    if (!preg_match_all('/<.*>/suU', $param, $matches)) {
+                        break;
+                    }
+                    $open = false;
+                    foreach ($matches[0] as $match) {
+                        if ($match === '</lang>') {
+                            if ($open) {
+                                $open = false;
+                                continue;
+                            } else {
+                                break 2;
+                            }
+                        }
+                        if (!preg_match('/^<lang lang="[a-zA-Z0-9_-]+"\s*>$/u', $match)) {
+                            break 2;
+                        } else {
+                            $open = true;
+                        }
+                    }
+                    if ($open) {
+                        break;
+                    }
+                    return $param;
+
+                } else if (strpos($param, '</span>') !== false) {
+                    // current problematic multilang syntax
+                    $param = strip_tags($param, '<span>');
+                    if (!preg_match_all('/<.*>/suU', $param, $matches)) {
+                        break;
+                    }
+                    $open = false;
+                    foreach ($matches[0] as $match) {
+                        if ($match === '</span>') {
+                            if ($open) {
+                                $open = false;
+                                continue;
+                            } else {
+                                break 2;
+                            }
+                        }
+                        if (!preg_match('/^<span(\s+lang="[a-zA-Z0-9_-]+"|\s+class="multilang"){2}\s*>$/u', $match)) {
+                            break 2;
+                        } else {
+                            $open = true;
+                        }
+                    }
+                    if ($open) {
+                        break;
+                    }
+                    return $param;
+                }
+            } while (false);
+            // easy, just strip all tags, if we ever want to fix orphaned '&' we have to do that in format_string()
+            return strip_tags($param);
 
         case PARAM_SAFEDIR:      // Remove everything not a-zA-Z0-9_-
             return preg_replace('/[^a-zA-Z0-9_-]/i', '', $param);
 
-        case PARAM_CLEANFILE:    // allow only safe characters
-            return clean_filename($param);
+        case PARAM_SAFEPATH:     // Remove everything not a-zA-Z0-9/_-
+            return preg_replace('/[^a-zA-Z0-9\/_-]/i', '', $param);
 
         case PARAM_FILE:         // Strip all suspicious characters from filename
             $param = preg_replace('~[[:cntrl:]]|[&<>"`\|\':\\\\/]~u', '', $param);
@@ -508,7 +746,7 @@ function clean_param($param, $type) {
                     // absolute, and matches our wwwroot
                 } else {
                     // relative - let's make sure there are no tricks
-                    if (validateUrlSyntax($param, 's-u-P-a-p-f+q?r?')) {
+                    if (validateUrlSyntax('/' . $param, 's-u-P-a-p-f+q?r?')) {
                         // looks ok.
                     } else {
                         $param = '';
@@ -571,9 +809,6 @@ function clean_param($param, $type) {
             // it must be processed with s(), urlencode() before embedding anywhere.
             // remove some nasties
             $param = preg_replace('~[[:cntrl:]]|[<>`]~u', '', $param);
-            //as long as magic_quotes_gpc is used, a backslash will be a
-            //problem, so remove *all* backslash - BUT watch out for SQL injections caused by this sloppy design (skodak)
-            $param = str_replace('\\', '', $param);
             //convert many whitespace chars into one
             $param = preg_replace('/\s+/', ' ', $param);
             $textlib = textlib_get_instance();
@@ -585,7 +820,7 @@ function clean_param($param, $type) {
             $result = array();
             foreach ($tags as $tag) {
                 $res = clean_param($tag, PARAM_TAG);
-                if ($res != '') {
+                if ($res !== '') {
                     $result[] = $res;
                 }
             }
@@ -595,8 +830,81 @@ function clean_param($param, $type) {
                 return '';
             }
 
+        case PARAM_CAPABILITY:
+            if (get_capability_info($param)) {
+                return $param;
+            } else {
+                return '';
+            }
+
+        case PARAM_PERMISSION:
+            $param = (int)$param;
+            if (in_array($param, array(CAP_INHERIT, CAP_ALLOW, CAP_PREVENT, CAP_PROHIBIT))) {
+                return $param;
+            } else {
+                return CAP_INHERIT;
+            }
+
+        case PARAM_AUTH:
+            $param = clean_param($param, PARAM_SAFEDIR);
+            if (exists_auth_plugin($param)) {
+                return $param;
+            } else {
+                return '';
+            }
+
+        case PARAM_LANG:
+            $param = clean_param($param, PARAM_SAFEDIR);
+            if (get_string_manager()->translation_exists($param)) {
+                return $param;
+            } else {
+                return ''; // Specified language is not installed or param malformed
+            }
+
+        case PARAM_THEME:
+            $param = clean_param($param, PARAM_SAFEDIR);
+            if (file_exists("$CFG->dirroot/theme/$param/config.php")) {
+                return $param;
+            } else if (!empty($CFG->themedir) and file_exists("$CFG->themedir/$param/config.php")) {
+                return $param;
+            } else {
+                return '';  // Specified theme is not installed
+            }
+
+        case PARAM_USERNAME:
+            $param = str_replace(" " , "", $param);
+            $param = moodle_strtolower($param);  // Convert uppercase to lowercase MDL-16919
+            if (empty($CFG->extendedusernamechars)) {
+                // regular expression, eliminate all chars EXCEPT:
+                // alphanum, dash (-), underscore (_), at sign (@) and period (.) characters.
+                $param = preg_replace('/[^-\.@_a-z0-9]/', '', $param);
+            }
+            return $param;
+
+        case PARAM_EMAIL:
+            if (validate_email($param)) {
+                return $param;
+            } else {
+                return '';
+            }
+
+        case PARAM_STRINGID:
+            if (preg_match('|^[a-zA-Z][a-zA-Z0-9\.:/_-]*$|', $param)) {
+                return $param;
+            } else {
+                return '';
+            }
+
+        case PARAM_TIMEZONE:    //can be int, float(with .5 or .0) or string seperated by '/' and can have '-_'
+            $timezonepattern = '/^(([+-]?(0?[0-9](\.[5|0])?|1[0-3]|1[0-2]\.5))|(99)|[[:alnum:]]+(\/?[[:alpha:]_-])+)$/';
+            if (preg_match($timezonepattern, $param)) {
+                return $param;
+            } else {
+                return '';
+            }
+
         default:                 // throw error, switched parameters in optional_param or another serious problem
-            error("Unknown parameter type: $type");
+            print_error("unknownparamtype", '', '', $type);
     }
 }
 
@@ -617,13 +925,28 @@ function is_number($value) {
 }
 
 /**
+ * Returns host part from url
+ * @param string $url full url
+ * @return string host, null if not found
+ */
+function get_host_from_url($url) {
+    preg_match('|^[a-z]+://([a-zA-Z0-9-.]+)|i', $url, $matches);
+    if ($matches) {
+        return $matches[1];
+    }
+    return null;
+}
+
+/**
+ * Tests whether anything was returned by text editor
+ *
  * This function is useful for testing whether something you got back from
  * the HTML editor actually contains anything. Sometimes the HTML editor
  * appear to be empty, but actually you get back a <br> tag or something.
  *
  * @param string $string a string containing HTML.
  * @return boolean does the string contain any actual content - that is text,
- * images, objcts, etc.
+ * images, objects, etc.
  */
 function html_is_blank($string) {
     return trim(strip_tags($string, '<img><object><applet><input><select><textarea><hr>')) == '';
@@ -640,16 +963,15 @@ function html_is_blank($string) {
  *
  * A NULL value will delete the entry.
  *
+ * @global object
+ * @global object
  * @param string $name the key to set
  * @param string $value the value to set (without magic quotes)
- * @param string $plugin (optional) the plugin scope
- * @uses $CFG
- * @return bool
+ * @param string $plugin (optional) the plugin scope, default NULL
+ * @return bool true or exception
  */
 function set_config($name, $value, $plugin=NULL) {
-/// No need for get_config because they are usually always available in $CFG
-
-    global $CFG;
+    global $CFG, $DB;
 
     if (empty($plugin)) {
         if (!array_key_exists($name, $CFG->config_php_settings)) {
@@ -661,100 +983,115 @@ function set_config($name, $value, $plugin=NULL) {
             }
         }
 
-        if (get_field('config', 'name', 'name', $name)) {
-            if ($value===null) {
-                return delete_records('config', 'name', $name);
+        if ($DB->get_field('config', 'name', array('name'=>$name))) {
+            if ($value === null) {
+                $DB->delete_records('config', array('name'=>$name));
             } else {
-                return set_field('config', 'value', addslashes($value), 'name', $name);
+                $DB->set_field('config', 'value', $value, array('name'=>$name));
             }
         } else {
-            if ($value===null) {
-                return true;
-            }
-            $config = new object();
+            if ($value !== null) {
+                $config = new stdClass();
             $config->name = $name;
-            $config->value = addslashes($value);
-            return insert_record('config', $config);
+                $config->value = $value;
+                $DB->insert_record('config', $config, false);
+            }
         }
+
     } else { // plugin scope
-        if ($id = get_field('config_plugins', 'id', 'name', $name, 'plugin', $plugin)) {
+        if ($id = $DB->get_field('config_plugins', 'id', array('name'=>$name, 'plugin'=>$plugin))) {
             if ($value===null) {
-                return delete_records('config_plugins', 'name', $name, 'plugin', $plugin);
+                $DB->delete_records('config_plugins', array('name'=>$name, 'plugin'=>$plugin));
             } else {
-                return set_field('config_plugins', 'value', addslashes($value), 'id', $id);
+                $DB->set_field('config_plugins', 'value', $value, array('id'=>$id));
             }
         } else {
-            if ($value===null) {
-                return true;
-            }
-            $config = new object();
-            $config->plugin = addslashes($plugin);
+            if ($value !== null) {
+                $config = new stdClass();
+                $config->plugin = $plugin;
             $config->name   = $name;
-            $config->value  = addslashes($value);
-            return insert_record('config_plugins', $config);
+                $config->value  = $value;
+                $DB->insert_record('config_plugins', $config, false);
         }
     }
+    }
+
+    return true;
 }
 
 /**
  * Get configuration values from the global config table
  * or the config_plugins table.
  *
- * If called with no parameters it will do the right thing
- * generating $CFG safely from the database without overwriting
- * existing values.
- *
- * If called with 2 parameters it will return a $string single
- * value or false of the value is not found.
+ * If called with one parameter, it will load all the config
+ * variables for one plugin, and return them as an object.
  *
- * @param string $plugin
- * @param string $name
- * @uses $CFG
- * @return hash-like object or single value
+ * If called with 2 parameters it will return a string single
+ * value or false if the value is not found.
  *
+ * @param string $plugin full component name
+ * @param string $name default NULL
+ * @return mixed hash-like object or single value, return false no config found
  */
-function get_config($plugin=NULL, $name=NULL) {
+function get_config($plugin, $name = NULL) {
+    global $CFG, $DB;
 
-    global $CFG;
+    // normalise component name
+    if ($plugin === 'moodle' or $plugin === 'core') {
+        $plugin = NULL;
+    }
 
     if (!empty($name)) { // the user is asking for a specific value
         if (!empty($plugin)) {
-            return get_field('config_plugins', 'value', 'plugin' , $plugin, 'name', $name);
+            if (isset($CFG->forced_plugin_settings[$plugin]) and array_key_exists($name, $CFG->forced_plugin_settings[$plugin])) {
+                // setting forced in config file
+                return $CFG->forced_plugin_settings[$plugin][$name];
         } else {
-            return get_field('config', 'value', 'name', $name);
+                return $DB->get_field('config_plugins', 'value', array('plugin'=>$plugin, 'name'=>$name));
+            }
+        } else {
+            if (array_key_exists($name, $CFG->config_php_settings)) {
+                // setting force in config file
+                return $CFG->config_php_settings[$name];
+            } else {
+                return $DB->get_field('config', 'value', array('name'=>$name));
+            }
         }
     }
 
     // the user is after a recordset
-    if (!empty($plugin)) {
-        if ($configs=get_records('config_plugins', 'plugin', $plugin, '', 'name,value')) {
-            $configs = (array)$configs;
-            $localcfg = array();
-            foreach ($configs as $config) {
-                $localcfg[$config->name] = $config->value;
-            }
-            return (object)$localcfg;
+    if ($plugin) {
+        $localcfg = $DB->get_records_menu('config_plugins', array('plugin'=>$plugin), '', 'name,value');
+        if (isset($CFG->forced_plugin_settings[$plugin])) {
+            foreach($CFG->forced_plugin_settings[$plugin] as $n=>$v) {
+                if (is_null($v) or is_array($v) or is_object($v)) {
+                    // we do not want any extra mess here, just real settings that could be saved in db
+                    unset($localcfg[$n]);
         } else {
-            return false;
+                    //convert to string as if it went through the DB
+                    $localcfg[$n] = (string)$v;
         }
-    } else {
-        // this was originally in setup.php
-        if ($configs = get_records('config')) {
-            $localcfg = (array)$CFG;
-            foreach ($configs as $config) {
-                if (!isset($localcfg[$config->name])) {
-                    $localcfg[$config->name] = $config->value;
                 }
-                // do not complain anymore if config.php overrides settings from db
             }
-
-            $localcfg = (object)$localcfg;
-            return $localcfg;
+        if ($localcfg) {
+            return (object)$localcfg;
         } else {
-            // preserve $CFG if DB returns nothing or error
-            return $CFG;
+            return null;
         }
 
+    } else {
+        // this part is not really used any more, but anyway...
+        $localcfg = $DB->get_records_menu('config', array(), '', 'name,value');
+        foreach($CFG->config_php_settings as $n=>$v) {
+            if (is_null($v) or is_array($v) or is_object($v)) {
+                // we do not want any extra mess here, just real settings that could be saved in db
+                unset($localcfg[$n]);
+            } else {
+                //convert to string as if it went through the DB
+                $localcfg[$n] = (string)$v;
+            }
+        }
+        return (object)$localcfg;
     }
 }
 
@@ -763,41 +1100,126 @@ function get_config($plugin=NULL, $name=NULL) {
  *
  * @param string $name the key to set
  * @param string $plugin (optional) the plugin scope
- * @uses $CFG
- * @return bool
+ * @global object
+ * @return boolean whether the operation succeeded.
  */
 function unset_config($name, $plugin=NULL) {
-
-    global $CFG;
-
-    unset($CFG->$name);
+    global $CFG, $DB;
 
     if (empty($plugin)) {
-        return delete_records('config', 'name', $name);
+        unset($CFG->$name);
+        $DB->delete_records('config', array('name'=>$name));
     } else {
-        return delete_records('config_plugins', 'name', $name, 'plugin', $plugin);
+        $DB->delete_records('config_plugins', array('name'=>$name, 'plugin'=>$plugin));
+    }
+
+    return true;
+}
+
+/**
+ * Remove all the config variables for a given plugin.
+ *
+ * @param string $plugin a plugin, for example 'quiz' or 'qtype_multichoice';
+ * @return boolean whether the operation succeeded.
+ */
+function unset_all_config_for_plugin($plugin) {
+    global $DB;
+    $DB->delete_records('config_plugins', array('plugin' => $plugin));
+    $like = $DB->sql_like('name', '?', true, true, false, '|');
+    $params = array($DB->sql_like_escape($plugin.'_', '|') . '%');
+    $DB->delete_records_select('config', $like, $params);
+    return true;
+}
+
+/**
+ * Use this function to get a list of users from a config setting of type admin_setting_users_with_capability.
+ *
+ * All users are verified if they still have the necessary capability.
+ *
+ * @param string $value the value of the config setting.
+ * @param string $capability the capability - must match the one passed to the admin_setting_users_with_capability constructor.
+ * @param bool $include admins, include administrators
+ * @return array of user objects.
+ */
+function get_users_from_config($value, $capability, $includeadmins = true) {
+    global $CFG, $DB;
+
+    if (empty($value) or $value === '$@NONE@$') {
+        return array();
+    }
+
+    // we have to make sure that users still have the necessary capability,
+    // it should be faster to fetch them all first and then test if they are present
+    // instead of validating them one-by-one
+    $users = get_users_by_capability(get_context_instance(CONTEXT_SYSTEM), $capability);
+    if ($includeadmins) {
+        $admins = get_admins();
+        foreach ($admins as $admin) {
+            $users[$admin->id] = $admin;
+        }
     }
+
+    if ($value === '$@ALL@$') {
+        return $users;
+    }
+
+    $result = array(); // result in correct order
+    $allowed = explode(',', $value);
+    foreach ($allowed as $uid) {
+        if (isset($users[$uid])) {
+            $user = $users[$uid];
+            $result[$user->id] = $user;
+        }
+    }
+
+    return $result;
+}
+
+
+/**
+ * Invalidates browser caches and cached data in temp
+ * @return void
+ */
+function purge_all_caches() {
+    global $CFG;
+
+    reset_text_filters_cache();
+    js_reset_all_caches();
+    theme_reset_all_caches();
+    get_string_manager()->reset_caches();
+
+    // purge all other caches: rss, simplepie, etc.
+    remove_dir($CFG->dataroot.'/cache', true);
+
+    // make sure cache dir is writable, throws exception if not
+    make_upload_directory('cache');
+
+    // hack: this script may get called after the purifier was initialised,
+    // but we do not want to verify repeatedly this exists in each call
+    make_upload_directory('cache/htmlpurifier');
+
+    clearstatcache();
 }
 
 /**
  * Get volatile flags
  *
  * @param string $type
- * @param int    $changedsince
+ * @param int    $changedsince default null
  * @return records array
- *
  */
 function get_cache_flags($type, $changedsince=NULL) {
+    global $DB;
 
-    $type = addslashes($type);
-
-    $sqlwhere = 'flagtype=\'' . $type . '\' AND expiry >= ' . time();
+    $params = array('type'=>$type, 'expiry'=>time());
+    $sqlwhere = "flagtype = :type AND expiry >= :expiry";
     if ($changedsince !== NULL) {
-        $changedsince = (int)$changedsince;
-        $sqlwhere .= ' AND timemodified > ' . $changedsince;
+        $params['changedsince'] = $changedsince;
+        $sqlwhere .= " AND timemodified > :changedsince";
     }
     $cf = array();
-    if ($flags=get_records_select('cache_flags', $sqlwhere, '', 'name,value')) {
+
+    if ($flags = $DB->get_records_select('cache_flags', $sqlwhere, $params, '', 'name,value')) {
         foreach ($flags as $flag) {
             $cf[$flag->name] = $flag->value;
         }
@@ -806,44 +1228,25 @@ function get_cache_flags($type, $changedsince=NULL) {
 }
 
 /**
- * Use this funciton to get a list of users from a config setting of type admin_setting_users_with_capability.
- * @param string $value the value of the config setting.
- * @param string $capability the capability - must match the one passed to the admin_setting_users_with_capability constructor.
- * @return array of user objects.
- */
-function get_users_from_config($value, $capability) {
-    global $CFG;
-    if ($value == '$@ALL@$') {
-        $users = get_users_by_capability(get_context_instance(CONTEXT_SYSTEM), $capability);
-    } else if ($value) {
-        $usernames = explode(',', $value);
-        $users = get_records_select('user', "username IN ('" . implode("','", $usernames) . "') AND mnethostid = " . $CFG->mnet_localhost_id);
-    } else {
-        $users = array();
-    }
-    return $users;
-}
-
-/**
  * Get volatile flags
  *
  * @param string $type
  * @param string $name
- * @param int    $changedsince
+ * @param int    $changedsince default null
  * @return records array
- *
  */
 function get_cache_flag($type, $name, $changedsince=NULL) {
+    global $DB;
 
-    $type = addslashes($type);
-    $name = addslashes($name);
+    $params = array('type'=>$type, 'name'=>$name, 'expiry'=>time());
 
-    $sqlwhere = 'flagtype=\'' . $type . '\' AND name=\'' . $name . '\' AND expiry >= ' . time();
+    $sqlwhere = "flagtype = :type AND name = :name AND expiry >= :expiry";
     if ($changedsince !== NULL) {
-        $changedsince = (int)$changedsince;
-        $sqlwhere .= ' AND timemodified > ' . $changedsince;
+        $params['changedsince'] = $changedsince;
+        $sqlwhere .= " AND timemodified > :changedsince";
     }
-    return get_field_select('cache_flags', 'value', $sqlwhere);
+
+    return $DB->get_field_select('cache_flags', 'value', $sqlwhere, $params);
 }
 
 /**
@@ -853,10 +1256,10 @@ function get_cache_flag($type, $name, $changedsince=NULL) {
  * @param string $name the key to set
  * @param string $value the value to set (without magic quotes) - NULL will remove the flag
  * @param int $expiry (optional) epoch indicating expiry - defaults to now()+ 24hs
- * @return bool
+ * @return bool Always returns true
  */
 function set_cache_flag($type, $name, $value, $expiry=NULL) {
-
+    global $DB;
 
     $timemodified = time();
     if ($expiry===NULL || $expiry < $timemodified) {
@@ -866,249 +1269,310 @@ function set_cache_flag($type, $name, $value, $expiry=NULL) {
     }
 
     if ($value === NULL) {
-        return unset_cache_flag($type,$name);
+        unset_cache_flag($type,$name);
+        return true;
     }
 
-    $type = addslashes($type);
-    $name = addslashes($name);
-    if ($f = get_record('cache_flags', 'name', $name, 'flagtype', $type)) { // this is a potentail problem in DEBUG_DEVELOPER
+    if ($f = $DB->get_record('cache_flags', array('name'=>$name, 'flagtype'=>$type), '*', IGNORE_MULTIPLE)) { // this is a potential problem in DEBUG_DEVELOPER
         if ($f->value == $value and $f->expiry == $expiry and $f->timemodified == $timemodified) {
             return true; //no need to update; helps rcache too
         }
-        $f->value        = addslashes($value);
+        $f->value        = $value;
         $f->expiry       = $expiry;
         $f->timemodified = $timemodified;
-        return update_record('cache_flags', $f);
+        $DB->update_record('cache_flags', $f);
     } else {
-        $f = new object();
+        $f = new stdClass();
         $f->flagtype     = $type;
         $f->name         = $name;
-        $f->value        = addslashes($value);
+        $f->value        = $value;
         $f->expiry       = $expiry;
         $f->timemodified = $timemodified;
-        return (bool)insert_record('cache_flags', $f);
+        $DB->insert_record('cache_flags', $f);
     }
+    return true;
 }
 
 /**
  * Removes a single volatile flag
  *
+ * @global object
  * @param string $type the "type" namespace for the key
  * @param string $name the key to set
- * @uses $CFG
  * @return bool
  */
 function unset_cache_flag($type, $name) {
-
-    return delete_records('cache_flags',
-                          'name', addslashes($name),
-                          'flagtype', addslashes($type));
+    global $DB;
+    $DB->delete_records('cache_flags', array('name'=>$name, 'flagtype'=>$type));
+    return true;
 }
 
 /**
  * Garbage-collect volatile flags
  *
+ * @return bool Always returns true
  */
 function gc_cache_flags() {
-    return delete_records_select('cache_flags', 'expiry < ' . time());
+    global $DB;
+    $DB->delete_records_select('cache_flags', 'expiry < ?', array(time()));
+    return true;
 }
 
+/// FUNCTIONS FOR HANDLING USER PREFERENCES ////////////////////////////////////
+
 /**
- * Refresh current $USER session global variable with all their current preferences.
- * @uses $USER
+ * Refresh user preference cache. This is used most often for $USER
+ * object that is stored in session, but it also helps with performance in cron script.
+ *
+ * Preferences for each user are loaded on first use on every page, then again after the timeout expires.
+ *
+ * @param stdClass $user user object, preferences are preloaded into ->preference property
+ * @param int $cachelifetime cache life time on the current page (ins seconds)
+ * @return void
  */
-function reload_user_preferences() {
+function check_user_preferences_loaded(stdClass $user, $cachelifetime = 120) {
+    global $DB;
+    static $loadedusers = array(); // Static cache, we need to check on each page load, not only every 2 minutes.
 
-    global $USER;
+    if (!isset($user->id)) {
+        throw new coding_exception('Invalid $user parameter in check_user_preferences_loaded() call, missing id field');
+    }
+
+    if (empty($user->id) or isguestuser($user->id)) {
+        // No permanent storage for not-logged-in users and guest
+        if (!isset($user->preference)) {
+            $user->preference = array();
+        }
+        return;
+    }
 
-    //reset preference
-    $USER->preference = array();
+    $timenow = time();
 
-    if (!isloggedin() or isguestuser()) {
-        // no permanent storage for not-logged-in user and guest
+    if (isset($loadedusers[$user->id]) and isset($user->preference) and isset($user->preference['_lastloaded'])) {
+        // Already loaded at least once on this page. Are we up to date?
+        if ($user->preference['_lastloaded'] + $cachelifetime > $timenow) {
+            // no need to reload - we are on the same page and we loaded prefs just a moment ago
+            return;
 
-    } else if ($preferences = get_records('user_preferences', 'userid', $USER->id)) {
-        foreach ($preferences as $preference) {
-            $USER->preference[$preference->name] = $preference->value;
+        } else if (!get_cache_flag('userpreferenceschanged', $user->id, $user->preference['_lastloaded'])) {
+            // no change since the lastcheck on this page
+            $user->preference['_lastloaded'] = $timenow;
+            return;
         }
     }
 
-    return true;
+    // OK, so we have to reload all preferences
+    $loadedusers[$user->id] = true;
+    $user->preference = $DB->get_records_menu('user_preferences', array('userid'=>$user->id), '', 'name,value'); // All values
+    $user->preference['_lastloaded'] = $timenow;
 }
 
 /**
- * Sets a preference for the current user
- * Optionally, can set a preference for a different user object
- * @uses $USER
- * @todo Add a better description and include usage examples. Add inline links to $USER and user functions in above line.
+ * Called from set/delete_user_preferences, so that the prefs can
+ * be correctly reloaded in different sessions.
+ *
+ * NOTE: internal function, do not call from other code.
+ *
+ * @param integer $userid the user whose prefs were changed.
+ * @return void
+ */
+function mark_user_preferences_changed($userid) {
+    global $CFG;
 
+    if (empty($userid) or isguestuser($userid)) {
+        // no cache flags for guest and not-logged-in users
+        return;
+    }
+
+    set_cache_flag('userpreferenceschanged', $userid, 1, time() + $CFG->sessiontimeout);
+}
+
+/**
+ * Sets a preference for the specified user.
+ *
+ * If user object submitted, 'preference' property contains the preferences cache.
+ *
  * @param string $name The key to set as preference for the specified user
- * @param string $value The value to set forthe $name key in the specified user's record
- * @param int $otheruserid A moodle user ID
- * @return bool
+ * @param string $value The value to set for the $name key in the specified user's record,
+ *                      null means delete current value
+ * @param stdClass|int $user A moodle user object or id, null means current user
+ * @return bool always true or exception
  */
-function set_user_preference($name, $value, $otheruserid=NULL) {
-
-    global $USER;
+function set_user_preference($name, $value, $user = null) {
+    global $USER, $DB;
 
-    if (!isset($USER->preference)) {
-        reload_user_preferences();
+    if (empty($name) or is_numeric($name) or $name === '_lastloaded') {
+        throw new coding_exception('Invalid preference name in set_user_preference() call');
     }
 
-    if (empty($name)) {
-        return false;
+    if (is_null($value)) {
+        // null means delete current
+        return unset_user_preference($name, $user);
+    } else if (is_object($value)) {
+        throw new coding_exception('Invalid value in set_user_preference() call, objects are not allowed');
+    } else if (is_array($value)) {
+        throw new coding_exception('Invalid value in set_user_preference() call, arrays are not allowed');
     }
+    $value = (string)$value;
 
-    $nostore = false;
-
-    if (empty($otheruserid)){
-        if (!isloggedin() or isguestuser()) {
-            $nostore = true;
-        }
-        $userid = $USER->id;
+    if (is_null($user)) {
+        $user = $USER;
+    } else if (isset($user->id)) {
+        // $user is valid object
+    } else if (is_numeric($user)) {
+        $user = (object)array('id'=>(int)$user);
     } else {
-        if (isguestuser($otheruserid)) {
-            $nostore = true;
-        }
-        $userid = $otheruserid;
+        throw new coding_exception('Invalid $user parameter in set_user_preference() call');
     }
 
-    $return = true;
-    if ($nostore) {
-        // no permanent storage for not-logged-in user and guest
+    check_user_preferences_loaded($user);
 
-    } else if ($preference = get_record('user_preferences', 'userid', $userid, 'name', addslashes($name))) {
-        if ($preference->value === $value) {
+    if (empty($user->id) or isguestuser($user->id)) {
+        // no permanent storage for not-logged-in users and guest
+        $user->preference[$name] = $value;
             return true;
         }
-        if (!set_field('user_preferences', 'value', addslashes((string)$value), 'id', $preference->id)) {
-            $return = false;
+
+    if ($preference = $DB->get_record('user_preferences', array('userid'=>$user->id, 'name'=>$name))) {
+        if ($preference->value === $value and isset($user->preference[$name]) and $user->preference[$name] === $value) {
+            // preference already set to this value
+            return true;
         }
+        $DB->set_field('user_preferences', 'value', $value, array('id'=>$preference->id));
 
     } else {
-        $preference = new object();
-        $preference->userid = $userid;
-        $preference->name   = addslashes($name);
-        $preference->value  = addslashes((string)$value);
-        if (!insert_record('user_preferences', $preference)) {
-            $return = false;
-        }
+        $preference = new stdClass();
+        $preference->userid = $user->id;
+        $preference->name   = $name;
+        $preference->value  = $value;
+        $DB->insert_record('user_preferences', $preference);
     }
 
-    // update value in USER session if needed
-    if ($userid == $USER->id) {
-        $USER->preference[$name] = (string)$value;
-    }
+    // update value in cache
+    $user->preference[$name] = $value;
 
-    return $return;
+    // set reload flag for other sessions
+    mark_user_preferences_changed($user->id);
+
+    return true;
+}
+
+/**
+ * Sets a whole array of preferences for the current user
+ *
+ * If user object submitted, 'preference' property contains the preferences cache.
+ *
+ * @param array $prefarray An array of key/value pairs to be set
+ * @param stdClass|int $user A moodle user object or id, null means current user
+ * @return bool always true or exception
+ */
+function set_user_preferences(array $prefarray, $user = null) {
+    foreach ($prefarray as $name => $value) {
+        set_user_preference($name, $value, $user);
+    }
+    return true;
 }
 
 /**
  * Unsets a preference completely by deleting it from the database
- * Optionally, can set a preference for a different user id
- * @uses $USER
+ *
+ * If user object submitted, 'preference' property contains the preferences cache.
+ *
  * @param string  $name The key to unset as preference for the specified user
- * @param int $otheruserid A moodle user ID
+ * @param stdClass|int $user A moodle user object or id, null means current user
+ * @return bool always true or exception
  */
-function unset_user_preference($name, $otheruserid=NULL) {
-
-    global $USER;
+function unset_user_preference($name, $user = null) {
+    global $USER, $DB;
 
-    if (!isset($USER->preference)) {
-        reload_user_preferences();
+    if (empty($name) or is_numeric($name) or $name === '_lastloaded') {
+        throw new coding_exception('Invalid preference name in unset_user_preference() call');
     }
 
-    if (empty($otheruserid)){
-        $userid = $USER->id;
+    if (is_null($user)) {
+        $user = $USER;
+    } else if (isset($user->id)) {
+        // $user is valid object
+    } else if (is_numeric($user)) {
+        $user = (object)array('id'=>(int)$user);
     } else {
-        $userid = $otheruserid;
+        throw new coding_exception('Invalid $user parameter in unset_user_preference() call');
     }
 
-    //Delete the preference from $USER if needed
-    if ($userid == $USER->id) {
-        unset($USER->preference[$name]);
-    }
+    check_user_preferences_loaded($user);
 
-    //Then from DB
-    return delete_records('user_preferences', 'userid', $userid, 'name', addslashes($name));
-}
+    if (empty($user->id) or isguestuser($user->id)) {
+        // no permanent storage for not-logged-in user and guest
+        unset($user->preference[$name]);
+        return true;
+    }
 
+    // delete from DB
+    $DB->delete_records('user_preferences', array('userid'=>$user->id, 'name'=>$name));
 
-/**
- * Sets a whole array of preferences for the current user
- * @param array $prefarray An array of key/value pairs to be set
- * @param int $otheruserid A moodle user ID
- * @return bool
- */
-function set_user_preferences($prefarray, $otheruserid=NULL) {
+    // delete the preference from cache
+    unset($user->preference[$name]);
 
-    if (!is_array($prefarray) or empty($prefarray)) {
-        return false;
-    }
+    // set reload flag for other sessions
+    mark_user_preferences_changed($user->id);
 
-    $return = true;
-    foreach ($prefarray as $name => $value) {
-        // The order is important; test for return is done first
-        $return = (set_user_preference($name, $value, $otheruserid) && $return);
-    }
-    return $return;
+    return true;
 }
 
 /**
+ * Used to fetch user preference(s)
+ *
  * If no arguments are supplied this function will return
  * all of the current user preferences as an array.
+ *
  * If a name is specified then this function
  * attempts to return that particular preference value.  If
  * none is found, then the optional value $default is returned,
  * otherwise NULL.
+ *
+ * If user object submitted, 'preference' property contains the preferences cache.
+ *
  * @param string $name Name of the key to use in finding a preference value
- * @param string $default Value to be returned if the $name key is not set in the user preferences
- * @param int $otheruserid A moodle user ID
- * @uses $USER
- * @return string
+ * @param mixed $default Value to be returned if the $name key is not set in the user preferences
+ * @param stdClass|int $user A moodle user object or id, null means current user
+ * @return mixed string value or default
  */
-function get_user_preferences($name=NULL, $default=NULL, $otheruserid=NULL) {
+function get_user_preferences($name = null, $default = null, $user = null) {
     global $USER;
 
-    if (!isset($USER->preference)) {
-        reload_user_preferences();
+    if (is_null($name)) {
+        // all prefs
+    } else if (is_numeric($name) or $name === '_lastloaded') {
+        throw new coding_exception('Invalid preference name in get_user_preferences() call');
     }
 
-    if (empty($otheruserid)){
-        $userid = $USER->id;
+    if (is_null($user)) {
+        $user = $USER;
+    } else if (isset($user->id)) {
+        // $user is valid object
+    } else if (is_numeric($user)) {
+        $user = (object)array('id'=>(int)$user);
     } else {
-        $userid = $otheruserid;
+        throw new coding_exception('Invalid $user parameter in get_user_preferences() call');
     }
 
-    if ($userid == $USER->id) {
-        $preference = $USER->preference;
-
-    } else {
-        $preference = array();
-        if ($prefdata = get_records('user_preferences', 'userid', $userid)) {
-            foreach ($prefdata as $pref) {
-                $preference[$pref->name] = $pref->value;
-            }
-        }
-    }
+    check_user_preferences_loaded($user);
 
     if (empty($name)) {
-        return $preference;            // All values
-
-    } else if (array_key_exists($name, $preference)) {
-        return $preference[$name];    // The single value
-
+        return $user->preference; // All values
+    } else if (isset($user->preference[$name])) {
+        return $user->preference[$name]; // The single string value
     } else {
-        return $default;              // Default value (or NULL)
+        return $default; // Default value (null if not specified)
     }
 }
 
-
 /// FUNCTIONS FOR HANDLING TIME ////////////////////////////////////////////
 
 /**
  * Given date parts in user time produce a GMT timestamp.
  *
+ * @todo Finish documenting this function
  * @param int $year The year part to create timestamp of
  * @param int $month The month part to create timestamp of
  * @param int $day The day part to create timestamp of
@@ -1119,7 +1583,6 @@ function get_user_preferences($name=NULL, $default=NULL, $otheruserid=NULL) {
  * @param bool $applydst Toggle Daylight Saving Time, default true, will be 
  *             applied only if timezone is 99 or string.
  * @return int timestamp
- * @todo Finish documenting this function
  */
 function make_timestamp($year, $month=1, $day=1, $hour=0, $minute=0, $second=0, $timezone=99, $applydst=true) {
 
@@ -1145,6 +1608,8 @@ function make_timestamp($year, $month=1, $day=1, $hour=0, $minute=0, $second=0,
 }
 
 /**
+ * Format a date/time (seconds) as weeks, days, hours etc as needed
+ *
  * Given an amount of time in seconds, returns string
  * formatted nicely as weeks, days, hours etc as needed
  *
@@ -1152,9 +1617,9 @@ function make_timestamp($year, $month=1, $day=1, $hour=0, $minute=0, $second=0,
  * @uses HOURSECS
  * @uses DAYSECS
  * @uses YEARSECS
- * @param int $totalsecs ?
- * @param array $str ?
- * @return string
+ * @param int $totalsecs Time in seconds
+ * @param object $str Should be a time object
+ * @return string A nicely formatted date/time string
  */
  function format_time($totalsecs, $str=NULL) {
 
@@ -1211,6 +1676,8 @@ function make_timestamp($year, $month=1, $day=1, $hour=0, $minute=0, $second=0,
 
 /**
  * Returns a formatted string that represents a date in user time
+ *
+ * Returns a formatted string that represents a date in user time
  * <b>WARNING: note that the format is for strftime(), not date().</b>
  * Because of a bug in most Windows time libraries, we can't use
  * the nicer %e, so we have to use %d which has leading zeroes.
@@ -1218,23 +1685,23 @@ function make_timestamp($year, $month=1, $day=1, $hour=0, $minute=0, $second=0,
  * zeroes as efficiently as possible.
  *
  * If parameter fixday = true (default), then take off leading
- * zero from %d, else mantain it.
+ * zero from %d, else maintain it.
  *
- * @uses HOURSECS
- * @param  int $date timestamp in GMT
- * @param string $format strftime format
+ * @param int $date the timestamp in UTC, as obtained from the database.
+ * @param string $format strftime format. You should probably get this using
+ *      get_string('strftime...', 'langconfig');
  * @param mixed $timezone by default, uses the user's time zone. if numeric and
  *      not 99 then daylight saving will not be added.
- * @param bool $fixday If true (default) then the leading
- * zero from %d is removed. If false then the leading zero is mantained.
- * @return string
+ * @param bool $fixday If true (default) then the leading zero from %d is removed.
+ *      If false then the leading zero is maintained.
+ * @return string the formatted date/time.
  */
-function userdate($date, $format='', $timezone=99, $fixday = true) {
+function userdate($date, $format = '', $timezone = 99, $fixday = true) {
 
     global $CFG;
 
     if (empty($format)) {
-        $format = get_string('strftimedaydatetime');
+        $format = get_string('strftimedaydatetime', 'langconfig');
     }
 
     if (!empty($CFG->nofixday)) {  // Config.php can force %d not to be fixed.
@@ -1255,7 +1722,7 @@ function userdate($date, $format='', $timezone=99, $fixday = true) {
     if (abs($timezone) > 13) {   /// Server time
         if ($fixday) {
             $datestring = strftime($formatnoday, $date);
-            $daystring  = str_replace(' 0', '', strftime(' %d', $date));
+            $daystring  = ltrim(str_replace(array(' 0', ' '), '', strftime(' %d', $date)));
             $datestring = str_replace('DD', $daystring, $datestring);
         } else {
             $datestring = strftime($format, $date);
@@ -1264,7 +1731,7 @@ function userdate($date, $format='', $timezone=99, $fixday = true) {
         $date += (int)($timezone * 3600);
         if ($fixday) {
             $datestring = gmstrftime($formatnoday, $date);
-            $daystring  = str_replace(' 0', '', gmstrftime(' %d', $date));
+            $daystring  = ltrim(str_replace(array(' 0', ' '), '', gmstrftime(' %d', $date)));
             $datestring = str_replace('DD', $daystring, $datestring);
         } else {
             $datestring = gmstrftime($format, $date);
@@ -1275,7 +1742,7 @@ function userdate($date, $format='', $timezone=99, $fixday = true) {
 /// (because it's impossible to specify UTF-8 to fetch locale info in Win32)
 
    if ($CFG->ostype == 'WINDOWS') {
-       if ($localewincharset = get_string('localewincharset')) {
+       if ($localewincharset = get_string('localewincharset', 'langconfig')) {
            $textlib = textlib_get_instance();
            $datestring = $textlib->convert($datestring, $localewincharset, 'utf-8');
        }
@@ -1288,12 +1755,12 @@ function userdate($date, $format='', $timezone=99, $fixday = true) {
  * Given a $time timestamp in GMT (seconds since epoch),
  * returns an array that represents the date in user time
  *
+ * @todo Finish documenting this function
  * @uses HOURSECS
  * @param int $time Timestamp in GMT
  * @param mixed $timezone offset time with timezone, if float and not 99, then no
  *        dst offset is applyed
  * @return array An array that represents the date in user time
- * @todo Finish documenting this function
  */
 function usergetdate($time, $timezone=99) {
 
@@ -1357,8 +1824,8 @@ function usertime($date, $timezone=99) {
  * for the current user.
  *
  * @param int $date Timestamp in GMT
- * @param float $timezone ?
- * @return ?
+ * @param float $timezone Defaults to user's timezone
+ * @return int Returns a GMT timestamp
  */
 function usergetmidnight($date, $timezone=99) {
 
@@ -1408,10 +1875,10 @@ function usertimezone($timezone=99) {
  * Returns a float which represents the user's timezone difference from GMT in hours
  * Checks various settings and picks the most dominant of those which have a value
  *
- * @uses $CFG
- * @uses $USER
+ * @global object
+ * @global object
  * @param float $tz If this value is provided and not equal to 99, it will be returned as is and no other settings will be checked
- * @return int
+ * @return float
  */
 function get_user_timezone_offset($tz = 99) {
 
@@ -1432,6 +1899,8 @@ function get_user_timezone_offset($tz = 99) {
 
 /**
  * Returns an int which represents the systems's timezone difference from GMT in seconds
+ *
+ * @global object
  * @param mixed $tz timezone
  * @return int if found, false is timezone 99 or error
  */
@@ -1458,8 +1927,8 @@ function get_timezone_offset($tz) {
  * means that for this timezone there are also DST rules to be taken into account
  * Checks various settings and picks the most dominant of those which have a value
  *
- * @uses $USER
- * @uses $CFG
+ * @global object
+ * @global object
  * @param mixed $tz If this value is provided and not equal to 99, it will be returned as is and no other settings will be checked
  * @return mixed
  */
@@ -1475,7 +1944,7 @@ function get_user_timezone($tz = 99) {
 
     $tz = 99;
 
-    while(($tz == '' || $tz == 99 || $tz == NULL) && $next = each($timezones)) {
+    while(($tz === '' || $tz == 99 || $tz === NULL) && $next = each($timezones)) {
         $tz = $next['value'];
     }
 
@@ -1483,15 +1952,15 @@ function get_user_timezone($tz = 99) {
 }
 
 /**
- * ?
+ * Returns cached timezone record for given $timezonename
  *
- * @uses $CFG
- * @uses $db
- * @param string $timezonename ?
- * @return object
+ * @global object
+ * @global object
+ * @param string $timezonename
+ * @return mixed timezonerecord object or false
  */
 function get_timezone_record($timezonename) {
-    global $CFG, $db;
+    global $CFG, $DB;
     static $cache = NULL;
 
     if ($cache === NULL) {
@@ -1502,21 +1971,23 @@ function get_timezone_record($timezonename) {
         return $cache[$timezonename];
     }
 
-    return $cache[$timezonename] = get_record_sql('SELECT * FROM '.$CFG->prefix.'timezone
-                                      WHERE name = '.$db->qstr($timezonename).' ORDER BY year DESC', true);
+    return $cache[$timezonename] = $DB->get_record_sql('SELECT * FROM {timezone}
+                                                        WHERE name = ? ORDER BY year DESC', array($timezonename), true);
 }
 
 /**
- * ?
+ * Build and store the users Daylight Saving Time (DST) table
  *
- * @uses $CFG
- * @uses $USER
- * @param ? $fromyear ?
- * @param ? $to_year ?
+ * @global object
+ * @global object
+ * @global object
+ * @param mixed $from_year Start year for the table, defaults to 1971
+ * @param mixed $to_year End year for the table, defaults to 2035
+ * @param mixed $strtimezone, if null or 99 then user's default timezone is used
  * @return bool
  */
 function calculate_user_dst_table($from_year = NULL, $to_year = NULL, $strtimezone = NULL) {
-    global $CFG, $SESSION;
+    global $CFG, $SESSION, $DB;
 
     $usertz = get_user_timezone($strtimezone);
 
@@ -1595,7 +2066,7 @@ function calculate_user_dst_table($from_year = NULL, $to_year = NULL, $strtimezo
 
     static $presets_cache = array();
     if (!isset($presets_cache[$usertz])) {
-        $presets_cache[$usertz] = get_records('timezone', 'name', $usertz, 'year DESC', 'year, gmtoff, dstoff, dst_month, dst_startday, dst_weekday, dst_skipweeks, dst_time, std_month, std_startday, std_weekday, std_skipweeks, std_time');
+        $presets_cache[$usertz] = $DB->get_records('timezone', array('name'=>$usertz), 'year DESC', 'year, gmtoff, dstoff, dst_month, dst_startday, dst_weekday, dst_skipweeks, dst_time, std_month, std_startday, std_weekday, std_skipweeks, std_time');
     }
     if(empty($presets_cache[$usertz])) {
         return false;
@@ -1637,6 +2108,15 @@ function calculate_user_dst_table($from_year = NULL, $to_year = NULL, $strtimezo
     return true;
 }
 
+/**
+ * Calculates the required DST change and returns a Timestamp Array
+ *
+ * @uses HOURSECS
+ * @uses MINSECS
+ * @param mixed $year Int or String Year to focus on
+ * @param object $timezone Instatiated Timezone object
+ * @return mixed Null, or Array dst=>xx, 0=>xx, std=>yy, 1=>yy
+ */
 function dst_changes_for_year($year, $timezone) {
 
     if($timezone->dst_startday == 0 && $timezone->dst_weekday == 0 && $timezone->std_startday == 0 && $timezone->std_weekday == 0) {
@@ -1662,7 +2142,16 @@ function dst_changes_for_year($year, $timezone) {
     return array('dst' => $timedst, 0 => $timedst, 'std' => $timestd, 1 => $timestd);
 }
 
-// $time must NOT be compensated at all, it has to be a pure timestamp
+/**
+ * Calculates the Daylight Saving Offset for a given date/time (timestamp)
+ * - Note: Daylight saving only works for string timezones and not for float.
+ *
+ * @global object
+ * @param int $time must NOT be compensated at all, it has to be a pure timestamp
+ * @param mixed $strtimezone timezone for which offset is expected, if 99 or null
+ *        then user's default timezone is used.
+ * @return int
+ */
 function dst_offset_on($time, $strtimezone = NULL) {
     global $SESSION;
 
@@ -1704,6 +2193,16 @@ function dst_offset_on($time, $strtimezone = NULL) {
     }
 }
 
+/**
+ * ?
+ *
+ * @todo Document what this function does
+ * @param int $startday
+ * @param int $weekday
+ * @param int $month
+ * @param int $year
+ * @return int
+ */
 function find_day_in_month($startday, $weekday, $month, $year) {
 
     $daysinmonth = days_in_month($month, $year);
@@ -1727,7 +2226,7 @@ function find_day_in_month($startday, $weekday, $month, $year) {
     if($startday < 1) {
 
         $startday = abs($startday);
-        $lastmonthweekday  = strftime('%w', mktime(12, 0, 0, $month, $daysinmonth, $year, 0));
+        $lastmonthweekday  = strftime('%w', mktime(12, 0, 0, $month, $daysinmonth, $year));
 
         // This is the last such weekday of the month
         $lastinmonth = $daysinmonth + $weekday - $lastmonthweekday;
@@ -1745,7 +2244,7 @@ function find_day_in_month($startday, $weekday, $month, $year) {
     }
     else {
 
-        $indexweekday = strftime('%w', mktime(12, 0, 0, $month, $startday, $year, 0));
+        $indexweekday = strftime('%w', mktime(12, 0, 0, $month, $startday, $year));
 
         $diff = $weekday - $indexweekday;
         if($diff < 0) {
@@ -1768,7 +2267,7 @@ function find_day_in_month($startday, $weekday, $month, $year) {
  * @return int
  */
 function days_in_month($month, $year) {
-   return intval(date('t', mktime(12, 0, 0, $month, 1, $year, 0)));
+   return intval(date('t', mktime(12, 0, 0, $month, 1, $year)));
 }
 
 /**
@@ -1782,176 +2281,137 @@ function days_in_month($month, $year) {
 function dayofweek($day, $month, $year) {
     // I wonder if this is any different from
     // strftime('%w', mktime(12, 0, 0, $month, $daysinmonth, $year, 0));
-    return intval(date('w', mktime(12, 0, 0, $month, $day, $year, 0)));
+    return intval(date('w', mktime(12, 0, 0, $month, $day, $year)));
 }
 
 /// USER AUTHENTICATION AND LOGIN ////////////////////////////////////////
 
 /**
- * Makes sure that $USER->sesskey exists, if $USER itself exists. It sets a new sesskey
- * if one does not already exist, but does not overwrite existing sesskeys. Returns the
- * sesskey string if $USER exists, or boolean false if not.
+ * Returns full login url.
  *
- * @uses $USER
- * @return string
+ * @return string login url
  */
-function sesskey() {
-    global $USER;
+function get_login_url() {
+    global $CFG;
 
-    if(!isset($USER)) {
-        return false;
-    }
+    $url = "$CFG->wwwroot/login/index.php";
 
-    if (empty($USER->sesskey)) {
-        $USER->sesskey = random_string(10);
+    if (!empty($CFG->loginhttps)) {
+        $url = str_replace('http:', 'https:', $url);
     }
 
-    return $USER->sesskey;
+    return $url;
 }
 
-
 /**
- * For security purposes, this function will check that the currently
- * given sesskey (passed as a parameter to the script or this function)
- * matches that of the current user.
+ * This function checks that the current user is logged in and has the
+ * required privileges
  *
- * @param string $sesskey optionally provided sesskey
- * @return bool
+ * This function checks that the current user is logged in, and optionally
+ * whether they are allowed to be in a particular course and view a particular
+ * course module.
+ * If they are not logged in, then it redirects them to the site login unless
+ * $autologinguest is set and {@link $CFG}->autologinguests is set to 1 in which
+ * case they are automatically logged in as guests.
+ * If $courseid is given and the user is not enrolled in that course then the
+ * user is redirected to the course enrolment page.
+ * If $cm is given and the course module is hidden and the user is not a teacher
+ * in the course then the user is redirected to the course home page.
+ *
+ * When $cm parameter specified, this function sets page layout to 'module'.
+ * You need to change it manually later if some other layout needed.
+ *
+ * @param mixed $courseorid id of the course or course object
+ * @param bool $autologinguest default true
+ * @param object $cm course module object
+ * @param bool $setwantsurltome Define if we want to set $SESSION->wantsurl, defaults to
+ *             true. Used to avoid (=false) some scripts (file.php...) to set that variable,
+ *             in order to keep redirects working properly. MDL-14495
+ * @param bool $preventredirect set to true in scripts that can not redirect (CLI, rss feeds, etc.), throws exceptions
+ * @return mixed Void, exit, and die depending on path
  */
-function confirm_sesskey($sesskey=NULL) {
-    global $USER;
+function require_login($courseorid = NULL, $autologinguest = true, $cm = NULL, $setwantsurltome = true, $preventredirect = false) {
+    global $CFG, $SESSION, $USER, $FULLME, $PAGE, $SITE, $DB, $OUTPUT;
 
-    if (!empty($USER->ignoresesskey) || !empty($CFG->ignoresesskey)) {
-        return true;
+    // setup global $COURSE, themes, language and locale
+    if (!empty($courseorid)) {
+        if (is_object($courseorid)) {
+            $course = $courseorid;
+        } else if ($courseorid == SITEID) {
+            $course = clone($SITE);
+        } else {
+            $course = $DB->get_record('course', array('id' => $courseorid), '*', MUST_EXIST);
     }
-
-    if (empty($sesskey)) {
-        $sesskey = required_param('sesskey', PARAM_RAW);  // Check script parameters
+        if ($cm) {
+            if ($cm->course != $course->id) {
+                throw new coding_exception('course and cm parameters in require_login() call do not match!!');
     }
-
-    if (!isset($USER->sesskey)) {
-        return false;
-    }
-
-    return ($USER->sesskey === $sesskey);
-}
-
-/**
- * Check the session key using {@link confirm_sesskey()},
- * and cause a fatal error if it does not match.
- */
-function require_sesskey() {
-    if (!confirm_sesskey()) {
-        print_error('invalidsesskey');
+            // make sure we have a $cm from get_fast_modinfo as this contains activity access details
+            if (!($cm instanceof cm_info)) {
+                // note: nearly all pages call get_fast_modinfo anyway and it does not make any
+                // db queries so this is not really a performance concern, however it is obviously
+                // better if you use get_fast_modinfo to get the cm before calling this.
+                $modinfo = get_fast_modinfo($course);
+                $cm = $modinfo->get_cm($cm->id);
     }
-}
-
-/**
- * Setup all global $CFG course variables, set locale and also themes
- * This function can be used on pages that do not require login instead of require_login()
- *
- * @param mixed $courseorid id of the course or course object
- */
-function course_setup($courseorid=0) {
-    global $COURSE, $CFG, $SITE;
-
-/// Redefine global $COURSE if needed
-    if (empty($courseorid)) {
-        // no change in global $COURSE - for backwards compatibiltiy
-        // if require_rogin() used after require_login($courseid);
-    } else if (is_object($courseorid)) {
-        $COURSE = clone($courseorid);
+            $PAGE->set_cm($cm, $course); // set's up global $COURSE
+            $PAGE->set_pagelayout('incourse');
     } else {
-        global $course; // used here only to prevent repeated fetching from DB - may be removed later
-        if ($courseorid == SITEID) {
-            $COURSE = clone($SITE);
-        } else if (!empty($course->id) and $course->id == $courseorid) {
-            $COURSE = clone($course);
-        } else {
-            if (!$COURSE = get_record('course', 'id', $courseorid)) {
-                error('Invalid course ID');
+            $PAGE->set_course($course); // set's up global $COURSE
             }
+    } else {
+        // do not touch global $COURSE via $PAGE->set_course(),
+        // the reasons is we need to be able to call require_login() at any time!!
+        $course = $SITE;
+        if ($cm) {
+            throw new coding_exception('cm parameter in require_login() requires valid course parameter!');
         }
     }
 
-/// set locale and themes
-    moodle_setlocale();
-    theme_setup();
-
-}
-
-/**
- * This function checks that the current user is logged in and has the
- * required privileges
- *
- * This function checks that the current user is logged in, and optionally
- * whether they are allowed to be in a particular course and view a particular
- * course module.
- * If they are not logged in, then it redirects them to the site login unless
- * $autologinguest is set and {@link $CFG}->autologinguests is set to 1 in which
- * case they are automatically logged in as guests.
- * If $courseid is given and the user is not enrolled in that course then the
- * user is redirected to the course enrolment page.
- * If $cm is given and the coursemodule is hidden and the user is not a teacher
- * in the course then the user is redirected to the course home page.
- *
- * @uses $CFG
- * @uses $SESSION
- * @uses $USER
- * @uses $FULLME
- * @uses SITEID
- * @uses $COURSE
- * @param mixed $courseorid id of the course or course object
- * @param bool $autologinguest
- * @param object $cm course module object
- * @param bool $setwantsurltome Define if we want to set $SESSION->wantsurl, defaults to
- *             true. Used to avoid (=false) some scripts (file.php...) to set that variable,
- *             in order to keep redirects working properly. MDL-14495
- */
-function require_login($courseorid=0, $autologinguest=true, $cm=null, $setwantsurltome=true) {
-
-    global $CFG, $SESSION, $USER, $COURSE, $FULLME;
-
-/// setup global $COURSE, themes, language and locale
-    course_setup($courseorid);
-
-/// If the user is not even logged in yet then make sure they are
+    // If the user is not even logged in yet then make sure they are
     if (!isloggedin()) {
+        if ($autologinguest and !empty($CFG->guestloginbutton) and !empty($CFG->autologinguests)) {
+            if (!$guest = get_complete_user_data('id', $CFG->siteguest)) {
+                // misconfigured site guest, just redirect to login page
+                redirect(get_login_url());
+                exit; // never reached
+            }
+            $lang = isset($SESSION->lang) ? $SESSION->lang : $CFG->lang;
+            complete_user_login($guest, false);
+            $USER->autologinguest = true;
+            $SESSION->lang = $lang;
+        } else {
         //NOTE: $USER->site check was obsoleted by session test cookie,
         //      $USER->confirmed test is in login/index.php
+            if ($preventredirect) {
+                throw new require_login_exception('You are not logged in');
+            }
+
         if ($setwantsurltome) {
+                // TODO: switch to PAGE->url
             $SESSION->wantsurl = $FULLME;
         }
         if (!empty($_SERVER['HTTP_REFERER'])) {
             $SESSION->fromurl  = $_SERVER['HTTP_REFERER'];
         }
-        if ($autologinguest and !empty($CFG->guestloginbutton) and !empty($CFG->autologinguests) and ($COURSE->id == SITEID or $COURSE->guest) ) {
-            $loginguest = '?loginguest=true';
-        } else {
-            $loginguest = '';
-        }
-        if (empty($CFG->loginhttps) or $loginguest) { //do not require https for guest logins
-            redirect($CFG->wwwroot .'/login/index.php'. $loginguest);
-        } else {
-            $wwwroot = str_replace('http:','https:', $CFG->wwwroot);
-            redirect($wwwroot .'/login/index.php');
+            redirect(get_login_url());
+            exit; // never reached
         }
-        exit;
     }
 
-/// loginas as redirection if needed
-    if ($COURSE->id != SITEID and !empty($USER->realuser)) {
+    // loginas as redirection if needed
+    if ($course->id != SITEID and session_is_loggedinas()) {
         if ($USER->loginascontext->contextlevel == CONTEXT_COURSE) {
-            if ($USER->loginascontext->instanceid != $COURSE->id) {
+            if ($USER->loginascontext->instanceid != $course->id) {
                 print_error('loginasonecourse', '', $CFG->wwwroot.'/course/view.php?id='.$USER->loginascontext->instanceid);
             }
         }
     }
 
-/// check whether the user should be changing password (but only if it is REALLY them)
-    if (get_user_preferences('auth_forcepasswordchange') && empty($USER->realuser)) {
+    // check whether the user should be changing password (but only if it is REALLY them)
+    if (get_user_preferences('auth_forcepasswordchange') && !session_is_loggedinas()) {
         $userauth = get_auth_plugin($USER->auth);
-        if ($userauth->can_change_password()) {
+        if ($userauth->can_change_password() and !$preventredirect) {
             $SESSION->wantsurl = $FULLME;
             if ($changeurl = $userauth->change_password_url()) {
                 //use plugin custom url
@@ -1970,184 +2430,224 @@ function require_login($courseorid=0, $autologinguest=true, $cm=null, $setwantsu
         }
     }
 
-/// Check that the user account is properly set up
+    // Check that the user account is properly set up
     if (user_not_fully_set_up($USER)) {
+        if ($preventredirect) {
+            throw new require_login_exception('User not fully set-up');
+        }
         $SESSION->wantsurl = $FULLME;
         redirect($CFG->wwwroot .'/user/edit.php?id='. $USER->id .'&amp;course='. SITEID);
     }
 
-/// Make sure current IP matches the one for this session (if required)
-    if (!empty($CFG->tracksessionip)) {
-        if ($USER->sessionIP != md5(getremoteaddr())) {
-            print_error('sessionipnomatch', 'error');
-        }
-    }
-
-/// Make sure the USER has a sesskey set up.  Used for checking script parameters.
+    // Make sure the USER has a sesskey set up. Used for CSRF protection.
     sesskey();
 
-    // Check that the user has agreed to a site policy if there is one
-    if (!empty($CFG->sitepolicy)) {
-        if (!$USER->policyagreed) {
+    // Do not bother admins with any formalities
+    if (is_siteadmin()) {
+        //set accesstime or the user will appear offline which messes up messaging
+        user_accesstime_log($course->id);
+        return;
+    }
+
+    // Check that the user has agreed to a site policy if there is one - do not test in case of admins
+    if (!$USER->policyagreed and !is_siteadmin()) {
+        if (!empty($CFG->sitepolicy) and !isguestuser()) {
+            if ($preventredirect) {
+                throw new require_login_exception('Policy not agreed');
+            }
+            $SESSION->wantsurl = $FULLME;
+            redirect($CFG->wwwroot .'/user/policy.php');
+        } else if (!empty($CFG->sitepolicyguest) and isguestuser()) {
+            if ($preventredirect) {
+                throw new require_login_exception('Policy not agreed');
+            }
             $SESSION->wantsurl = $FULLME;
             redirect($CFG->wwwroot .'/user/policy.php');
         }
     }
 
-    // Fetch the system context, we are going to use it a lot.
+    // Fetch the system context, the course context, and prefetch its child contexts
     $sysctx = get_context_instance(CONTEXT_SYSTEM);
-
-/// If the site is currently under maintenance, then print a message
-    if (!has_capability('moodle/site:config', $sysctx)) {
-        if (file_exists($CFG->dataroot.'/'.SITEID.'/maintenance.html')) {
-            print_maintenance_message();
-            exit;
-        }
+    $coursecontext = get_context_instance(CONTEXT_COURSE, $course->id, MUST_EXIST);
+    if ($cm) {
+        $cmcontext = get_context_instance(CONTEXT_MODULE, $cm->id, MUST_EXIST);
+    } else {
+        $cmcontext = null;
     }
 
-/// groupmembersonly access control
-    if (!empty($CFG->enablegroupings) and $cm and $cm->groupmembersonly and !has_capability('moodle/site:accessallgroups', get_context_instance(CONTEXT_MODULE, $cm->id))) {
-        if (isguestuser() or !groups_has_membership($cm)) {
-            print_error('groupmembersonlyerror', 'group', $CFG->wwwroot.'/course/view.php?id='.$cm->course);
-        }
+    // If the site is currently under maintenance, then print a message
+    if (!empty($CFG->maintenance_enabled) and !has_capability('moodle/site:config', $sysctx)) {
+        if ($preventredirect) {
+            throw new require_login_exception('Maintenance in progress');
     }
 
-    // Fetch the course context, and prefetch its child contexts
-    if (!isset($COURSE->context)) {
-        if ( ! $COURSE->context = get_context_instance(CONTEXT_COURSE, $COURSE->id) ) {
-            print_error('nocontext');
-        }
-    }
-    if (!empty($cm) && !isset($cm->context)) {
-        if ( ! $cm->context = get_context_instance(CONTEXT_MODULE, $cm->id) ) {
-            print_error('nocontext');
-        }
-    }
-    if ($COURSE->id == SITEID) {
-        /// Eliminate hidden site activities straight away
-        if (!empty($cm) && !$cm->visible
-            && !has_capability('moodle/course:viewhiddenactivities', $cm->context)) {
-            redirect($CFG->wwwroot, get_string('activityiscurrentlyhidden'));
+        print_maintenance_message();
         }
-        user_accesstime_log($COURSE->id); /// Access granted, update lastaccess times
-        return;
 
+    // make sure the course itself is not hidden
+    if ($course->id == SITEID) {
+        // frontpage can not be hidden
     } else {
-
-        /// Check if the user can be in a particular course
-        if (empty($USER->access['rsw'][$COURSE->context->path])) {
-            //
-            // MDL-13900 - If the course or the parent category are hidden
-            // and the user hasn't the 'course:viewhiddencourses' capability, prevent access
-            //
-            if ( !($COURSE->visible && course_parent_visible($COURSE)) &&
-                   !has_capability('moodle/course:viewhiddencourses', $COURSE->context)) {
-                print_header_simple();
+        if (is_role_switched($course->id)) {
+            // when switching roles ignore the hidden flag - user had to be in course to do the switch
+        } else {
+            if (!$course->visible and !has_capability('moodle/course:viewhiddencourses', $coursecontext)) {
+                // originally there was also test of parent category visibility,
+                // BUT is was very slow in complex queries involving "my courses"
+                // now it is also possible to simply hide all courses user is not enrolled in :-)
+                if ($preventredirect) {
+                    throw new require_login_exception('Course is hidden');
+                }
                 notice(get_string('coursehidden'), $CFG->wwwroot .'/');
             }
         }
+    }
 
-    /// Non-guests who don't currently have access, check if they can be allowed in as a guest
+    // is the user enrolled?
+    if ($course->id == SITEID) {
+        // everybody is enrolled on the frontpage
 
-        if ($USER->username != 'guest' and !has_capability('moodle/course:view', $COURSE->context)) {
-            if ($COURSE->guest == 1) {
-                 // Temporarily assign them guest role for this context, if it fails later user is asked to enrol
-                 $USER->access = load_temp_role($COURSE->context, $CFG->guestroleid, $USER->access);
+    } else {
+        if (session_is_loggedinas()) {
+            // Make sure the REAL person can access this course first
+            $realuser = session_get_realuser();
+            if (!is_enrolled($coursecontext, $realuser->id, '', true) and !is_viewing($coursecontext, $realuser->id) and !is_siteadmin($realuser->id)) {
+                if ($preventredirect) {
+                    throw new require_login_exception('Invalid course login-as access');
+                }
+                echo $OUTPUT->header();
+                notice(get_string('studentnotallowed', '', fullname($USER, true)), $CFG->wwwroot .'/');
             }
         }
 
-    /// If the user is a guest then treat them according to the course policy about guests
-
-        if (has_capability('moodle/legacy:guest', $COURSE->context, NULL, false)) {
-            if (has_capability('moodle/site:doanything', $sysctx)) {
-                // administrators must be able to access any course - even if somebody gives them guest access
-                user_accesstime_log($COURSE->id); /// Access granted, update lastaccess times
-                return;
+        // very simple enrolment caching - changes in course setting are not reflected immediately
+        if (!isset($USER->enrol)) {
+            $USER->enrol = array();
+            $USER->enrol['enrolled'] = array();
+            $USER->enrol['tempguest'] = array();
             }
 
-            switch ($COURSE->guest) {    /// Check course policy about guest access
+        $access = false;
+
+        if (is_viewing($coursecontext, $USER)) {
+            // ok, no need to mess with enrol
+            $access = true;
 
-                case 1:    /// Guests always allowed
-                    if (!has_capability('moodle/course:view', $COURSE->context)) {    // Prohibited by capability
-                        print_header_simple();
-                        notice(get_string('guestsnotallowed', '', format_string($COURSE->fullname)), "$CFG->wwwroot/login/index.php");
+        } else {
+            if (isset($USER->enrol['enrolled'][$course->id])) {
+                if ($USER->enrol['enrolled'][$course->id] == 0) {
+                    $access = true;
+                } else if ($USER->enrol['enrolled'][$course->id] > time()) {
+                    $access = true;
+                } else {
+                    //expired
+                    unset($USER->enrol['enrolled'][$course->id]);
+                }
+            }
+            if (isset($USER->enrol['tempguest'][$course->id])) {
+                if ($USER->enrol['tempguest'][$course->id] == 0) {
+                    $access = true;
+                } else if ($USER->enrol['tempguest'][$course->id] > time()) {
+                    $access = true;
+                } else {
+                    //expired
+                    unset($USER->enrol['tempguest'][$course->id]);
+                    $USER->access = remove_temp_roles($coursecontext, $USER->access);
                     }
-                    if (!empty($cm) and !$cm->visible) { // Not allowed to see module, send to course page
-                        redirect($CFG->wwwroot.'/course/view.php?id='.$cm->course,
-                                 get_string('activityiscurrentlyhidden'));
                     }
 
-                    user_accesstime_log($COURSE->id); /// Access granted, update lastaccess times
-                    return;   // User is allowed to see this course
+            if ($access) {
+                // cache ok
+            } else if (is_enrolled($coursecontext, $USER, '', true)) {
+                // active participants may always access
+                // TODO: refactor this into some new function
+                $now = time();
+                $sql = "SELECT MAX(ue.timeend)
+                          FROM {user_enrolments} ue
+                          JOIN {enrol} e ON (e.id = ue.enrolid AND e.courseid = :courseid)
+                          JOIN {user} u ON u.id = ue.userid
+                         WHERE ue.userid = :userid AND ue.status = :active AND e.status = :enabled AND u.deleted = 0
+                               AND ue.timestart < :now1 AND (ue.timeend = 0 OR ue.timeend > :now2)";
+                $params = array('enabled'=>ENROL_INSTANCE_ENABLED, 'active'=>ENROL_USER_ACTIVE,
+                                'userid'=>$USER->id, 'courseid'=>$coursecontext->instanceid, 'now1'=>$now, 'now2'=>$now);
+                $until = $DB->get_field_sql($sql, $params);
+                if (!$until or $until > time() + ENROL_REQUIRE_LOGIN_CACHE_PERIOD) {
+                    $until = time() + ENROL_REQUIRE_LOGIN_CACHE_PERIOD;
+                }
 
-                    break;
+                $USER->enrol['enrolled'][$course->id] = $until;
+                $access = true;
 
-                case 2:    /// Guests allowed with key
-                    if (!empty($USER->enrolkey[$COURSE->id])) {   // Set by enrol/manual/enrol.php
-                        user_accesstime_log($COURSE->id); /// Access granted, update lastaccess times
-                        return true;
+                // remove traces of previous temp guest access
+                $USER->access = remove_temp_roles($coursecontext, $USER->access);
+
+            } else {
+                $instances = $DB->get_records('enrol', array('courseid'=>$course->id, 'status'=>ENROL_INSTANCE_ENABLED), 'sortorder, id ASC');
+                $enrols = enrol_get_plugins(true);
+                // first ask all enabled enrol instances in course if they want to auto enrol user
+                foreach($instances as $instance) {
+                    if (!isset($enrols[$instance->enrol])) {
+                        continue;
                     }
-                    //  otherwise drop through to logic below (--> enrol.php)
+                    // Get a duration for the guestaccess, a timestamp in the future or false.
+                    $until = $enrols[$instance->enrol]->try_autoenrol($instance);
+                    if ($until !== false) {
+                        $USER->enrol['enrolled'][$course->id] = $until;
+                        $USER->access = remove_temp_roles($coursecontext, $USER->access);
+                        $access = true;
                     break;
-
-                default:    /// Guests not allowed
-                    $strloggedinasguest = get_string('loggedinasguest');
-                    print_header_simple('', '',
-                            build_navigation(array(array('name' => $strloggedinasguest, 'link' => null, 'type' => 'misc'))));
-                    if (empty($USER->access['rsw'][$COURSE->context->path])) {  // Normal guest
-                            $loginurl = "$CFG->wwwroot/login/index.php";
-                            if (!empty($CFG->loginhttps)) {
-                                $loginurl = str_replace('http:','https:', $loginurl);
                             }
-                        notice(get_string('guestsnotallowed', '', format_string($COURSE->fullname)), $loginurl);
-                    } else {
-                        notify(get_string('guestsnotallowed', '', format_string($COURSE->fullname)));
-                        echo '<div class="notifyproblem">'.switchroles_form($COURSE->id).'</div>';
-                        print_footer($COURSE);
-                        exit;
                     }
+                // if not enrolled yet try to gain temporary guest access
+                if (!$access) {
+                    foreach($instances as $instance) {
+                        if (!isset($enrols[$instance->enrol])) {
+                            continue;
+                        }
+                        // Get a duration for the guestaccess, a timestamp in the future or false.
+                        $until = $enrols[$instance->enrol]->try_guestaccess($instance);
+                        if ($until !== false) {
+                            $USER->enrol['tempguest'][$course->id] = $until;
+                            $access = true;
                     break;
             }
-
-    /// For non-guests, check if they have course view access
-
-        } else if (has_capability('moodle/course:view', $COURSE->context)) {
-            if (!empty($USER->realuser)) {   // Make sure the REAL person can also access this course
-                if (!has_capability('moodle/course:view', $COURSE->context, $USER->realuser)) {
-                    print_header_simple();
-                    notice(get_string('studentnotallowed', '', fullname($USER, true)), $CFG->wwwroot .'/');
                 }
             }
-
-        /// Make sure they can read this activity too, if specified
-
-            if (!empty($cm) && !$cm->visible && !has_capability('moodle/course:viewhiddenactivities', $cm->context)) {
-                redirect($CFG->wwwroot.'/course/view.php?id='.$cm->course, get_string('activityiscurrentlyhidden'));
             }
-            user_accesstime_log($COURSE->id); /// Access granted, update lastaccess times
-            return;   // User is allowed to see this course
-
         }
 
-
-    /// Currently not enrolled in the course, so see if they want to enrol
+        if (!$access) {
+            if ($preventredirect) {
+                throw new require_login_exception('Not enrolled');
+            }
         $SESSION->wantsurl = $FULLME;
-        redirect($CFG->wwwroot .'/course/enrol.php?id='. $COURSE->id);
-        die;
+            redirect($CFG->wwwroot .'/enrol/index.php?id='. $course->id);
+        }
+    }
+
+    // Check visibility of activity to current user; includes visible flag, groupmembersonly,
+    // conditional availability, etc
+    if ($cm && !$cm->uservisible) {
+        if ($preventredirect) {
+            throw new require_login_exception('Activity is hidden');
+        }
+        redirect($CFG->wwwroot, get_string('activityiscurrentlyhidden'));
     }
-}
 
+    // Finally access granted, update lastaccess times
+    user_accesstime_log($course->id);
+}
 
 
 /**
  * This function just makes sure a user is logged out.
  *
- * @uses $CFG
- * @uses $USER
+ * @global object
  */
 function require_logout() {
+    global $USER;
 
-    global $USER, $CFG, $SESSION;
+    $params = $USER;
 
     if (isloggedin()) {
         add_to_log(SITEID, "user", "logout", "view.php?id=$USER->id&course=".SITEID, $USER->id, 0, $USER->id);
@@ -2159,86 +2659,113 @@ function require_logout() {
         }
     }
 
-    if (ini_get_bool("register_globals") and check_php_version("4.3.0")) {
-        // This method is just to try to avoid silly warnings from PHP 4.3.0
-        session_unregister("USER");
-        session_unregister("SESSION");
-    }
-
-    // Initialize variable to pass-by-reference to headers_sent(&$file, &$line)
-    $file = $line = null;
-    if (headers_sent($file, $line)) {
-        error_log('MoodleSessionTest cookie could not be set in moodlelib.php:'.__LINE__);
-        error_log('Headers were already sent in file: '.$file.' on line '.$line);
-    } else {
-        if (check_php_version('5.2.0')) {
-            setcookie('MoodleSessionTest'.$CFG->sessioncookie, '', time() - 3600, $CFG->sessioncookiepath, $CFG->sessioncookiedomain, $CFG->cookiesecure, $CFG->cookiehttponly);
-        } else {
-            setcookie('MoodleSessionTest'.$CFG->sessioncookie, '', time() - 3600, $CFG->sessioncookiepath, $CFG->sessioncookiedomain, $CFG->cookiesecure);
-        }
-    }
-
-    unset($_SESSION['USER']);
-    unset($_SESSION['SESSION']);
-
-    unset($SESSION);
-    unset($USER);
-
+    events_trigger('user_logout', $params);
+    session_get_instance()->terminate_current();
+    unset($params);
 }
 
 /**
+ * Weaker version of require_login()
+ *
  * This is a weaker version of {@link require_login()} which only requires login
  * when called from within a course rather than the site page, unless
  * the forcelogin option is turned on.
+ * @see require_login()
  *
- * @uses $CFG
+ * @global object
  * @param mixed $courseorid The course object or id in question
  * @param bool $autologinguest Allow autologin guests if that is wanted
  * @param object $cm Course activity module if known
  * @param bool $setwantsurltome Define if we want to set $SESSION->wantsurl, defaults to
  *             true. Used to avoid (=false) some scripts (file.php...) to set that variable,
  *             in order to keep redirects working properly. MDL-14495
+ * @param bool $preventredirect set to true in scripts that can not redirect (CLI, rss feeds, etc.), throws exceptions
+ * @return void
  */
-function require_course_login($courseorid, $autologinguest=true, $cm=null, $setwantsurltome=true) {
-    global $CFG;
+function require_course_login($courseorid, $autologinguest = true, $cm = NULL, $setwantsurltome = true, $preventredirect = false) {
+    global $CFG, $PAGE, $SITE;
+    $issite = (is_object($courseorid) and $courseorid->id == SITEID)
+          or (!is_object($courseorid) and $courseorid == SITEID);
+    if ($issite && !empty($cm) && !($cm instanceof cm_info)) {
+        // note: nearly all pages call get_fast_modinfo anyway and it does not make any
+        // db queries so this is not really a performance concern, however it is obviously
+        // better if you use get_fast_modinfo to get the cm before calling this.
+        if (is_object($courseorid)) {
+            $course = $courseorid;
+        } else {
+            $course = clone($SITE);
+        }
+        $modinfo = get_fast_modinfo($course);
+        $cm = $modinfo->get_cm($cm->id);
+    }
     if (!empty($CFG->forcelogin)) {
         // login required for both SITE and courses
-        require_login($courseorid, $autologinguest, $cm, $setwantsurltome);
+        require_login($courseorid, $autologinguest, $cm, $setwantsurltome, $preventredirect);
 
-    } else if (!empty($cm) and !$cm->visible) {
+    } else if ($issite && !empty($cm) and !$cm->uservisible) {
         // always login for hidden activities
-        require_login($courseorid, $autologinguest, $cm, $setwantsurltome);
+        require_login($courseorid, $autologinguest, $cm, $setwantsurltome, $preventredirect);
 
-    } else if ((is_object($courseorid) and $courseorid->id == SITEID)
-          or (!is_object($courseorid) and $courseorid == SITEID)) {
+    } else if ($issite) {
               //login for SITE not required
         if ($cm and empty($cm->visible)) {
             // hidden activities are not accessible without login
-            require_login($courseorid, $autologinguest, $cm, $setwantsurltome);
-        } else if ($cm and !empty($CFG->enablegroupings) and $cm->groupmembersonly) {
+            require_login($courseorid, $autologinguest, $cm, $setwantsurltome, $preventredirect);
+        } else if ($cm and !empty($CFG->enablegroupmembersonly) and $cm->groupmembersonly) {
             // not-logged-in users do not have any group membership
-            require_login($courseorid, $autologinguest, $cm, $setwantsurltome);
+            require_login($courseorid, $autologinguest, $cm, $setwantsurltome, $preventredirect);
+        } else {
+            // We still need to instatiate PAGE vars properly so that things
+            // that rely on it like navigation function correctly.
+            if (!empty($courseorid)) {
+                if (is_object($courseorid)) {
+                    $course = $courseorid;
+                } else {
+                    $course = clone($SITE);
+                }
+                if ($cm) {
+                    if ($cm->course != $course->id) {
+                        throw new coding_exception('course and cm parameters in require_course_login() call do not match!!');
+                    }
+                    $PAGE->set_cm($cm, $course);
+                    $PAGE->set_pagelayout('incourse');
+                } else {
+                    $PAGE->set_course($course);
+                }
         } else {
+                // If $PAGE->course, and hence $PAGE->context, have not already been set
+                // up properly, set them up now.
+                $PAGE->set_course($PAGE->course);
+            }
+            //TODO: verify conditional activities here
             user_accesstime_log(SITEID);
             return;
         }
 
     } else {
         // course login always required
-        require_login($courseorid, $autologinguest, $cm, $setwantsurltome);
+        require_login($courseorid, $autologinguest, $cm, $setwantsurltome, $preventredirect);
     }
 }
 
 /**
  * Require key login. Function terminates with error if key not found or incorrect.
+ *
+ * @global object
+ * @global object
+ * @global object
+ * @global object
+ * @uses NO_MOODLE_COOKIES
+ * @uses PARAM_ALPHANUM
  * @param string $script unique script identifier
  * @param int $instance optional instance id
+ * @return int Instance ID
  */
 function require_user_key_login($script, $instance=null) {
-    global $nomoodlecookie, $USER, $SESSION, $CFG;
+    global $USER, $SESSION, $CFG, $DB;
 
-    if (empty($nomoodlecookie)) {
-        error('Incorrect use of require_key_login() - session cookies must be disabled!');
+    if (!NO_MOODLE_COOKIES) {
+        print_error('sessioncookiesdisable');
     }
 
 /// extra safety
@@ -2246,51 +2773,52 @@ function require_user_key_login($script, $instance=null) {
 
     $keyvalue = required_param('key', PARAM_ALPHANUM);
 
-    if (!$key = get_record('user_private_key', 'script', $script, 'value', $keyvalue, 'instance', $instance)) {
-        error('Incorrect key');
+    if (!$key = $DB->get_record('user_private_key', array('script'=>$script, 'value'=>$keyvalue, 'instance'=>$instance))) {
+        print_error('invalidkey');
     }
 
     if (!empty($key->validuntil) and $key->validuntil < time()) {
-        error('Expired key');
+        print_error('expiredkey');
     }
 
     if ($key->iprestriction) {
-        $remoteaddr = getremoteaddr();
-        if ($remoteaddr == '' or !address_in_subnet($remoteaddr, $key->iprestriction)) {
-            error('Client IP address mismatch');
+        $remoteaddr = getremoteaddr(null);
+        if (empty($remoteaddr) or !address_in_subnet($remoteaddr, $key->iprestriction)) {
+            print_error('ipmismatch');
         }
     }
 
-    if (!$user = get_record('user', 'id', $key->userid)) {
-        error('Incorrect user record');
+    if (!$user = $DB->get_record('user', array('id'=>$key->userid))) {
+        print_error('invaliduserid');
     }
 
 /// emulate normal session
-    $SESSION = new object();
-    $USER    = $user;
+    session_set_user($user);
 
 /// note we are not using normal login
     if (!defined('USER_KEY_LOGIN')) {
         define('USER_KEY_LOGIN', true);
     }
 
-    load_all_capabilities();
-
-/// return isntance id - it might be empty
+/// return instance id - it might be empty
     return $key->instance;
 }
 
 /**
  * Creates a new private user access key.
+ *
+ * @global object
  * @param string $script unique target identifier
  * @param int $userid
- * @param instance $int optional instance id
+ * @param int $instance optional instance id
  * @param string $iprestriction optional ip restricted access
  * @param timestamp $validuntil key valid only until given data
  * @return string access key value
  */
 function create_user_key($script, $userid, $instance=null, $iprestriction=null, $validuntil=null) {
-    $key = new object();
+    global $DB;
+
+    $key = new stdClass();
     $key->script        = $script;
     $key->userid        = $userid;
     $key->instance      = $instance;
@@ -2299,50 +2827,95 @@ function create_user_key($script, $userid, $instance=null, $iprestriction=null,
     $key->timecreated   = time();
 
     $key->value         = md5($userid.'_'.time().random_string(40)); // something long and unique
-    while (record_exists('user_private_key', 'value', $key->value)) {
+    while ($DB->record_exists('user_private_key', array('value'=>$key->value))) {
         // must be unique
         $key->value     = md5($userid.'_'.time().random_string(40));
     }
+    $DB->insert_record('user_private_key', $key);
+    return $key->value;
+}
 
-    if (!insert_record('user_private_key', $key)) {
-        error('Can not insert new key');
-    }
+/**
+ * Delete the user's new private user access keys for a particular script.
+ *
+ * @global object
+ * @param string $script unique target identifier
+ * @param int $userid
+ * @return void
+ */
+function delete_user_key($script,$userid) {
+    global $DB;
+    $DB->delete_records('user_private_key', array('script'=>$script, 'userid'=>$userid));
+}
+
+/**
+ * Gets a private user access key (and creates one if one doesn't exist).
+ *
+ * @global object
+ * @param string $script unique target identifier
+ * @param int $userid
+ * @param int $instance optional instance id
+ * @param string $iprestriction optional ip restricted access
+ * @param timestamp $validuntil key valid only until given data
+ * @return string access key value
+ */
+function get_user_key($script, $userid, $instance=null, $iprestriction=null, $validuntil=null) {
+    global $DB;
 
+    if ($key = $DB->get_record('user_private_key', array('script'=>$script, 'userid'=>$userid,
+                                                         'instance'=>$instance, 'iprestriction'=>$iprestriction,
+                                                         'validuntil'=>$validuntil))) {
     return $key->value;
+    } else {
+        return create_user_key($script, $userid, $instance, $iprestriction, $validuntil);
+    }
 }
 
+
 /**
  * Modify the user table by setting the currently logged in user's
  * last login to now.
  *
- * @uses $USER
- * @return bool
+ * @global object
+ * @global object
+ * @return bool Always returns true
  */
 function update_user_login_times() {
-    global $USER;
+    global $USER, $DB;
 
-    $user = new object();
+    $user = new stdClass();
     $USER->lastlogin = $user->lastlogin = $USER->currentlogin;
     $USER->currentlogin = $user->lastaccess = $user->currentlogin = time();
 
     $user->id = $USER->id;
 
-    return update_record('user', $user);
+    $DB->update_record('user', $user);
+    return true;
 }
 
 /**
  * Determines if a user has completed setting up their account.
  *
- * @param user $user A {@link $USER} object to test for the existance of a valid name and email
+ * @param user $user A {@link $USER} object to test for the existence of a valid name and email
  * @return bool
  */
 function user_not_fully_set_up($user) {
-    return ($user->username != 'guest' and (empty($user->firstname) or empty($user->lastname) or empty($user->email) or over_bounce_threshold($user)));
+    if (isguestuser($user)) {
+        return false;
+    }
+    return (empty($user->firstname) or empty($user->lastname) or empty($user->email) or over_bounce_threshold($user));
 }
 
+/**
+ * Check whether the user has exceeded the bounce threshold
+ *
+ * @global object
+ * @global object
+ * @param user $user A {@link $USER} object
+ * @return bool true=>User has exceeded bounce threshold
+ */
 function over_bounce_threshold($user) {
-
-    global $CFG;
+    global $CFG, $DB;
 
     if (empty($CFG->handlebounces)) {
         return false;
@@ -2361,63 +2934,74 @@ function over_bounce_threshold($user) {
     }
     $bouncecount = 0;
     $sendcount = 0;
-    if ($bounce = get_record('user_preferences','userid',$user->id,'name','email_bounce_count')) {
+    if ($bounce = $DB->get_record('user_preferences', array ('userid'=>$user->id, 'name'=>'email_bounce_count'))) {
         $bouncecount = $bounce->value;
     }
-    if ($send = get_record('user_preferences','userid',$user->id,'name','email_send_count')) {
+    if ($send = $DB->get_record('user_preferences', array('userid'=>$user->id, 'name'=>'email_send_count'))) {
         $sendcount = $send->value;
     }
     return ($bouncecount >= $CFG->minbounces && $bouncecount/$sendcount >= $CFG->bounceratio);
 }
 
 /**
- * @param $user - object containing an id
- * @param $reset - will reset the count to 0
+ * Used to increment or reset email sent count
+ *
+ * @global object
+ * @param user $user object containing an id
+ * @param bool $reset will reset the count to 0
+ * @return void
  */
 function set_send_count($user,$reset=false) {
+    global $DB;
 
     if (empty($user->id)) { /// No real (DB) user, nothing to do here.
         return;
     }
 
-    if ($pref = get_record('user_preferences','userid',$user->id,'name','email_send_count')) {
+    if ($pref = $DB->get_record('user_preferences', array('userid'=>$user->id, 'name'=>'email_send_count'))) {
         $pref->value = (!empty($reset)) ? 0 : $pref->value+1;
-        update_record('user_preferences',$pref);
+        $DB->update_record('user_preferences', $pref);
     }
     else if (!empty($reset)) { // if it's not there and we're resetting, don't bother.
         // make a new one
+        $pref = new stdClass();
         $pref->name = 'email_send_count';
         $pref->value = 1;
         $pref->userid = $user->id;
-        insert_record('user_preferences',$pref, false);
+        $DB->insert_record('user_preferences', $pref, false);
     }
 }
 
 /**
-* @param $user - object containing an id
- * @param $reset - will reset the count to 0
+ * Increment or reset user's email bounce count
+ *
+ * @global object
+ * @param user $user object containing an id
+ * @param bool $reset will reset the count to 0
  */
 function set_bounce_count($user,$reset=false) {
-    if ($pref = get_record('user_preferences','userid',$user->id,'name','email_bounce_count')) {
+    global $DB;
+
+    if ($pref = $DB->get_record('user_preferences', array('userid'=>$user->id, 'name'=>'email_bounce_count'))) {
         $pref->value = (!empty($reset)) ? 0 : $pref->value+1;
-        update_record('user_preferences',$pref);
+        $DB->update_record('user_preferences', $pref);
     }
     else if (!empty($reset)) { // if it's not there and we're resetting, don't bother.
         // make a new one
+        $pref = new stdClass();
         $pref->name = 'email_bounce_count';
         $pref->value = 1;
         $pref->userid = $user->id;
-        insert_record('user_preferences',$pref, false);
+        $DB->insert_record('user_preferences', $pref, false);
     }
 }
 
 /**
  * Keeps track of login attempts
  *
- * @uses $SESSION
+ * @global object
  */
 function update_login_count() {
-
     global $SESSION;
 
     $max_logins = 10;
@@ -2437,7 +3021,7 @@ function update_login_count() {
 /**
  * Resets login attempts
  *
- * @uses $SESSION
+ * @global object
  */
 function reset_login_count() {
     global $SESSION;
@@ -2445,275 +3029,80 @@ function reset_login_count() {
     $SESSION->logincount = 0;
 }
 
-function sync_metacourses() {
-
-    global $CFG;
+/**
+ * Determines if the currently logged in user is in editing mode.
+ * Note: originally this function had $userid parameter - it was not usable anyway
+ *
+ * @deprecated since Moodle 2.0 - use $PAGE->user_is_editing() instead.
+ * @todo Deprecated function remove when ready
+ *
+ * @global object
+ * @uses DEBUG_DEVELOPER
+ * @return bool
+ */
+function isediting() {
+    global $PAGE;
+    debugging('call to deprecated function isediting(). Please use $PAGE->user_is_editing() instead', DEBUG_DEVELOPER);
+    return $PAGE->user_is_editing();
+}
 
-    if (!$courses = get_records('course', 'metacourse', 1)) {
-        return;
-    }
+/**
+ * Determines if the logged in user is currently moving an activity
+ *
+ * @global object
+ * @param int $courseid The id of the course being tested
+ * @return bool
+ */
+function ismoving($courseid) {
+    global $USER;
 
-    foreach ($courses as $course) {
-        sync_metacourse($course);
+    if (!empty($USER->activitycopy)) {
+        return ($USER->activitycopycourse == $courseid);
     }
+    return false;
 }
 
 /**
- * Goes through all enrolment records for the courses inside the metacourse and sync with them.
+ * Returns a persons full name
+ *
+ * Given an object containing firstname and lastname
+ * values, this function returns a string with the
+ * full name of the person.
+ * The result may depend on system settings
+ * or language.  'override' will force both names
+ * to be used even if system settings specify one.
  *
- * @param mixed $course the metacourse to synch. Either the course object itself, or the courseid.
+ * @global object
+ * @global object
+ * @param object $user A {@link $USER} object to get full name of
+ * @param bool $override If true then the name will be first name followed by last name rather than adhering to fullnamedisplay setting.
+ * @return string
  */
-function sync_metacourse($course) {
-    global $CFG;
+function fullname($user, $override=false) {
+    global $CFG, $SESSION;
 
-    // Check the course is valid.
-    if (!is_object($course)) {
-        if (!$course = get_record('course', 'id', $course)) {
-            return false; // invalid course id
-        }
+    if (!isset($user->firstname) and !isset($user->lastname)) {
+        return '';
     }
 
-    // Check that we actually have a metacourse.
-    if (empty($course->metacourse)) {
-        return false;
+    if (!$override) {
+        if (!empty($CFG->forcefirstname)) {
+            $user->firstname = $CFG->forcefirstname;
     }
-
-    // Get a list of roles that should not be synced.
-    if (!empty($CFG->nonmetacoursesyncroleids)) {
-        $roleexclusions = 'ra.roleid NOT IN (' . $CFG->nonmetacoursesyncroleids . ') AND';
-    } else {
-        $roleexclusions = '';
+        if (!empty($CFG->forcelastname)) {
+            $user->lastname = $CFG->forcelastname;
     }
-
-    // Get the context of the metacourse.
-    $context = get_context_instance(CONTEXT_COURSE, $course->id); // SITEID can not be a metacourse
-
-    // We do not ever want to unassign the list of metacourse manager, so get a list of them.
-    if ($users = get_users_by_capability($context, 'moodle/course:managemetacourse')) {
-        $managers = array_keys($users);
-    } else {
-        $managers = array();
     }
 
-    // Get assignments of a user to a role that exist in a child course, but
-    // not in the meta coure. That is, get a list of the assignments that need to be made.
-    if (!$assignments = get_records_sql("
-            SELECT
-                ra.id, ra.roleid, ra.userid, ra.hidden
-            FROM
-                {$CFG->prefix}role_assignments ra,
-                {$CFG->prefix}context con,
-                {$CFG->prefix}course_meta cm
-            WHERE
-                ra.contextid = con.id AND
-                con.contextlevel = " . CONTEXT_COURSE . " AND
-                con.instanceid = cm.child_course AND
-                cm.parent_course = {$course->id} AND
-                $roleexclusions
-                NOT EXISTS (
-                    SELECT 1 FROM
-                        {$CFG->prefix}role_assignments ra2
-                    WHERE
-                        ra2.userid = ra.userid AND
-                        ra2.roleid = ra.roleid AND
-                        ra2.contextid = {$context->id}
-                )
-    ")) {
-        $assignments = array();
+    if (!empty($SESSION->fullnamedisplay)) {
+        $CFG->fullnamedisplay = $SESSION->fullnamedisplay;
     }
 
-    // Get assignments of a user to a role that exist in the meta course, but
-    // not in any child courses. That is, get a list of the unassignments that need to be made.
-    if (!$unassignments = get_records_sql("
-            SELECT
-                ra.id, ra.roleid, ra.userid
-            FROM
-                {$CFG->prefix}role_assignments ra
-            WHERE
-                ra.contextid = {$context->id} AND
-                $roleexclusions
-                NOT EXISTS (
-                    SELECT 1 FROM
-                        {$CFG->prefix}role_assignments ra2,
-                        {$CFG->prefix}context con2,
-                        {$CFG->prefix}course_meta cm
-                    WHERE
-                        ra2.userid = ra.userid AND
-                        ra2.roleid = ra.roleid AND
-                        ra2.contextid = con2.id AND
-                        con2.contextlevel = " . CONTEXT_COURSE . " AND
-                        con2.instanceid = cm.child_course AND
-                        cm.parent_course = {$course->id}
-                )
-    ")) {
-        $unassignments = array();
-    }
+    if (!isset($CFG->fullnamedisplay) or $CFG->fullnamedisplay === 'firstname lastname') {
+        return $user->firstname .' '. $user->lastname;
 
-    $success = true;
-
-    // Make the unassignments, if they are not managers.
-    foreach ($unassignments as $unassignment) {
-        if (!in_array($unassignment->userid, $managers)) {
-            $success = role_unassign($unassignment->roleid, $unassignment->userid, 0, $context->id) && $success;
-        }
-    }
-
-    // Make the assignments.
-    foreach ($assignments as $assignment) {
-        $success = role_assign($assignment->roleid, $assignment->userid, 0, $context->id, 0, 0, $assignment->hidden) && $success;
-    }
-
-    return $success;
-
-// TODO: finish timeend and timestart
-// maybe we could rely on cron job to do the cleaning from time to time
-}
-
-/**
- * Adds a record to the metacourse table and calls sync_metacoures
- */
-function add_to_metacourse ($metacourseid, $courseid) {
-
-    if (!$metacourse = get_record("course","id",$metacourseid)) {
-        return false;
-    }
-
-    if (!$course = get_record("course","id",$courseid)) {
-        return false;
-    }
-
-    if (!$record = get_record("course_meta","parent_course",$metacourseid,"child_course",$courseid)) {
-        $rec = new object();
-        $rec->parent_course = $metacourseid;
-        $rec->child_course = $courseid;
-        if (!insert_record('course_meta',$rec)) {
-            return false;
-        }
-        return sync_metacourse($metacourseid);
-    }
-    return true;
-
-}
-
-/**
- * Removes the record from the metacourse table and calls sync_metacourse
- */
-function remove_from_metacourse($metacourseid, $courseid) {
-
-    if (delete_records('course_meta','parent_course',$metacourseid,'child_course',$courseid)) {
-        return sync_metacourse($metacourseid);
-    }
-    return false;
-}
-
-
-/**
- * Determines if a user is currently logged in
- *
- * @uses $USER
- * @return bool
- */
-function isloggedin() {
-    global $USER;
-
-    return (!empty($USER->id));
-}
-
-/**
- * Determines if a user is logged in as real guest user with username 'guest'.
- * This function is similar to original isguest() in 1.6 and earlier.
- * Current isguest() is deprecated - do not use it anymore.
- *
- * @param $user mixed user object or id, $USER if not specified
- * @return bool true if user is the real guest user, false if not logged in or other user
- */
-function isguestuser($user=NULL) {
-    global $USER, $CFG;
-    if ($user === NULL) {
-        $user = $USER;
-    } else if (is_numeric($user)) {
-        $user = get_record('user', 'id', $user, '', '', '', '', 'id, username');
-    }
-
-    if (empty($user->id)) {
-        return false; // not logged in, can not be guest
-    }
-
-    return ($user->username == 'guest' and $user->mnethostid == $CFG->mnet_localhost_id);
-}
-
-/**
- * Determines if the currently logged in user is in editing mode.
- * Note: originally this function had $userid parameter - it was not usable anyway
- *
- * @uses $USER, $PAGE
- * @return bool
- */
-function isediting() {
-    global $USER, $PAGE;
-
-    if (empty($USER->editing)) {
-        return false;
-    } elseif (is_object($PAGE) && method_exists($PAGE,'user_allowed_editing')) {
-        return $PAGE->user_allowed_editing();
-    }
-    return true;//false;
-}
-
-/**
- * Determines if the logged in user is currently moving an activity
- *
- * @uses $USER
- * @param int $courseid The id of the course being tested
- * @return bool
- */
-function ismoving($courseid) {
-    global $USER;
-
-    if (!empty($USER->activitycopy)) {
-        return ($USER->activitycopycourse == $courseid);
-    }
-    return false;
-}
-
-/**
- * Given an object containing firstname and lastname
- * values, this function returns a string with the
- * full name of the person.
- * The result may depend on system settings
- * or language.  'override' will force both names
- * to be used even if system settings specify one.
- *
- * @uses $CFG
- * @uses $SESSION
- * @param object $user A {@link $USER} object to get full name of
- * @param bool $override If true then the name will be first name followed by last name rather than adhering to fullnamedisplay setting.
- */
-function fullname($user, $override=false) {
-    global $CFG, $SESSION;
-
-    if (!isset($user->firstname) and !isset($user->lastname)) {
-        return '';
-    }
-
-    if (!$override) {
-        if (!empty($CFG->forcefirstname)) {
-            $user->firstname = $CFG->forcefirstname;
-        }
-        if (!empty($CFG->forcelastname)) {
-            $user->lastname = $CFG->forcelastname;
-        }
-    }
-
-    if (!empty($SESSION->fullnamedisplay)) {
-        $CFG->fullnamedisplay = $SESSION->fullnamedisplay;
-    }
-
-    if (!isset($CFG->fullnamedisplay) or $CFG->fullnamedisplay === 'firstname lastname') {
-        return $user->firstname .' '. $user->lastname;
-
-    } else if ($CFG->fullnamedisplay == 'lastname firstname') {
-        return $user->lastname .' '. $user->firstname;
+    } else if ($CFG->fullnamedisplay == 'lastname firstname') {
+        return $user->lastname .' '. $user->firstname;
 
     } else if ($CFG->fullnamedisplay == 'firstname') {
         if ($override) {
@@ -2727,52 +3116,9 @@ function fullname($user, $override=false) {
 }
 
 /**
- * Sets a moodle cookie with an encrypted string
- *
- * @uses $CFG
- * @uses DAYSECS
- * @uses HOURSECS
- * @param string $thing The string to encrypt and place in a cookie
- */
-function set_moodle_cookie($thing) {
-    global $CFG;
-
-    if ($thing == 'guest') {  // Ignore guest account
-        return;
-    }
-
-    $cookiename = 'MOODLEID_'.$CFG->sessioncookie;
-
-    $days = 60;
-    $seconds = DAYSECS*$days;
-
-    setCookie($cookiename, '', time() - HOURSECS, $CFG->sessioncookiepath, $CFG->sessioncookiedomain, $CFG->cookiesecure);
-    setCookie($cookiename, rc4encrypt($thing), time()+$seconds, $CFG->sessioncookiepath, $CFG->sessioncookiedomain, $CFG->cookiesecure);
-}
-
-/**
- * Gets a moodle cookie with an encrypted string
- *
- * @uses $CFG
- * @return string
- */
-function get_moodle_cookie() {
-    global $CFG;
-
-    $cookiename = 'MOODLEID_'.$CFG->sessioncookie;
-
-    if (empty($_COOKIE[$cookiename])) {
-        return '';
-    } else {
-        $thing = rc4decrypt($_COOKIE[$cookiename]);
-        return ($thing == 'guest') ? '': $thing;  // Ignore guest account
-    }
-}
-
-/**
  * Returns whether a given authentication plugin exists.
  *
- * @uses $CFG
+ * @global object
  * @param string $auth Form of authentication to check for. Defaults to the
  *        global setting in {@link $CFG}.
  * @return boolean Whether the plugin is available.
@@ -2805,16 +3151,16 @@ function is_enabled_auth($auth) {
 /**
  * Returns an authentication plugin instance.
  *
- * @uses $CFG
+ * @global object
  * @param string $auth name of authentication plugin
- * @return object An instance of the required authentication plugin.
+ * @return auth_plugin_base An instance of the required authentication plugin.
  */
 function get_auth_plugin($auth) {
     global $CFG;
 
     // check the plugin exists first
     if (! exists_auth_plugin($auth)) {
-        error("Authentication plugin '$auth' not found.");
+        print_error('authpluginnotfound', 'debug', '', $auth);
     }
 
     // return auth plugin instance
@@ -2860,7 +3206,6 @@ function get_enabled_auth_plugins($fix=false) {
  * Returns true if an internal authentication method is being used.
  * if method not specified then, global default is assumed
  *
- * @uses $CFG
  * @param string $auth Form of authentication required
  * @return bool
  */
@@ -2876,83 +3221,55 @@ function is_internal_auth($auth) {
  * and allow him/her to reset the password
  *
  * @uses $CFG
+ * @uses $DB
  * @param string $username username to be checked
  * @return bool
  */
 function is_restored_user($username) {
-    global $CFG;
+    global $CFG, $DB;
 
-    return record_exists('user', 'username', $username, 'mnethostid', $CFG->mnet_localhost_id, 'password', 'restored');
+    return $DB->record_exists('user', array('username'=>$username, 'mnethostid'=>$CFG->mnet_localhost_id, 'password'=>'restored'));
 }
 
 /**
  * Returns an array of user fields
  *
- * @uses $CFG
- * @uses $db
  * @return array User field/column names
  */
 function get_user_fieldnames() {
+    global $DB;
 
-    global $CFG, $db;
-
-    $fieldarray = $db->MetaColumnNames($CFG->prefix.'user');
-    unset($fieldarray['ID']);
+    $fieldarray = $DB->get_columns('user');
+    unset($fieldarray['id']);
+    $fieldarray = array_keys($fieldarray);
 
     return $fieldarray;
 }
 
 /**
- * Creates the default "guest" user. Used both from
- * admin/index.php and login/index.php
- * @return mixed user object created or boolean false if the creation has failed
- */
-function create_guest_record() {
-
-    global $CFG;
-
-    $guest = new stdClass();
-    $guest->auth        = 'manual';
-    $guest->username    = 'guest';
-    $guest->password    = hash_internal_user_password('guest');
-    $guest->firstname   = addslashes(get_string('guestuser'));
-    $guest->lastname    = ' ';
-    $guest->email       = 'root@localhost';
-    $guest->description = addslashes(get_string('guestuserinfo'));
-    $guest->mnethostid  = $CFG->mnet_localhost_id;
-    $guest->confirmed   = 1;
-    $guest->lang        = $CFG->lang;
-    $guest->timemodified= time();
-
-    if (! $guest->id = insert_record("user", $guest)) {
-        return false;
-    }
-
-    return $guest;
-}
-
-/**
  * Creates a bare-bones user record
  *
- * @uses $CFG
+ * @todo Outline auth types and provide code example
+ *
  * @param string $username New user's username to add to record
  * @param string $password New user's password to add to record
  * @param string $auth Form of authentication required
- * @return object A {@link $USER} object
- * @todo Outline auth types and provide code example
+ * @return stdClass A complete user object
  */
-function create_user_record($username, $password, $auth='manual') {
-    global $CFG;
+function create_user_record($username, $password, $auth = 'manual') {
+    global $CFG, $DB;
 
     //just in case check text case
     $username = trim(moodle_strtolower($username));
 
     $authplugin = get_auth_plugin($auth);
 
+    $newuser = new stdClass();
+
     if ($newinfo = $authplugin->get_userinfo($username)) {
         $newinfo = truncate_userinfo($newinfo);
         foreach ($newinfo as $key => $value){
-            $newuser->$key = addslashes($value);
+            $newuser->$key = $value;
         }
     }
 
@@ -2972,49 +3289,51 @@ function create_user_record($username, $password, $auth='manual') {
     // fix for MDL-8480
     // user CFG lang for user if $newuser->lang is empty
     // or $user->lang is not an installed language
-    $sitelangs = array_keys(get_list_of_languages());
-    if (empty($newuser->lang) || !in_array($newuser->lang, $sitelangs)) {
-        $newuser -> lang = $CFG->lang;
+    if (empty($newuser->lang) || !get_string_manager()->translation_exists($newuser->lang)) {
+        $newuser->lang = $CFG->lang;
     }
     $newuser->confirmed = 1;
     $newuser->lastip = getremoteaddr();
-    if (empty($newuser->lastip)) {
-        $newuser->lastip = '0.0.0.0';
-    }
     $newuser->timemodified = time();
     $newuser->mnethostid = $CFG->mnet_localhost_id;
 
-    if (insert_record('user', $newuser)) {
-        $user = get_complete_user_data('username', $newuser->username, $CFG->mnet_localhost_id);
-        if(!empty($CFG->{'auth_'.$newuser->auth.'_forcechangepassword'})){
-            set_user_preference('auth_forcepasswordchange', 1, $user->id);
+    $newuser->id = $DB->insert_record('user', $newuser);
+    $user = get_complete_user_data('id', $newuser->id);
+    if (!empty($CFG->{'auth_'.$newuser->auth.'_forcechangepassword'})){
+        set_user_preference('auth_forcepasswordchange', 1, $user);
         }
         update_internal_user_password($user, $password);
+
+    // fetch full user record for the event, the complete user data contains too much info
+    // and we want to be consistent with other places that trigger this event
+    events_trigger('user_created', $DB->get_record('user', array('id'=>$user->id)));
+
         return $user;
-    }
-    return false;
 }
 
 /**
- * Will update a local user record from an external source
+ * Will update a local user record from an external source.
+ * (MNET users can not be updated using this method!)
  *
- * @uses $CFG
- * @param string $username New user's username to add to record
- * @return user A {@link $USER} object
+ * @param string $username user's username to update the record
+ * @return stdClass A complete user object
  */
-function update_user_record($username, $unused) {
-    global $CFG;
+function update_user_record($username) {
+    global $DB, $CFG;
 
     $username = trim(moodle_strtolower($username)); /// just in case check text case
 
-    $oldinfo = get_record('user', 'username', $username, 'mnethostid', $CFG->mnet_localhost_id, '','', 'id, username, auth');
+    $oldinfo = $DB->get_record('user', array('username'=>$username, 'mnethostid'=>$CFG->mnet_localhost_id), '*', MUST_EXIST);
+    $newuser = array();
     $userauth = get_auth_plugin($oldinfo->auth);
 
     if ($newinfo = $userauth->get_userinfo($username)) {
         $newinfo = truncate_userinfo($newinfo);
         foreach ($newinfo as $key => $value){
-            if ($key === 'username' or $key === 'id' or $key === 'auth' or $key === 'mnethostid' or $key === 'deleted') {
-                // these fields must not be changed
+            $key = strtolower($key);
+            if (!property_exists($oldinfo, $key) or $key === 'username' or $key === 'id'
+                    or $key === 'auth' or $key === 'mnethostid' or $key === 'deleted') {
+                // unknown or must not be changed
                 continue;
             }
             $confval = $userauth->config->{'field_updatelocal_' . $key};
@@ -3023,7 +3342,6 @@ function update_user_record($username, $unused) {
                 continue;
             }
             if ($confval === 'onlogin') {
-                $value = addslashes($value);
                 // MDL-4207 Don't overwrite modified user profile values with
                 // empty LDAP values when 'unlocked if empty' is set. The purpose
                 // of the setting 'unlocked if empty' is to allow the user to fill
@@ -3031,20 +3349,34 @@ function update_user_record($username, $unused) {
                 // nothing_ for this field. Thus it makes sense to let this value
                 // stand in until LDAP is giving a value for this field.
                 if (!(empty($value) && $lockval === 'unlockedifempty')) {
-                    set_field('user', $key, $value, 'id', $oldinfo->id)
-                        || error_log("Error updating $key for $username");
+                    if ((string)$oldinfo->$key !== (string)$value) {
+                        $newuser[$key] = (string)$value;
                 }
             }
         }
     }
+        if ($newuser) {
+            $newuser['id'] = $oldinfo->id;
+            $DB->update_record('user', $newuser);
+            // fetch full user record for the event, the complete user data contains too much info
+            // and we want to be consistent with other places that trigger this event
+            events_trigger('user_updated', $DB->get_record('user', array('id'=>$oldinfo->id)));
+        }
+    }
 
-    return get_complete_user_data('username', $username, $CFG->mnet_localhost_id);
+    return get_complete_user_data('id', $oldinfo->id);
 }
 
+/**
+ * Will truncate userinfo as it comes from auth_get_userinfo (from external auth)
+ * which may have large fields
+ *
+ * @todo Add vartype handling to ensure $info is an array
+ *
+ * @param array $info Array of user properties to truncate if needed
+ * @return array The now truncated information that was passed in
+ */
 function truncate_userinfo($info) {
-/// will truncate userinfo as it comes from auth_get_userinfo (from external auth)
-/// which may have large fields
-
     // define the limits
     $limit = array(
                     'username'    => 100,
@@ -3058,13 +3390,13 @@ function truncate_userinfo($info) {
                     'institution' =>  40,
                     'department'  =>  30,
                     'address'     =>  70,
-                    'city'        =>  20,
+                    'city'        => 120,
                     'country'     =>   2,
                     'url'         => 255,
                     );
 
-    // apply where needed
     $textlib = textlib_get_instance();
+    // apply where needed
     foreach (array_keys($info) as $key) {
         if (!empty($limit[$key])) {
             $info[$key] = trim($textlib->substr($info[$key],0, $limit[$key]));
@@ -3077,47 +3409,67 @@ function truncate_userinfo($info) {
 /**
  * Marks user deleted in internal user database and notifies the auth plugin.
  * Also unenrols user from all roles and does other cleanup.
- * @param object $user       Userobject before delete    (without system magic quotes)
- * @return boolean success
+ *
+ * Any plugin that needs to purge user data should register the 'user_deleted' event.
+ *
+ * @param stdClass $user full user object before delete
+ * @return boolean always true
  */
 function delete_user($user) {
-    global $CFG;
+    global $CFG, $DB;
     require_once($CFG->libdir.'/grouplib.php');
     require_once($CFG->libdir.'/gradelib.php');
     require_once($CFG->dirroot.'/message/lib.php');
-
-    begin_sql();
+    require_once($CFG->dirroot.'/tag/lib.php');
 
     // delete all grades - backup is kept in grade_grades_history table
-    if ($grades = grade_grade::fetch_all(array('userid'=>$user->id))) {
-        foreach ($grades as $grade) {
-            $grade->delete('userdelete');
-        }
-    }
+    grade_user_delete($user->id);
 
     //move unread messages from this user to read
     message_move_userfrom_unread2read($user->id);
 
-    // remove from all groups
-    delete_records('groups_members', 'userid', $user->id);
+    // TODO: remove from cohorts using standard API here
+
+    // remove user tags
+    tag_set('user', $user->id, array());
+
+    // unconditionally unenrol from all courses
+    enrol_user_delete($user);
 
     // unenrol from all roles in all contexts
-    role_unassign(0, $user->id); // this might be slow but it is really needed - modules might do some extra cleanup!
+    role_unassign_all(array('userid'=>$user->id)); // this might be slow but it is really needed - modules might do some extra cleanup!
 
-    // now do a final accesslib cleanup - removes all role assingments in user context and context itself
-    delete_context(CONTEXT_USER, $user->id);
+    //now do a brute force cleanup
 
-    require_once($CFG->dirroot.'/tag/lib.php');
-    tag_set('user', $user->id, array());
+    // remove from all cohorts
+    $DB->delete_records('cohort_members', array('userid'=>$user->id));
+
+    // remove from all groups
+    $DB->delete_records('groups_members', array('userid'=>$user->id));
+
+    // brute force unenrol from all courses
+    $DB->delete_records('user_enrolments', array('userid'=>$user->id));
+
+    // purge user preferences
+    $DB->delete_records('user_preferences', array('userid'=>$user->id));
+
+    // purge user extra profile info
+    $DB->delete_records('user_info_data', array('userid'=>$user->id));
+
+    // last course access not necessary either
+    $DB->delete_records('user_lastaccess', array('userid'=>$user->id));
+
+    // now do a final accesslib cleanup - removes all role assignments in user context and context itself
+    delete_context(CONTEXT_USER, $user->id);
 
     // workaround for bulk deletes of users with the same email address
-    $delname = addslashes("$user->email.".time());
-    while (record_exists('user', 'username', $delname)) { // no need to use mnethostid here
+    $delname = "$user->email.".time();
+    while ($DB->record_exists('user', array('username'=>$delname))) { // no need to use mnethostid here
         $delname++;
     }
 
     // mark internal user record as "deleted"
-    $updateuser = new object();
+    $updateuser = new stdClass();
     $updateuser->id           = $user->id;
     $updateuser->deleted      = 1;
     $updateuser->username     = $delname;            // Remember it just in case
@@ -3125,43 +3477,40 @@ function delete_user($user) {
     $updateuser->idnumber     = '';                  // Clear this field to free it up
     $updateuser->timemodified = time();
 
-    if (update_record('user', $updateuser)) {
-        commit_sql();
+    $DB->update_record('user', $updateuser);
+
         // notify auth plugin - do not block the delete even when plugin fails
         $authplugin = get_auth_plugin($user->auth);
         $authplugin->user_delete($user);
 
+    // any plugin that needs to cleanup should register this event
         events_trigger('user_deleted', $user);
-        return true;
 
-    } else {
-        rollback_sql();
-        return false;
-    }
+    return true;
 }
 
 /**
  * Retrieve the guest user object
  *
- * @uses $CFG
+ * @global object
+ * @global object
  * @return user A {@link $USER} object
  */
 function guest_user() {
-    global $CFG;
+    global $CFG, $DB;
 
-    if ($newuser = get_record('user', 'username', 'guest', 'mnethostid',  $CFG->mnet_localhost_id)) {
+    if ($newuser = $DB->get_record('user', array('id'=>$CFG->siteguest))) {
         $newuser->confirmed = 1;
         $newuser->lang = $CFG->lang;
         $newuser->lastip = getremoteaddr();
-        if (empty($newuser->lastip)) {
-            $newuser->lastip = '0.0.0.0';
-        }
     }
 
     return $newuser;
 }
 
 /**
+ * Authenticates a user against the chosen authentication mechanism
+ *
  * Given a username and password, this function looks them
  * up using the currently selected authentication mechanism,
  * and if the authentication is successful, it returns a
@@ -3173,21 +3522,26 @@ function guest_user() {
  * log that the user has logged in, and call complete_user_login() to set
  * the session up.
  *
- * @uses $CFG
- * @param string $username  User's username (with system magic quotes)
- * @param string $password  User's password (with system magic quotes)
+ * Note: this function works only with non-mnet accounts!
+ *
+ * @param string $username  User's username
+ * @param string $password  User's password
  * @return user|flase A {@link $USER} object or false if error
  */
 function authenticate_user_login($username, $password) {
-
-    global $CFG;
+    global $CFG, $DB;
 
     $authsenabled = get_enabled_auth_plugins();
 
-    if ($user = get_complete_user_data('username', $username)) {
+    if ($user = get_complete_user_data('username', $username, $CFG->mnet_localhost_id)) {
         $auth = empty($user->auth) ? 'manual' : $user->auth;  // use manual if auth not set
+        if (!empty($user->suspended)) {
+            add_to_log(SITEID, 'login', 'error', 'index.php', $username);
+            error_log('[client '.getremoteaddr()."]  $CFG->wwwroot  Suspended Login:  $username  ".$_SERVER['HTTP_USER_AGENT']);
+            return false;
+        }
         if ($auth=='nologin' or !is_enabled_auth($auth)) {
-            add_to_log(0, 'login', 'error', 'index.php', $username);
+            add_to_log(SITEID, 'login', 'error', 'index.php', $username);
             error_log('[client '.getremoteaddr()."]  $CFG->wwwroot  Disabled Login:  $username  ".$_SERVER['HTTP_USER_AGENT']);
             return false;
         }
@@ -3195,14 +3549,15 @@ function authenticate_user_login($username, $password) {
 
     } else {
         // check if there's a deleted record (cheaply)
-        if (get_field('user', 'id', 'username', $username, 'deleted', 1, '')) {
-            error_log('[client '.$_SERVER['REMOTE_ADDR']."]  $CFG->wwwroot  Deleted Login:  $username  ".$_SERVER['HTTP_USER_AGENT']);
+        if ($DB->get_field('user', 'id', array('username'=>$username, 'deleted'=>1))) {
+            error_log('[client '.getremoteaddr()."]  $CFG->wwwroot  Deleted Login:  $username  ".$_SERVER['HTTP_USER_AGENT']);
             return false;
         }
 
+        // User does not exist
         $auths = $authsenabled;
-        $user = new object();
-        $user->id = 0;     // User does not exist
+        $user = new stdClass();
+        $user->id = 0;
     }
 
     foreach ($auths as $auth) {
@@ -3216,22 +3571,26 @@ function authenticate_user_login($username, $password) {
         // successful authentication
         if ($user->id) {                          // User already exists in database
             if (empty($user->auth)) {             // For some reason auth isn't set yet
-                set_field('user', 'auth', $auth, 'username', $username);
+                $DB->set_field('user', 'auth', $auth, array('username'=>$username));
                 $user->auth = $auth;
             }
             if (empty($user->firstaccess)) { //prevent firstaccess from remaining 0 for manual account that never required confirmation
-                set_field('user','firstaccess', $user->timemodified, 'id', $user->id);
+                $DB->set_field('user','firstaccess', $user->timemodified, array('id' => $user->id));
                 $user->firstaccess = $user->timemodified;
             }
 
             update_internal_user_password($user, $password); // just in case salt or encoding were changed (magic quotes too one day)
 
-            if (!$authplugin->is_internal()) {            // update user record from external DB
-                $user = update_user_record($username, get_auth_plugin($user->auth));
+            if ($authplugin->is_synchronised_with_external()) { // update user record from external DB
+                $user = update_user_record($username);
             }
         } else {
-            // if user not found, create him
+            // if user not found and user creation is not disabled, create it
+            if (empty($CFG->authpreventaccountcreation)) {
             $user = create_user_record($username, $password, $auth);
+            } else {
+                continue;
+            }
         }
 
         $authplugin->sync_roles($user);
@@ -3241,25 +3600,22 @@ function authenticate_user_login($username, $password) {
             $hauth->user_authenticated_hook($user, $username, $password);
         }
 
-    /// Log in to a second system if necessary
-    /// NOTICE: /sso/ will be moved to auth and deprecated soon; use user_authenticated_hook() instead
-        if (!empty($CFG->sso)) {
-            include_once($CFG->dirroot .'/sso/'. $CFG->sso .'/lib.php');
-            if (function_exists('sso_user_login')) {
-                if (!sso_user_login($username, $password)) {   // Perform the signon process
-                    notify('Second sign-on failed');
-                }
-            }
+        if (empty($user->id)) {
+            return false;
         }
 
-        if ($user->id===0) {
+        if (!empty($user->suspended)) {
+            // just in case some auth plugin suspended account
+            add_to_log(SITEID, 'login', 'error', 'index.php', $username);
+            error_log('[client '.getremoteaddr()."]  $CFG->wwwroot  Suspended Login:  $username  ".$_SERVER['HTTP_USER_AGENT']);
             return false;
         }
+
         return $user;
     }
 
     // failed if all the plugins have failed
-    add_to_log(0, 'login', 'error', 'index.php', $username);
+    add_to_log(SITEID, 'login', 'error', 'index.php', $username);
     if (debugging('', DEBUG_ALL)) {
         error_log('[client '.getremoteaddr()."]  $CFG->wwwroot  Failed Login:  $username  ".$_SERVER['HTTP_USER_AGENT']);
     }
@@ -3274,40 +3630,45 @@ function authenticate_user_login($username, $password) {
  * NOTE:
  * - It will NOT log anything -- up to the caller to decide what to log.
  *
- *
- *
- * @uses $CFG, $USER
- * @param string $user obj
- * @return user|flase A {@link $USER} object or false if error
+ * @param object $user
+ * @param bool $setcookie
+ * @return object A {@link $USER} object - BC only, do not use
  */
-function complete_user_login($user) {
+function complete_user_login($user, $setcookie=true) {
     global $CFG, $USER;
 
-    $USER = $user; // this is required because we need to access preferences here!
+    // regenerate session id and delete old session,
+    // this helps prevent session fixation attacks from the same domain
+    session_regenerate_id(true);
 
-    if (!empty($CFG->regenloginsession)) {
-        // please note this setting may break some auth plugins
-        session_regenerate_id();
-    }
+    // check enrolments, load caps and setup $USER object
+    session_set_user($user);
 
-    reload_user_preferences();
+    // reload preferences from DB
+    unset($user->preference);
+    check_user_preferences_loaded($user);
 
+    // update login times
     update_user_login_times();
+
+    // extra session prefs init
+    set_login_session_preferences();
+
+    if (isguestuser()) {
+        // no need to continue when user is THE guest
+        return $USER;
+    }
+
+    if ($setcookie) {
     if (empty($CFG->nolastloggedin)) {
         set_moodle_cookie($USER->username);
     } else {
         // do not store last logged in user in cookie
         // auth plugins can temporarily override this from loginpage_hook()
         // do not save $CFG->nolastloggedin in database!
-        set_moodle_cookie('nobody');
+            set_moodle_cookie('');
+        }
     }
-    set_login_session_preferences();
-
-    // Call enrolment plugins
-    check_enrolment_plugins($user);
-
-    /// This is what lets the user do anything on the site :-)
-    load_all_capabilities();
 
     /// Select password change url
     $userauth = get_auth_plugin($USER->auth);
@@ -3331,11 +3692,11 @@ function complete_user_login($user) {
  * Compare password against hash stored in internal user table.
  * If necessary it also updates the stored hash to new format.
  *
- * @param object user
- * @param string plain text password
+ * @param stdClass $user (password property may be updated)
+ * @param string $password plain text password
  * @return bool is password valid?
  */
-function validate_internal_user_password(&$user, $password) {
+function validate_internal_user_password($user, $password) {
     global $CFG;
 
     if (!isset($CFG->passwordsaltmain)) {
@@ -3344,18 +3705,22 @@ function validate_internal_user_password(&$user, $password) {
 
     $validated = false;
 
-    // get password original encoding in case it was not updated to unicode yet
-    $textlib = textlib_get_instance();
-    $convpassword = $textlib->convert($password, 'utf-8', get_string('oldcharset'));
+    if ($user->password === 'not cached') {
+        // internal password is not used at all, it can not validate
 
-    if ($user->password == md5($password.$CFG->passwordsaltmain) or $user->password == md5($password)
-        or $user->password == md5($convpassword.$CFG->passwordsaltmain) or $user->password == md5($convpassword)) {
+    } else if ($user->password === md5($password.$CFG->passwordsaltmain)
+            or $user->password === md5($password)
+            or $user->password === md5(addslashes($password).$CFG->passwordsaltmain)
+            or $user->password === md5(addslashes($password))) {
+        // note: we are intentionally using the addslashes() here because we
+        //       need to accept old password hashes of passwords with magic quotes
         $validated = true;
+
     } else {
         for ($i=1; $i<=20; $i++) { //20 alternative salts should be enough, right?
             $alt = 'passwordsaltalt'.$i;
             if (!empty($CFG->$alt)) {
-                if ($user->password == md5($password.$CFG->$alt) or $user->password == md5($convpassword.$CFG->$alt)) {
+                if ($user->password === md5($password.$CFG->$alt) or $user->password === md5(addslashes($password).$CFG->$alt)) {
                     $validated = true;
                     break;
                 }
@@ -3374,7 +3739,7 @@ function validate_internal_user_password(&$user, $password) {
 /**
  * Calculate hashed value from password using current hash mechanism.
  *
- * @param string password
+ * @param string $password
  * @return string password hash
  */
 function hash_internal_user_password($password) {
@@ -3388,15 +3753,14 @@ function hash_internal_user_password($password) {
 }
 
 /**
- * Update pssword hash in user object.
+ * Update password hash in user object.
  *
- * @param object user
- * @param string plain text password
- * @param bool store changes also in db, default true
- * @return true if hash changed
+ * @param stdClass $user (password property may be updated)
+ * @param string $password plain text password
+ * @return bool always returns true
  */
-function update_internal_user_password(&$user, $password) {
-    global $CFG;
+function update_internal_user_password($user, $password) {
+    global $DB;
 
     $authplugin = get_auth_plugin($user->auth);
     if ($authplugin->prevent_local_passwords()) {
@@ -3405,31 +3769,35 @@ function update_internal_user_password(&$user, $password) {
         $hashedpassword = hash_internal_user_password($password);
     }
 
-    return set_field('user', 'password',  $hashedpassword, 'id', $user->id);
+    if ($user->password !== $hashedpassword) {
+        $DB->set_field('user', 'password',  $hashedpassword, array('id'=>$user->id));
+        $user->password = $hashedpassword;
+    }
+
+    return true;
 }
 
 /**
  * Get a complete user record, which includes all the info
- * in the user record
+ * in the user record.
+ *
  * Intended for setting as $USER session variable
  *
- * @uses $CFG
- * @uses SITEID
  * @param string $field The user field to be checked for a given value.
  * @param string $value The value to match for $field.
- * @return user A {@link $USER} object.
+ * @param int $mnethostid
+ * @return mixed False, or A {@link $USER} object.
  */
-function get_complete_user_data($field, $value, $mnethostid=null) {
-
-    global $CFG;
+function get_complete_user_data($field, $value, $mnethostid = null) {
+    global $CFG, $DB;
 
     if (!$field || !$value) {
         return false;
     }
 
 /// Build the WHERE clause for an SQL query
-
-    $constraints = $field .' = \''. $value .'\' AND deleted <> \'1\'';
+    $params = array('fieldval'=>$value);
+    $constraints = "$field = :fieldval AND deleted <> 1";
 
     // If we are loading user data based on anything other than id,
     // we must also restrict our search based on mnet host.
@@ -3440,41 +3808,38 @@ function get_complete_user_data($field, $value, $mnethostid=null) {
         }
     }
     if (!empty($mnethostid)) {
-        $mnethostid = (int)$mnethostid;
-        $constraints .= ' AND mnethostid = ' . $mnethostid;
+        $params['mnethostid'] = $mnethostid;
+        $constraints .= " AND mnethostid = :mnethostid";
     }
 
 /// Get all the basic user data
 
-    if (! $user = get_record_select('user', $constraints)) {
+    if (! $user = $DB->get_record_select('user', $constraints, $params)) {
         return false;
     }
 
 /// Get various settings and preferences
 
-    if ($displays = get_records('course_display', 'userid', $user->id)) {
-        foreach ($displays as $display) {
-            $user->display[$display->course] = $display->display;
-        }
-    }
-
-    $user->preference = get_user_preferences(null, null, $user->id);
+    // preload preference cache
+    check_user_preferences_loaded($user);
 
+    // load course enrolment related stuff
     $user->lastcourseaccess    = array(); // during last session
     $user->currentcourseaccess = array(); // during current session
-    if ($lastaccesses = get_records('user_lastaccess', 'userid', $user->id)) {
+    if ($lastaccesses = $DB->get_records('user_lastaccess', array('userid'=>$user->id))) {
         foreach ($lastaccesses as $lastaccess) {
             $user->lastcourseaccess[$lastaccess->courseid] = $lastaccess->timeaccess;
         }
     }
 
     $sql = "SELECT g.id, g.courseid
-              FROM {$CFG->prefix}groups g, {$CFG->prefix}groups_members gm
-             WHERE gm.groupid=g.id AND gm.userid={$user->id}";
+              FROM {groups} g, {groups_members} gm
+             WHERE gm.groupid=g.id AND gm.userid=?";
 
     // this is a special hack to speedup calendar display
     $user->groupmember = array();
-    if ($groups = get_records_sql($sql)) {
+    if (!isguestuser($user)) {
+        if ($groups = $DB->get_records_sql($sql, array($user->id))) {
         foreach ($groups as $group) {
             if (!array_key_exists($group->courseid, $user->groupmember)) {
                 $user->groupmember[$group->courseid] = array();
@@ -3482,37 +3847,33 @@ function get_complete_user_data($field, $value, $mnethostid=null) {
             $user->groupmember[$group->courseid][$group->id] = $group->id;
         }
     }
+    }
 
 /// Add the custom profile fields to the user record
-    include_once($CFG->dirroot.'/user/profile/lib.php');
-    $customfields = (array)profile_user_record($user->id);
-    foreach ($customfields as $cname=>$cvalue) {
-        if (!isset($user->$cname)) { // Don't overwrite any standard fields
-            $user->$cname = $cvalue;
-        }
+    $user->profile = array();
+    if (!isguestuser($user)) {
+        require_once($CFG->dirroot.'/user/profile/lib.php');
+        profile_load_custom_fields($user);
     }
 
 /// Rewrite some variables if necessary
     if (!empty($user->description)) {
         $user->description = true;   // No need to cart all of it around
     }
-    if ($user->username == 'guest') {
+    if (isguestuser($user)) {
         $user->lang       = $CFG->lang;               // Guest language always same as site
         $user->firstname  = get_string('guestuser');  // Name always in current language
         $user->lastname   = ' ';
     }
 
-    if (isset($_SERVER['REMOTE_ADDR'])) {
-        $user->sesskey  = random_string(10);
-        $user->sessionIP = md5(getremoteaddr());   // Store the current IP in the session
-    }
-
     return $user;
 }
 
 /**
- * @uses $CFG
- * @param string $password the password to be checked agains the password policy
+ * Validate a password against the configured password policy
+ *
+ * @global object
+ * @param string $password the password to be checked against the password policy
  * @param string $errmsg the error message to display when the password doesn't comply with the policy.
  * @return bool true if the password is valid according to the policy. false otherwise.
  */
@@ -3544,6 +3905,9 @@ function check_password_policy($password, &$errmsg) {
     if (preg_match_all('/[^[:upper:][:lower:][:digit:]]/u', $password, $matches) < $CFG->minpasswordnonalphanum) {
         $errmsg .= '<div>'. get_string('errorminpasswordnonalphanum', 'auth', $CFG->minpasswordnonalphanum) .'</div>';
     }
+    if (!check_consecutive_identical_characters($password, $CFG->maxconsecutiveidentchars)) {
+        $errmsg .= '<div>'. get_string('errormaxconsecutiveidentchars', 'auth', $CFG->maxconsecutiveidentchars) .'</div>';
+    }
 
     if ($errmsg == '') {
         return true;
@@ -3556,6 +3920,9 @@ function check_password_policy($password, &$errmsg) {
 /**
  * When logging in, this function is run to set certain preferences
  * for the current SESSION
+ *
+ * @global object
+ * @global object
  */
 function set_login_session_preferences() {
     global $SESSION, $CFG;
@@ -3563,19 +3930,15 @@ function set_login_session_preferences() {
     $SESSION->justloggedin = true;
 
     unset($SESSION->lang);
-
-    // Restore the calendar filters, if saved
-    if (intval(get_user_preferences('calendar_persistflt', 0))) {
-        include_once($CFG->dirroot.'/calendar/lib.php');
-        calendar_set_filters_status(get_user_preferences('calendar_savedflt', 0xff));
-    }
 }
 
 
 /**
  * Delete a course, including all related data from the database,
- * and any associated files from the moodledata folder.
+ * and any associated files.
  *
+ * @global object
+ * @global object
  * @param mixed $courseorid The id of the course or course object to delete.
  * @param bool $showfeedback Whether to display notifications of each action the function performs.
  * @return bool true if all the removals succeeded. false if there were any failures. If this
@@ -3583,105 +3946,111 @@ function set_login_session_preferences() {
  *             failed, but you have no way of knowing which.
  */
 function delete_course($courseorid, $showfeedback = true) {
-    global $CFG;
-    $result = true;
+    global $DB;
 
     if (is_object($courseorid)) {
         $courseid = $courseorid->id;
         $course   = $courseorid;
     } else {
         $courseid = $courseorid;
-        if (!$course = get_record('course', 'id', $courseid)) {
+        if (!$course = $DB->get_record('course', array('id'=>$courseid))) {
             return false;
         }
     }
+    $context = get_context_instance(CONTEXT_COURSE, $courseid);
 
     // frontpage course can not be deleted!!
     if ($courseid == SITEID) {
         return false;
     }
 
-    if (!remove_course_contents($courseid, $showfeedback)) {
-        if ($showfeedback) {
-            notify("An error occurred while deleting some of the course contents.");
-        }
-        $result = false;
-    }
-
-    if (!delete_records("course", "id", $courseid)) {
-        if ($showfeedback) {
-            notify("An error occurred while deleting the main course record.");
-        }
-        $result = false;
-    }
-
-/// Delete all roles and overiddes in the course context
-    if (!delete_context(CONTEXT_COURSE, $courseid)) {
-        if ($showfeedback) {
-            notify("An error occurred while deleting the main course context.");
-        }
-        $result = false;
-    }
+    // make the course completely empty
+    remove_course_contents($courseid, $showfeedback);
 
-    if (!fulldelete($CFG->dataroot.'/'.$courseid)) {
-        if ($showfeedback) {
-            notify("An error occurred while deleting the course files.");
-        }
-        $result = false;
-    }
+    // delete the course and related context instance
+    delete_context(CONTEXT_COURSE, $courseid);
+    $DB->delete_records("course", array("id"=>$courseid));
 
-    if ($result) {
         //trigger events
+    $course->context = $context; // you can not fetch context in the event because it was already deleted
         events_trigger('course_deleted', $course);
-    }
 
-    return $result;
+    return true;
 }
 
 /**
  * Clear a course out completely, deleting all content
- * but don't delete the course itself
+ * but don't delete the course itself.
+ * This function does not verify any permissions.
+ *
+ * Please note this function also deletes all user enrolments,
+ * enrolment instances and role assignments.
  *
- * @uses $CFG
  * @param int $courseid The id of the course that is being deleted
  * @param bool $showfeedback Whether to display notifications of each action the function performs.
  * @return bool true if all the removals succeeded. false if there were any failures. If this
  *             method returns false, some of the removals will probably have succeeded, and others
  *             failed, but you have no way of knowing which.
  */
-function remove_course_contents($courseid, $showfeedback=true) {
-
-    global $CFG;
+function remove_course_contents($courseid, $showfeedback = true) {
+    global $CFG, $DB, $OUTPUT;
+    require_once($CFG->libdir.'/completionlib.php');
     require_once($CFG->libdir.'/questionlib.php');
     require_once($CFG->libdir.'/gradelib.php');
+    require_once($CFG->dirroot.'/group/lib.php');
+    require_once($CFG->dirroot.'/tag/coursetagslib.php');
 
-    $result = true;
-
-    if (! $course = get_record('course', 'id', $courseid)) {
-        error('Course ID was incorrect (can\'t find it)');
-    }
+    $course = $DB->get_record('course', array('id'=>$courseid), '*', MUST_EXIST);
+    $context = get_context_instance(CONTEXT_COURSE, $courseid, MUST_EXIST);
 
     $strdeleted = get_string('deleted');
 
-/// Clean up course formats (iterate through all formats in the even the course format was ever changed)
-    $formats = get_list_of_plugins('course/format');
-    foreach ($formats as $format) {
-        $formatdelete = $format.'_course_format_delete_course';
-        $formatlib    = "$CFG->dirroot/course/format/$format/lib.php";
+    // Delete course completion information,
+    // this has to be done before grades and enrols
+    $cc = new completion_info($course);
+    $cc->clear_criteria();
+
+    // remove roles and enrolments
+    role_unassign_all(array('contextid'=>$context->id), true);
+    enrol_course_delete($course);
+
+    // Clean up course formats (iterate through all formats in the even the course format was ever changed)
+    $formats = get_plugin_list('format');
+    foreach ($formats as $format=>$formatdir) {
+        $formatdelete = 'format_'.$format.'_delete_course';
+        $formatlib    = "$formatdir/lib.php";
         if (file_exists($formatlib)) {
             include_once($formatlib);
             if (function_exists($formatdelete)) {
                 if ($showfeedback) {
-                    notify($strdeleted.' '.$format);
+                    echo $OUTPUT->notification($strdeleted.' '.$format);
                 }
                 $formatdelete($course->id);
             }
         }
     }
 
-/// Delete every instance of every module
+    // Remove all data from gradebook - this needs to be done before course modules
+    // because while deleting this information, the system may need to reference
+    // the course modules that own the grades.
+    remove_course_grades($courseid, $showfeedback);
+    remove_grade_letters($context, $showfeedback);
 
-    if ($allmods = get_records('modules') ) {
+    // Remove all data from availability and completion tables that is associated
+    // with course-modules belonging to this course. Note this is done even if the
+    // features are not enabled now, in case they were enabled previously
+    $DB->delete_records_select('course_modules_completion',
+           'coursemoduleid IN (SELECT id from {course_modules} WHERE course=?)',
+           array($courseid));
+    $DB->delete_records_select('course_modules_availability',
+           'coursemoduleid IN (SELECT id from {course_modules} WHERE course=?)',
+           array($courseid));
+
+    // Delete course blocks - they may depend on modules so delete them first
+    blocks_delete_all_for_context($context->id);
+
+    // Delete every instance of every module
+    if ($allmods = $DB->get_records('modules') ) {
         foreach ($allmods as $mod) {
             $modname = $mod->name;
             $modfile = $CFG->dirroot .'/mod/'. $modname .'/lib.php';
@@ -3691,7 +4060,7 @@ function remove_course_contents($courseid, $showfeedback=true) {
             if (file_exists($modfile)) {
                 include_once($modfile);
                 if (function_exists($moddelete)) {
-                    if ($instances = get_records($modname, 'course', $course->id)) {
+                    if ($instances = $DB->get_records($modname, array('course'=>$course->id))) {
                         foreach ($instances as $instance) {
                             if ($cm = get_coursemodule_from_instance($modname, $instance->id, $course->id)) {
                                 /// Delete activity context questions and question categories
@@ -3701,19 +4070,18 @@ function remove_course_contents($courseid, $showfeedback=true) {
                                 $count++;
 
                             } else {
-                                notify('Could not delete '. $modname .' instance '. $instance->id .' ('. format_string($instance->name) .')');
-                                $result = false;
+                                echo $OUTPUT->notification('Could not delete '. $modname .' instance '. $instance->id .' ('. format_string($instance->name) .')');
                             }
                             if ($cm) {
                                 // delete cm and its context in correct order
-                                delete_records('course_modules', 'id', $cm->id);
-                                delete_context(CONTEXT_MODULE, $cm->id);
+                                delete_context(CONTEXT_MODULE, $cm->id); // some callbacks may try to fetch context, better delete first
+                                $DB->delete_records('course_modules', array('id'=>$cm->id));
                             }
                         }
                     }
                 } else {
-                    notify('Function '.$moddelete.'() doesn\'t exist!');
-                    $result = false;
+                    //note: we should probably delete these anyway
+                    echo $OUTPUT->notification('Function '.$moddelete.'() doesn\'t exist!');
                 }
 
                 if (function_exists($moddeletecourse)) {
@@ -3721,130 +4089,84 @@ function remove_course_contents($courseid, $showfeedback=true) {
                 }
             }
             if ($showfeedback) {
-                notify($strdeleted .' '. $count .' x '. $modname);
-            }
-        }
-    } else {
-        error('No modules are installed!');
-    }
-
-/// Give local code a chance to delete its references to this course.
-    require_once($CFG->libdir.'/locallib.php');
-    notify_local_delete_course($courseid, $showfeedback);
-
-/// Delete course blocks
-
-    if ($blocks = get_records_sql("SELECT *
-                                   FROM {$CFG->prefix}block_instance
-                                   WHERE pagetype = '".PAGE_COURSE_VIEW."'
-                                   AND pageid = $course->id")) {
-        if (delete_records('block_instance', 'pagetype', PAGE_COURSE_VIEW, 'pageid', $course->id)) {
-            if ($showfeedback) {
-                notify($strdeleted .' block_instance');
-            }
-
-            require_once($CFG->libdir.'/blocklib.php');
-            foreach ($blocks as $block) {  /// Delete any associated contexts for this block
-
-                delete_context(CONTEXT_BLOCK, $block->id);
-
-                // fix for MDL-7164
-                // Get the block object and call instance_delete()
-                if (!$record = blocks_get_record($block->blockid)) {
-                    $result = false;
-                    continue;
-                }
-                if (!$obj = block_instance($record->name, $block)) {
-                    $result = false;
-                    continue;
-                }
-                // Return value ignored, in core mods this does not do anything, but just in case
-                // third party blocks might have stuff to clean up
-                // we execute this anyway
-                $obj->instance_delete();
-
+                echo $OUTPUT->notification($strdeleted .' '. $count .' x '. $modname);
             }
-        } else {
-            $result = false;
         }
     }
 
-/// Delete any groups, removing members and grouping/course links first.
-    require_once($CFG->dirroot.'/group/lib.php');
-    groups_delete_groupings($courseid, $showfeedback);
-    groups_delete_groups($courseid, $showfeedback);
+    // Delete any groups, removing members and grouping/course links first.
+    groups_delete_groupings($course->id, $showfeedback);
+    groups_delete_groups($course->id, $showfeedback);
 
-/// Delete all related records in other tables that may have a courseid
-/// This array stores the tables that need to be cleared, as
-/// table_name => column_name that contains the course id.
+    // Delete questions and question categories
+    question_delete_course($course, $showfeedback);
 
+    // Delete course tags
+    coursetag_delete_course_tags($course->id, $showfeedback);
+
+    // Delete legacy files (just in case some files are still left there after conversion to new file api)
+    fulldelete($CFG->dataroot.'/'.$course->id);
+
+    // cleanup course record - remove links to delted stuff
+    $oldcourse = new stdClass();
+    $oldcourse->id                = $course->id;
+    $oldcourse->summary           = '';
+    $oldcourse->modinfo           = NULL;
+    $oldcourse->legacyfiles       = 0;
+    $oldcourse->defaultgroupingid = 0;
+    $oldcourse->enablecompletion  = 0;
+    $DB->update_record('course', $oldcourse);
+
+    // Delete all related records in other tables that may have a courseid
+    // This array stores the tables that need to be cleared, as
+    // table_name => column_name that contains the course id.
     $tablestoclear = array(
         'event' => 'courseid', // Delete events
         'log' => 'course', // Delete logs
         'course_sections' => 'course', // Delete any course stuff
         'course_modules' => 'course',
+        'course_display' => 'course',
         'backup_courses' => 'courseid', // Delete scheduled backup stuff
         'user_lastaccess' => 'courseid',
         'backup_log' => 'courseid'
     );
     foreach ($tablestoclear as $table => $col) {
-        if (delete_records($table, $col, $course->id)) {
-            if ($showfeedback) {
-                notify($strdeleted . ' ' . $table);
-            }
-        } else {
-            $result = false;
-        }
-    }
-
-
-/// Clean up metacourse stuff
-
-    if ($course->metacourse) {
-        delete_records("course_meta","parent_course",$course->id);
-        sync_metacourse($course->id); // have to do it here so the enrolments get nuked. sync_metacourses won't find it without the id.
-        if ($showfeedback) {
-            notify("$strdeleted course_meta");
-        }
-    } else {
-        if ($parents = get_records("course_meta","child_course",$course->id)) {
-            foreach ($parents as $parent) {
-                remove_from_metacourse($parent->parent_course,$parent->child_course); // this will do the unenrolments as well.
-            }
-            if ($showfeedback) {
-                notify("$strdeleted course_meta");
-            }
-        }
+        $DB->delete_records($table, array($col=>$course->id));
     }
 
-/// Delete questions and question categories
-    question_delete_course($course, $showfeedback);
+    // Delete all remaining stuff linked to context,
+    // such as remaining roles, files, comments, etc.
+    // Keep the context record for now.
+    delete_context(CONTEXT_COURSE, $course->id, false);
 
-/// Remove all data from gradebook
-    $context = get_context_instance(CONTEXT_COURSE, $courseid);
-    remove_course_grades($courseid, $showfeedback);
-    remove_grade_letters($context, $showfeedback);
+    //trigger events
+    $course->context = $context; // you can not access context in cron event later after course is deleted
+    events_trigger('course_content_removed', $course);
 
-    return $result;
+    return true;
 }
 
 /**
  * Change dates in module - used from course reset.
- * @param strin $modname forum, assignent, etc
+ *
+ * @global object
+ * @global object
+ * @param string $modname forum, assignment, etc
  * @param array $fields array of date fields from mod table
  * @param int $timeshift time difference
- * @return success
+ * @param int $courseid
+ * @return bool success
  */
 function shift_course_mod_dates($modname, $fields, $timeshift, $courseid) {
-    global $CFG;
+    global $CFG, $DB;
     include_once($CFG->dirroot.'/mod/'.$modname.'/lib.php');
 
     $return = true;
     foreach ($fields as $field) {
-        $updatesql = "UPDATE {$CFG->prefix}$modname
-                          SET $field = $field + ($timeshift)
-                        WHERE course=$courseid AND $field<>0 AND $field<>0";
-        $return = execute_sql($updatesql, false) && $return;
+        $updatesql = "UPDATE {".$modname."}
+                          SET $field = $field + ?
+                        WHERE course=? AND $field<>0 AND $field<>0";
+        $return = $DB->execute($updatesql, array($timeshift, $courseid)) && $return;
     }
 
     $refreshfunction = $modname.'_refresh_events';
@@ -3858,12 +4180,14 @@ function shift_course_mod_dates($modname, $fields, $timeshift, $courseid) {
 /**
  * This function will empty a course of user data.
  * It will retain the activities and the structure of the course.
+ *
  * @param object $data an object containing all the settings including courseid (without magic quotes)
  * @return array status array of array component, item, error
  */
 function reset_course_userdata($data) {
-    global $CFG, $USER;
+    global $CFG, $USER, $DB;
     require_once($CFG->libdir.'/gradelib.php');
+    require_once($CFG->libdir.'/completionlib.php');
     require_once($CFG->dirroot.'/group/lib.php');
 
     $data->courseid = $data->id;
@@ -3886,23 +4210,23 @@ function reset_course_userdata($data) {
     // move the course start time
     if (!empty($data->reset_start_date) and $data->timeshift) {
         // change course start data
-        set_field('course', 'startdate', $data->reset_start_date, 'id', $data->courseid);
+        $DB->set_field('course', 'startdate', $data->reset_start_date, array('id'=>$data->courseid));
         // update all course and group events - do not move activity events
-        $updatesql = "UPDATE {$CFG->prefix}event
-                         SET timestart = timestart + ({$data->timeshift})
-                       WHERE courseid={$data->courseid} AND instance=0";
-        execute_sql($updatesql, false);
+        $updatesql = "UPDATE {event}
+                         SET timestart = timestart + ?
+                       WHERE courseid=? AND instance=0";
+        $DB->execute($updatesql, array($data->timeshift, $data->courseid));
 
         $status[] = array('component'=>$componentstr, 'item'=>get_string('datechanged'), 'error'=>false);
     }
 
     if (!empty($data->reset_logs)) {
-        delete_records('log', 'course', $data->courseid);
+        $DB->delete_records('log', array('course'=>$data->courseid));
         $status[] = array('component'=>$componentstr, 'item'=>get_string('deletelogs'), 'error'=>false);
     }
 
     if (!empty($data->reset_events)) {
-        delete_records('event', 'courseid', $data->courseid);
+        $DB->delete_records('event', array('courseid'=>$data->courseid));
         $status[] = array('component'=>$componentstr, 'item'=>get_string('deleteevents', 'calendar'), 'error'=>false);
     }
 
@@ -3912,14 +4236,28 @@ function reset_course_userdata($data) {
         $status[] = array('component'=>$componentstr, 'item'=>get_string('deletenotes', 'notes'), 'error'=>false);
     }
 
+    if (!empty($data->delete_blog_associations)) {
+        require_once($CFG->dirroot.'/blog/lib.php');
+        blog_remove_associations_for_course($data->courseid);
+        $status[] = array('component'=>$componentstr, 'item'=>get_string('deleteblogassociations', 'blog'), 'error'=>false);
+    }
+
+    if (!empty($data->reset_course_completion)) {
+        // Delete course completion information
+        $course = $DB->get_record('course', array('id'=>$data->courseid));
+        $cc = new completion_info($course);
+        $cc->delete_course_completion_data();
+        $status[] = array('component'=>$componentstr, 'item'=>get_string('deletecoursecompletiondata', 'completion'), 'error'=>false);
+    }
+
     $componentstr = get_string('roles');
 
     if (!empty($data->reset_roles_overrides)) {
         $children = get_child_contexts($context);
         foreach ($children as $child) {
-            delete_records('role_capabilities', 'contextid', $child->id);
+            $DB->delete_records('role_capabilities', array('contextid'=>$child->id));
         }
-        delete_records('role_capabilities', 'contextid', $context->id);
+        $DB->delete_records('role_capabilities', array('contextid'=>$context->id));
         //force refresh for logged in users
         mark_context_dirty($context->path);
         $status[] = array('component'=>$componentstr, 'item'=>get_string('deletecourseoverrides', 'role'), 'error'=>false);
@@ -3928,7 +4266,7 @@ function reset_course_userdata($data) {
     if (!empty($data->reset_roles_local)) {
         $children = get_child_contexts($context);
         foreach ($children as $child) {
-            role_unassign(0, 0, 0, $child->id);
+            role_unassign_all(array('contextid'=>$child->id));
         }
         //force refresh for logged in users
         mark_context_dirty($context->path);
@@ -3937,20 +4275,40 @@ function reset_course_userdata($data) {
 
     // First unenrol users - this cleans some of related user data too, such as forum subscriptions, tracking, etc.
     $data->unenrolled = array();
-    if (!empty($data->reset_roles)) {
-        foreach($data->reset_roles as $roleid) {
-            if ($users = get_role_users($roleid, $context, false, 'u.id', 'u.id ASC')) {
-                foreach ($users as $user) {
-                    role_unassign($roleid, $user->id, 0, $context->id);
-                    if (!has_capability('moodle/course:view', $context, $user->id)) {
-                        $data->unenrolled[$user->id] = $user->id;
+    if (!empty($data->unenrol_users)) {
+        $plugins = enrol_get_plugins(true);
+        $instances = enrol_get_instances($data->courseid, true);
+        foreach ($instances as $key=>$instance) {
+            if (!isset($plugins[$instance->enrol])) {
+                unset($instances[$key]);
+                continue;
+            }
+            if (!$plugins[$instance->enrol]->allow_unenrol($instance)) {
+                unset($instances[$key]);
+            }
                     }
+
+        $sqlempty = $DB->sql_empty();
+        foreach($data->unenrol_users as $withroleid) {
+            $sql = "SELECT DISTINCT ue.userid, ue.enrolid
+                      FROM {user_enrolments} ue
+                      JOIN {enrol} e ON (e.id = ue.enrolid AND e.courseid = :courseid)
+                      JOIN {context} c ON (c.contextlevel = :courselevel AND c.instanceid = e.courseid)
+                      JOIN {role_assignments} ra ON (ra.contextid = c.id AND ra.roleid = :roleid AND ra.userid = ue.userid)";
+            $params = array('courseid'=>$data->courseid, 'roleid'=>$withroleid, 'courselevel'=>CONTEXT_COURSE);
+
+            $rs = $DB->get_recordset_sql($sql, $params);
+            foreach ($rs as $ue) {
+                if (!isset($instances[$ue->enrolid])) {
+                    continue;
                 }
+                $plugins[$instances[$ue->enrolid]->enrol]->unenrol_user($instances[$ue->enrolid], $ue->userid);
+                $data->unenrolled[$ue->userid] = $ue->userid;
             }
         }
     }
     if (!empty($data->unenrolled)) {
-        $status[] = array('component'=>$componentstr, 'item'=>get_string('unenrol').' ('.count($data->unenrolled).')', 'error'=>false);
+        $status[] = array('component'=>$componentstr, 'item'=>get_string('unenrol', 'enrol').' ('.count($data->unenrolled).')', 'error'=>false);
     }
 
 
@@ -3982,10 +4340,10 @@ function reset_course_userdata($data) {
 
     // Look in every instance of every module for data to delete
     $unsupported_mods = array();
-    if ($allmods = get_records('modules') ) {
+    if ($allmods = $DB->get_records('modules') ) {
         foreach ($allmods as $mod) {
             $modname = $mod->name;
-            if (!count_records($modname, 'course', $data->courseid)) {
+            if (!$DB->count_records($modname, array('course'=>$data->courseid))) {
                 continue; // skip mods with no instances
             }
             $modfile = $CFG->dirroot.'/mod/'. $modname.'/lib.php';
@@ -4028,10 +4386,22 @@ function reset_course_userdata($data) {
         grade_course_reset($data->courseid);
         $status[] = array('component'=>$componentstr, 'item'=>get_string('removeallcoursegrades', 'grades'), 'error'=>false);
     }
+    // reset comments
+    if (!empty($data->reset_comments)) {
+        require_once($CFG->dirroot.'/comment/lib.php');
+        comment::reset_course_page_comments($context);
+    }
 
     return $status;
 }
 
+/**
+ * Generate an email processing address
+ *
+ * @param int $modid
+ * @param string $modargs
+ * @return string Returns email processing address
+ */
 function generate_email_processing_address($modid,$modargs) {
     global $CFG;
 
@@ -4039,12 +4409,23 @@ function generate_email_processing_address($modid,$modargs) {
     return $header . substr(md5($header.get_site_identifier()),0,16).'@'.$CFG->maildomain;
 }
 
+/**
+ * ?
+ *
+ * @todo Finish documenting this function
+ *
+ * @global object
+ * @param string $modargs
+ * @param string $body Currently unused
+ */
 function moodle_process_email($modargs,$body) {
+    global $DB;
+
     // the first char should be an unencoded letter. We'll take this as an action
     switch ($modargs{0}) {
         case 'B': { // bounce
             list(,$userid) = unpack('V',base64_decode(substr($modargs,1,8)));
-            if ($user = get_record_select("user","id=$userid","id,email")) {
+            if ($user = $DB->get_record("user", array('id'=>$userid), "id,email")) {
                 // check the half md5 of their email
                 $md5check = substr(md5($user->email),0,16);
                 if ($md5check == substr($modargs, -16)) {
@@ -4062,10 +4443,12 @@ function moodle_process_email($modargs,$body) {
 
 /**
  * Get mailer instance, enable buffering, flush buffer or disable buffering.
- * @param $action string 'get', 'buffer', 'close' or 'flush'
- * @return reference to mailer instance if 'get' used or nothing
+ *
+ * @global object
+ * @param string $action 'get', 'buffer', 'close' or 'flush'
+ * @return object|null mailer instance if 'get' used or nothing
  */
-function &get_mailer($action='get') {
+function get_mailer($action='get') {
     global $CFG;
 
     static $mailer  = null;
@@ -4079,7 +4462,7 @@ function &get_mailer($action='get') {
         $prevkeepalive = false;
 
         if (isset($mailer) and $mailer->Mailer == 'smtp') {
-            if ($counter < $CFG->smtpmaxbulk and empty($mailer->error_count)) {
+            if ($counter < $CFG->smtpmaxbulk and !$mailer->IsError()) {
                 $counter++;
                 // reset the mailer
                 $mailer->Priority         = 3;
@@ -4105,8 +4488,8 @@ function &get_mailer($action='get') {
             get_mailer('flush');
         }
 
-        include_once($CFG->libdir.'/phpmailer/class.phpmailer.php');
-        $mailer = new phpmailer();
+        include_once($CFG->libdir.'/phpmailer/moodle_phpmailer.php');
+        $mailer = new moodle_phpmailer();
 
         $counter = 1;
 
@@ -4115,7 +4498,6 @@ function &get_mailer($action='get') {
         $mailer->CharSet   = 'UTF-8';
 
         // some MTAs may do double conversion of LF if CRLF used, CRLF is required line ending in RFC 822bis
-        // hmm, this is a bit hacky because LE should be private
         if (isset($CFG->mailnewline) and $CFG->mailnewline == 'CRLF') {
             $mailer->LE = "\r\n";
         } else {
@@ -4152,7 +4534,7 @@ function &get_mailer($action='get') {
     if ($action == 'buffer') {
         if (!empty($CFG->smtpmaxbulk)) {
             get_mailer('flush');
-            $m =& get_mailer();
+            $m = get_mailer();
             if ($m->Mailer == 'smtp') {
                 $m->SMTPKeepAlive = true;
             }
@@ -4188,12 +4570,12 @@ function &get_mailer($action='get') {
 /**
  * Send an email to a specified user
  *
- * @uses $CFG
- * @uses $FULLME
- * @uses $MNETIDPJUMPURL IdentityProvider(IDP) URL user hits to jump to mnet peer.
+ * @global object
+ * @global string
+ * @global string IdentityProvider(IDP) URL user hits to jump to mnet peer.
  * @uses SITEID
- * @param user $user  A {@link $USER} object
- * @param user $from A {@link $USER} object
+ * @param stdClass $user  A {@link $USER} object
+ * @param stdClass $from A {@link $USER} object
  * @param string $subject plain text subject line of the email
  * @param string $messagetext plain text version of the message
  * @param string $messagehtml complete html version of the message (optional)
@@ -4201,26 +4583,29 @@ function &get_mailer($action='get') {
  * @param string $attachname the name of the file (extension indicates MIME)
  * @param bool $usetrueaddress determines whether $from email address should
  *          be sent out. Will be overruled by user profile setting for maildisplay
- * @param int $wordwrapwidth custom word wrap width
- * @return bool|string Returns "true" if mail was sent OK, "emailstop" if email
- *          was blocked by user and "false" if there was another sort of error.
+ * @param string $replyto Email address to reply to
+ * @param string $replytoname Name of reply to recipient
+ * @param int $wordwrapwidth custom word wrap width, default 79
+ * @return bool Returns true if mail was sent OK and false if there was an error.
  */
 function email_to_user($user, $from, $subject, $messagetext, $messagehtml='', $attachment='', $attachname='', $usetrueaddress=true, $replyto='', $replytoname='', $wordwrapwidth=79) {
 
-    global $CFG, $FULLME, $MNETIDPJUMPURL;
-    static $mnetjumps = array();
+    global $CFG, $FULLME;
 
     if (empty($user) || empty($user->email)) {
+        mtrace('Error: lib/moodlelib.php email_to_user(): User is null or has no email');
         return false;
     }
 
     if (!empty($user->deleted)) {
         // do not mail delted users
+        mtrace('Error: lib/moodlelib.php email_to_user(): User is deleted');
         return false;
     }
 
     if (!empty($CFG->noemailever)) {
         // hidden setting for development sites, set in config.php if needed
+        mtrace('Error: lib/moodlelib.php email_to_user(): Not sending email due to noemailever config setting');
         return true;
     }
 
@@ -4235,12 +4620,10 @@ function email_to_user($user, $from, $subject, $messagetext, $messagehtml='', $a
         return true;
     }
 
-    if (!empty($user->emailstop)) {
-        return 'emailstop';
-    }
-
     if (over_bounce_threshold($user)) {
-        error_log("User $user->id (".fullname($user).") is over bounce threshold! Not sending.");
+        $bouncemsg = "User $user->id (".fullname($user).") is over bounce threshold! Not sending.";
+        error_log($bouncemsg);
+        mtrace('Error: lib/moodlelib.php email_to_user(): '.$bouncemsg);
         return false;
     }
 
@@ -4249,31 +4632,25 @@ function email_to_user($user, $from, $subject, $messagetext, $messagehtml='', $a
     // home site (identity provider - idp) before hitting the link itself
     if (is_mnet_remote_user($user)) {
         require_once($CFG->dirroot.'/mnet/lib.php');
-        // Form the request url to hit the idp's jump.php
-        if (isset($mnetjumps[$user->mnethostid])) {
-            $MNETIDPJUMPURL = $mnetjumps[$user->mnethostid];
-        } else {
-            $idp = mnet_get_peer_host($user->mnethostid);
-            $idpjumppath = '/auth/mnet/jump.php';
-            $MNETIDPJUMPURL = $idp->wwwroot . $idpjumppath . '?hostwwwroot=' . $CFG->wwwroot . '&wantsurl=';
-            $mnetjumps[$user->mnethostid] = $MNETIDPJUMPURL;
-        }
+
+        $jumpurl = mnet_get_idp_jump_url($user);
+        $callback = partial('mnet_sso_apply_indirection', $jumpurl);
 
         $messagetext = preg_replace_callback("%($CFG->wwwroot[^[:space:]]*)%",
-                'mnet_sso_apply_indirection',
+                $callback,
                 $messagetext);
         $messagehtml = preg_replace_callback("%href=[\"'`]($CFG->wwwroot[\w_:\?=#&@/;.~-]*)[\"'`]%",
-                'mnet_sso_apply_indirection',
+                $callback,
                 $messagehtml);
     }
-    $mail =& get_mailer();
+    $mail = get_mailer();
 
     if (!empty($mail->SMTPDebug)) {
         echo '<pre>' . "\n";
     }
 
-/// We are going to use textlib services here
-    $textlib = textlib_get_instance();
+    $temprecipients = array();
+    $tempreplyto = array();
 
     $supportuser = generate_email_supportuser();
 
@@ -4289,23 +4666,23 @@ function email_to_user($user, $from, $subject, $messagetext, $messagehtml='', $a
         $mail->From     = $CFG->noreplyaddress;
         $mail->FromName = $from;
     } else if ($usetrueaddress and $from->maildisplay) {
-        $mail->From     = stripslashes($from->email);
+        $mail->From     = $from->email;
         $mail->FromName = fullname($from);
     } else {
         $mail->From     = $CFG->noreplyaddress;
         $mail->FromName = fullname($from);
         if (empty($replyto)) {
-            $mail->AddReplyTo($CFG->noreplyaddress,get_string('noreplyname'));
+            $tempreplyto[] = array($CFG->noreplyaddress, get_string('noreplyname'));
         }
     }
 
     if (!empty($replyto)) {
-        $mail->AddReplyTo($replyto,$replytoname);
+        $tempreplyto[] = array($replyto, $replytoname);
     }
 
-    $mail->Subject = substr(stripslashes($subject), 0, 900);
+    $mail->Subject = substr($subject, 0, 900);
 
-    $mail->AddAddress(stripslashes($user->email), fullname($user) );
+    $temprecipients[] = array($user->email, fullname($user));
 
     $mail->WordWrap = $wordwrapwidth;                   // set word wrap
 
@@ -4323,7 +4700,7 @@ function email_to_user($user, $from, $subject, $messagetext, $messagehtml='', $a
         $mail->Priority = $from->priority;
     }
 
-    if ($messagehtml && $user->mailformat == 1) { // Don't ever send HTML to users who don't want it
+    if ($messagehtml && !empty($user->mailformat) && $user->mailformat == 1) { // Don't ever send HTML to users who don't want it
         $mail->IsHTML(true);
         $mail->Encoding = 'quoted-printable';           // Encoding to use
         $mail->Body    =  $messagehtml;
@@ -4334,8 +4711,8 @@ function email_to_user($user, $from, $subject, $messagetext, $messagehtml='', $a
     }
 
     if ($attachment && $attachname) {
-        if (ereg( "\\.\\." ,$attachment )) {    // Security check for ".." in dir path
-            $mail->AddAddress($supportuser->email, fullname($supportuser, true) );
+        if (preg_match( "~\\.\\.~" ,$attachment )) {    // Security check for ".." in dir path
+            $temprecipients[] = array($supportuser->email, fullname($supportuser, true));
             $mail->AddStringAttachment('Error in attachment.  User attempted to attach a filename with a unsafe name.', 'error.txt', '8bit', 'text/plain');
         } else {
             require_once($CFG->libdir.'/filelib.php');
@@ -4344,39 +4721,44 @@ function email_to_user($user, $from, $subject, $messagetext, $messagehtml='', $a
         }
     }
 
-
-
-/// If we are running under Unicode and sitemailcharset or allowusermailcharset are set, convert the email
-/// encoding to the specified one
+    // Check if the email should be sent in an other charset then the default UTF-8
     if ((!empty($CFG->sitemailcharset) || !empty($CFG->allowusermailcharset))) {
-    /// Set it to site mail charset
+
+        // use the defined site mail charset or eventually the one preferred by the recipient
         $charset = $CFG->sitemailcharset;
-    /// Overwrite it with the user mail charset
         if (!empty($CFG->allowusermailcharset)) {
             if ($useremailcharset = get_user_preferences('mailcharset', '0', $user->id)) {
                 $charset = $useremailcharset;
             }
         }
-    /// If it has changed, convert all the necessary strings
+
+        // convert all the necessary strings if the charset is supported
         $charsets = get_list_of_charsets();
         unset($charsets['UTF-8']);
         if (in_array($charset, $charsets)) {
-        /// Save the new mail charset
+            $textlib = textlib_get_instance();
             $mail->CharSet = $charset;
-        /// And convert some strings
-            $mail->FromName = $textlib->convert($mail->FromName, 'utf-8', $mail->CharSet); //From Name
-            foreach ($mail->ReplyTo as $key => $rt) {                                      //ReplyTo Names
-                $mail->ReplyTo[$key][1] = $textlib->convert($rt[1], 'utf-8', $mail->CharSet);
+            $mail->FromName = $textlib->convert($mail->FromName, 'utf-8', strtolower($charset));
+            $mail->Subject  = $textlib->convert($mail->Subject, 'utf-8', strtolower($charset));
+            $mail->Body     = $textlib->convert($mail->Body, 'utf-8', strtolower($charset));
+            $mail->AltBody  = $textlib->convert($mail->AltBody, 'utf-8', strtolower($charset));
+
+            foreach ($temprecipients as $key => $values) {
+                $temprecipients[$key][1] = $textlib->convert($values[1], 'utf-8', strtolower($charset));
             }
-            $mail->Subject = $textlib->convert($mail->Subject, 'utf-8', $mail->CharSet);   //Subject
-            foreach ($mail->to as $key => $to) {
-                $mail->to[$key][1] = $textlib->convert($to[1], 'utf-8', $mail->CharSet);      //To Names
+            foreach ($tempreplyto as $key => $values) {
+                $tempreplyto[$key][1] = $textlib->convert($values[1], 'utf-8', strtolower($charset));
             }
-            $mail->Body = $textlib->convert($mail->Body, 'utf-8', $mail->CharSet);         //Body
-            $mail->AltBody = $textlib->convert($mail->AltBody, 'utf-8', $mail->CharSet);   //Subject
         }
     }
 
+    foreach ($temprecipients as $values) {
+        $mail->AddAddress($values[0], $values[1]);
+    }
+    foreach ($tempreplyto as $values) {
+        $mail->AddReplyTo($values[0], $values[1]);
+    }
+
     if ($mail->Send()) {
         set_send_count($user);
         $mail->IsSMTP();                               // use SMTP directly
@@ -4397,6 +4779,8 @@ function email_to_user($user, $from, $subject, $messagetext, $messagehtml='', $a
 /**
  * Generate a signoff for emails based on support settings
  *
+ * @global object
+ * @return string
  */
 function generate_email_signoff() {
     global $CFG;
@@ -4416,10 +4800,10 @@ function generate_email_signoff() {
 
 /**
  * Generate a fake user for emails based on support settings
- *
+ * @global object
+ * @return object user info
  */
 function generate_email_supportuser() {
-
     global $CFG;
 
     static $supportuser;
@@ -4428,7 +4812,7 @@ function generate_email_supportuser() {
         return $supportuser;
     }
 
-    $supportuser = new object;
+    $supportuser = new stdClass();
     $supportuser->email = $CFG->supportemail ? $CFG->supportemail : $CFG->noreplyaddress;
     $supportuser->firstname = $CFG->supportname ? $CFG->supportname : get_string('noreplyname');
     $supportuser->lastname = '';
@@ -4441,14 +4825,13 @@ function generate_email_supportuser() {
 /**
  * Sets specified user's password and send the new password to the user via email.
  *
- * @uses $CFG
+ * @global object
+ * @global object
  * @param user $user A {@link $USER} object
- * @return boolean|string Returns "true" if mail was sent OK, "emailstop" if email
- *          was blocked by user and "false" if there was another sort of error.
+ * @return boolean|string Returns "true" if mail was sent OK and "false" if there was an error
  */
 function setnew_password_and_mail($user) {
-
-    global $CFG;
+    global $CFG, $DB;
 
     $site  = get_site();
 
@@ -4456,12 +4839,9 @@ function setnew_password_and_mail($user) {
 
     $newpassword = generate_password();
 
-    if (! set_field('user', 'password', hash_internal_user_password($newpassword), 'id', $user->id) ) {
-        trigger_error('Could not set user password!');
-        return false;
-    }
+    $DB->set_field('user', 'password', hash_internal_user_password($newpassword), array('id'=>$user->id));
 
-    $a = new object();
+    $a = new stdClass();
     $a->firstname   = fullname($user, true);
     $a->sitename    = format_string($site->fullname);
     $a->username    = $user->username;
@@ -4473,6 +4853,7 @@ function setnew_password_and_mail($user) {
 
     $subject  = format_string($site->fullname) .': '. get_string('newusernewpasswordsubj');
 
+    //directly email rather than using the messaging system to ensure its not routed to a popup or jabber
     return email_to_user($user, $supportuser, $subject, $message);
 
 }
@@ -4480,13 +4861,10 @@ function setnew_password_and_mail($user) {
 /**
  * Resets specified user's password and send the new password to the user via email.
  *
- * @uses $CFG
- * @param user $user A {@link $USER} object
- * @return bool|string Returns "true" if mail was sent OK, "emailstop" if email
- *          was blocked by user and "false" if there was another sort of error.
+ * @param stdClass $user A {@link $USER} object
+ * @return bool Returns true if mail was sent OK and false if there was an error.
  */
 function reset_password_and_mail($user) {
-
     global $CFG;
 
     $site  = get_site();
@@ -4500,11 +4878,11 @@ function reset_password_and_mail($user) {
 
     $newpassword = generate_password();
 
-    if (!$userauth->user_update_password(addslashes_recursive($user), addslashes($newpassword))) {
-        error("Could not set user password!");
+    if (!$userauth->user_update_password($user, $newpassword)) {
+        print_error("cannotsetpassword");
     }
 
-    $a = new object();
+    $a = new stdClass();
     $a->firstname   = $user->firstname;
     $a->lastname    = $user->lastname;
     $a->sitename    = format_string($site->fullname);
@@ -4517,6 +4895,9 @@ function reset_password_and_mail($user) {
 
     $subject  = format_string($site->fullname) .': '. get_string('changedpassword');
 
+    unset_user_preference('create_password', $user); // prevent cron from generating the password
+
+    //directly email rather than using the messaging system to ensure its not routed to a popup or jabber
     return email_to_user($user, $supportuser, $subject, $message);
 
 }
@@ -4524,19 +4905,17 @@ function reset_password_and_mail($user) {
 /**
  * Send email to specified user with confirmation text and activation link.
  *
- * @uses $CFG
+ * @global object
  * @param user $user A {@link $USER} object
- * @return bool|string Returns "true" if mail was sent OK, "emailstop" if email
- *          was blocked by user and "false" if there was another sort of error.
+ * @return bool Returns true if mail was sent OK and false if there was an error.
  */
  function send_confirmation_email($user) {
-
     global $CFG;
 
     $site = get_site();
     $supportuser = generate_email_supportuser();
 
-    $data = new object();
+    $data = new stdClass();
     $data->firstname = fullname($user);
     $data->sitename = format_string($site->fullname);
     $data->admin = generate_email_signoff();
@@ -4549,6 +4928,7 @@ function reset_password_and_mail($user) {
 
     $user->mailformat = 1;  // Always send HTML version as well
 
+    //directly email rather than using the messaging system to ensure its not routed to a popup or jabber
     return email_to_user($user, $supportuser, $subject, $message, $messagehtml);
 
 }
@@ -4556,19 +4936,17 @@ function reset_password_and_mail($user) {
 /**
  * send_password_change_confirmation_email.
  *
- * @uses $CFG
+ * @global object
  * @param user $user A {@link $USER} object
- * @return bool|string Returns "true" if mail was sent OK, "emailstop" if email
- *          was blocked by user and "false" if there was another sort of error.
+ * @return bool Returns true if mail was sent OK and false if there was an error.
  */
 function send_password_change_confirmation_email($user) {
-
     global $CFG;
 
     $site = get_site();
     $supportuser = generate_email_supportuser();
 
-    $data = new object();
+    $data = new stdClass();
     $data->firstname = $user->firstname;
     $data->lastname  = $user->lastname;
     $data->sitename  = format_string($site->fullname);
@@ -4578,6 +4956,7 @@ function send_password_change_confirmation_email($user) {
     $message = get_string('emailpasswordconfirmation', '', $data);
     $subject = get_string('emailpasswordconfirmationsubject', '', format_string($site->fullname));
 
+    //directly email rather than using the messaging system to ensure its not routed to a popup or jabber
     return email_to_user($user, $supportuser, $subject, $message);
 
 }
@@ -4585,20 +4964,18 @@ function send_password_change_confirmation_email($user) {
 /**
  * send_password_change_info.
  *
- * @uses $CFG
+ * @global object
  * @param user $user A {@link $USER} object
- * @return bool|string Returns "true" if mail was sent OK, "emailstop" if email
- *          was blocked by user and "false" if there was another sort of error.
+ * @return bool Returns true if mail was sent OK and false if there was an error.
  */
 function send_password_change_info($user) {
-
     global $CFG;
 
     $site = get_site();
     $supportuser = generate_email_supportuser();
     $systemcontext = get_context_instance(CONTEXT_SYSTEM);
 
-    $data = new object();
+    $data = new stdClass();
     $data->firstname = $user->firstname;
     $data->lastname  = $user->lastname;
     $data->sitename = format_string($site->fullname);
@@ -4609,6 +4986,7 @@ function send_password_change_info($user) {
     if (!is_enabled_auth($user->auth) or $user->auth == 'nologin') {
         $message = get_string('emailpasswordchangeinfodisabled', '', $data);
         $subject = get_string('emailpasswordchangeinfosubject', '', format_string($site->fullname));
+        //directly email rather than using the messaging system to ensure its not routed to a popup or jabber
         return email_to_user($user, $supportuser, $subject, $message);
     }
 
@@ -4629,6 +5007,7 @@ function send_password_change_info($user) {
         $subject = get_string('emailpasswordchangeinfosubject', '', format_string($site->fullname));
     }
 
+    //directly email rather than using the messaging system to ensure its not routed to a popup or jabber
     return email_to_user($user, $supportuser, $subject, $message);
 
 }
@@ -4637,12 +5016,11 @@ function send_password_change_info($user) {
  * Check that an email is allowed.  It returns an error message if there
  * was a problem.
  *
- * @uses $CFG
+ * @global object
  * @param  string $email Content of email
  * @return string|false
  */
 function email_is_not_allowed($email) {
-
     global $CFG;
 
     if (!empty($CFG->allowemailaddresses)) {
@@ -4686,139 +5064,93 @@ function email_is_not_allowed($email) {
     return false;
 }
 
-function email_welcome_message_to_user($course, $user=NULL) {
-    global $CFG, $USER;
-
-    if (isset($CFG->sendcoursewelcomemessage) and !$CFG->sendcoursewelcomemessage) {
-        return;
-    }
-
-    if (empty($user)) {
-        if (!isloggedin()) {
-            return false;
-        }
-        $user = $USER;
-    }
-
-    if (!empty($course->welcomemessage)) {
-        $message = $course->welcomemessage;
-    } else {
-        $a = new Object();
-        $a->coursename = $course->fullname;
-        $a->profileurl = "$CFG->wwwroot/user/view.php?id=$user->id&course=$course->id";
-        $message = get_string("welcometocoursetext", "", $a);
-    }
-
-    /// If you don't want a welcome message sent, then make the message string blank.
-    if (!empty($message)) {
-        $subject = get_string('welcometocourse', '', format_string($course->fullname));
-
-        if (! $teacher = get_teacher($course->id)) {
-            $teacher = get_admin();
-        }
-        email_to_user($user, $teacher, $subject, $message);
-    }
-}
-
 /// FILE HANDLING  /////////////////////////////////////////////
 
-
 /**
- * Makes an upload directory for a particular module.
+ * Returns local file storage instance
  *
- * @uses $CFG
- * @param int $courseid The id of the course in question - maps to id field of 'course' table.
- * @return string|false Returns full path to directory if successful, false if not
+ * @return file_storage
  */
-function make_mod_upload_directory($courseid) {
+function get_file_storage() {
     global $CFG;
 
-    if (! $moddata = make_upload_directory($courseid .'/'. $CFG->moddata)) {
-        return false;
+    static $fs = null;
+
+    if ($fs) {
+        return $fs;
     }
 
-    $strreadme = get_string('readme');
+    require_once("$CFG->libdir/filelib.php");
+
+    if (isset($CFG->filedir)) {
+        $filedir = $CFG->filedir;
+    } else {
+        $filedir = $CFG->dataroot.'/filedir';
+    }
 
-    if (file_exists($CFG->dirroot .'/lang/'. $CFG->lang .'/docs/module_files.txt')) {
-        copy($CFG->dirroot .'/lang/'. $CFG->lang .'/docs/module_files.txt', $moddata .'/'. $strreadme .'.txt');
+    if (isset($CFG->trashdir)) {
+        $trashdirdir = $CFG->trashdir;
     } else {
-        copy($CFG->dirroot .'/lang/en_utf8/docs/module_files.txt', $moddata .'/'. $strreadme .'.txt');
+        $trashdirdir = $CFG->dataroot.'/trashdir';
     }
-    return $moddata;
+
+    $fs = new file_storage($filedir, $trashdirdir, "$CFG->dataroot/temp/filestorage", $CFG->directorypermissions, $CFG->filepermissions);
+
+    return $fs;
 }
 
 /**
- * Makes a directory for a particular user.
+ * Returns local file storage instance
  *
- * @uses $CFG
- * @param int $userid The id of the user in question - maps to id field of 'user' table.
- * @param bool $test Whether we are only testing the return value (do not create the directory)
- * @return string|false Returns full path to directory if successful, false if not
+ * @return file_browser
  */
-function make_user_directory($userid, $test=false) {
+function get_file_browser() {
     global $CFG;
 
-    if (is_bool($userid) || $userid < 0 || !ereg('^[0-9]{1,10}$', $userid) || $userid > 2147483647) {
-        if (!$test) {
-            notify("Given userid was not a valid integer! (" . gettype($userid) . " $userid)");
-        }
-        return false;
+    static $fb = null;
+
+    if ($fb) {
+        return $fb;
     }
 
-    // Generate a two-level path for the userid. First level groups them by slices of 1000 users, second level is userid
-    $level1 = floor($userid / 1000) * 1000;
+    require_once("$CFG->libdir/filelib.php");
 
-    $userdir = "user/$level1/$userid";
-    if ($test) {
-        return $CFG->dataroot . '/' . $userdir;
-    } else {
-        return make_upload_directory($userdir);
-    }
+    $fb = new file_browser();
+
+    return $fb;
 }
 
 /**
- * Returns an array of full paths to user directories, indexed by their userids.
+ * Returns file packer
  *
- * @param bool $only_non_empty Only return directories that contain files
- * @param bool $legacy Search for user directories in legacy location (dataroot/users/userid) instead of (dataroot/user/section/userid)
- * @return array An associative array: userid=>array(basedir => $basedir, userfolder => $userfolder)
+ * @param string $mimetype default application/zip
+ * @return file_packer
  */
-function get_user_directories($only_non_empty=true, $legacy=false) {
+function get_file_packer($mimetype='application/zip') {
     global $CFG;
 
-    $rootdir = $CFG->dataroot."/user";
+    static $fp = array();;
 
-    if ($legacy) {
-        $rootdir = $CFG->dataroot."/users";
+    if (isset($fp[$mimetype])) {
+        return $fp[$mimetype];
     }
-    $dirlist = array();
 
-    //Check if directory exists
-    if (check_dir_exists($rootdir, true)) {
-        if ($legacy) {
-            if ($userlist = get_directory_list($rootdir, '', true, true, false)) {
-                foreach ($userlist as $userid) {
-                    $dirlist[$userid] = array('basedir' => $rootdir, 'userfolder' => $userid);
-                }
-            } else {
-                notify("no directories found under $rootdir");
-            }
-        } else {
-            if ($grouplist =get_directory_list($rootdir, '', true, true, false)) { // directories will be in the form 0, 1000, 2000 etc...
-                foreach ($grouplist as $group) {
-                    if ($userlist = get_directory_list("$rootdir/$group", '', true, true, false)) {
-                        foreach ($userlist as $userid) {
-                            $dirlist[$userid] = array('basedir' => $rootdir, 'userfolder' => $group . '/' . $userid);
-                        }
-                    }
-                }
-            }
-        }
-    } else {
-        notify("$rootdir does not exist!");
+    switch ($mimetype) {
+        case 'application/zip':
+        case 'application/vnd.moodle.backup':
+            $classname = 'zip_packer';
+            break;
+        case 'application/x-tar':
+//            $classname = 'tar_packer';
+//            break;
+        default:
         return false;
     }
-    return $dirlist;
+
+    require_once("$CFG->libdir/filestorage/$classname.php");
+    $fp[$mimetype] = new $classname();
+
+    return $fp[$mimetype];
 }
 
 /**
@@ -4854,11 +5186,12 @@ function valid_uploaded_file($newfile) {
  * Anything defined as 0 is ignored.
  * The smallest of all the non-zero numbers is returned.
  *
- * @param int $sizebytes ?
+ * @todo Finish documenting this function
+ *
+ * @param int $sizebytes Set maximum size
  * @param int $coursebytes Current course $course->maxbytes (in bytes)
  * @param int $modulebytes Current module ->maxbytes (in bytes)
  * @return int The maximum size for uploading files.
- * @todo Finish documenting this function
  */
 function get_max_upload_file_size($sitebytes=0, $coursebytes=0, $modulebytes=0) {
 
@@ -4890,16 +5223,20 @@ function get_max_upload_file_size($sitebytes=0, $coursebytes=0, $modulebytes=0)
 }
 
 /**
+ * Returns an array of possible sizes in local language
+ *
  * Related to {@link get_max_upload_file_size()} - this function returns an
  * array of possible sizes in an array, translated to the
  * local language.
  *
+ * @todo Finish documenting this function
+ *
+ * @global object
  * @uses SORT_NUMERIC
- * @param int $sizebytes ?
+ * @param int $sizebytes Set maximum size
  * @param int $coursebytes Current course $course->maxbytes (in bytes)
  * @param int $modulebytes Current module ->maxbytes (in bytes)
- * @return int
- * @todo Finish documenting this function
+ * @return array
  */
 function get_max_upload_sizes($sitebytes=0, $coursebytes=0, $modulebytes=0) {
     global $CFG;
@@ -4908,19 +5245,20 @@ function get_max_upload_sizes($sitebytes=0, $coursebytes=0, $modulebytes=0) {
         return array();
     }
 
-    $filesize[$maxsize] = display_size($maxsize);
+    $filesize[intval($maxsize)] = display_size($maxsize);
 
     $sizelist = array(10240, 51200, 102400, 512000, 1048576, 2097152,
                       5242880, 10485760, 20971520, 52428800, 104857600);
 
     // Allow maxbytes to be selected if it falls outside the above boundaries
-    if( isset($CFG->maxbytes) && !in_array($CFG->maxbytes, $sizelist) ){
-            $sizelist[] = $CFG->maxbytes;
+    if (isset($CFG->maxbytes) && !in_array(get_real_size($CFG->maxbytes), $sizelist)) {
+        // note: get_real_size() is used in order to prevent problems with invalid values
+        $sizelist[] = get_real_size($CFG->maxbytes);
     }
 
     foreach ($sizelist as $sizebytes) {
        if ($sizebytes < $maxsize) {
-           $filesize[$sizebytes] = display_size($sizebytes);
+           $filesize[intval($sizebytes)] = display_size($sizebytes);
        }
     }
 
@@ -4930,139 +5268,41 @@ function get_max_upload_sizes($sitebytes=0, $coursebytes=0, $modulebytes=0) {
 }
 
 /**
- * If there has been an error uploading a file, print the appropriate error message
- * Numerical constants used as constant definitions not added until PHP version 4.2.0
+ * Returns an array with all the filenames in all subdirectories, relative to the given rootdir.
+ *
+ * If excludefiles is defined, then that file/directory is ignored
+ * If getdirs is true, then (sub)directories are included in the output
+ * If getfiles is true, then files are included in the output
+ * (at least one of these must be true!)
  *
- * $filearray is a 1-dimensional sub-array of the $_FILES array
- * eg $filearray = $_FILES['userfile1']
- * If left empty then the first element of the $_FILES array will be used
+ * @todo Finish documenting this function. Add examples of $excludefile usage.
  *
- * @uses $_FILES
- * @param array $filearray  A 1-dimensional sub-array of the $_FILES array
- * @param bool $returnerror If true then a string error message will be returned. Otherwise the user will be notified of the error in a notify() call.
- * @return bool|string
+ * @param string $rootdir A given root directory to start from
+ * @param string|array $excludefile If defined then the specified file/directory is ignored
+ * @param bool $descend If true then subdirectories are recursed as well
+ * @param bool $getdirs If true then (sub)directories are included in the output
+ * @param bool $getfiles  If true then files are included in the output
+ * @return array An array with all the filenames in
+ * all subdirectories, relative to the given rootdir
  */
-function print_file_upload_error($filearray = '', $returnerror = false) {
-
-    if ($filearray == '' or !isset($filearray['error'])) {
+function get_directory_list($rootdir, $excludefiles='', $descend=true, $getdirs=false, $getfiles=true) {
 
-        if (empty($_FILES)) return false;
+    $dirs = array();
 
-        $files = $_FILES; /// so we don't mess up the _FILES array for subsequent code
-        $filearray = array_shift($files); /// use first element of array
+    if (!$getdirs and !$getfiles) {   // Nothing to show
+        return $dirs;
     }
 
-    switch ($filearray['error']) {
-
-        case 0: // UPLOAD_ERR_OK
-            if ($filearray['size'] > 0) {
-                $errmessage = get_string('uploadproblem', $filearray['name']);
-            } else {
-                $errmessage = get_string('uploadnofilefound'); /// probably a dud file name
+    if (!is_dir($rootdir)) {          // Must be a directory
+        return $dirs;
             }
-            break;
-
-        case 1: // UPLOAD_ERR_INI_SIZE
-            $errmessage = get_string('uploadserverlimit');
-            break;
-
-        case 2: // UPLOAD_ERR_FORM_SIZE
-            $errmessage = get_string('uploadformlimit');
-            break;
-
-        case 3: // UPLOAD_ERR_PARTIAL
-            $errmessage = get_string('uploadpartialfile');
-            break;
 
-        case 4: // UPLOAD_ERR_NO_FILE
-            $errmessage = get_string('uploadnofilefound');
-            break;
-
-        default:
-            $errmessage = get_string('uploadproblem', $filearray['name']);
+    if (!$dir = opendir($rootdir)) {  // Can't open it for some reason
+        return $dirs;
     }
 
-    if ($returnerror) {
-        return $errmessage;
-    } else {
-        notify($errmessage);
-        return true;
-    }
-
-}
-
-/**
- * handy function to loop through an array of files and resolve any filename conflicts
- * both in the array of filenames and for what is already on disk.
- * not really compatible with the similar function in uploadlib.php
- * but this could be used for files/index.php for moving files around.
- */
-
-function resolve_filename_collisions($destination,$files,$format='%s_%d.%s') {
-    foreach ($files as $k => $f) {
-        if (check_potential_filename($destination,$f,$files)) {
-            $bits = explode('.', $f);
-            for ($i = 1; true; $i++) {
-                $try = sprintf($format, $bits[0], $i, $bits[1]);
-                if (!check_potential_filename($destination,$try,$files)) {
-                    $files[$k] = $try;
-                    break;
-                }
-            }
-        }
-    }
-    return $files;
-}
-
-/**
- * @used by resolve_filename_collisions
- */
-function check_potential_filename($destination,$filename,$files) {
-    if (file_exists($destination.'/'.$filename)) {
-        return true;
-    }
-    if (count(array_keys($files,$filename)) > 1) {
-        return true;
-    }
-    return false;
-}
-
-
-/**
- * Returns an array with all the filenames in
- * all subdirectories, relative to the given rootdir.
- * If excludefile is defined, then that file/directory is ignored
- * If getdirs is true, then (sub)directories are included in the output
- * If getfiles is true, then files are included in the output
- * (at least one of these must be true!)
- *
- * @param string $rootdir  ?
- * @param string $excludefile  If defined then the specified file/directory is ignored
- * @param bool $descend  ?
- * @param bool $getdirs  If true then (sub)directories are included in the output
- * @param bool $getfiles  If true then files are included in the output
- * @return array An array with all the filenames in
- * all subdirectories, relative to the given rootdir
- * @todo Finish documenting this function. Add examples of $excludefile usage.
- */
-function get_directory_list($rootdir, $excludefiles='', $descend=true, $getdirs=false, $getfiles=true) {
-
-    $dirs = array();
-
-    if (!$getdirs and !$getfiles) {   // Nothing to show
-        return $dirs;
-    }
-
-    if (!is_dir($rootdir)) {          // Must be a directory
-        return $dirs;
-    }
-
-    if (!$dir = opendir($rootdir)) {  // Can't open it for some reason
-        return $dirs;
-    }
-
-    if (!is_array($excludefiles)) {
-        $excludefiles = array($excludefiles);
+    if (!is_array($excludefiles)) {
+        $excludefiles = array($excludefiles);
     }
 
     while (false !== ($file = readdir($dir))) {
@@ -5096,13 +5336,13 @@ function get_directory_list($rootdir, $excludefiles='', $descend=true, $getdirs=
 /**
  * Adds up all the files in a directory and works out the size.
  *
- * @param string $rootdir  ?
- * @param string $excludefile  ?
- * @return array
  * @todo Finish documenting this function
+ *
+ * @param string $rootdir  The directory to start from
+ * @param string $excludefile A file to exclude when summing directory size
+ * @return int The summed size of all files and subfiles within the root directory
  */
 function get_directory_size($rootdir, $excludefile='') {
-
     global $CFG;
 
     // do it this way if we can, it's much faster
@@ -5146,13 +5386,14 @@ function get_directory_size($rootdir, $excludefile='') {
 /**
  * Converts bytes into display form
  *
- * @param string $size  ?
- * @return string
+ * @todo Finish documenting this function. Verify return type.
+ *
  * @staticvar string $gb Localized string for size in gigabytes
  * @staticvar string $mb Localized string for size in megabytes
  * @staticvar string $kb Localized string for size in kilobytes
  * @staticvar string $b Localized string for size in bytes
- * @todo Finish documenting this function. Verify return type.
+ * @param int $size  The size to convert to human readable form
+ * @return string
  */
 function display_size($size) {
 
@@ -5172,35 +5413,21 @@ function display_size($size) {
     } else if ($size >= 1024) {
         $size = round($size / 1024 * 10) / 10 . $kb;
     } else {
-        $size = $size .' '. $b;
+        $size = intval($size) .' '. $b; // file sizes over 2GB can not work in 32bit PHP anyway
     }
     return $size;
 }
 
 /**
  * Cleans a given filename by removing suspicious or troublesome characters
- * Only these are allowed: alphanumeric _ - .
- * Unicode characters can be enabled by setting $CFG->unicodecleanfilename = true in config.php
- *
- * WARNING: unicode characters may not be compatible with zip compression in backup/restore,
- *          because native zip binaries do weird character conversions. Use PHP zipping instead.
+ * @see clean_param()
  *
+ * @uses PARAM_FILE
  * @param string $string  file name
  * @return string cleaned file name
  */
 function clean_filename($string) {
-    global $CFG;
-    if (empty($CFG->unicodecleanfilename)) {
-        $textlib = textlib_get_instance();
-        $string = $textlib->specialtoascii($string);
-        $string = preg_replace('/[^\.a-zA-Z\d\_-]/','_', $string ); // only allowed chars
-    } else {
-        //clean only ascii range
-        $string = preg_replace("/[\\000-\\x2c\\x2f\\x3a-\\x40\\x5b-\\x5e\\x60\\x7b-\\177]/s", '_', $string);
-    }
-    $string = preg_replace("/_+/", '_', $string);
-    $string = preg_replace("/\.\.+/", '.', $string);
-    return $string;
+    return clean_param($string, PARAM_FILE);
 }
 
 
@@ -5209,9 +5436,6 @@ function clean_filename($string) {
 /**
  * Returns the code for the current language
  *
- * @uses $CFG
- * @param $USER
- * @param $SESSION
  * @return string
  */
 function current_language() {
@@ -5226,549 +5450,1109 @@ function current_language() {
     } else if (!empty($USER->lang)) {
         $return = $USER->lang;
 
-    } else {
+    } else if (isset($CFG->lang)) {
         $return = $CFG->lang;
-    }
 
-    if ($return == 'en') {
-        $return = 'en_utf8';
+    } else {
+        $return = 'en';
     }
 
+    $return = str_replace('_utf8', '', $return);  // Just in case this slipped in from somewhere by accident
+
     return $return;
 }
 
 /**
- * Prints out a translated string.
- *
- * Prints out a translated string using the return value from the {@link get_string()} function.
- *
- * Example usage of this function when the string is in the moodle.php file:<br/>
- * <code>
- * echo '<strong>';
- * print_string('wordforstudent');
- * echo '</strong>';
- * </code>
- *
- * Example usage of this function when the string is not in the moodle.php file:<br/>
- * <code>
- * echo '<h1>';
- * print_string('typecourse', 'calendar');
- * echo '</h1>';
- * </code>
+ * Returns parent language of current active language if defined
  *
- * @param string $identifier The key identifier for the localized string
- * @param string $module The module where the key identifier is stored. If none is specified then moodle.php is used.
- * @param mixed $a An object, string or number that can be used
- * within translation strings
+ * @uses COURSE
+ * @uses SESSION
+ * @param string $lang null means current language
+ * @return string
  */
-function print_string($identifier, $module='', $a=NULL) {
-    echo get_string($identifier, $module, $a);
-}
+function get_parent_language($lang=null) {
+    global $COURSE, $SESSION;
 
-/**
- * fix up the optional data in get_string()/print_string() etc
- * ensure possible sprintf() format characters are escaped correctly
- * needs to handle arbitrary strings and objects
- * @param mixed $a An object, string or number that can be used
- * @return mixed the supplied parameter 'cleaned'
- */
-function clean_getstring_data( $a ) {
-    if (is_string($a)) {
-        return str_replace( '%','%%',$a );
+    //let's hack around the current language
+    if (!empty($lang)) {
+        $old_course_lang  = empty($COURSE->lang) ? '' : $COURSE->lang;
+        $old_session_lang = empty($SESSION->lang) ? '' : $SESSION->lang;
+        $COURSE->lang  = '';
+        $SESSION->lang = $lang;
     }
-    elseif (is_object($a)) {
-        $a_vars = get_object_vars( $a );
-        $new_a_vars = array();
-        foreach ($a_vars as $fname => $a_var) {
-            $new_a_vars[$fname] = clean_getstring_data( $a_var );
-        }
-        return (object)$new_a_vars;
+
+    $parentlang = get_string('parentlanguage', 'langconfig');
+    if ($parentlang === 'en') {
+        $parentlang = '';
     }
-    else {
-        return $a;
+
+    //let's hack around the current language
+    if (!empty($lang)) {
+        $COURSE->lang  = $old_course_lang;
+        $SESSION->lang = $old_session_lang;
     }
+
+    return $parentlang;
 }
 
 /**
- * @return array places to look for lang strings based on the prefix to the
- * module name. For example qtype_ in question/type. Used by get_string and
- * help.php.
+ * Returns current string_manager instance.
+ *
+ * The param $forcereload is needed for CLI installer only where the string_manager instance
+ * must be replaced during the install.php script life time.
+ *
+ * @param bool $forcereload shall the singleton be released and new instance created instead?
+ * @return string_manager
  */
-function places_to_search_for_lang_strings() {
+function get_string_manager($forcereload=false) {
     global $CFG;
 
-    return array(
-        '__exceptions' => array('moodle', 'langconfig'),
-        'assignment_' => array('mod/assignment/type'),
-        'auth_' => array('auth'),
-        'block_' => array('blocks'),
-        'datafield_' => array('mod/data/field'),
-        'datapreset_' => array('mod/data/preset'),
-        'enrol_' => array('enrol'),
-        'filter_' => array('filter'),
-        'format_' => array('course/format'),
-        'qtype_' => array('question/type'),
-        'report_' => array($CFG->admin.'/report', 'course/report', 'mod/quiz/report'),
-        'resource_' => array('mod/resource/type'),
-        'gradereport_' => array('grade/report'),
-        'gradeimport_' => array('grade/import'),
-        'gradeexport_' => array('grade/export'),
-        'qformat_' => array('question/format'),
-        'profilefield_' => array('user/profile/field'),
-        '' => array('mod')
-    );
+    static $singleton = null;
+
+    if ($forcereload) {
+        $singleton = null;
+    }
+    if ($singleton === null) {
+        if (empty($CFG->early_install_lang)) {
+
+            if (empty($CFG->langcacheroot)) {
+                $langcacheroot = $CFG->dataroot . '/cache/lang';
+            } else {
+                $langcacheroot = $CFG->langcacheroot;
+            }
+
+            if (empty($CFG->langlist)) {
+                 $translist = array();
+            } else {
+                $translist = explode(',', $CFG->langlist);
+            }
+
+            if (empty($CFG->langmenucachefile)) {
+                $langmenucache = $CFG->dataroot . '/cache/languages';
+            } else {
+                $langmenucache = $CFG->langmenucachefile;
+            }
+
+            $singleton = new core_string_manager($CFG->langotherroot, $CFG->langlocalroot, $langcacheroot,
+                                                 !empty($CFG->langstringcache), $translist, $langmenucache);
+
+        } else {
+            $singleton = new install_string_manager();
+        }
+    }
+
+    return $singleton;
 }
 
+
 /**
- * Returns a localized string.
+ * Interface describing class which is responsible for getting
+ * of localised strings from language packs.
  *
- * Returns the translated string specified by $identifier as
- * for $module.  Uses the same format files as STphp.
- * $a is an object, string or number that can be used
+ * @package    moodlecore
+ * @copyright  2010 Petr Skoda (http://skodak.org)
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+interface string_manager {
+    /**
+     * Get String returns a requested string
+     *
+     * @param string $identifier The identifier of the string to search for
+     * @param string $component The module the string is associated with
+     * @param string|object|array $a An object, string or number that can be used
  * within translation strings
+     * @param string $lang moodle translation language, NULL means use current
+     * @return string The String !
+     */
+    public function get_string($identifier, $component = '', $a = NULL, $lang = NULL);
+
+    /**
+     * Does the string actually exist?
  *
- * eg "hello \$a->firstname \$a->lastname"
- * or "hello \$a"
+     * get_string() is throwing debug warnings, sometimes we do not want them
+     * or we want to display better explanation of the problem.
  *
- * If you would like to directly echo the localized string use
- * the function {@link print_string()}
+     * Use with care!
  *
- * Example usage of this function involves finding the string you would
- * like a local equivalent of and using its identifier and module information
- * to retrive it.<br/>
- * If you open moodle/lang/en/moodle.php and look near line 1031
- * you will find a string to prompt a user for their word for student
- * <code>
- * $string['wordforstudent'] = 'Your word for Student';
- * </code>
- * So if you want to display the string 'Your word for student'
- * in any language that supports it on your site
- * you just need to use the identifier 'wordforstudent'
- * <code>
- * $mystring = '<strong>'. get_string('wordforstudent') .'</strong>';
-or
- * </code>
- * If the string you want is in another file you'd take a slightly
- * different approach. Looking in moodle/lang/en/calendar.php you find
- * around line 75:
- * <code>
- * $string['typecourse'] = 'Course event';
- * </code>
- * If you want to display the string "Course event" in any language
- * supported you would use the identifier 'typecourse' and the module 'calendar'
- * (because it is in the file calendar.php):
- * <code>
- * $mystring = '<h1>'. get_string('typecourse', 'calendar') .'</h1>';
- * </code>
+     * @param string $identifier The identifier of the string to search for
+     * @param string $component The module the string is associated with
+     * @return boot true if exists
+     */
+    public function string_exists($identifier, $component);
+
+    /**
+     * Returns a localised list of all country names, sorted by country keys.
+     * @param bool $returnall return all or just enabled
+     * @param string $lang moodle translation language, NULL means use current
+     * @return array two-letter country code => translated name.
+     */
+    public function get_list_of_countries($returnall = false, $lang = NULL);
+
+    /**
+     * Returns a localised list of languages, sorted by code keys.
  *
- * As a last resort, should the identifier fail to map to a string
- * the returned string will be [[ $identifier ]]
+     * @param string $lang moodle translation language, NULL means use current
+     * @param string $standard language list standard
+     *                     iso6392: three-letter language code (ISO 639-2/T) => translated name.
+     * @return array language code => translated name
+     */
+    public function get_list_of_languages($lang = NULL, $standard = 'iso6392');
+
+    /**
+     * Does the translation exist?
  *
- * @uses $CFG
- * @param string $identifier The key identifier for the localized string
- * @param string $module The module where the key identifier is stored, usually expressed as the filename in the language pack without the .php on the end but can also be written as mod/forum or grade/export/xls.  If none is specified then moodle.php is used.
- * @param mixed $a An object, string or number that can be used
- * within translation strings
- * @param array $extralocations An array of strings with other locations to look for string files
- * @return string The localized string.
+     * @param string $lang moodle translation language code
+     * @param bool include also disabled translations?
+     * @return boot true if exists
  */
-function get_string($identifier, $module='', $a=NULL, $extralocations=NULL) {
+    public function translation_exists($lang, $includeall = true);
 
-    global $CFG;
+    /**
+     * Returns localised list of installed translations
+     * @param bool $returnall return all or just enabled
+     * @return array moodle translation code => localised translation name
+     */
+    public function get_list_of_translations($returnall = false);
+
+    /**
+     * Returns localised list of currencies.
+     *
+     * @param string $lang moodle translation language, NULL means use current
+     * @return array currency code => localised currency name
+     */
+    public function get_list_of_currencies($lang = NULL);
+
+    /**
+     * Load all strings for one component
+     * @param string $component The module the string is associated with
+     * @param string $lang
+     * @param bool $disablecache Do not use caches, force fetching the strings from sources
+     * @param bool $disablelocal Do not use customized strings in xx_local language packs
+     * @return array of all string for given component and lang
+     */
+    public function load_component_strings($component, $lang, $disablecache=false, $disablelocal=false);
 
-/// originally these special strings were stored in moodle.php now we are only in langconfig.php
-    $langconfigstrs = array('alphabet', 'backupnameformat', 'decsep', 'firstdayofweek', 'listsep', 'locale',
-                            'localewin', 'localewincharset', 'oldcharset',
-                            'parentlanguage', 'strftimedate', 'strftimedateshort', 'strftimedatetime',
-                            'strftimedaydate', 'strftimedaydatetime', 'strftimedayshort', 'strftimedaytime',
-                            'strftimemonthyear', 'strftimerecent', 'strftimerecentfull', 'strftimetime',
-                            'thischarset', 'thisdirection', 'thislanguage', 'strftimedatetimeshort', 'thousandssep');
+    /**
+     * Invalidates all caches, should the implementation use any
+     */
+    public function reset_caches();
+}
 
-    $filetocheck = 'langconfig.php';
-    $defaultlang = 'en_utf8';
-    if (in_array($identifier, $langconfigstrs)) {
-        $module = 'langconfig';  //This strings are under langconfig.php for 1.6 lang packs
+
+/**
+ * Standard string_manager implementation
+ *
+ * @package    moodlecore
+ * @copyright  2010 Petr Skoda (http://skodak.org)
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class core_string_manager implements string_manager {
+    /** @var string location of all packs except 'en' */
+    protected $otherroot;
+    /** @var string location of all lang pack local modifications */
+    protected $localroot;
+    /** @var string location of on-disk cache of merged strings */
+    protected $cacheroot;
+    /** @var array lang string cache - it will be optimised more later */
+    protected $cache = array();
+    /** @var int get_string() counter */
+    protected $countgetstring = 0;
+    /** @var int in-memory cache hits counter */
+    protected $countmemcache = 0;
+    /** @var int on-disk cache hits counter */
+    protected $countdiskcache = 0;
+    /** @var bool use disk cache */
+    protected $usediskcache;
+    /* @var array limit list of translations */
+    protected $translist;
+    /** @var string location of a file that caches the list of available translations */
+    protected $menucache;
+
+    /**
+     * Create new instance of string manager
+     *
+     * @param string $otherroot location of downlaoded lang packs - usually $CFG->dataroot/lang
+     * @param string $localroot usually the same as $otherroot
+     * @param string $cacheroot usually lang dir in cache folder
+     * @param bool $usediskcache use disk cache
+     * @param array $translist limit list of visible translations
+     * @param string $menucache the location of a file that caches the list of available translations
+     */
+    public function __construct($otherroot, $localroot, $cacheroot, $usediskcache, $translist, $menucache) {
+        $this->otherroot    = $otherroot;
+        $this->localroot    = $localroot;
+        $this->cacheroot    = $cacheroot;
+        $this->usediskcache = $usediskcache;
+        $this->translist    = $translist;
+        $this->menucache    = $menucache;
     }
 
-    $lang = current_language();
+    /**
+     * Returns dependencies of current language, en is not included.
+     * @param string $lang
+     * @return array all parents, the lang itself is last
+     */
+    public function get_language_dependencies($lang) {
+        if ($lang === 'en') {
+            return array();
+        }
+        if (!file_exists("$this->otherroot/$lang/langconfig.php")) {
+            return array();
+        }
+        $string = array();
+        include("$this->otherroot/$lang/langconfig.php");
 
-    if ($module == '') {
-        $module = 'moodle';
+        if (empty($string['parentlanguage'])) {
+            return array($lang);
+        } else {
+            $parentlang = $string['parentlanguage'];
+            unset($string);
+            return array_merge($this->get_language_dependencies($parentlang), array($lang));
+        }
     }
 
-/// If the "module" is actually a pathname, then automatically derive the proper module name
-    if (strpos($module, '/') !== false) {
-        $modulepath = split('/', $module);
+    /**
+     * Load all strings for one component
+     * @param string $component The module the string is associated with
+     * @param string $lang
+     * @param bool $disablecache Do not use caches, force fetching the strings from sources
+     * @param bool $disablelocal Do not use customized strings in xx_local language packs
+     * @return array of all string for given component and lang
+     */
+    public function load_component_strings($component, $lang, $disablecache=false, $disablelocal=false) {
+        global $CFG;
 
-        switch ($modulepath[0]) {
+        list($plugintype, $pluginname) = normalize_component($component);
+        if ($plugintype == 'core' and is_null($pluginname)) {
+            $component = 'core';
+        } else {
+            $component = $plugintype . '_' . $pluginname;
+        }
 
-            case 'mod':
-                $module = $modulepath[1];
-            break;
+        if (!$disablecache) {
+            // try in-memory cache first
+            if (isset($this->cache[$lang][$component])) {
+                $this->countmemcache++;
+                return $this->cache[$lang][$component];
+            }
 
-            case 'blocks':
-            case 'block':
-                $module = 'block_'.$modulepath[1];
-            break;
+            // try on-disk cache then
+            if ($this->usediskcache and file_exists($this->cacheroot . "/$lang/$component.php")) {
+                $this->countdiskcache++;
+                include($this->cacheroot . "/$lang/$component.php");
+                return $this->cache[$lang][$component];
+            }
+        }
 
-            case 'enrol':
-                $module = 'enrol_'.$modulepath[1];
-            break;
+        // no cache found - let us merge all possible sources of the strings
+        if ($plugintype === 'core') {
+            $file = $pluginname;
+            if ($file === null) {
+                $file = 'moodle';
+            }
+            $string = array();
+            // first load english pack
+            if (!file_exists("$CFG->dirroot/lang/en/$file.php")) {
+                return array();
+            }
+            include("$CFG->dirroot/lang/en/$file.php");
+            $originalkeys = array_keys($string);
+            $originalkeys = array_flip($originalkeys);
 
-            case 'format':
-                $module = 'format_'.$modulepath[1];
-            break;
+            // and then corresponding local if present and allowed
+            if (!$disablelocal and file_exists("$this->localroot/en_local/$file.php")) {
+                include("$this->localroot/en_local/$file.php");
+            }
+            // now loop through all langs in correct order
+            $deps = $this->get_language_dependencies($lang);
+            foreach ($deps as $dep) {
+                // the main lang string location
+                if (file_exists("$this->otherroot/$dep/$file.php")) {
+                    include("$this->otherroot/$dep/$file.php");
+                }
+                if (!$disablelocal and file_exists("$this->localroot/{$dep}_local/$file.php")) {
+                    include("$this->localroot/{$dep}_local/$file.php");
+                }
+            }
 
-            case 'grade':
-                $module = 'grade'.$modulepath[1].'_'.$modulepath[2];
-            break;
+        } else {
+            if (!$location = get_plugin_directory($plugintype, $pluginname) or !is_dir($location)) {
+                return array();
+            }
+            if ($plugintype === 'mod') {
+                // bloody mod hack
+                $file = $pluginname;
+            } elseif (strncmp($plugintype, 'elis:', 5) === 0) {
+                $file = $pluginname;
+            } else {
+                $file = $plugintype . '_' . $pluginname;
+            }
+            $string = array();
+            // first load English pack
+            if (!file_exists("$location/lang/en/$file.php")) {
+                //English pack does not exist, so do not try to load anything else
+                return array();
         }
+            include("$location/lang/en/$file.php");
+            $originalkeys = array_keys($string);
+            $originalkeys = array_flip($originalkeys);
+            // and then corresponding local english if present
+            if (!$disablelocal and file_exists("$this->localroot/en_local/$file.php")) {
+                include("$this->localroot/en_local/$file.php");
     }
 
-/// if $a happens to have % in it, double it so sprintf() doesn't break
-    if ($a) {
-        $a = clean_getstring_data( $a );
+            // now loop through all langs in correct order
+            $deps = $this->get_language_dependencies($lang);
+            foreach ($deps as $dep) {
+                // legacy location - used by contrib only
+                if (file_exists("$location/lang/$dep/$file.php")) {
+                    include("$location/lang/$dep/$file.php");
+                }
+                // the main lang string location
+                if (file_exists("$this->otherroot/$dep/$file.php")) {
+                    include("$this->otherroot/$dep/$file.php");
+                }
+                // local customisations
+                if (!$disablelocal and file_exists("$this->localroot/{$dep}_local/$file.php")) {
+                    include("$this->localroot/{$dep}_local/$file.php");
+                }
+            }
     }
 
-/// Define the two or three major locations of language strings for this module
-    $locations = array();
+        // we do not want any extra strings from other languages - everything must be in en lang pack
+        $string = array_intersect_key($string, $originalkeys);
 
-    if (!empty($extralocations)) {   // Calling code has a good idea where to look
-        if (is_array($extralocations)) {
-            $locations += $extralocations;
-        } else if (is_string($extralocations)) {
-            $locations[] = $extralocations;
-        } else {
-            debugging('Bad lang path provided');
+        // now we have a list of strings from all possible sources. put it into both in-memory and on-disk
+        // caches so we do not need to do all this merging and dependencies resolving again
+        $this->cache[$lang][$component] = $string;
+        if ($this->usediskcache) {
+            check_dir_exists("$this->cacheroot/$lang");
+            file_put_contents("$this->cacheroot/$lang/$component.php", "<?php \$this->cache['$lang']['$component'] = ".var_export($string, true).";");
         }
+        return $string;
     }
 
-    if (isset($CFG->running_installer)) {
-        $module = 'installer';
-        $filetocheck = 'installer.php';
-        $locations[] = $CFG->dirroot.'/install/lang/';
-        $locations[] = $CFG->dataroot.'/lang/';
-        $locations[] = $CFG->dirroot.'/lang/';
-        $defaultlang = 'en_utf8';
-    } else {
-        $locations[] = $CFG->dataroot.'/lang/';
-        $locations[] = $CFG->dirroot.'/lang/';
+    /**
+     * Does the string actually exist?
+     *
+     * get_string() is throwing debug warnings, sometimes we do not want them
+     * or we want to display better explanation of the problem.
+     *
+     * Use with care!
+     *
+     * @param string $identifier The identifier of the string to search for
+     * @param string $component The module the string is associated with
+     * @return boot true if exists
+     */
+    public function string_exists($identifier, $component) {
+       $identifier = clean_param($identifier, PARAM_STRINGID);
+        if (empty($identifier)) {
+            return false;
+        }
+        $lang = current_language();
+        $string = $this->load_component_strings($component, $lang);
+        return isset($string[$identifier]);
     }
 
-/// Add extra places to look for strings for particular plugin types.
-    $rules = places_to_search_for_lang_strings();
-    $exceptions = $rules['__exceptions'];
-    unset($rules['__exceptions']);
+    /**
+     * Get String returns a requested string
+     *
+     * @param string $identifier The identifier of the string to search for
+     * @param string $component The module the string is associated with
+     * @param string|object|array $a An object, string or number that can be used
+     *      within translation strings
+     * @param string $lang moodle translation language, NULL means use current
+     * @return string The String !
+     */
+    public function get_string($identifier, $component = '', $a = NULL, $lang = NULL) {
+        $this->countgetstring++;
+        // there are very many uses of these time formating strings without the 'langconfig' component,
+        // it would not be reasonable to expect that all of them would be converted during 2.0 migration
+        static $langconfigstrs = array(
+                'strftimedate' => 1,
+                'strftimedatefullshort' => 1,
+                'strftimedateshort' => 1,
+                'strftimedatetime' => 1,
+                'strftimedatetimeshort' => 1,
+                'strftimedaydate' => 1,
+                'strftimedaydatetime' => 1,
+                'strftimedayshort' => 1,
+                'strftimedaytime' => 1,
+                'strftimemonthyear' => 1,
+                'strftimerecent' => 1,
+                'strftimerecentfull' => 1,
+                'strftimetime' => 1);
+
+        if (empty($component)) {
+            if (isset($langconfigstrs[$identifier])) {
+                $component = 'langconfig';
+            } else {
+                $component = 'moodle';
+            }
+        }
+
+        if ($lang === NULL) {
+            $lang = current_language();
+        }
 
-    if (!in_array($module, $exceptions)) {
-        $dividerpos = strpos($module, '_');
-        if ($dividerpos === false) {
-            $type = '';
-            $plugin = $module;
-        } else {
-            $type = substr($module, 0, $dividerpos + 1);
-            $plugin = substr($module, $dividerpos + 1);
+        $string = $this->load_component_strings($component, $lang);
+
+        if (!isset($string[$identifier])) {
+            if ($component === 'pix' or $component === 'core_pix') {
+                // this component contains only alt tags for emoticons,
+                // not all of them are supposed to be defined
+                return '';
         }
-        if ($module == 'local') {
-            $locations[] = $CFG->dirroot . '/local/lang/';
-        } if (!empty($rules[$type])) {
-            foreach ($rules[$type] as $location) {
-                $locations[] = $CFG->dirroot . "/$location/$plugin/lang/";
+            if ($identifier === 'parentlanguage' and ($component === 'langconfig' or $component === 'core_langconfig')) {
+                // parentlanguage is a special string, undefined means use English if not defined
+                return 'en';
             }
+            if ($this->usediskcache) {
+                // maybe the on-disk cache is dirty - let the last attempt be to find the string in original sources
+                $string = $this->load_component_strings($component, $lang, true);
         }
+            if (!isset($string[$identifier])) {
+                // the string is still missing - should be fixed by developer
+                debugging("Invalid get_string() identifier: '$identifier' or component '$component'", DEBUG_DEVELOPER);
+                return "[[$identifier]]";
     }
+        }
+
+        $string = $string[$identifier];
 
-/// First check all the normal locations for the string in the current language
-    $resultstring = '';
-    foreach ($locations as $location) {
-        $locallangfile = $location.$lang.'_local'.'/'.$module.'.php';    //first, see if there's a local file
-        if (file_exists($locallangfile)) {
-            if ($result = get_string_from_file($identifier, $locallangfile, "\$resultstring")) {
-                if (eval($result) === FALSE) {
-                    trigger_error('Lang error: '.$identifier.':'.$locallangfile, E_USER_NOTICE);
+        if ($a !== NULL) {
+            if (is_object($a) or is_array($a)) {
+                $a = (array)$a;
+                $search = array();
+                $replace = array();
+                foreach ($a as $key=>$value) {
+                    if (is_int($key)) {
+                        // we do not support numeric keys - sorry!
+                        continue;
                 }
-                return $resultstring;
+                    if (is_object($value) or is_array($value)) {
+                        // we support just string as value
+                        continue;
             }
+                    $search[]  = '{$a->'.$key.'}';
+                    $replace[] = (string)$value;
         }
-        //if local directory not found, or particular string does not exist in local direcotry
-        $langfile = $location.$lang.'/'.$module.'.php';
-        if (file_exists($langfile)) {
-            if ($result = get_string_from_file($identifier, $langfile, "\$resultstring")) {
-                if (eval($result) === FALSE) {
-                    trigger_error('Lang error: '.$identifier.':'.$langfile, E_USER_NOTICE);
+                if ($search) {
+                    $string = str_replace($search, $replace, $string);
                 }
-                return $resultstring;
+            } else {
+                $string = str_replace('{$a}', (string)$a, $string);
             }
        }
+
+        return $string;
     }
 
-/// If the preferred language was English (utf8) we can abort now
-/// saving some checks beacuse it's the only "root" lang
-    if ($lang == 'en_utf8') {
-        return '[['. $identifier .']]';
+    /**
+     * Returns information about the string_manager performance
+     * @return array
+     */
+    public function get_performance_summary() {
+        return array(array(
+            'langcountgetstring' => $this->countgetstring,
+            'langcountmemcache' => $this->countmemcache,
+            'langcountdiskcache' => $this->countdiskcache,
+        ), array(
+            'langcountgetstring' => 'get_string calls',
+            'langcountmemcache' => 'strings mem cache hits',
+            'langcountdiskcache' => 'strings disk cache hits',
+        ));
     }
 
-/// Is a parent language defined?  If so, try to find this string in a parent language file
+    /**
+     * Returns a localised list of all country names, sorted by localised name.
+     *
+     * @param bool $returnall return all or just enabled
+     * @param string $lang moodle translation language, NULL means use current
+     * @return array two-letter country code => translated name.
+     */
+    public function get_list_of_countries($returnall = false, $lang = NULL) {
+        global $CFG;
 
-    foreach ($locations as $location) {
-        $langfile = $location.$lang.'/'.$filetocheck;
-        if (file_exists($langfile)) {
-            if ($result = get_string_from_file('parentlanguage', $langfile, "\$parentlang")) {
-                if (eval($result) === FALSE) {
-                    trigger_error('Lang error: '.$identifier.':'.$langfile, E_USER_NOTICE);
+        if ($lang === NULL) {
+            $lang = current_language();
                 }
-                if (!empty($parentlang)) {   // found it!
 
-                    //first, see if there's a local file for parent
-                    $locallangfile = $location.$parentlang.'_local'.'/'.$module.'.php';
-                    if (file_exists($locallangfile)) {
-                        if ($result = get_string_from_file($identifier, $locallangfile, "\$resultstring")) {
-                            if (eval($result) === FALSE) {
-                                trigger_error('Lang error: '.$identifier.':'.$locallangfile, E_USER_NOTICE);
+        $countries = $this->load_component_strings('core_countries', $lang);
+        textlib_get_instance()->asort($countries);
+        if (!$returnall and !empty($CFG->allcountrycodes)) {
+            $enabled = explode(',', $CFG->allcountrycodes);
+            $return = array();
+            foreach ($enabled as $c) {
+                if (isset($countries[$c])) {
+                    $return[$c] = $countries[$c];
                             }
-                            return $resultstring;
                         }
+            return $return;
                     }
 
-                    //if local directory not found, or particular string does not exist in local direcotry
-                    $langfile = $location.$parentlang.'/'.$module.'.php';
-                    if (file_exists($langfile)) {
-                        if ($result = get_string_from_file($identifier, $langfile, "\$resultstring")) {
-                            eval($result);
-                            return $resultstring;
+        return $countries;
                         }
+
+    /**
+     * Returns a localised list of languages, sorted by code keys.
+     *
+     * @param string $lang moodle translation language, NULL means use current
+     * @param string $standard language list standard
+     *    - iso6392: three-letter language code (ISO 639-2/T) => translated name
+     *    - iso6391: two-letter langauge code (ISO 639-1) => translated name
+     * @return array language code => translated name
+     */
+    public function get_list_of_languages($lang = NULL, $standard = 'iso6391') {
+        if ($lang === NULL) {
+            $lang = current_language();
                     }
+
+        if ($standard === 'iso6392') {
+            $langs = $this->load_component_strings('core_iso6392', $lang);
+            ksort($langs);
+            return $langs;
+
+        } else if ($standard === 'iso6391') {
+            $langs2 = $this->load_component_strings('core_iso6392', $lang);
+            static $mapping = array('aar' => 'aa', 'abk' => 'ab', 'afr' => 'af', 'aka' => 'ak', 'sqi' => 'sq', 'amh' => 'am', 'ara' => 'ar', 'arg' => 'an', 'hye' => 'hy',
+                'asm' => 'as', 'ava' => 'av', 'ave' => 'ae', 'aym' => 'ay', 'aze' => 'az', 'bak' => 'ba', 'bam' => 'bm', 'eus' => 'eu', 'bel' => 'be', 'ben' => 'bn', 'bih' => 'bh',
+                'bis' => 'bi', 'bos' => 'bs', 'bre' => 'br', 'bul' => 'bg', 'mya' => 'my', 'cat' => 'ca', 'cha' => 'ch', 'che' => 'ce', 'zho' => 'zh', 'chu' => 'cu', 'chv' => 'cv',
+                'cor' => 'kw', 'cos' => 'co', 'cre' => 'cr', 'ces' => 'cs', 'dan' => 'da', 'div' => 'dv', 'nld' => 'nl', 'dzo' => 'dz', 'eng' => 'en', 'epo' => 'eo', 'est' => 'et',
+                'ewe' => 'ee', 'fao' => 'fo', 'fij' => 'fj', 'fin' => 'fi', 'fra' => 'fr', 'fry' => 'fy', 'ful' => 'ff', 'kat' => 'ka', 'deu' => 'de', 'gla' => 'gd', 'gle' => 'ga',
+                'glg' => 'gl', 'glv' => 'gv', 'ell' => 'el', 'grn' => 'gn', 'guj' => 'gu', 'hat' => 'ht', 'hau' => 'ha', 'heb' => 'he', 'her' => 'hz', 'hin' => 'hi', 'hmo' => 'ho',
+                'hrv' => 'hr', 'hun' => 'hu', 'ibo' => 'ig', 'isl' => 'is', 'ido' => 'io', 'iii' => 'ii', 'iku' => 'iu', 'ile' => 'ie', 'ina' => 'ia', 'ind' => 'id', 'ipk' => 'ik',
+                'ita' => 'it', 'jav' => 'jv', 'jpn' => 'ja', 'kal' => 'kl', 'kan' => 'kn', 'kas' => 'ks', 'kau' => 'kr', 'kaz' => 'kk', 'khm' => 'km', 'kik' => 'ki', 'kin' => 'rw',
+                'kir' => 'ky', 'kom' => 'kv', 'kon' => 'kg', 'kor' => 'ko', 'kua' => 'kj', 'kur' => 'ku', 'lao' => 'lo', 'lat' => 'la', 'lav' => 'lv', 'lim' => 'li', 'lin' => 'ln',
+                'lit' => 'lt', 'ltz' => 'lb', 'lub' => 'lu', 'lug' => 'lg', 'mkd' => 'mk', 'mah' => 'mh', 'mal' => 'ml', 'mri' => 'mi', 'mar' => 'mr', 'msa' => 'ms', 'mlg' => 'mg',
+                'mlt' => 'mt', 'mon' => 'mn', 'nau' => 'na', 'nav' => 'nv', 'nbl' => 'nr', 'nde' => 'nd', 'ndo' => 'ng', 'nep' => 'ne', 'nno' => 'nn', 'nob' => 'nb', 'nor' => 'no',
+                'nya' => 'ny', 'oci' => 'oc', 'oji' => 'oj', 'ori' => 'or', 'orm' => 'om', 'oss' => 'os', 'pan' => 'pa', 'fas' => 'fa', 'pli' => 'pi', 'pol' => 'pl', 'por' => 'pt',
+                'pus' => 'ps', 'que' => 'qu', 'roh' => 'rm', 'ron' => 'ro', 'run' => 'rn', 'rus' => 'ru', 'sag' => 'sg', 'san' => 'sa', 'sin' => 'si', 'slk' => 'sk', 'slv' => 'sl',
+                'sme' => 'se', 'smo' => 'sm', 'sna' => 'sn', 'snd' => 'sd', 'som' => 'so', 'sot' => 'st', 'spa' => 'es', 'srd' => 'sc', 'srp' => 'sr', 'ssw' => 'ss', 'sun' => 'su',
+                'swa' => 'sw', 'swe' => 'sv', 'tah' => 'ty', 'tam' => 'ta', 'tat' => 'tt', 'tel' => 'te', 'tgk' => 'tg', 'tgl' => 'tl', 'tha' => 'th', 'bod' => 'bo', 'tir' => 'ti',
+                'ton' => 'to', 'tsn' => 'tn', 'tso' => 'ts', 'tuk' => 'tk', 'tur' => 'tr', 'twi' => 'tw', 'uig' => 'ug', 'ukr' => 'uk', 'urd' => 'ur', 'uzb' => 'uz', 'ven' => 've',
+                'vie' => 'vi', 'vol' => 'vo', 'cym' => 'cy', 'wln' => 'wa', 'wol' => 'wo', 'xho' => 'xh', 'yid' => 'yi', 'yor' => 'yo', 'zha' => 'za', 'zul' => 'zu');
+            $langs1 = array();
+            foreach ($mapping as $c2=>$c1) {
+                $langs1[$c1] = $langs2[$c2];
+            }
+            ksort($langs1);
+            return $langs1;
+
+        } else {
+            debugging('Unsupported $standard parameter in get_list_of_languages() method: '.$standard);
                 }
+
+        return array();
             }
+
+    /**
+     * Does the translation exist?
+     *
+     * @param string $lang moodle translation language code
+     * @param bool include also disabled translations?
+     * @return boot true if exists
+     */
+    public function translation_exists($lang, $includeall = true) {
+
+        if (strpos($lang, '_local') !== false) {
+            // _local packs are not real translations
+            return false;
         }
+        if (!$includeall and !empty($this->translist)) {
+            if (!in_array($lang, $this->translist)) {
+                return false;
+            }
+        }
+        if ($lang === 'en') {
+            // part of distribution
+            return true;
     }
+        return file_exists("$this->otherroot/$lang/langconfig.php");
+    }
+
+    /**
+     * Returns localised list of installed translations
+     * @param bool $returnall return all or just enabled
+     * @return array moodle translation code => localised translation name
+     */
+    public function get_list_of_translations($returnall = false) {
+        global $CFG;
+
+        $languages = array();
 
-/// Our only remaining option is to try English
+        if (!empty($CFG->langcache) and is_readable($this->menucache)) {
+            // try to re-use the cached list of all available languages
+            $cachedlist = json_decode(file_get_contents($this->menucache), true);
 
-    foreach ($locations as $location) {
-        $locallangfile = $location.$defaultlang.'_local/'.$module.'.php';    //first, see if there's a local file
-        if (file_exists($locallangfile)) {
-            if ($result = get_string_from_file($identifier, $locallangfile, "\$resultstring")) {
-                eval($result);
-                return $resultstring;
+            if (is_array($cachedlist) and !empty($cachedlist)) {
+                // the cache file is restored correctly
+
+                if (!$returnall and !empty($this->translist)) {
+                    // return just enabled translations
+                    foreach ($cachedlist as $langcode => $langname) {
+                        if (in_array($langcode, $this->translist)) {
+                            $languages[$langcode] = $langname;
             }
         }
+                    return $languages;
 
-        //if local_en not found, or string not found in local_en
-        $langfile = $location.$defaultlang.'/'.$module.'.php';
-
-        if (file_exists($langfile)) {
-            if ($result = get_string_from_file($identifier, $langfile, "\$resultstring")) {
-                eval($result);
-                return $resultstring;
+                } else {
+                    // return all translations
+                    return $cachedlist;
             }
         }
     }
 
-/// And, because under 1.6 en is defined as en_utf8 child, me must try
-/// if it hasn't been queried before.
-    if ($defaultlang  == 'en') {
-        $defaultlang = 'en_utf8';
-        foreach ($locations as $location) {
-            $locallangfile = $location.$defaultlang.'_local/'.$module.'.php';    //first, see if there's a local file
-            if (file_exists($locallangfile)) {
-                if ($result = get_string_from_file($identifier, $locallangfile, "\$resultstring")) {
-                    eval($result);
-                    return $resultstring;
+        // the cached list of languages is not available, let us populate the list
+
+        if (!$returnall and !empty($this->translist)) {
+            // return only some translations
+            foreach ($this->translist as $lang) {
+                $lang = trim($lang);   //Just trim spaces to be a bit more permissive
+                if (strstr($lang, '_local') !== false) {
+                    continue;
                 }
+                if (strstr($lang, '_utf8') !== false) {
+                    continue;
             }
+                if ($lang !== 'en' and !file_exists("$this->otherroot/$lang/langconfig.php")) {
+                    // some broken or missing lang - can not switch to it anyway
+                    continue;
+                }
+                $string = $this->load_component_strings('langconfig', $lang);
+                if (!empty($string['thislanguage'])) {
+                    $languages[$lang] = $string['thislanguage'].' ('. $lang .')';
+                }
+                unset($string);
+            }
+
+        } else {
+            // return all languages available in system
+            $langdirs = get_list_of_plugins('', '', $this->otherroot);
 
-            //if local_en not found, or string not found in local_en
-            $langfile = $location.$defaultlang.'/'.$module.'.php';
+            $langdirs = array_merge($langdirs, array("$CFG->dirroot/lang/en"=>'en'));
+            // Sort all
 
-            if (file_exists($langfile)) {
-                if ($result = get_string_from_file($identifier, $langfile, "\$resultstring")) {
-                    eval($result);
-                    return $resultstring;
+            // Loop through all langs and get info
+            foreach ($langdirs as $lang) {
+                if (strstr($lang, '_local') !== false) {
+                    continue;
                 }
+                if (strstr($lang, '_utf8') !== false) {
+                    continue;
             }
+                $string = $this->load_component_strings('langconfig', $lang);
+                if (!empty($string['thislanguage'])) {
+                    $languages[$lang] = $string['thislanguage'].' ('. $lang .')';
         }
+                unset($string);
     }
 
-    return '[['.$identifier.']]';  // Last resort
-}
+            if (!empty($CFG->langcache) and !empty($this->menucache)) {
+                // cache the list so that it can be used next time
+                textlib_get_instance()->asort($languages);
+                file_put_contents($this->menucache, json_encode($languages));
+            }
+        }
 
-/**
- * This function is only used from {@link get_string()}.
+        textlib_get_instance()->asort($languages);
+
+        return $languages;
+    }
+
+    /**
+     * Returns localised list of currencies.
  *
- * @internal Only used from get_string, not meant to be public API
- * @param string $identifier ?
- * @param string $langfile ?
- * @param string $destination ?
- * @return string|false ?
- * @staticvar array $strings Localized strings
- * @access private
- * @todo Finish documenting this function.
+     * @param string $lang moodle translation language, NULL means use current
+     * @return array currency code => localised currency name
  */
-function get_string_from_file($identifier, $langfile, $destination) {
+    public function get_list_of_currencies($lang = NULL) {
+        if ($lang === NULL) {
+            $lang = current_language();
+        }
 
-    static $strings;    // Keep the strings cached in memory.
+        $currencies = $this->load_component_strings('core_currencies', $lang);
+        asort($currencies);
 
-    if (empty($strings[$langfile])) {
-        $string = array();
-        include ($langfile);
-        $strings[$langfile] = $string;
-    } else {
-        $string = &$strings[$langfile];
+        return $currencies;
     }
 
-    if (!isset ($string[$identifier])) {
-        return false;
-    }
+    /**
+     * Clears both in-memory and on-disk caches
+     */
+    public function reset_caches() {
+        global $CFG;
+        require_once("$CFG->libdir/filelib.php");
 
-    return $destination .'= sprintf("'. $string[$identifier] .'");';
-}
+        // clear the on-disk disk with aggregated string files
+        fulldelete($this->cacheroot);
 
-/**
- * Converts an array of strings to their localized value.
- *
- * @param array $array An array of strings
- * @param string $module The language module that these strings can be found in.
- * @return string
- */
-function get_strings($array, $module='') {
+        // clear the in-memory cache of loaded strings
+        $this->cache = array();
 
-   $string = NULL;
-   foreach ($array as $item) {
-       $string->$item = get_string($item, $module);
+        // clear the cache containing the list of available translations
+        // and re-populate it again
+        fulldelete($this->menucache);
+        $this->get_list_of_translations(true);
    }
-   return $string;
 }
 
+
 /**
- * Returns a list of language codes and their full names
- * hides the _local files from everyone.
- * @param bool refreshcache force refreshing of lang cache
- * @param bool returnall ignore langlist, return all languages available
- * @return array An associative array with contents in the form of LanguageCode => LanguageName
+ * Minimalistic string fetching implementation
+ * that is used in installer before we fetch the wanted
+ * language pack from moodle.org lang download site.
+ *
+ * @package    moodlecore
+ * @copyright  2010 Petr Skoda (http://skodak.org)
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
  */
-function get_list_of_languages($refreshcache=false, $returnall=false) {
+class install_string_manager implements string_manager {
+    /** @var string location of pre-install packs for all langs */
+    protected $installroot;
 
+    /**
+     * Crate new instance of install string manager
+     */
+    public function __construct() {
     global $CFG;
+        $this->installroot = "$CFG->dirroot/install/lang";
+    }
 
-    $languages = array();
+    /**
+     * Load all strings for one component
+     * @param string $component The module the string is associated with
+     * @param string $lang
+     * @param bool $disablecache Do not use caches, force fetching the strings from sources
+     * @param bool $disablelocal Do not use customized strings in xx_local language packs
+     * @return array of all string for given component and lang
+     */
+    public function load_component_strings($component, $lang, $disablecache=false, $disablelocal=false) {
+        // not needed in installer
+        return array();
+    }
 
-    $filetocheck = 'langconfig.php';
+    /**
+     * Does the string actually exist?
+     *
+     * get_string() is throwing debug warnings, sometimes we do not want them
+     * or we want to display better explanation of the problem.
+     *
+     * Use with care!
+     *
+     * @param string $identifier The identifier of the string to search for
+     * @param string $component The module the string is associated with
+     * @return boot true if exists
+     */
+    public function string_exists($identifier, $component) {
+        $identifier = clean_param($identifier, PARAM_STRINGID);
+        if (empty($identifier)) {
+            return false;
+        }
+        // simple old style hack ;)
+        $str = get_string($identifier, $component);
+        return (strpos($str, '[[') === false);
+    }
 
-    if (!$refreshcache && !$returnall && !empty($CFG->langcache) && file_exists($CFG->dataroot .'/cache/languages')) {
-/// read available langs from cache
+    /**
+     * Get String returns a requested string
+     *
+     * @param string $identifier The identifier of the string to search for
+     * @param string $component The module the string is associated with
+     * @param string|object|array $a An object, string or number that can be used
+     *      within translation strings
+     * @param string $lang moodle translation language, NULL means use current
+     * @return string The String !
+     */
+    public function get_string($identifier, $component = '', $a = NULL, $lang = NULL) {
+        if (!$component) {
+            $component = 'moodle';
+        }
+
+        if ($lang === NULL) {
+            $lang = current_language();
+        }
 
-        $lines = file($CFG->dataroot .'/cache/languages');
-        foreach ($lines as $line) {
-            $line = trim($line);
-            if (preg_match('/^(\w+)\s+(.+)/', $line, $matches)) {
-                $languages[$matches[1]] = $matches[2];
+        //get parent lang
+        $parent = '';
+        if ($lang !== 'en' and $identifier !== 'parentlanguage' and $component !== 'langconfig') {
+            if (file_exists("$this->installroot/$lang/langconfig.php")) {
+                $string = array();
+                include("$this->installroot/$lang/langconfig.php");
+                if (isset($string['parentlanguage'])) {
+                    $parent = $string['parentlanguage'];
             }
+                unset($string);
         }
-        unset($lines); unset($line); unset($matches);
-        return $languages;
     }
 
-    if (!$returnall && !empty($CFG->langlist)) {
-/// return only languages allowed in langlist admin setting
+        // include en string first
+        if (!file_exists("$this->installroot/en/$component.php")) {
+            return "[[$identifier]]";
+        }
+        $string = array();
+        include("$this->installroot/en/$component.php");
 
-        $langlist = explode(',', $CFG->langlist);
-        // fix short lang names first - non existing langs are skipped anyway...
-        foreach ($langlist as $lang) {
-            if (strpos($lang, '_utf8') === false) {
-                $langlist[] = $lang.'_utf8';
+        // now override en with parent if defined
+        if ($parent and $parent !== 'en' and file_exists("$this->installroot/$parent/$component.php")) {
+            include("$this->installroot/$parent/$component.php");
             }
+
+        // finally override with requested language
+        if ($lang !== 'en' and file_exists("$this->installroot/$lang/$component.php")) {
+            include("$this->installroot/$lang/$component.php");
         }
-        // find existing langs from langlist
-        foreach ($langlist as $lang) {
-            $lang = trim($lang);   //Just trim spaces to be a bit more permissive
-            if (strstr($lang, '_local')!==false) {
+
+        if (!isset($string[$identifier])) {
+            return "[[$identifier]]";
+        }
+
+        $string = $string[$identifier];
+
+        if ($a !== NULL) {
+            if (is_object($a) or is_array($a)) {
+                $a = (array)$a;
+                $search = array();
+                $replace = array();
+                foreach ($a as $key=>$value) {
+                    if (is_int($key)) {
+                        // we do not support numeric keys - sorry!
                 continue;
             }
-            if (substr($lang, -5) == '_utf8') {   //Remove the _utf8 suffix from the lang to show
-                $shortlang = substr($lang, 0, -5);
+                    $search[]  = '{$a->'.$key.'}';
+                    $replace[] = (string)$value;
+                }
+                if ($search) {
+                    $string = str_replace($search, $replace, $string);
+                }
             } else {
-                $shortlang = $lang;
+                $string = str_replace('{$a}', (string)$a, $string);
             }
-        /// Search under dirroot/lang
-            if (file_exists($CFG->dirroot .'/lang/'. $lang .'/'. $filetocheck)) {
-                include($CFG->dirroot .'/lang/'. $lang .'/'. $filetocheck);
-                if (!empty($string['thislanguage'])) {
-                    $languages[$lang] = $string['thislanguage'].' ('. $shortlang .')';
                 }
-                unset($string);
+
+        return $string;
             }
-        /// And moodledata/lang
-            if (file_exists($CFG->dataroot .'/lang/'. $lang .'/'. $filetocheck)) {
-                include($CFG->dataroot .'/lang/'. $lang .'/'. $filetocheck);
-                if (!empty($string['thislanguage'])) {
-                    $languages[$lang] = $string['thislanguage'].' ('. $shortlang .')';
+
+    /**
+     * Returns a localised list of all country names, sorted by country keys.
+     *
+     * @param bool $returnall return all or just enabled
+     * @param string $lang moodle translation language, NULL means use current
+     * @return array two-letter country code => translated name.
+     */
+    public function get_list_of_countries($returnall = false, $lang = NULL) {
+        //not used in installer
+        return array();
                 }
-                unset($string);
+
+    /**
+     * Returns a localised list of languages, sorted by code keys.
+     *
+     * @param string $lang moodle translation language, NULL means use current
+     * @param string $standard language list standard
+     *                     iso6392: three-letter language code (ISO 639-2/T) => translated name.
+     * @return array language code => translated name
+     */
+    public function get_list_of_languages($lang = NULL, $standard = 'iso6392') {
+        //not used in installer
+        return array();
             }
+
+    /**
+     * Does the translation exist?
+     *
+     * @param string $lang moodle translation language code
+     * @param bool include also disabled translations?
+     * @return boot true if exists
+     */
+    public function translation_exists($lang, $includeall = true) {
+        return file_exists($this->installroot.'/'.$lang.'/langconfig.php');
         }
 
-    } else {
-/// return all languages available in system
-    /// Fetch langs from moodle/lang directory
-        $langdirs = get_list_of_plugins('lang');
-    /// Fetch langs from moodledata/lang directory
-        $langdirs2 = get_list_of_plugins('lang', '', $CFG->dataroot);
-    /// Merge both lists of langs
-        $langdirs = array_merge($langdirs, $langdirs2);
-    /// Sort all
+    /**
+     * Returns localised list of installed translations
+     * @param bool $returnall return all or just enabled
+     * @return array moodle translation code => localised translation name
+     */
+    public function get_list_of_translations($returnall = false) {
+        // return all is ignored here - we need to know all langs in installer
+        $languages = array();
+        // Get raw list of lang directories
+        $langdirs = get_list_of_plugins('install/lang');
         asort($langdirs);
-    /// Get some info from each lang (first from moodledata, then from moodle)
+        // Get some info from each lang
         foreach ($langdirs as $lang) {
-            if (strstr($lang, '_local')!==false) {
-                continue;
-            }
-            if (substr($lang, -5) == '_utf8') {   //Remove the _utf8 suffix from the lang to show
-                $shortlang = substr($lang, 0, -5);
-            } else {
-                $shortlang = $lang;
-            }
-        /// Search under moodledata/lang
-            if (file_exists($CFG->dataroot .'/lang/'. $lang .'/'. $filetocheck)) {
-                include($CFG->dataroot .'/lang/'. $lang .'/'. $filetocheck);
+            if (file_exists($this->installroot.'/'.$lang.'/langconfig.php')) {
+                $string = array();
+                include($this->installroot.'/'.$lang.'/langconfig.php');
                 if (!empty($string['thislanguage'])) {
-                    $languages[$lang] = $string['thislanguage'] .' ('. $shortlang .')';
-                }
-                unset($string);
+                    $languages[$lang] = $string['thislanguage'].' ('.$lang.')';
             }
-        /// And dirroot/lang
-            if (file_exists($CFG->dirroot .'/lang/'. $lang .'/'. $filetocheck)) {
-                include($CFG->dirroot .'/lang/'. $lang .'/'. $filetocheck);
-                if (!empty($string['thislanguage'])) {
-                    $languages[$lang] = $string['thislanguage'] .' ('. $shortlang .')';
                 }
-                unset($string);
             }
+        // Return array
+        return $languages;
         }
+
+    /**
+     * Returns localised list of currencies.
+     *
+     * @param string $lang moodle translation language, NULL means use current
+     * @return array currency code => localised currency name
+     */
+    public function get_list_of_currencies($lang = NULL) {
+        // not used in installer
+        return array();
     }
 
-    if ($refreshcache && !empty($CFG->langcache)) {
-        if ($returnall) {
-            // we have a list of all langs only, just delete old cache
-            @unlink($CFG->dataroot.'/cache/languages');
+    /**
+     * This implementation does not use any caches
+     */
+    public function reset_caches() {}
+}
+
 
-        } else {
-            // store the list of allowed languages
-            if ($file = fopen($CFG->dataroot .'/cache/languages', 'w')) {
-                foreach ($languages as $key => $value) {
-                    fwrite($file, "$key $value\n");
+/**
+ * Returns a localized string.
+ *
+ * Returns the translated string specified by $identifier as
+ * for $module.  Uses the same format files as STphp.
+ * $a is an object, string or number that can be used
+ * within translation strings
+ *
+ * eg 'hello {$a->firstname} {$a->lastname}'
+ * or 'hello {$a}'
+ *
+ * If you would like to directly echo the localized string use
+ * the function {@link print_string()}
+ *
+ * Example usage of this function involves finding the string you would
+ * like a local equivalent of and using its identifier and module information
+ * to retrieve it.<br/>
+ * If you open moodle/lang/en/moodle.php and look near line 278
+ * you will find a string to prompt a user for their word for 'course'
+ * <code>
+ * $string['course'] = 'Course';
+ * </code>
+ * So if you want to display the string 'Course'
+ * in any language that supports it on your site
+ * you just need to use the identifier 'course'
+ * <code>
+ * $mystring = '<strong>'. get_string('course') .'</strong>';
+ * or
+ * </code>
+ * If the string you want is in another file you'd take a slightly
+ * different approach. Looking in moodle/lang/en/calendar.php you find
+ * around line 75:
+ * <code>
+ * $string['typecourse'] = 'Course event';
+ * </code>
+ * If you want to display the string "Course event" in any language
+ * supported you would use the identifier 'typecourse' and the module 'calendar'
+ * (because it is in the file calendar.php):
+ * <code>
+ * $mystring = '<h1>'. get_string('typecourse', 'calendar') .'</h1>';
+ * </code>
+ *
+ * As a last resort, should the identifier fail to map to a string
+ * the returned string will be [[ $identifier ]]
+ *
+ * @param string $identifier The key identifier for the localized string
+ * @param string $component The module where the key identifier is stored,
+ *      usually expressed as the filename in the language pack without the
+ *      .php on the end but can also be written as mod/forum or grade/export/xls.
+ *      If none is specified then moodle.php is used.
+ * @param string|object|array $a An object, string or number that can be used
+ *      within translation strings
+ * @return string The localized string.
+ */
+function get_string($identifier, $component = '', $a = NULL) {
+
+    $identifier = clean_param($identifier, PARAM_STRINGID);
+    if (empty($identifier)) {
+        throw new coding_exception('Invalid string identifier. Most probably some illegal character is part of the string identifier. Please fix your get_string() call and string definition');
                 }
-                fclose($file);
+
+    if (func_num_args() > 3) {
+        debugging('extralocations parameter in get_string() is not supported any more, please use standard lang locations only.');
+    }
+
+    if (strpos($component, '/') !== false) {
+        debugging('The module name you passed to get_string is the deprecated format ' .
+                'like mod/mymod or block/myblock. The correct form looks like mymod, or block_myblock.' , DEBUG_DEVELOPER);
+        $componentpath = explode('/', $component);
+
+        switch ($componentpath[0]) {
+            case 'mod':
+                $component = $componentpath[1];
+                break;
+            case 'blocks':
+            case 'block':
+                $component = 'block_'.$componentpath[1];
+                break;
+            case 'enrol':
+                $component = 'enrol_'.$componentpath[1];
+                break;
+            case 'format':
+                $component = 'format_'.$componentpath[1];
+                break;
+            case 'grade':
+                $component = 'grade'.$componentpath[1].'_'.$componentpath[2];
+                break;
             }
         }
+
+    return get_string_manager()->get_string($identifier, $component, $a);
+}
+
+/**
+ * Converts an array of strings to their localized value.
+ *
+ * @param array $array An array of strings
+ * @param string $module The language module that these strings can be found in.
+ * @return array and array of translated strings.
+ */
+function get_strings($array, $component = '') {
+   $string = new stdClass;
+   foreach ($array as $item) {
+       $string->$item = get_string($item, $component);
     }
+   return $string;
+}
 
-    return $languages;
+/**
+ * Prints out a translated string.
+ *
+ * Prints out a translated string using the return value from the {@link get_string()} function.
+ *
+ * Example usage of this function when the string is in the moodle.php file:<br/>
+ * <code>
+ * echo '<strong>';
+ * print_string('course');
+ * echo '</strong>';
+ * </code>
+ *
+ * Example usage of this function when the string is not in the moodle.php file:<br/>
+ * <code>
+ * echo '<h1>';
+ * print_string('typecourse', 'calendar');
+ * echo '</h1>';
+ * </code>
+ *
+ * @param string $identifier The key identifier for the localized string
+ * @param string $component The module where the key identifier is stored. If none is specified then moodle.php is used.
+ * @param mixed $a An object, string or number that can be used within translation strings
+ */
+function print_string($identifier, $component = '', $a = NULL) {
+    echo get_string($identifier, $component, $a);
 }
 
 /**
+ * Returns a list of charset codes
+ *
  * Returns a list of charset codes. It's hardcoded, so they should be added manually
- * (cheking that such charset is supported by the texlib library!)
+ * (checking that such charset is supported by the texlib library!)
  *
  * @return array And associative array with contents in the form of charset => charset
  */
@@ -5789,92 +6573,12 @@ function get_list_of_charsets() {
 }
 
 /**
- * For internal use only.
- * @return array with two elements, the path to use and the name of the lang.
- */
-function get_list_of_countries_language() {
-	global $CFG;
-
-	$lang = current_language();
-    if (is_readable($CFG->dataroot.'/lang/'. $lang .'/countries.php')) {
-        return array($CFG->dataroot, $lang);
-    }
-    if (is_readable($CFG->dirroot .'/lang/'. $lang .'/countries.php')) {
-        return array($CFG->dirroot , $lang);
-    }
-
-    if ($lang == 'en_utf8') {
-    	return;
-    }
-
-    $parentlang = get_string('parentlanguage');
-    if (substr($parentlang, 0, 1) != '[') {
-	    if (is_readable($CFG->dataroot.'/lang/'. $parentlang .'/countries.php')) {
-	        return array($CFG->dataroot, $parentlang);
-	    }
-	    if (is_readable($CFG->dirroot .'/lang/'. $parentlang .'/countries.php')) {
-	        return array($CFG->dirroot , $parentlang);
-	    }
-
-	    if ($parentlang == 'en_utf8') {
-	        return;
-	    }
-    }
-
-    if (is_readable($CFG->dataroot.'/lang/en_utf8/countries.php')) {
-        return array($CFG->dataroot, 'en_utf8');
-    }
-    if (is_readable($CFG->dirroot .'/lang/en_utf8/countries.php')) {
-        return array($CFG->dirroot , 'en_utf8');
-    }
-
-    return array(null, null);
-}
-
-/**
- * Returns a list of country names in the current language
- *
- * @uses $CFG
- * @uses $USER
- * @return array
- */
-function get_list_of_countries() {
-    global $CFG;
-
-    list($path, $lang) = get_list_of_countries_language();
-
-    if (empty($path)) {
-    	print_error('countriesphpempty', '', '', $lang);
-    }
-
-    // Load all the strings into $string.
-    include($path . '/lang/' . $lang . '/countries.php');
-
-    // See if there are local overrides to countries.php.
-    // If so, override those elements of $string.
-    if (is_readable($CFG->dirroot .'/lang/' . $lang . '_local/countries.php')) {
-        include($CFG->dirroot .'/lang/' . $lang . '_local/countries.php');
-    }
-    if (is_readable($CFG->dataroot.'/lang/' . $lang . '_local/countries.php')) {
-        include($CFG->dataroot.'/lang/' . $lang . '_local/countries.php');
-    }
-
-    if (empty($string)) {
-        print_error('countriesphpempty', '', '', $lang);
-    }
-
-    uasort($string, 'strcoll');
-    return $string;
-}
-
-/**
  * Returns a list of valid and compatible themes
  *
- * @uses $CFG
+ * @global object
  * @return array
  */
 function get_list_of_themes() {
-
     global $CFG;
 
     $themes = array();
@@ -5882,69 +6586,27 @@ function get_list_of_themes() {
     if (!empty($CFG->themelist)) {       // use admin's list of themes
         $themelist = explode(',', $CFG->themelist);
     } else {
-        $themelist = get_list_of_plugins("theme");
+        $themelist = array_keys(get_plugin_list("theme"));
     }
 
-    foreach ($themelist as $key => $theme) {
-        if (!file_exists("$CFG->themedir/$theme/config.php")) {   // bad folder
-            continue;
-        }
-        $THEME = new object();    // Note this is not the global one!!  :-)
-        include("$CFG->themedir/$theme/config.php");
-        if (!isset($THEME->sheets)) {   // Not a valid 1.5 theme
-            continue;
-        }
-        $themes[$theme] = $theme;
+    foreach ($themelist as $key => $themename) {
+        $theme = theme_config::load($themename);
+        $themes[$themename] = $theme;
     }
     asort($themes);
 
     return $themes;
 }
 
-
-/**
- * Returns a list of picture names in the current or specified language
- *
- * @uses $CFG
- * @return array
- */
-function get_list_of_pixnames($lang = '') {
-    global $CFG;
-
-    if (empty($lang)) {
-        $lang = current_language();
-    }
-
-    $string = array();
-
-    $path = $CFG->dirroot .'/lang/en_utf8/pix.php'; // always exists
-
-    if (file_exists($CFG->dataroot .'/lang/'. $lang .'_local/pix.php')) {
-        $path = $CFG->dataroot .'/lang/'. $lang .'_local/pix.php';
-
-    } else if (file_exists($CFG->dirroot .'/lang/'. $lang .'/pix.php')) {
-        $path = $CFG->dirroot .'/lang/'. $lang .'/pix.php';
-
-    } else if (file_exists($CFG->dataroot .'/lang/'. $lang .'/pix.php')) {
-        $path = $CFG->dataroot .'/lang/'. $lang .'/pix.php';
-
-    } else if ($parentlang = get_string('parentlanguage') and $parentlang != '[[parentlanguage]]') {
-        return get_list_of_pixnames($parentlang); //return pixnames from parent language instead
-    }
-
-    include($path);
-
-    return $string;
-}
-
 /**
  * Returns a list of timezones in the current language
  *
- * @uses $CFG
+ * @global object
+ * @global object
  * @return array
  */
 function get_list_of_timezones() {
-    global $CFG;
+    global $CFG, $DB;
 
     static $timezones;
 
@@ -5954,10 +6616,14 @@ function get_list_of_timezones() {
 
     $timezones = array();
 
-    if ($rawtimezones = get_records_sql('SELECT MAX(id), name FROM '.$CFG->prefix.'timezone GROUP BY name')) {
+    if ($rawtimezones = $DB->get_records_sql("SELECT MAX(id), name FROM {timezone} GROUP BY name")) {
         foreach($rawtimezones as $timezone) {
             if (!empty($timezone->name)) {
+                if (get_string_manager()->string_exists(strtolower($timezone->name), 'timezones')) {
                 $timezones[$timezone->name] = get_string(strtolower($timezone->name), 'timezones');
+                } else {
+                    $timezones[$timezone->name] = $timezone->name;
+                }
                 if (substr($timezones[$timezone->name], 0, 1) == '[') {  // No translation found
                     $timezones[$timezone->name] = $timezone->name;
                 }
@@ -5982,51 +6648,168 @@ function get_list_of_timezones() {
 }
 
 /**
- * Returns a list of currencies in the current language
+ * Factory function for emoticon_manager
  *
- * @uses $CFG
- * @uses $USER
- * @return array
+ * @return emoticon_manager singleton
  */
-function get_list_of_currencies() {
-    global $CFG, $USER;
+function get_emoticon_manager() {
+    static $singleton = null;
 
-    $lang = current_language();
+    if (is_null($singleton)) {
+        $singleton = new emoticon_manager();
+    }
 
-    if (!file_exists($CFG->dataroot .'/lang/'. $lang .'/currencies.php')) {
-        if ($parentlang = get_string('parentlanguage')) {
-            if (file_exists($CFG->dataroot .'/lang/'. $parentlang .'/currencies.php')) {
-                $lang = $parentlang;
-            } else {
-                $lang = 'en_utf8';  // currencies.php must exist in this pack
+    return $singleton;
+}
+
+/**
+ * Provides core support for plugins that have to deal with
+ * emoticons (like HTML editor or emoticon filter).
+ *
+ * Whenever this manager mentiones 'emoticon object', the following data
+ * structure is expected: stdClass with properties text, imagename, imagecomponent,
+ * altidentifier and altcomponent
+ *
+ * @see admin_setting_emoticons
+ */
+class emoticon_manager {
+
+    /**
+     * Returns the currently enabled emoticons
+     *
+     * @return array of emoticon objects
+     */
+    public function get_emoticons() {
+        global $CFG;
+
+        if (empty($CFG->emoticons)) {
+            return array();
+        }
+
+        $emoticons = $this->decode_stored_config($CFG->emoticons);
+
+        if (!is_array($emoticons)) {
+            // something is wrong with the format of stored setting
+            debugging('Invalid format of emoticons setting, please resave the emoticons settings form', DEBUG_NORMAL);
+            return array();
+        }
+
+        return $emoticons;
             }
+
+    /**
+     * Converts emoticon object into renderable pix_emoticon object
+     *
+     * @param stdClass $emoticon emoticon object
+     * @param array $attributes explicit HTML attributes to set
+     * @return pix_emoticon
+     */
+    public function prepare_renderable_emoticon(stdClass $emoticon, array $attributes = array()) {
+        $stringmanager = get_string_manager();
+        if ($stringmanager->string_exists($emoticon->altidentifier, $emoticon->altcomponent)) {
+            $alt = get_string($emoticon->altidentifier, $emoticon->altcomponent);
         } else {
-            $lang = 'en_utf8';  // currencies.php must exist in this pack
+            $alt = s($emoticon->text);
         }
+        return new pix_emoticon($emoticon->imagename, $alt, $emoticon->imagecomponent, $attributes);
     }
 
-    if (file_exists($CFG->dataroot .'/lang/'. $lang .'/currencies.php')) {
-        include_once($CFG->dataroot .'/lang/'. $lang .'/currencies.php');
-    } else {    //if en_utf8 is not installed in dataroot
-        include_once($CFG->dirroot .'/lang/'. $lang .'/currencies.php');
+    /**
+     * Encodes the array of emoticon objects into a string storable in config table
+     *
+     * @see self::decode_stored_config()
+     * @param array $emoticons array of emtocion objects
+     * @return string
+     */
+    public function encode_stored_config(array $emoticons) {
+        return json_encode($emoticons);
+    }
+
+    /**
+     * Decodes the string into an array of emoticon objects
+     *
+     * @see self::encode_stored_config()
+     * @param string $encoded
+     * @return string|null
+     */
+    public function decode_stored_config($encoded) {
+        $decoded = json_decode($encoded);
+        if (!is_array($decoded)) {
+            return null;
+        }
+        return $decoded;
     }
 
-    if (!empty($string)) {
-        asort($string);
+    /**
+     * Returns default set of emoticons supported by Moodle
+     *
+     * @return array of sdtClasses
+     */
+    public function default_emoticons() {
+        return array(
+            $this->prepare_emoticon_object(":-)", 's/smiley', 'smiley'),
+            $this->prepare_emoticon_object(":)", 's/smiley', 'smiley'),
+            $this->prepare_emoticon_object(":-D", 's/biggrin', 'biggrin'),
+            $this->prepare_emoticon_object(";-)", 's/wink', 'wink'),
+            $this->prepare_emoticon_object(":-/", 's/mixed', 'mixed'),
+            $this->prepare_emoticon_object("V-.", 's/thoughtful', 'thoughtful'),
+            $this->prepare_emoticon_object(":-P", 's/tongueout', 'tongueout'),
+            $this->prepare_emoticon_object(":-p", 's/tongueout', 'tongueout'),
+            $this->prepare_emoticon_object("B-)", 's/cool', 'cool'),
+            $this->prepare_emoticon_object("^-)", 's/approve', 'approve'),
+            $this->prepare_emoticon_object("8-)", 's/wideeyes', 'wideeyes'),
+            $this->prepare_emoticon_object(":o)", 's/clown', 'clown'),
+            $this->prepare_emoticon_object(":-(", 's/sad', 'sad'),
+            $this->prepare_emoticon_object(":(", 's/sad', 'sad'),
+            $this->prepare_emoticon_object("8-.", 's/shy', 'shy'),
+            $this->prepare_emoticon_object(":-I", 's/blush', 'blush'),
+            $this->prepare_emoticon_object(":-X", 's/kiss', 'kiss'),
+            $this->prepare_emoticon_object("8-o", 's/surprise', 'surprise'),
+            $this->prepare_emoticon_object("P-|", 's/blackeye', 'blackeye'),
+            $this->prepare_emoticon_object("8-[", 's/angry', 'angry'),
+            $this->prepare_emoticon_object("(grr)", 's/angry', 'angry'),
+            $this->prepare_emoticon_object("xx-P", 's/dead', 'dead'),
+            $this->prepare_emoticon_object("|-.", 's/sleepy', 'sleepy'),
+            $this->prepare_emoticon_object("}-]", 's/evil', 'evil'),
+            $this->prepare_emoticon_object("(h)", 's/heart', 'heart'),
+            $this->prepare_emoticon_object("(heart)", 's/heart', 'heart'),
+            $this->prepare_emoticon_object("(y)", 's/yes', 'yes', 'core'),
+            $this->prepare_emoticon_object("(n)", 's/no', 'no', 'core'),
+            $this->prepare_emoticon_object("(martin)", 's/martin', 'martin'),
+            $this->prepare_emoticon_object("( )", 's/egg', 'egg'),
+        );
     }
 
-    return $string;
+    /**
+     * Helper method preparing the stdClass with the emoticon properties
+     *
+     * @param string|array $text or array of strings
+     * @param string $imagename to be used by {@see pix_emoticon}
+     * @param string $altidentifier alternative string identifier, null for no alt
+     * @param array $altcomponent where the alternative string is defined
+     * @param string $imagecomponent to be used by {@see pix_emoticon}
+     * @return stdClass
+     */
+    protected function prepare_emoticon_object($text, $imagename, $altidentifier = null, $altcomponent = 'core_pix', $imagecomponent = 'core') {
+        return (object)array(
+            'text'           => $text,
+            'imagename'      => $imagename,
+            'imagecomponent' => $imagecomponent,
+            'altidentifier'  => $altidentifier,
+            'altcomponent'   => $altcomponent,
+        );
+    }
 }
 
-
 /// ENCRYPTION  ////////////////////////////////////////////////
 
 /**
  * rc4encrypt
  *
- * @param string $data ?
- * @return string
  * @todo Finish documenting this function
+ *
+ * @param string $data Data to encrypt
+ * @return string The now encrypted data
  */
 function rc4encrypt($data) {
     $password = 'nfgjeingjk';
@@ -6036,9 +6819,10 @@ function rc4encrypt($data) {
 /**
  * rc4decrypt
  *
- * @param string $data ?
- * @return string
  * @todo Finish documenting this function
+ *
+ * @param string $data Data to decrypt
+ * @return string The now decrypted data
  */
 function rc4decrypt($data) {
     $password = 'nfgjeingjk';
@@ -6048,11 +6832,12 @@ function rc4decrypt($data) {
 /**
  * Based on a class by Mukul Sabharwal [mukulsabharwal @ yahoo.com]
  *
- * @param string $pwd ?
- * @param string $data ?
- * @param string $case ?
- * @return string
  * @todo Finish documenting this function
+ *
+ * @param string $pwd The password to use when encrypting or decrypting
+ * @param string $data The data to be decrypted/encrypted
+ * @param string $case Either 'de' for decrypt or '' for encrypt
+ * @return string
  */
 function endecrypt ($pwd, $data, $case) {
 
@@ -6110,193 +6895,439 @@ function endecrypt ($pwd, $data, $case) {
     return $cipher;
 }
 
-
-/// CALENDAR MANAGEMENT  ////////////////////////////////////////////////////////////////
-
+/// ENVIRONMENT CHECKING  ////////////////////////////////////////////////////////////
 
 /**
- * Call this function to add an event to the calendar table
- *  and to call any calendar plugins
+ * Returns the exact absolute path to plugin directory.
  *
- * @uses $CFG
- * @param array $event An associative array representing an event from the calendar table. The event will be identified by the id field. The object event should include the following:
- *  <ul>
- *    <li><b>$event->name</b> - Name for the event
- *    <li><b>$event->description</b> - Description of the event (defaults to '')
- *    <li><b>$event->format</b> - Format for the description (using formatting types defined at the top of weblib.php)
- *    <li><b>$event->courseid</b> - The id of the course this event belongs to (0 = all courses)
- *    <li><b>$event->groupid</b> - The id of the group this event belongs to (0 = no group)
- *    <li><b>$event->userid</b> - The id of the user this event belongs to (0 = no user)
- *    <li><b>$event->modulename</b> - Name of the module that creates this event
- *    <li><b>$event->instance</b> - Instance of the module that owns this event
- *    <li><b>$event->eventtype</b> - The type info together with the module info could
- *             be used by calendar plugins to decide how to display event
- *    <li><b>$event->timestart</b>- Timestamp for start of event
- *    <li><b>$event->timeduration</b> - Duration (defaults to zero)
- *    <li><b>$event->visible</b> - 0 if the event should be hidden (e.g. because the activity that created it is hidden)
- *  </ul>
- * @return int The id number of the resulting record
- */
- function add_event($event) {
-
+ * @param string $plugintype type of plugin
+ * @param string $name name of the plugin
+ * @return string full path to plugin directory; NULL if not found
+ */
+function get_plugin_directory($plugintype, $name) {
     global $CFG;
 
-    $event->timemodified = time();
-
-    if (!$event->id = insert_record('event', $event)) {
-        return false;
+    if ($plugintype === '') {
+        $plugintype = 'mod';
     }
 
-    if (!empty($CFG->calendar)) { // call the add_event function of the selected calendar
-        if (file_exists($CFG->dirroot .'/calendar/'. $CFG->calendar .'/lib.php')) {
-            include_once($CFG->dirroot .'/calendar/'. $CFG->calendar .'/lib.php');
-            $calendar_add_event = $CFG->calendar.'_add_event';
-            if (function_exists($calendar_add_event)) {
-                $calendar_add_event($event);
+    $types = get_plugin_types(true);
+    if (!array_key_exists($plugintype, $types)) {
+        return NULL;
             }
+    $name = clean_param($name, PARAM_SAFEDIR); // just in case ;-)
+
+    if (!empty($CFG->themedir) and $plugintype === 'theme') {
+        if (!is_dir($types['theme'] . '/' . $name)) {
+            // ok, so the theme is supposed to be in the $CFG->themedir
+            return $CFG->themedir . '/' . $name;
         }
     }
 
-    return $event->id;
+    return $types[$plugintype].'/'.$name;
 }
 
 /**
- * Call this function to update an event in the calendar table
- * the event will be identified by the id field of the $event object.
+ * Return exact absolute path to a plugin directory,
+ * this method support "simpletest_" prefix designed for unit testing.
  *
- * @uses $CFG
- * @param array $event An associative array representing an event from the calendar table. The event will be identified by the id field.
- * @return bool
+ * @param string $component name such as 'moodle', 'mod_forum' or special simpletest value
+ * @return string full path to component directory; NULL if not found
  */
-function update_event($event) {
-
+function get_component_directory($component) {
     global $CFG;
+/*
+    $simpletest = false;
+    if (strpos($component, 'simpletest_') === 0) {
+        $subdir = substr($component, strlen('simpletest_'));
+        //TODO: this looks borked, where is it used actually?
+        return $subdir;
+    }
+*/
+    list($type, $plugin) = normalize_component($component);
+
+    if ($type === 'core') {
+        if ($plugin === NULL ) {
+            $path = $CFG->libdir;
+        } else {
+            $subsystems = get_core_subsystems();
+            if (isset($subsystems[$plugin])) {
+                $path = $CFG->dirroot.'/'.$subsystems[$plugin];
+            } else {
+                $path = NULL;
+            }
+        }
 
-    $event->timemodified = time();
+    } else {
+        $path = get_plugin_directory($type, $plugin);
+    }
+
+    return $path;
+}
 
-    if (!empty($CFG->calendar)) { // call the update_event function of the selected calendar
-        if (file_exists($CFG->dirroot .'/calendar/'. $CFG->calendar .'/lib.php')) {
-            include_once($CFG->dirroot .'/calendar/'. $CFG->calendar .'/lib.php');
-            $calendar_update_event = $CFG->calendar.'_update_event';
-            if (function_exists($calendar_update_event)) {
-                $calendar_update_event($event);
+/**
+ * Normalize the component name using the "frankenstyle" names.
+ * @param string $component
+ * @return array $type+$plugin elements
+ */
+function normalize_component($component) {
+    if ($component === 'moodle' or $component === 'core') {
+        $type = 'core';
+        $plugin = NULL;
+
+    } else if (strpos($component, '_') === false) {
+        $subsystems = get_core_subsystems();
+        if (array_key_exists($component, $subsystems)) {
+            $type   = 'core';
+            $plugin = $component;
+        } else {
+            // everything else is a module
+            $type   = 'mod';
+            $plugin = $component;
             }
+
+    } else {
+        list($type, $plugin) = explode('_', $component, 2);
+        $plugintypes = get_plugin_types(false);
+        if ($type !== 'core' and !array_key_exists($type, $plugintypes)) {
+            $type   = 'mod';
+            $plugin = $component;
         }
     }
-    return update_record('event', $event);
+
+    return array($type, $plugin);
 }
 
 /**
- * Call this function to delete the event with id $id from calendar table.
+ * List all core subsystems and their location
  *
- * @uses $CFG
- * @param int $id The id of an event from the 'calendar' table.
- * @return array An associative array with the results from the SQL call.
- * @todo Verify return type
+ * This is a whitelist of components that are part of the core and their
+ * language strings are defined in /lang/en/<<subsystem>>.php. If a given
+ * plugin is not listed here and it does not have proper plugintype prefix,
+ * then it is considered as course activity module.
+ *
+ * The location is dirroot relative path. NULL means there is no special
+ * directory for this subsystem. If the location is set, the subsystem's
+ * renderer.php is expected to be there.
+ *
+ * @return array of (string)name => (string|null)location
  */
-function delete_event($id) {
+function get_core_subsystems() {
+    global $CFG;
+
+    static $info = null;
+
+    if (!$info) {
+        $info = array(
+            'access'      => NULL,
+            'admin'       => $CFG->admin,
+            'auth'        => 'auth',
+            'backup'      => 'backup/util/ui',
+            'block'       => 'blocks',
+            'blog'        => 'blog',
+            'bulkusers'   => NULL,
+            'calendar'    => 'calendar',
+            'cohort'      => 'cohort',
+            'condition'   => NULL,
+            'completion'  => NULL,
+            'countries'   => NULL,
+            'course'      => 'course',
+            'currencies'  => NULL,
+            'dbtransfer'  => NULL,
+            'debug'       => NULL,
+            'dock'        => NULL,
+            'editor'      => 'lib/editor',
+            'edufields'   => NULL,
+            'enrol'       => 'enrol',
+            'error'       => NULL,
+            'filepicker'  => NULL,
+            'files'       => 'files',
+            'filters'     => NULL,
+            'flashdetect' => NULL,
+            'fonts'       => NULL,
+            'form'        => 'lib/form',
+            'grades'      => 'grade',
+            'group'       => 'group',
+            'help'        => NULL,
+            'hub'         => NULL,
+            'imscc'       => NULL,
+            'install'     => NULL,
+            'iso6392'     => NULL,
+            'langconfig'  => NULL,
+            'license'     => NULL,
+            'mathslib'    => NULL,
+            'message'     => 'message',
+            'message'     => 'message',
+            'mimetypes'   => NULL,
+            'mnet'        => 'mnet',
+            'moodle.org'  => NULL, // the dot is nasty, watch out! should be renamed to moodleorg
+            'my'          => 'my',
+            'notes'       => 'notes',
+            'pagetype'    => NULL,
+            'pix'         => NULL,
+            'plagiarism'  => 'plagiarism',
+            'plugin'      => NULL,
+            'portfolio'   => 'portfolio',
+            'publish'     => 'course/publish',
+            'question'    => 'question',
+            'rating'      => 'rating',
+            'register'    => 'admin/registration',
+            'repository'  => 'repository',
+            'rss'         => 'rss',
+            'role'        => $CFG->admin.'/role',
+            'simpletest'  => NULL,
+            'search'      => 'search',
+            'table'       => NULL,
+            'tag'         => 'tag',
+            'timezones'   => NULL,
+            'user'        => 'user',
+            'userkey'     => NULL,
+            'webservice'  => 'webservice',
+            'xmldb'       => NULL,
+        );
+    }
+
+    return $info;
+}
 
+/**
+ * Lists all plugin types
+ * @param bool $fullpaths false means relative paths from dirroot
+ * @return array Array of strings - name=>location
+ */
+function get_plugin_types($fullpaths=true) {
     global $CFG;
 
-    if (!empty($CFG->calendar)) { // call the delete_event function of the selected calendar
-        if (file_exists($CFG->dirroot .'/calendar/'. $CFG->calendar .'/lib.php')) {
-            include_once($CFG->dirroot .'/calendar/'. $CFG->calendar .'/lib.php');
-            $calendar_delete_event = $CFG->calendar.'_delete_event';
-            if (function_exists($calendar_delete_event)) {
-                $calendar_delete_event($id);
+    static $info     = null;
+    static $fullinfo = null;
+
+    if (!$info) {
+        $info = array('qtype'         => 'question/type',
+                      'mod'           => 'mod',
+                      'auth'          => 'auth',
+                      'enrol'         => 'enrol',
+                      'message'       => 'message/output',
+                      'block'         => 'blocks',
+                      'filter'        => 'filter',
+                      'editor'        => 'lib/editor',
+                      'format'        => 'course/format',
+                      'profilefield'  => 'user/profile/field',
+                      'report'        => $CFG->admin.'/report',
+                      'coursereport'  => 'course/report', // must be after system reports
+                      'gradeexport'   => 'grade/export',
+                      'gradeimport'   => 'grade/import',
+                      'gradereport'   => 'grade/report',
+                      'mnetservice'   => 'mnet/service',
+                      'webservice'    => 'webservice',
+                      'repository'    => 'repository',
+                      'portfolio'     => 'portfolio',
+                      'qbehaviour'    => 'question/behaviour',
+                      'qformat'       => 'question/format',
+                      'plagiarism'    => 'plagiarism',
+                      'elis'          => 'elis',
+                      'theme'         => 'theme'); // this is a bit hacky, themes may be in $CFG->themedir too
+
+        $mods = get_plugin_list('mod');
+        foreach ($mods as $mod => $moddir) {
+            if (file_exists("$moddir/db/subplugins.php")) {
+                $subplugins = array();
+                include("$moddir/db/subplugins.php");
+                foreach ($subplugins as $subtype=>$dir) {
+                    $info[$subtype] = $dir;
+                }
+            }
+        }
+
+        $blocks = get_plugin_list('block');
+        foreach ($blocks as $block => $blockdir) {
+            if (file_exists("$blockdir/db/subplugins.php")) {
+                $subplugins = array();
+                include("$blockdir/db/subplugins.php");
+                foreach ($subplugins as $subtype=>$dir) {
+                    $info[$subtype] = $dir;
+                }
+            }
+        }
+
+        $plugins = get_plugin_list('elis');
+        foreach ($plugins as $plugin => $plugindir) {
+            if (file_exists("$plugindir/db/subplugins.php")) {
+                $subplugins = array();
+                include("$plugindir/db/subplugins.php");
+                foreach ($subplugins as $subtype=>$dir) {
+                    $info[$subtype] = $dir;
+                }
             }
         }
+
+        // local is always last!
+        $info['local'] = 'local';
+
+        $fullinfo = array();
+        foreach ($info as $type => $dir) {
+            $fullinfo[$type] = $CFG->dirroot.'/'.$dir;
+        }
     }
-    return delete_records('event', 'id', $id);
+
+    return ($fullpaths ? $fullinfo : $info);
 }
 
 /**
- * Call this function to hide an event in the calendar table
- * the event will be identified by the id field of the $event object.
- *
- * @uses $CFG
- * @param array $event An associative array representing an event from the calendar table. The event will be identified by the id field.
- * @return array An associative array with the results from the SQL call.
- * @todo Verify return type
+ * Simplified version of get_list_of_plugins()
+ * @param string $plugintype type of plugin
+ * @return array name=>fulllocation pairs of plugins of given type
  */
-function hide_event($event) {
+function get_plugin_list($plugintype) {
     global $CFG;
 
-    if (!empty($CFG->calendar)) { // call the update_event function of the selected calendar
-        if (file_exists($CFG->dirroot .'/calendar/'. $CFG->calendar .'/lib.php')) {
-            include_once($CFG->dirroot .'/calendar/'. $CFG->calendar .'/lib.php');
-            $calendar_hide_event = $CFG->calendar.'_hide_event';
-            if (function_exists($calendar_hide_event)) {
-                $calendar_hide_event($event);
+    $ignored = array('CVS', '_vti_cnf', 'simpletest', 'db', 'yui', 'phpunit');
+    if ($plugintype == 'auth') {
+        // Historically we have had an auth plugin called 'db', so allow a special case.
+        $key = array_search('db', $ignored);
+        if ($key !== false) {
+            unset($ignored[$key]);
             }
         }
+
+    if ($plugintype === '') {
+        $plugintype = 'mod';
+    }
+
+    $fulldirs = array();
+
+    if ($plugintype === 'mod') {
+        // mod is an exception because we have to call this function from get_plugin_types()
+        $fulldirs[] = $CFG->dirroot.'/mod';
+
+    } else if ($plugintype === 'block') {
+        // block is similarly an exception because we have to call this function from get_plugin_types()
+        $fulldirs[] = $CFG->dirroot.'/blocks';
+
+    } else if ($plugintype === 'elis') {
+        // elis is an exception because we have to call this function from get_plugin_types()
+        $fulldirs[] = $CFG->dirroot.'/elis';
+
+    } else if ($plugintype === 'theme') {
+        $fulldirs[] = $CFG->dirroot.'/theme';
+        // themes are special because they may be stored also in separate directory
+        if (!empty($CFG->themedir) and file_exists($CFG->themedir) and is_dir($CFG->themedir) ) {
+            $fulldirs[] = $CFG->themedir;
+        }
+
+    } else {
+        $types = get_plugin_types(true);
+        if (!array_key_exists($plugintype, $types)) {
+            return array();
+        }
+        $fulldir = $types[$plugintype];
+        if (!file_exists($fulldir)) {
+            return array();
+        }
+        $fulldirs[] = $fulldir;
+    }
+
+    $result = array();
+
+    foreach ($fulldirs as $fulldir) {
+        if (!is_dir($fulldir)) {
+            continue;
+        }
+        $items = new DirectoryIterator($fulldir);
+        foreach ($items as $item) {
+            if ($item->isDot() or !$item->isDir()) {
+                continue;
+            }
+            $pluginname = $item->getFilename();
+            if (in_array($pluginname, $ignored)) {
+                continue;
+            }
+            if ($pluginname !== clean_param($pluginname, PARAM_SAFEDIR)) {
+                // better ignore plugins with problematic names here
+                continue;
+            }
+            $result[$pluginname] = $fulldir.'/'.$pluginname;
+            unset($item);
     }
-    return set_field('event', 'visible', 0, 'id', $event->id);
+        unset($items);
+    }
+
+    //TODO: implement better sorting once we migrated all plugin names to 'pluginname', ksort does not work for unicode, that is why we have to sort by the dir name, not the strings!
+    ksort($result);
+    return $result;
 }
 
 /**
- * Call this function to unhide an event in the calendar table
- * the event will be identified by the id field of the $event object.
- *
- * @uses $CFG
- * @param array $event An associative array representing an event from the calendar table. The event will be identified by the id field.
- * @return array An associative array with the results from the SQL call.
- * @todo Verify return type
+ * Gets a list of all plugin API functions for given plugin type, function
+ * name, and filename.
+ * @param string $plugintype Plugin type, e.g. 'mod' or 'report'
+ * @param string $function Name of function after the frankenstyle prefix;
+ *   e.g. if the function is called report_courselist_hook then this value
+ *   would be 'hook'
+ * @param string $file Name of file that includes function within plugin,
+ *   default 'lib.php'
+ * @return Array of plugin frankenstyle (e.g. 'report_courselist', 'mod_forum')
+ *   to valid, existing plugin function name (e.g. 'report_courselist_hook',
+ *   'forum_hook')
  */
-function show_event($event) {
-    global $CFG;
+function get_plugin_list_with_function($plugintype, $function, $file='lib.php') {
+    global $CFG; // mandatory in case it is referenced by include()d PHP script
 
-    if (!empty($CFG->calendar)) { // call the update_event function of the selected calendar
-        if (file_exists($CFG->dirroot .'/calendar/'. $CFG->calendar .'/lib.php')) {
-            include_once($CFG->dirroot .'/calendar/'. $CFG->calendar .'/lib.php');
-            $calendar_show_event = $CFG->calendar.'_show_event';
-            if (function_exists($calendar_show_event)) {
-                $calendar_show_event($event);
+    $result = array();
+    // Loop through list of plugins with given type
+    $list = get_plugin_list($plugintype);
+    foreach($list as $plugin => $dir) {
+        $path = $dir . '/' . $file;
+        // If file exists, require it and look for function
+        if (file_exists($path)) {
+            include_once($path);
+            $fullfunction = $plugintype . '_' . $plugin . '_' . $function;
+            if (function_exists($fullfunction)) {
+                // Function exists with standard name. Store, indexed by
+                // frankenstyle name of plugin
+                $result[$plugintype . '_' . $plugin] = $fullfunction;
+            } else if ($plugintype === 'mod') {
+                // For modules, we also allow plugin without full frankenstyle
+                // but just starting with the module name
+                $shortfunction = $plugin . '_' . $function;
+                if (function_exists($shortfunction)) {
+                    $result[$plugintype . '_' . $plugin] = $shortfunction;
+                }
             }
         }
     }
-    return set_field('event', 'visible', 1, 'id', $event->id);
+    return $result;
 }
 
-
-/// ENVIRONMENT CHECKING  ////////////////////////////////////////////////////////////
-
 /**
- * Lists plugin directories within some directory
+ * Lists plugin-like directories within specified directory
  *
- * @uses $CFG
- * @param string $plugin dir under we'll look for plugins (defaults to 'mod')
+ * This function was originally used for standard Moodle plugins, please use
+ * new get_plugin_list() now.
+ *
+ * This function is used for general directory listing and backwards compatility.
+ *
+ * @param string $directory relative directory from root
  * @param string $exclude dir name to exclude from the list (defaults to none)
  * @param string $basedir full path to the base dir where $plugin resides (defaults to $CFG->dirroot)
- * @return array of plugins found under the requested parameters
+ * @return array Sorted array of directory names found under the requested parameters
  */
-function get_list_of_plugins($plugin='mod', $exclude='', $basedir='') {
-
+function get_list_of_plugins($directory='mod', $exclude='', $basedir='') {
     global $CFG;
 
     $plugins = array();
 
     if (empty($basedir)) {
-
-        # This switch allows us to use the appropiate theme directory - and potentialy alternatives for other plugins
-        switch ($plugin) {
-        case "theme":
-            $basedir = $CFG->themedir;
-            break;
-
-        default:
-            $basedir = $CFG->dirroot .'/'. $plugin;
-        }
+        $basedir = $CFG->dirroot .'/'. $directory;
 
     } else {
-        $basedir = $basedir .'/'. $plugin;
+        $basedir = $basedir .'/'. $directory;
     }
 
     if (file_exists($basedir) && filetype($basedir) == 'dir') {
         $dirhandle = opendir($basedir);
         while (false !== ($dir = readdir($dirhandle))) {
             $firstchar = substr($dir, 0, 1);
-            if ($firstchar == '.' or $dir == 'CVS' or $dir == '_vti_cnf' or $dir == 'simpletest' or $dir == $exclude) {
+            if ($firstchar === '.' or $dir === 'CVS' or $dir === '_vti_cnf' or $dir === 'simpletest' or $dir === 'yui' or $dir === 'phpunit' or $dir === $exclude) {
                 continue;
             }
             if (filetype($basedir .'/'. $dir) != 'dir') {
@@ -6312,13 +7343,108 @@ function get_list_of_plugins($plugin='mod', $exclude='', $basedir='') {
     return $plugins;
 }
 
+
+/**
+ * invoke plugin's callback functions
+ *
+ * @param string $type Plugin type e.g. 'mod'
+ * @param string $name Plugin name
+ * @param string $feature Feature code (FEATURE_xx constant)
+ * @param string $action Feature's action
+ * @param string $options parameters of callback function, should be an array
+ * @param mixed $default default value if callback function hasn't been defined
+ * @return mixed
+ */
+function plugin_callback($type, $name, $feature, $action, $options = null, $default=null) {
+    global $CFG;
+
+    $name = clean_param($name, PARAM_SAFEDIR);
+    $function = $name.'_'.$feature.'_'.$action;
+    $file = get_component_directory($type . '_' . $name) . '/lib.php';
+
+    // Load library and look for function
+    if (file_exists($file)) {
+        require_once($file);
+    }
+    if (function_exists($function)) {
+        // Function exists, so just return function result
+        $ret = call_user_func_array($function, (array)$options);
+        if (is_null($ret)) {
+            return $default;
+        } else {
+            return $ret;
+        }
+    }
+    return $default;
+}
+
+/**
+ * Checks whether a plugin supports a specified feature.
+ *
+ * @param string $type Plugin type e.g. 'mod'
+ * @param string $name Plugin name e.g. 'forum'
+ * @param string $feature Feature code (FEATURE_xx constant)
+ * @param mixed $default default value if feature support unknown
+ * @return mixed Feature result (false if not supported, null if feature is unknown,
+ *         otherwise usually true but may have other feature-specific value such as array)
+ */
+function plugin_supports($type, $name, $feature, $default = NULL) {
+    global $CFG;
+
+    $name = clean_param($name, PARAM_SAFEDIR); //bit of extra security
+
+    $function = null;
+
+    if ($type === 'mod') {
+        // we need this special case because we support subplugins in modules,
+        // otherwise it would end up in infinite loop
+        if ($name === 'NEWMODULE') {
+            //somebody forgot to rename the module template
+            return false;
+        }
+        if (file_exists("$CFG->dirroot/mod/$name/lib.php")) {
+            include_once("$CFG->dirroot/mod/$name/lib.php");
+            $function = $type.'_'.$name.'_supports';
+            if (!function_exists($function)) {
+                // legacy non-frankenstyle function name
+                $function = $name.'_supports';
+            }
+        }
+
+    } else {
+        if (!$path = get_plugin_directory($type, $name)) {
+            // non existent plugin type
+            return false;
+        }
+        if (file_exists("$path/lib.php")) {
+            include_once("$path/lib.php");
+            $function = $type.'_'.$name.'_supports';
+        }
+    }
+
+    if ($function and function_exists($function)) {
+        $supports = $function($feature);
+        if (is_null($supports)) {
+            // plugin does not know - use default
+            return $default;
+        } else {
+            return $supports;
+        }
+    }
+
+    //plugin does not care, so use default
+    return $default;
+}
+
 /**
  * Returns true if the current version of PHP is greater that the specified one.
  *
+ * @todo Check PHP version being required here is it too low?
+ *
  * @param string $version The version of php being tested.
  * @return bool
  */
-function check_php_version($version='4.1.0') {
+function check_php_version($version='5.2.4') {
     return (version_compare(phpversion(), $version) >= 0);
 }
 
@@ -6350,10 +7476,10 @@ function check_php_version($version='4.1.0') {
  *
  * @uses $_SERVER
  * @param string $brand The browser identifier being tested
- * @param int $version The version of the browser
+ * @param int $version The version of the browser, if not specified any version (except 5.5 for IE for BC reasons)
  * @return bool true if the given version is below that of the detected browser
  */
- function check_browser_version($brand='MSIE', $version=5.5) {
+ function check_browser_version($brand, $version = null) {
     if (empty($_SERVER['HTTP_USER_AGENT'])) {
         return false;
     }
@@ -6362,8 +7488,13 @@ function check_php_version($version='4.1.0') {
 
     switch ($brand) {
 
-      case 'Camino':   /// Mozilla Firefox browsers
-
+      case 'Camino':   /// OSX browser using Gecke engine
+          if (strpos($agent, 'Camino') === false) {
+              return false;
+          }
+          if (empty($version)) {
+              return true; // no version specified
+          }
               if (preg_match("/Camino\/([0-9\.]+)/i", $agent, $match)) {
                   if (version_compare($match[1], $version) >= 0) {
                       return true;
@@ -6373,9 +7504,14 @@ function check_php_version($version='4.1.0') {
 
 
       case 'Firefox':   /// Mozilla Firefox browsers
-
-          if (preg_match("/Firefox\/([0-9\.]+)/i", $agent, $match)) {
-              if (version_compare($match[1], $version) >= 0) {
+          if (strpos($agent, 'Iceweasel') === false and strpos($agent, 'Firefox') === false) {
+              return false;
+          }
+          if (empty($version)) {
+              return true; // no version specified
+          }
+          if (preg_match("/(Iceweasel|Firefox)\/([0-9\.]+)/i", $agent, $match)) {
+              if (version_compare($match[2], $version) >= 0) {
                   return true;
               }
           }
@@ -6383,8 +7519,7 @@ function check_php_version($version='4.1.0') {
 
 
       case 'Gecko':   /// Gecko based browsers
-
-          if (substr_count($agent, 'Camino')) {
+          if (empty($version) and substr_count($agent, 'Camino')) {
               // MacOS X Camino support
               $version = 20041110;
           }
@@ -6400,25 +7535,30 @@ function check_php_version($version='4.1.0') {
 
 
       case 'MSIE':   /// Internet Explorer
-
-          if (strpos($agent, 'Opera')) {     // Reject Opera
-              return false;
-          }
-          $string = explode(';', $agent);
-          if (!isset($string[1])) {
+          if (strpos($agent, 'Opera') !== false) {     // Reject Opera
               return false;
           }
-          $string = explode(' ', trim($string[1]));
-          if (!isset($string[0]) and !isset($string[1])) {
-              return false;
+          // in case of IE we have to deal with BC of the version parameter
+          if (is_null($version)) {
+              $version = 5.5; // anything older is not considered a browser at all!
           }
-          if ($string[0] == $brand and (float)$string[1] >= $version ) {
+
+          //see: http://www.useragentstring.com/pages/Internet%20Explorer/
+          if (preg_match("/MSIE ([0-9\.]+)/", $agent, $match)) {
+              if (version_compare($match[1], $version) >= 0) {
               return true;
           }
+          }
           break;
 
-      case 'Opera':  /// Opera
 
+      case 'Opera':  /// Opera
+          if (strpos($agent, 'Opera') === false) {
+              return false;
+          }
+          if (empty($version)) {
+              return true; // no version specified
+          }
           if (preg_match("/Opera\/([0-9\.]+)/i", $agent, $match)) {
               if (version_compare($match[1], $version) >= 0) {
                   return true;
@@ -6426,34 +7566,103 @@ function check_php_version($version='4.1.0') {
           }
           break;
 
-      case 'Chrome':
-          if (preg_match("/Chrome\/(.*)[ ]+/i", $agent, $match)) {
+
+      case 'WebKit':  /// WebKit based browser - everything derived from it (Safari, Chrome, iOS, Android and other mobiles)
+          if (strpos($agent, 'AppleWebKit') === false) {
+              return false;
+          }
+          if (empty($version)) {
+              return true; // no version specified
+          }
+          if (preg_match("/AppleWebKit\/([0-9]+)/i", $agent, $match)) {
               if (version_compare($match[1], $version) >= 0) {
                   return true;
               }
           }
           break;
 
-      case 'Safari':  /// Safari
-          // Look for AppleWebKit, excluding strings with OmniWeb, Shiira and SymbianOS
+
+      case 'Safari':  /// Desktop version of Apple Safari browser - no mobile or touch devices
+          if (strpos($agent, 'AppleWebKit') === false) {
+              return false;
+          }
+          // Look for AppleWebKit, excluding strings with OmniWeb, Shiira and SymbianOS and any other mobile devices
           if (strpos($agent, 'OmniWeb')) { // Reject OmniWeb
               return false;
-          } elseif (strpos($agent, 'Shiira')) { // Reject Shiira
+          }
+          if (strpos($agent, 'Shiira')) { // Reject Shiira
+              return false;
+          }
+          if (strpos($agent, 'SymbianOS')) { // Reject SymbianOS
               return false;
-          } elseif (strpos($agent, 'SymbianOS')) { // Reject SymbianOS
+          }
+          if (strpos($agent, 'Android')) { // Reject Androids too
               return false;
           }
           if (strpos($agent, 'iPhone') or strpos($agent, 'iPad') or strpos($agent, 'iPod')) {
               // No Apple mobile devices here - editor does not work, course ajax is not touch compatible, etc.
               return false;
           }
+          if (strpos($agent, 'Chrome')) { // Reject chrome browsers - it needs to be tested explicitly
+              return false;
+          }
 
+          if (empty($version)) {
+              return true; // no version specified
+          }
+          if (preg_match("/AppleWebKit\/([0-9]+)/i", $agent, $match)) {
+              if (version_compare($match[1], $version) >= 0) {
+                  return true;
+              }
+          }
+          break;
+
+
+      case 'Chrome':
+          if (strpos($agent, 'Chrome') === false) {
+              return false;
+          }
+          if (empty($version)) {
+              return true; // no version specified
+          }
+          if (preg_match("/Chrome\/(.*)[ ]+/i", $agent, $match)) {
+              if (version_compare($match[1], $version) >= 0) {
+                  return true;
+              }
+          }
+          break;
+
+
+      case 'Safari iOS':  /// Safari on iPhone, iPad and iPod touch
+          if (strpos($agent, 'AppleWebKit') === false or strpos($agent, 'Safari') === false) {
+              return false;
+          }
+          if (!strpos($agent, 'iPhone') and !strpos($agent, 'iPad') and !strpos($agent, 'iPod')) {
+              return false;
+          }
+          if (empty($version)) {
+              return true; // no version specified
+          }
           if (preg_match("/AppleWebKit\/([0-9]+)/i", $agent, $match)) {
               if (version_compare($match[1], $version) >= 0) {
                   return true;
               }
           }
+          break;
+
 
+      case 'WebKit Android':  /// WebKit browser on Android
+          if (strpos($agent, 'Linux; U; Android') === false) {
+              return false;
+          }
+          if (empty($version)) {
+              return true; // no version specified
+          }
+          if (preg_match("/AppleWebKit\/([0-9]+)/i", $agent, $match)) {
+              if (version_compare($match[1], $version) >= 0) {
+                  return true;
+              }
+          }
           break;
 
     }
@@ -6462,90 +7671,194 @@ function check_php_version($version='4.1.0') {
 }
 
 /**
- * Returns one or several CSS class names that match the user's browser. These can be put
- * in the body tag of the page to apply browser-specific rules without relying on CSS hacks
+ * Returns whether a device/browser combination is mobile, tablet, legacy, default or the result of
+ * an optional admin specified regular expression.  If enabledevicedetection is set to no or not set
+ * it returns default
+ *
+ * @return string device type
  */
-function get_browser_version_classes() {
-    $classes = '';
-    if (check_browser_version("MSIE", "0")) {
-        $classes .= 'ie ';
-        if (check_browser_version("MSIE", 8)) {
-            $classes .= 'ie8 ';
-        } elseif (check_browser_version("MSIE", 7)) {
-            $classes .= 'ie7 ';
-        } elseif (check_browser_version("MSIE", 6)) {
-            $classes .= 'ie6 ';
+function get_device_type() {
+    global $CFG;
+
+    if (empty($CFG->enabledevicedetection) || empty($_SERVER['HTTP_USER_AGENT'])) {
+        return 'default';
         }
-    } elseif (check_browser_version("Firefox", 0) || check_browser_version("Gecko", 0) || check_browser_version("Camino", 0)) {
-        $classes .= 'gecko ';
 
-        if (preg_match('/rv\:([1-2])\.([0-9])/', $_SERVER['HTTP_USER_AGENT'], $matches)) {
-            $classes .= "gecko{$matches[1]}{$matches[2]} ";
+    $useragent = $_SERVER['HTTP_USER_AGENT'];
+
+    if (!empty($CFG->devicedetectregex)) {
+        $regexes = json_decode($CFG->devicedetectregex);
+
+        foreach ($regexes as $value=>$regex) {
+            if (preg_match($regex, $useragent)) {
+                return $value;
+            }
+        }
         }
 
-    } elseif (check_browser_version("Safari", 0)) {
-        $classes .= 'safari ';
+    //mobile detection PHP direct copy from open source detectmobilebrowser.com
+    $phonesregex = '/android|avantgo|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i';
+    $modelsregex = '/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|e\-|e\/|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(di|rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|xda(\-|2|g)|yas\-|your|zeto|zte\-/i';
+    if (preg_match($phonesregex,$useragent) || preg_match($modelsregex,substr($useragent, 0, 4))){
+        return 'mobile';
+    }
 
-    } elseif (check_browser_version("Opera", 0)) {
-        $classes .= 'opera ';
+    $tabletregex = '/Tablet browser|iPad|iProd|GT-P1000|GT-I9000|SHW-M180S|SGH-T849|SCH-I800|Build\/ERE27|sholest/i';
+    if (preg_match($tabletregex, $useragent)) {
+         return 'tablet';
+    }
 
+    if (strpos($_SERVER['HTTP_USER_AGENT'], 'MSIE 6.') !== false) {
+        return 'legacy';
     }
 
-    return $classes;
+    return 'default';
 }
 
 /**
- * This function makes the return value of ini_get consistent if you are
- * setting server directives through the .htaccess file in apache.
- * Current behavior for value set from php.ini On = 1, Off = [blank]
- * Current behavior for value set from .htaccess On = On, Off = Off
- * Contributed by jdell @ unr.edu
+ * Returns a list of the device types supporting by Moodle
  *
- * @param string $ini_get_arg ?
- * @return bool
- * @todo Finish documenting this function
+ * @param boolean $incusertypes includes types specified using the devicedetectregex admin setting
+ * @return array $types
  */
-function ini_get_bool($ini_get_arg) {
-    $temp = ini_get($ini_get_arg);
+function get_device_type_list($incusertypes = true) {
+    global $CFG;
 
-    if ($temp == '1' or strtolower($temp) == 'on') {
-        return true;
+    $types = array('default', 'legacy', 'mobile', 'tablet');
+
+    if ($incusertypes && !empty($CFG->devicedetectregex)) {
+        $regexes = json_decode($CFG->devicedetectregex);
+
+        foreach ($regexes as $value => $regex) {
+            $types[] = $value;
+        }
+    }
+
+    return $types;
+}
+
+/**
+ * Returns the theme selected for a particular device or false if none selected.
+ *
+ * @param string $devicetype
+ * @return string|false The name of the theme to use for the device or the false if not set
+ */
+function get_selected_theme_for_device_type($devicetype = null) {
+    global $CFG;
+
+    if (empty($devicetype)) {
+        $devicetype = get_user_device_type();
     }
+
+    $themevarname = get_device_cfg_var_name($devicetype);
+    if (empty($CFG->$themevarname)) {
     return false;
+    }
+
+    return $CFG->$themevarname;
+}
+
+/**
+ * Returns the name of the device type theme var in $CFG (because there is not a standard convention to allow backwards compatability
+ *
+ * @param string $devicetype
+ * @return string The config variable to use to determine the theme
+ */
+function get_device_cfg_var_name($devicetype = null) {
+    if ($devicetype == 'default' || empty($devicetype)) {
+        return 'theme';
+    }
+
+    return 'theme' . $devicetype;
 }
 
 /**
- * Compatibility stub to provide backward compatibility
+ * Allows the user to switch the device they are seeing the theme for.
+ * This allows mobile users to switch back to the default theme, or theme for any other device.
  *
- * Determines if the HTML editor is enabled.
- * @deprecated Use {@link can_use_html_editor()} instead.
+ * @param string $newdevice The device the user is currently using.
+ * @return string The device the user has switched to
  */
-function can_use_richtext_editor() {
-    return can_use_html_editor();
+function set_user_device_type($newdevice) {
+    global $USER;
+
+    $devicetype = get_device_type();
+    $devicetypes = get_device_type_list();
+
+    if ($newdevice == $devicetype) {
+        unset_user_preference('switchdevice'.$devicetype);
+    } else if (in_array($newdevice, $devicetypes)) {
+        set_user_preference('switchdevice'.$devicetype, $newdevice);
+    }
 }
 
 /**
- * Determines if the HTML editor is enabled.
+ * Returns the device the user is currently using, or if the user has chosen to switch devices
+ * for the current device type the type they have switched to.
  *
- * This depends on site and user
- * settings, as well as the current browser being used.
+ * @return string The device the user is currently using or wishes to use
+ */
+function get_user_device_type() {
+    $device = get_device_type();
+    $switched = get_user_preferences('switchdevice'.$device, false);
+    if ($switched != false) {
+        return $switched;
+    }
+    return $device;
+}
+
+/**
+ * Returns one or several CSS class names that match the user's browser. These can be put
+ * in the body tag of the page to apply browser-specific rules without relying on CSS hacks
  *
- * @return string|false Returns false if editor is not being used, otherwise
- * returns 'MSIE' or 'Gecko'.
+ * @return array An array of browser version classes
  */
-function can_use_html_editor() {
-    global $USER, $CFG;
+function get_browser_version_classes() {
+    $classes = array();
+
+    if (check_browser_version("MSIE", "0")) {
+        $classes[] = 'ie';
+        if (check_browser_version("MSIE", 9)) {
+            $classes[] = 'ie9';
+        } else if (check_browser_version("MSIE", 8)) {
+            $classes[] = 'ie8';
+        } elseif (check_browser_version("MSIE", 7)) {
+            $classes[] = 'ie7';
+        } elseif (check_browser_version("MSIE", 6)) {
+            $classes[] = 'ie6';
+        }
 
-    if (!empty($USER->htmleditor) and !empty($CFG->htmleditor)) {
-        if (check_browser_version('MSIE', 5.5)) {
-            return 'MSIE';
-        } else if (check_browser_version('Gecko', 20030516)) {
-            return 'Gecko';
-        } else if (check_browser_version('Safari', 531)) {
-            return 'AppleWebKit';
+    } else if (check_browser_version("Firefox") || check_browser_version("Gecko") || check_browser_version("Camino")) {
+        $classes[] = 'gecko';
+        if (preg_match('/rv\:([1-2])\.([0-9])/', $_SERVER['HTTP_USER_AGENT'], $matches)) {
+            $classes[] = "gecko{$matches[1]}{$matches[2]}";
         }
+
+    } else if (check_browser_version("WebKit")) {
+        $classes[] = 'safari';
+        if (check_browser_version("Safari iOS")) {
+            $classes[] = 'ios';
+
+        } else if (check_browser_version("WebKit Android")) {
+            $classes[] = 'android';
     }
-    return false;
+
+    } else if (check_browser_version("Opera")) {
+        $classes[] = 'opera';
+
+    }
+
+    return $classes;
+}
+
+/**
+ * Can handle rotated text. Whether it is safe to use the trickery in textrotate.js.
+ *
+ * @return bool True for yes, false for no
+ */
+function can_use_rotated_text() {
+    global $USER;
+    return ajaxenabled(array('Firefox' => 2.0)) && !$USER->screenreader;;
 }
 
 /**
@@ -6596,40 +7909,130 @@ function check_gd_version() {
  * Checks version numbers of main code and all modules to see
  * if there are any mismatches
  *
- * @uses $CFG
+ * @global object
+ * @global object
  * @return bool
  */
 function moodle_needs_upgrading() {
-    global $CFG;
+    global $CFG, $DB, $OUTPUT;
+
+    if (empty($CFG->version)) {
+        return true;
+    }
 
+    // main versio nfirst
     $version = null;
-    include_once($CFG->dirroot .'/version.php');  # defines $version and upgrades
-    if ($CFG->version) {
+    include($CFG->dirroot.'/version.php');  // defines $version and upgrades
         if ($version > $CFG->version) {
             return true;
         }
-        if ($mods = get_list_of_plugins('mod')) {
-            foreach ($mods as $mod) {
-                $fullmod = $CFG->dirroot .'/mod/'. $mod;
-                $module = new object();
-                if (!is_readable($fullmod .'/version.php')) {
-                    notify('Module "'. $mod .'" is not readable - check permissions');
+
+    // modules
+    $mods = get_plugin_list('mod');
+    $installed = $DB->get_records('modules', array(), '', 'name, version');
+    foreach ($mods as $mod => $fullmod) {
+        if ($mod === 'NEWMODULE') {   // Someone has unzipped the template, ignore it
+            continue;
+        }
+        $module = new stdClass();
+        if (!is_readable($fullmod.'/version.php')) {
                     continue;
                 }
-                include_once($fullmod .'/version.php');  # defines $module with version etc
-                if ($currmodule = get_record('modules', 'name', $mod)) {
-                    if ($module->version > $currmodule->version) {
+        include($fullmod.'/version.php');  // defines $module with version etc
+        if (empty($installed[$mod])) {
+            return true;
+        } else if ($module->version > $installed[$mod]->version) {
                         return true;
                     }
                 }
+    unset($installed);
+
+    // blocks
+    $blocks = get_plugin_list('block');
+    $installed = $DB->get_records('block', array(), '', 'name, version');
+    require_once($CFG->dirroot.'/blocks/moodleblock.class.php');
+    foreach ($blocks as $blockname=>$fullblock) {
+        if ($blockname === 'NEWBLOCK') {   // Someone has unzipped the template, ignore it
+            continue;
             }
+        if (!is_readable($fullblock.'/version.php')) {
+            continue;
         }
-    } else {
+        $plugin = new stdClass();
+        $plugin->version = NULL;
+        include($fullblock.'/version.php');
+        if (empty($installed[$blockname])) {
+            return true;
+        } else if ($plugin->version > $installed[$blockname]->version) {
+            return true;
+        }
+    }
+    unset($installed);
+
+    // now the rest of plugins
+    $plugintypes = get_plugin_types();
+    unset($plugintypes['mod']);
+    unset($plugintypes['block']);
+    foreach ($plugintypes as $type=>$unused) {
+        $plugs = get_plugin_list($type);
+        foreach ($plugs as $plug=>$fullplug) {
+            $component = $type.'_'.$plug;
+            if (!is_readable($fullplug.'/version.php')) {
+                continue;
+            }
+            $plugin = new stdClass();
+            include($fullplug.'/version.php');  // defines $plugin with version etc
+            $installedversion = get_config($component, 'version');
+            if (empty($installedversion)) { // new installation
+                return true;
+            } else if ($installedversion < $plugin->version) { // upgrade
         return true;
     }
+        }
+    }
+
     return false;
 }
 
+/**
+ * Sets maximum expected time needed for upgrade task.
+ * Please always make sure that upgrade will not run longer!
+ *
+ * The script may be automatically aborted if upgrade times out.
+ *
+ * @global object
+ * @param int $max_execution_time in seconds (can not be less than 60 s)
+ */
+function upgrade_set_timeout($max_execution_time=300) {
+    global $CFG;
+
+    if (!isset($CFG->upgraderunning) or $CFG->upgraderunning < time()) {
+        $upgraderunning = get_config(null, 'upgraderunning');
+    } else {
+        $upgraderunning = $CFG->upgraderunning;
+    }
+
+    if (!$upgraderunning) {
+        // upgrade not running or aborted
+        print_error('upgradetimedout', 'admin', "$CFG->wwwroot/$CFG->admin/");
+        die;
+    }
+
+    if ($max_execution_time < 60) {
+        // protection against 0 here
+        $max_execution_time = 60;
+    }
+
+    $expected_end = time() + $max_execution_time;
+
+    if ($expected_end < $upgraderunning + 10 and $expected_end > $upgraderunning - 10) {
+        // no need to store new end, it is nearly the same ;-)
+        return;
+    }
+
+    set_time_limit($max_execution_time);
+    set_config('upgraderunning', $expected_end); // keep upgrade locked until this time
+}
 
 /// MISCELLANEOUS ////////////////////////////////////////////////////////////////////
 
@@ -6640,21 +8043,14 @@ function moodle_needs_upgrading() {
  * It uses the cache_flags system to store temporary records, deleting them
  * by name before finishing
  *
- * @uses $CFG
- * @uses $db
+ * @global object
+ * @global object
  * @uses HOURSECS
  */
 function notify_login_failures() {
-    global $CFG, $db;
+    global $CFG, $DB, $OUTPUT;
 
-    switch ($CFG->notifyloginfailures) {
-        case 'mainadmin' :
-            $recip = array(get_admin());
-            break;
-        case 'alladmins':
-            $recip = get_admins();
-            break;
-    }
+    $recip = get_users_from_config($CFG->notifyloginfailures, 'moodle/site:config');
 
     if (empty($CFG->lastnotifyfailure)) {
         $CFG->lastnotifyfailure=0;
@@ -6667,67 +8063,69 @@ function notify_login_failures() {
 
 /// Get all the IPs with more than notifyloginthreshold failures since lastnotifyfailure
 /// and insert them into the cache_flags temp table
-    $iprs = get_recordset_sql("SELECT ip, count(*)
-                                 FROM {$CFG->prefix}log
-                                WHERE module = 'login'
-                                  AND action = 'error'
-                                  AND time > $CFG->lastnotifyfailure
+    $sql = "SELECT ip, COUNT(*)
+              FROM {log}
+             WHERE module = 'login' AND action = 'error'
+                   AND time > ?
                              GROUP BY ip
-                               HAVING count(*) >= $CFG->notifyloginthreshold");
-    while ($iprec = rs_fetch_next_record($iprs)) {
+            HAVING COUNT(*) >= ?";
+    $params = array($CFG->lastnotifyfailure, $CFG->notifyloginthreshold);
+    $rs = $DB->get_recordset_sql($sql, $params);
+    foreach ($rs as $iprec) {
         if (!empty($iprec->ip)) {
             set_cache_flag('login_failure_by_ip', $iprec->ip, '1', 0);
         }
     }
-    rs_close($iprs);
+    $rs->close();
 
 /// Get all the INFOs with more than notifyloginthreshold failures since lastnotifyfailure
 /// and insert them into the cache_flags temp table
-    $infors = get_recordset_sql("SELECT info, count(*)
-                                   FROM {$CFG->prefix}log
-                                  WHERE module = 'login'
-                                    AND action = 'error'
-                                    AND time > $CFG->lastnotifyfailure
+    $sql = "SELECT info, count(*)
+              FROM {log}
+             WHERE module = 'login' AND action = 'error'
+                   AND time > ?
                                GROUP BY info
-                                 HAVING count(*) >= $CFG->notifyloginthreshold");
-    while ($inforec = rs_fetch_next_record($infors)) {
+            HAVING count(*) >= ?";
+    $params = array($CFG->lastnotifyfailure, $CFG->notifyloginthreshold);
+    $rs = $DB->get_recordset_sql($sql, $params);
+    foreach ($rs as $inforec) {
         if (!empty($inforec->info)) {
             set_cache_flag('login_failure_by_info', $inforec->info, '1', 0);
         }
     }
-    rs_close($infors);
+    $rs->close();
 
 /// Now, select all the login error logged records belonging to the ips and infos
 /// since lastnotifyfailure, that we have stored in the cache_flags table
-    $logsrs = get_recordset_sql("SELECT l.*, u.firstname, u.lastname
-                                   FROM {$CFG->prefix}log l
-                                   JOIN {$CFG->prefix}cache_flags cf ON (l.ip = cf.name)
-                              LEFT JOIN {$CFG->prefix}user u ON (l.userid = u.id)
-                                  WHERE l.module = 'login'
-                                    AND l.action = 'error'
-                                    AND l.time > $CFG->lastnotifyfailure
+    $sql = "SELECT l.*, u.firstname, u.lastname
+              FROM {log} l
+              JOIN {cache_flags} cf ON l.ip = cf.name
+         LEFT JOIN {user} u         ON l.userid = u.id
+             WHERE l.module = 'login' AND l.action = 'error'
+                   AND l.time > ?
                                     AND cf.flagtype = 'login_failure_by_ip'
                              UNION ALL
                                  SELECT l.*, u.firstname, u.lastname
-                                   FROM {$CFG->prefix}log l
-                                   JOIN {$CFG->prefix}cache_flags cf ON (l.info = cf.name)
-                              LEFT JOIN {$CFG->prefix}user u ON (l.userid = u.id)
-                                  WHERE l.module = 'login'
-                                    AND l.action = 'error'
-                                    AND l.time > $CFG->lastnotifyfailure
+              FROM {log} l
+              JOIN {cache_flags} cf ON l.info = cf.name
+         LEFT JOIN {user} u         ON l.userid = u.id
+             WHERE l.module = 'login' AND l.action = 'error'
+                   AND l.time > ?
                                     AND cf.flagtype = 'login_failure_by_info'
-                             ORDER BY time DESC");
+          ORDER BY time DESC";
+    $params = array($CFG->lastnotifyfailure, $CFG->lastnotifyfailure);
 
 /// Init some variables
     $count = 0;
     $messages = '';
 /// Iterate over the logs recordset
-    while ($log = rs_fetch_next_record($logsrs)) {
+    $rs = $DB->get_recordset_sql($sql, $params);
+    foreach ($rs as $log) {
         $log->time = userdate($log->time);
         $messages .= get_string('notifyloginfailuresmessage','',$log)."\n";
         $count++;
     }
-    rs_close($logsrs);
+    $rs->close();
 
 /// If we haven't run in the last hour and
 /// we have something useful to report and we
@@ -6744,6 +8142,7 @@ function notify_login_failures() {
     /// For each destination, send mail
         mtrace('Emailing admins about '. $count .' failed login attempts');
         foreach ($recip as $admin) {
+            //emailing the admins directly rather than putting these through the messaging system
             email_to_user($admin,get_admin(), $subject, $body);
         }
 
@@ -6752,18 +8151,18 @@ function notify_login_failures() {
     }
 
 /// Finally, delete all the temp records we have created in cache_flags
-    delete_records_select('cache_flags', "flagtype IN ('login_failure_by_ip', 'login_failure_by_info')");
+    $DB->delete_records_select('cache_flags', "flagtype IN ('login_failure_by_ip', 'login_failure_by_info')");
 }
 
 /**
- * moodle_setlocale
+ * Sets the system locale
  *
- * @uses $CFG
- * @param string $locale ?
  * @todo Finish documenting this function
+ *
+ * @global object
+ * @param string $locale Can be used to force a locale
  */
 function moodle_setlocale($locale='') {
-
     global $CFG;
 
     static $currentlocale = ''; // last locale caching
@@ -6771,7 +8170,7 @@ function moodle_setlocale($locale='') {
     $oldlocale = $currentlocale;
 
 /// Fetch the correct locale based on ostype
-    if($CFG->ostype == 'WINDOWS') {
+    if ($CFG->ostype == 'WINDOWS') {
         $stringtofetch = 'localewin';
     } else {
         $stringtofetch = 'locale';
@@ -6783,7 +8182,7 @@ function moodle_setlocale($locale='') {
     } else if (!empty($CFG->locale)) { // override locale for all language packs
         $currentlocale = $CFG->locale;
     } else {
-        $currentlocale = get_string($stringtofetch);
+        $currentlocale = get_string($stringtofetch, 'langconfig');
     }
 
 /// do nothing if locale already set up
@@ -6818,11 +8217,12 @@ function moodle_setlocale($locale='') {
 /**
  * Converts string to lowercase using most compatible function available.
  *
+ * @todo Remove this function when no longer in use
+ * @deprecated Use textlib->strtolower($text) instead.
+ *
  * @param string $string The string to convert to all lowercase characters.
  * @param string $encoding The encoding on the string.
  * @return string
- * @todo Add examples of calling this function with/without encoding types
- * @deprecated Use textlib->strtolower($text) instead.
  */
 function moodle_strtolower ($string, $encoding='') {
 
@@ -6861,7 +8261,7 @@ function count_letters($string) {
     $textlib = textlib_get_instance();
 
     $string = strip_tags($string); // Tags are out now
-    $string = ereg_replace('[[:space:]]*','',$string); //Whitespace are out now
+    $string = preg_replace('/[[:space:]]*/','',$string); //Whitespace are out now
 
     return $textlib->strlen($string);
 }
@@ -6886,7 +8286,7 @@ function random_string ($length=15) {
 }
 
 /**
- * Generate a complex random string (usefull for md5 salts)
+ * Generate a complex random string (useful for md5 salts)
  *
  * This function is based on the above {@link random_string()} however it uses a
  * larger pool of characters and generates a string between 24 and 32 characters
@@ -6909,19 +8309,20 @@ function complex_random_string($length=null) {
     return $string;
 }
 
-/*
+/**
  * Given some text (which may contain HTML) and an ideal length,
  * this function truncates the text neatly on a word boundary if possible
+ *
+ * @global object
  * @param string $text - text to be shortened
  * @param int $ideal - ideal string length
  * @param boolean $exact if false, $text will not be cut mid-word
+ * @param string $ending The string to append if the passed string is truncated
  * @return string $truncate - shortened string
  */
-
-function shorten_text($text, $ideal=30, $exact = false) {
+function shorten_text($text, $ideal=30, $exact = false, $ending='...') {
 
     global $CFG;
-    $ending = '...';
 
     // if the plain text is shorter than the maximum length, return the whole text
     if (strlen(preg_replace('/<.*?>/', '', $text)) <= $ideal) {
@@ -6982,7 +8383,7 @@ function shorten_text($text, $ideal=30, $exact = false) {
                 }
             }
             $truncate .= substr($line_matchings[2], 0, $left+$entities_length);
-            // maximum lenght is reached, so get off the loop
+            // maximum length is reached, so get off the loop
             break;
         } else {
             $truncate .= $line_matchings[2];
@@ -6997,7 +8398,7 @@ function shorten_text($text, $ideal=30, $exact = false) {
 
     // if the words shouldn't be cut in the middle...
     if (!$exact) {
-        // ...search the last occurance of a space...
+        // ...search the last occurence of a space...
         for ($k=strlen($truncate);$k>0;$k--) {
             if (!empty($truncate[$k]) && ($char = $truncate[$k])) {
                 if ($char == '.' or $char == ' ') {
@@ -7050,11 +8451,12 @@ function shorten_text($text, $ideal=30, $exact = false) {
  * Given dates in seconds, how many weeks is the date from startdate
  * The first week is 1, the second 2 etc ...
  *
+ * @todo Finish documenting this function
+ *
  * @uses WEEKSECS
- * @param ? $startdate ?
- * @param ? $thedate ?
+ * @param int $startdate Timestamp for the start date
+ * @param int $thedate Timestamp for the end date
  * @return string
- * @todo Finish documenting this function
  */
 function getweek ($startdate, $thedate) {
     if ($thedate < $startdate) {   // error
@@ -7066,9 +8468,11 @@ function getweek ($startdate, $thedate) {
 
 /**
  * returns a randomly generated password of length $maxlen.  inspired by
+ *
  * {@link http://www.phpbuilder.com/columns/jesus19990502.php3} and
  * {@link http://es2.php.net/manual/en/function.str-shuffle.php#73254}
  *
+ * @global object
  * @param int $maxlen  The maximum size of the password being generated.
  * @return string
  */
@@ -7132,7 +8536,7 @@ function generate_password($maxlen=10) {
  * Given a float, prints it nicely.
  * Localized floats must not be used in calculations!
  *
- * @param float $flaot The float to print
+ * @param float $float The float to print
  * @param int $places The number of decimal places to print.
  * @param bool $localized use localized decimal separator
  * @return string locale float
@@ -7142,7 +8546,7 @@ function format_float($float, $decimalpoints=1, $localized=true) {
         return '';
     }
     if ($localized) {
-        return number_format($float, $decimalpoints, get_string('decsep'), '');
+        return number_format($float, $decimalpoints, get_string('decsep', 'langconfig'), '');
     } else {
         return number_format($float, $decimalpoints, '.', '');
     }
@@ -7153,6 +8557,7 @@ function format_float($float, $decimalpoints=1, $localized=true) {
  * Do NOT try to do any math operations before this conversion on any user submitted floats!
  *
  * @param  string $locale_float locale aware float representation
+ * @return float
  */
 function unformat_float($locale_float) {
     $locale_float = trim($locale_float);
@@ -7163,7 +8568,7 @@ function unformat_float($locale_float) {
 
     $locale_float = str_replace(' ', '', $locale_float); // no spaces - those might be used as thousand separators
 
-    return (float)str_replace(get_string('decsep'), '.', $locale_float);
+    return (float)str_replace(get_string('decsep', 'langconfig'), '.', $locale_float);
 }
 
 /**
@@ -7208,10 +8613,11 @@ function swapshuffle_assoc($array) {
  * this function returns an array with that amount
  * of items.  The indexes are retained.
  *
- * @param array $array ?
- * @param ? $draws ?
- * @return ?
  * @todo Finish documenting this function
+ *
+ * @param array $array
+ * @param int $draws
+ * @return array
  */
 function draw_rand_array($array, $draws) {
     srand ((double) microtime() * 10000000);
@@ -7240,12 +8646,11 @@ function draw_rand_array($array, $draws) {
 }
 
 /**
- * microtime_diff
+ * Calculate the difference between two microtimes
  *
- * @param string $a ?
- * @param string $b ?
+ * @param string $a The first Microtime
+ * @param string $b The second Microtime
  * @return string
- * @todo Finish documenting this function
  */
 function microtime_diff($a, $b) {
     list($a_dec, $a_sec) = explode(' ', $a);
@@ -7257,9 +8662,9 @@ function microtime_diff($a, $b) {
  * Given a list (eg a,b,c,d,e) this function returns
  * an array of 1->a, 2->b, 3->c etc
  *
- * @param array $list ?
- * @param string $separator ?
- * @todo Finish documenting this function
+ * @param string $list The string to explode into array bits
+ * @param string $separator The separator used within the list string
+ * @return array The now assembled array
  */
 function make_menu_from_list($list, $separator=',') {
 
@@ -7272,18 +8677,23 @@ function make_menu_from_list($list, $separator=',') {
 
 /**
  * Creates an array that represents all the current grades that
- * can be chosen using the given grading type.  Negative numbers
+ * can be chosen using the given grading type.
+ *
+ * Negative numbers
  * are scales, zero is no grade, and positive numbers are maximum
  * grades.
  *
- * @param int $gradingtype ?
- * return int
- * @todo Finish documenting this function
+ * @todo Finish documenting this function or better deprecated this completely!
+ *
+ * @param int $gradingtype
+ * @return array
  */
 function make_grades_menu($gradingtype) {
+    global $DB;
+
     $grades = array();
     if ($gradingtype < 0) {
-        if ($scale = get_record('scale', 'id', - $gradingtype)) {
+        if ($scale = $DB->get_record('scale', array('id'=> (-$gradingtype)))) {
             return make_menu_from_list($scale->scale);
         }
     } else if ($gradingtype > 0) {
@@ -7296,17 +8706,19 @@ function make_grades_menu($gradingtype) {
 }
 
 /**
- * This function returns the nummber of activities
+ * This function returns the number of activities
  * using scaleid in a courseid
  *
+ * @todo Finish documenting this function
+ *
+ * @global object
+ * @global object
  * @param int $courseid ?
  * @param int $scaleid ?
  * @return int
- * @todo Finish documenting this function
  */
 function course_scale_used($courseid, $scaleid) {
-
-    global $CFG;
+    global $CFG, $DB;
 
     $return = 0;
 
@@ -7327,31 +8739,28 @@ function course_scale_used($courseid, $scaleid) {
         }
 
         // check if any course grade item makes use of the scale
-        $return += count_records('grade_items', 'courseid', $courseid, 'scaleid', $scaleid);
+        $return += $DB->count_records('grade_items', array('courseid'=>$courseid, 'scaleid'=>$scaleid));
 
         // check if any outcome in the course makes use of the scale
-        $return += count_records_sql("SELECT COUNT(*)
-                                      FROM {$CFG->prefix}grade_outcomes_courses goc,
-                                           {$CFG->prefix}grade_outcomes go
+        $return += $DB->count_records_sql("SELECT COUNT('x')
+                                             FROM {grade_outcomes_courses} goc,
+                                                  {grade_outcomes} go
                                       WHERE go.id = goc.outcomeid
-                                        AND go.scaleid = $scaleid
-                                        AND goc.courseid = $courseid");
+                                                  AND go.scaleid = ? AND goc.courseid = ?",
+                                          array($scaleid, $courseid));
     }
     return $return;
 }
 
 /**
- * This function returns the nummber of activities
+ * This function returns the number of activities
  * using scaleid in the entire site
  *
- * @param int $scaleid ?
+ * @param int $scaleid
+ * @param array $courses
  * @return int
- * @todo Finish documenting this function. Is return type correct?
  */
-function site_scale_used($scaleid,&$courses) {
-
-    global $CFG;
-
+function site_scale_used($scaleid, &$courses) {
     $return = 0;
 
     if (!is_array($courses) || count($courses) == 0) {
@@ -7371,9 +8780,11 @@ function site_scale_used($scaleid,&$courses) {
 /**
  * make_unique_id_code
  *
- * @param string $extra ?
- * @return string
  * @todo Finish documenting this function
+ *
+ * @uses $_SERVER
+ * @param string $extra Extra string to append to the end of the code
+ * @return string
  */
 function make_unique_id_code($extra='') {
 
@@ -7405,450 +8816,295 @@ function make_unique_id_code($extra='') {
  *
  * The parameter is a comma separated string of subnet definitions.
  * Subnet strings can be in one of three formats:
- *   1: xxx.xxx.xxx.xxx/xx
- *   2: xxx.xxx
- *   3: xxx.xxx.xxx.xxx-xxx   //a range of IP addresses in the last group.
+ *   1: xxx.xxx.xxx.xxx/nn or xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx/nnn          (number of bits in net mask)
+ *   2: xxx.xxx.xxx.xxx-yyy or  xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx::xxxx-yyyy (a range of IP addresses in the last group)
+ *   3: xxx.xxx or xxx.xxx. or xxx:xxx:xxxx or xxx:xxx:xxxx.                  (incomplete address, a bit non-technical ;-)
  * Code for type 1 modified from user posted comments by mediator at
  * {@link http://au.php.net/manual/en/function.ip2long.php}
  *
- * TODO one day we will have to make this work with IP6.
- *
  * @param string $addr    The address you are checking
  * @param string $subnetstr    The string of subnet addresses
  * @return bool
  */
 function address_in_subnet($addr, $subnetstr) {
 
+    if ($addr == '0.0.0.0') {
+        return false;
+    }
     $subnets = explode(',', $subnetstr);
     $found = false;
     $addr = trim($addr);
+    $addr = cleanremoteaddr($addr, false); // normalise
+    if ($addr === null) {
+        return false;
+    }
+    $addrparts = explode(':', $addr);
+
+    $ipv6 = strpos($addr, ':');
 
     foreach ($subnets as $subnet) {
         $subnet = trim($subnet);
-        if (strpos($subnet, '/') !== false) { /// type 1
+        if ($subnet === '') {
+            continue;
+        }
+
+        if (strpos($subnet, '/') !== false) {
+        ///1: xxx.xxx.xxx.xxx/nn or xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx/nnn
             list($ip, $mask) = explode('/', $subnet);
-            if (!is_number($mask) || $mask < 0 || $mask > 32) {
+            $mask = trim($mask);
+            if (!is_number($mask)) {
+                continue; // incorect mask number, eh?
+            }
+            $ip = cleanremoteaddr($ip, false); // normalise
+            if ($ip === null) {
+                continue;
+            }
+            if (strpos($ip, ':') !== false) {
+                // IPv6
+                if (!$ipv6) {
                 continue;
             }
+                if ($mask > 128 or $mask < 0) {
+                    continue; // nonsense
+                }
             if ($mask == 0) {
-                return true;
+                    return true; // any address
             }
-            if ($mask == 32) {
+                if ($mask == 128) {
                 if ($ip === $addr) {
                     return true;
                 }
                 continue;
             }
-            $mask = 0xffffffff << (32 - $mask);
-            $found = ((ip2long($addr) & $mask) == (ip2long($ip) & $mask));
-        } else if (strpos($subnet, '-') !== false)  {/// type 3
-            $subnetparts = explode('.', $subnet);
-            $addrparts = explode('.', $addr);
-            $subnetrange = explode('-', array_pop($subnetparts));
-            if (count($subnetrange) == 2) {
-                $lastaddrpart = array_pop($addrparts);
-                $found = ($subnetparts == $addrparts &&
-                        $subnetrange[0] <= $lastaddrpart && $lastaddrpart <= $subnetrange[1]);
+                $ipparts = explode(':', $ip);
+                $modulo  = $mask % 16;
+                $ipnet   = array_slice($ipparts, 0, ($mask-$modulo)/16);
+                $addrnet = array_slice($addrparts, 0, ($mask-$modulo)/16);
+                if (implode(':', $ipnet) === implode(':', $addrnet)) {
+                    if ($modulo == 0) {
+                        return true;
             }
-        } else { /// type 2
-            if ($subnet[strlen($subnet) - 1] != '.') {
-                $subnet .= '.';
+                    $pos     = ($mask-$modulo)/16;
+                    $ipnet   = hexdec($ipparts[$pos]);
+                    $addrnet = hexdec($addrparts[$pos]);
+                    $mask    = 0xffff << (16 - $modulo);
+                    if (($addrnet & $mask) == ($ipnet & $mask)) {
+                        return true;
             }
-            $found = (strpos($addr . '.', $subnet) === 0);
         }
 
-        if ($found) {
-            break;
+            } else {
+                // IPv4
+                if ($ipv6) {
+                    continue;
         }
+                if ($mask > 32 or $mask < 0) {
+                    continue; // nonsense
     }
-    return $found;
-}
-
-/**
- * This function sets the $HTTPSPAGEREQUIRED global
- * (used in some parts of moodle to change some links)
- * and calculate the proper wwwroot to be used
- *
- * By using this function properly, we can ensure 100% https-ized pages
- * at our entire discretion (login, forgot_password, change_password)
- */
-function httpsrequired() {
-
-    global $CFG, $HTTPSPAGEREQUIRED;
-
-    if (!empty($CFG->loginhttps)) {
-        $HTTPSPAGEREQUIRED = true;
-        $CFG->httpswwwroot = str_replace('http:', 'https:', $CFG->wwwroot);
-        $CFG->httpsthemewww = str_replace('http:', 'https:', $CFG->themewww);
-
-        // change theme URLs to https
-        theme_setup();
-
-    } else {
-        $CFG->httpswwwroot = $CFG->wwwroot;
-        $CFG->httpsthemewww = $CFG->themewww;
+                if ($mask == 0) {
+                    return true;
     }
-}
-
-/**
- * For outputting debugging info
- *
- * @uses STDOUT
- * @param string $string ?
- * @param string $eol ?
- * @todo Finish documenting this function
- */
-function mtrace($string, $eol="\n", $sleep=0) {
-
-    if (defined('STDOUT')) {
-        fwrite(STDOUT, $string.$eol);
-    } else {
-        echo $string . $eol;
+                if ($mask == 32) {
+                    if ($ip === $addr) {
+                        return true;
     }
-
-    flush();
-
-    //delay to keep message on user's screen in case of subsequent redirect
-    if ($sleep) {
-        sleep($sleep);
+                    continue;
     }
-}
-
-//Replace 1 or more slashes or backslashes to 1 slash
-function cleardoubleslashes ($path) {
-    return preg_replace('/(\/|\\\){1,}/','/',$path);
-}
-
-function zip_files ($originalfiles, $destination) {
-//Zip an array of files/dirs to a destination zip file
-//Both parameters must be FULL paths to the files/dirs
-
-    global $CFG;
-
-    //Extract everything from destination
-    $path_parts = pathinfo(cleardoubleslashes($destination));
-    $destpath = $path_parts["dirname"];       //The path of the zip file
-    $destfilename = $path_parts["basename"];  //The name of the zip file
-    $extension = $path_parts["extension"];    //The extension of the file
-
-    //If no file, error
-    if (empty($destfilename)) {
-        return false;
+                $mask = 0xffffffff << (32 - $mask);
+                if (((ip2long($addr) & $mask) == (ip2long($ip) & $mask))) {
+                    return true;
     }
-
-    //If no extension, add it
-    if (empty($extension)) {
-        $extension = 'zip';
-        $destfilename = $destfilename.'.'.$extension;
     }
 
-    //Check destination path exists
-    if (!is_dir($destpath)) {
-        return false;
+        } else if (strpos($subnet, '-') !== false)  {
+        /// 2: xxx.xxx.xxx.xxx-yyy or  xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx::xxxx-yyyy ...a range of IP addresses in the last group.
+            $parts = explode('-', $subnet);
+            if (count($parts) != 2) {
+                continue;
     }
 
-    //Check destination path is writable. TODO!!
-
-    //Clean destination filename
-    $destfilename = clean_filename($destfilename);
-
-    //Now check and prepare every file
-    $files = array();
-    $origpath = NULL;
-
-    foreach ($originalfiles as $file) {  //Iterate over each file
-        //Check for every file
-        $tempfile = cleardoubleslashes($file); // no doubleslashes!
-        //Calculate the base path for all files if it isn't set
-        if ($origpath === NULL) {
-            $origpath = rtrim(cleardoubleslashes(dirname($tempfile)), "/");
+            if (strpos($subnet, ':') !== false) {
+                // IPv6
+                if (!$ipv6) {
+                    continue;
         }
-        //See if the file is readable
-        if (!is_readable($tempfile)) {  //Is readable
+                $ipstart = cleanremoteaddr(trim($parts[0]), false); // normalise
+                if ($ipstart === null) {
             continue;
         }
-        //See if the file/dir is in the same directory than the rest
-        if (rtrim(cleardoubleslashes(dirname($tempfile)), "/") != $origpath) {
+                $ipparts = explode(':', $ipstart);
+                $start = hexdec(array_pop($ipparts));
+                $ipparts[] = trim($parts[1]);
+                $ipend = cleanremoteaddr(implode(':', $ipparts), false); // normalise
+                if ($ipend === null) {
             continue;
         }
-        //Add the file to the array
-        $files[] = $tempfile;
+                $ipparts[7] = '';
+                $ipnet = implode(':', $ipparts);
+                if (strpos($addr, $ipnet) !== 0) {
+                    continue;
     }
+                $ipparts = explode(':', $ipend);
+                $end = hexdec($ipparts[7]);
 
-    //Everything is ready:
-    //    -$origpath is the path where ALL the files to be compressed reside (dir).
-    //    -$destpath is the destination path where the zip file will go (dir).
-    //    -$files is an array of files/dirs to compress (fullpath)
-    //    -$destfilename is the name of the zip file (without path)
+                $addrend = hexdec($addrparts[7]);
 
-    //print_object($files);                  //Debug
-
-    if (empty($CFG->zip)) {    // Use built-in php-based zip function
-
-        include_once("$CFG->libdir/pclzip/pclzip.lib.php");
-        //rewrite filenames because the old method with PCLZIP_OPT_REMOVE_PATH does not work under win32
-        $zipfiles = array();
-        $start = strlen($origpath)+1;
-        foreach($files as $file) {
-            $tf = array();
-            $tf[PCLZIP_ATT_FILE_NAME] = $file;
-            $tf[PCLZIP_ATT_FILE_NEW_FULL_NAME] = substr($file, $start);
-            $zipfiles[] = $tf;
-        }
-        //create the archive
-        $archive = new PclZip(cleardoubleslashes("$destpath/$destfilename"));
-        if (($list = $archive->create($zipfiles) == 0)) {
-            notice($archive->errorInfo(true));
-            return false;
+                if (($addrend >= $start) and ($addrend <= $end)) {
+                    return true;
         }
 
-    } else {                   // Use external zip program
-
-        $filestozip = "";
-        foreach ($files as $filetozip) {
-            $filestozip .= escapeshellarg(basename($filetozip));
-            $filestozip .= " ";
-        }
-        //Construct the command
-        $separator = strtoupper(substr(PHP_OS, 0, 3)) === 'WIN' ? ' &' : ' ;';
-        $command = 'cd '.escapeshellarg($origpath).$separator.
-                    escapeshellarg($CFG->zip).' -r '.
-                    escapeshellarg(cleardoubleslashes("$destpath/$destfilename")).' '.$filestozip;
-        //All converted to backslashes in WIN
-        if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {
-            $command = str_replace('/','\\',$command);
+            } else {
+                // IPv4
+                if ($ipv6) {
+                    continue;
         }
-        Exec($command);
+                $ipstart = cleanremoteaddr(trim($parts[0]), false); // normalise
+                if ($ipstart === null) {
+                    continue;
     }
-    return true;
-}
-
-function unzip_file ($zipfile, $destination = '', $showstatus = true) {
-//Unzip one zip file to a destination dir
-//Both parameters must be FULL paths
-//If destination isn't specified, it will be the
-//SAME directory where the zip file resides.
-
-    global $CFG;
-
-    //Extract everything from zipfile
-    $path_parts = pathinfo(cleardoubleslashes($zipfile));
-    $zippath = $path_parts["dirname"];       //The path of the zip file
-    $zipfilename = $path_parts["basename"];  //The name of the zip file
-    $extension = $path_parts["extension"];    //The extension of the file
-
-    //If no file, error
-    if (empty($zipfilename)) {
-        return false;
+                $ipparts = explode('.', $ipstart);
+                $ipparts[3] = trim($parts[1]);
+                $ipend = cleanremoteaddr(implode('.', $ipparts), false); // normalise
+                if ($ipend === null) {
+                    continue;
     }
 
-    //If no extension, error
-    if (empty($extension)) {
-        return false;
+                if ((ip2long($addr) >= ip2long($ipstart)) and (ip2long($addr) <= ip2long($ipend))) {
+                    return true;
     }
-
-    //Clear $zipfile
-    $zipfile = cleardoubleslashes($zipfile);
-
-    //Check zipfile exists
-    if (!file_exists($zipfile)) {
-        return false;
     }
 
-    //If no destination, passed let's go with the same directory
-    if (empty($destination)) {
-        $destination = $zippath;
+        } else {
+        /// 3: xxx.xxx or xxx.xxx. or xxx:xxx:xxxx or xxx:xxx:xxxx.
+            if (strpos($subnet, ':') !== false) {
+                // IPv6
+                if (!$ipv6) {
+                    continue;
     }
-
-    //Clear $destination
-    $destpath = rtrim(cleardoubleslashes($destination), "/");
-
-    //Check destination path exists
-    if (!is_dir($destpath)) {
-        return false;
+                $parts = explode(':', $subnet);
+                $count = count($parts);
+                if ($parts[$count-1] === '') {
+                    unset($parts[$count-1]); // trim trailing :
+                    $count--;
+                    $subnet = implode('.', $parts);
     }
-
-    //Check destination path is writable. TODO!!
-
-    //Everything is ready:
-    //    -$zippath is the path where the zip file resides (dir)
-    //    -$zipfilename is the name of the zip file (without path)
-    //    -$destpath is the destination path where the zip file will uncompressed (dir)
-
-    $list = array();
-
-    require_once("$CFG->libdir/filelib.php");
-
-    do {
-        $temppath = "$CFG->dataroot/temp/unzip/".random_string(10);
-    } while (file_exists($temppath));
-    if (!check_dir_exists($temppath, true, true)) {
-        return false;
+                $isip = cleanremoteaddr($subnet, false); // normalise
+                if ($isip !== null) {
+                    if ($isip === $addr) {
+                        return true;
     }
-
-    if (empty($CFG->unzip)) {    // Use built-in php-based unzip function
-
-        include_once("$CFG->libdir/pclzip/pclzip.lib.php");
-        $archive = new PclZip(cleardoubleslashes("$zippath/$zipfilename"));
-        if (!$list = $archive->extract(PCLZIP_OPT_PATH, $temppath,
-                                       PCLZIP_CB_PRE_EXTRACT, 'unzip_cleanfilename',
-                                       PCLZIP_OPT_EXTRACT_DIR_RESTRICTION, $temppath)) {
-            if (!empty($showstatus)) {
-                notice($archive->errorInfo(true));
+                    continue;
+                } else if ($count > 8) {
+                    continue;
             }
-            return false;
+                $zeros = array_fill(0, 8-$count, '0');
+                $subnet = $subnet.':'.implode(':', $zeros).'/'.($count*16);
+                if (address_in_subnet($addr, $subnet)) {
+                    return true;
         }
 
-    } else {                     // Use external unzip program
-
-        $separator = strtoupper(substr(PHP_OS, 0, 3)) === 'WIN' ? ' &' : ' ;';
-        $redirection = strtoupper(substr(PHP_OS, 0, 3)) === 'WIN' ? '' : ' 2>&1';
-
-        $command = 'cd '.escapeshellarg($zippath).$separator.
-                    escapeshellarg($CFG->unzip).' -o '.
-                    escapeshellarg(cleardoubleslashes("$zippath/$zipfilename")).' -d '.
-                    escapeshellarg($temppath).$redirection;
-        //All converted to backslashes in WIN
-        if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {
-            $command = str_replace('/','\\',$command);
-        }
-        Exec($command,$list);
+            } else {
+                // IPv4
+                if ($ipv6) {
+                    continue;
     }
-
-    unzip_process_temp_dir($temppath, $destpath);
-    fulldelete($temppath);
-
-    //Display some info about the unzip execution
-    if ($showstatus) {
-        unzip_show_status($list, $temppath, $destpath);
+                $parts = explode('.', $subnet);
+                $count = count($parts);
+                if ($parts[$count-1] === '') {
+                    unset($parts[$count-1]); // trim trailing .
+                    $count--;
+                    $subnet = implode('.', $parts);
     }
-
+                if ($count == 4) {
+                    $subnet = cleanremoteaddr($subnet, false); // normalise
+                    if ($subnet === $addr) {
     return true;
-}
-
-/**
- * Sanitize temporary unzipped files and move to target dir.
- * @param string $temppath path to temporary dir with unzip output
- * @param string $destpath destination path
- * @return void
- */
-function unzip_process_temp_dir($temppath, $destpath) {
-    global $CFG;
-
-    $filepermissions = ($CFG->directorypermissions & 0666); // strip execute flags
-
-    if (check_dir_exists($destpath, true, true)) {
-        $currdir = opendir($temppath);
-        while (false !== ($file = readdir($currdir))) {
-            if ($file <> ".." && $file <> ".") {
-                $fullfile = "$temppath/$file";
-                if (is_link($fullfile)) {
-                    //somebody tries to sneak in symbolik link - no way!
-                    continue;
                 }
-                $cleanfile = clean_param($file, PARAM_FILE); // no dangerous chars
-                if ($cleanfile === '') {
-                    // invalid file name
                     continue;
-                }
-                if ($cleanfile !== $file and file_exists("$temppath/$cleanfile")) {
-                    // eh, weird chars collision detected
+                } else if ($count > 4) {
                     continue;
                 }
-                $descfile = "$destpath/$cleanfile";
-                if (is_dir($fullfile)) {
-                    // recurse into subdirs
-                    unzip_process_temp_dir($fullfile, $descfile);
-                }
-                if (is_file($fullfile)) {
-                    // rename and move the file
-                    if (file_exists($descfile)) {
-                        //override existing files
-                        unlink($descfile);
-                    }
-                    rename($fullfile, $descfile);
-                    chmod($descfile, $filepermissions);
+                $zeros = array_fill(0, 4-$count, '0');
+                $subnet = $subnet.'.'.implode('.', $zeros).'/'.($count*8);
+                if (address_in_subnet($addr, $subnet)) {
+                    return true;
                 }
             }
         }
-        closedir($currdir);
     }
+
+    return false;
 }
 
-function unzip_cleanfilename ($p_event, &$p_header) {
-//This function is used as callback in unzip_file() function
-//to clean illegal characters for given platform and to prevent directory traversal.
-//Produces the same result as info-zip unzip.
-    $p_header['filename'] = ereg_replace('[[:cntrl:]]', '', $p_header['filename']); //strip control chars first!
-    $p_header['filename'] = ereg_replace('\.\.+', '', $p_header['filename']); //directory traversal protection
-    if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {
-        $p_header['filename'] = ereg_replace('[:*"?<>|]', '_', $p_header['filename']); //replace illegal chars
-        $p_header['filename'] = ereg_replace('^([a-zA-Z])_', '\1:', $p_header['filename']); //repair drive letter
+/**
+ * For outputting debugging info
+ *
+ * @uses STDOUT
+ * @param string $string The string to write
+ * @param string $eol The end of line char(s) to use
+ * @param string $sleep Period to make the application sleep
+ *                      This ensures any messages have time to display before redirect
+ */
+function mtrace($string, $eol="\n", $sleep=0) {
+
+    if (defined('STDOUT')) {
+        fwrite(STDOUT, $string.$eol);
     } else {
-        //Add filtering for other systems here
-        // BSD: none (tested)
-        // Linux: ??
-        // MacosX: ??
+        echo $string . $eol;
+    }
+
+    flush();
+
+    //delay to keep message on user's screen in case of subsequent redirect
+    if ($sleep) {
+        sleep($sleep);
     }
-    $p_header['filename'] = cleardoubleslashes($p_header['filename']); //normalize the slashes/backslashes
-    return 1;
 }
 
-function unzip_show_status($list, $removepath, $removepath2) {
-//This function shows the results of the unzip execution
-//depending of the value of the $CFG->zip, results will be
-//text or an array of files.
+/**
+ * Replace 1 or more slashes or backslashes to 1 slash
+ *
+ * @param string $path The path to strip
+ * @return string the path with double slashes removed
+ */
+function cleardoubleslashes ($path) {
+    return preg_replace('/(\/|\\\){1,}/','/',$path);
+}
 
-    global $CFG;
+/**
+ * Is current ip in give list?
+ *
+ * @param string $list
+ * @return bool
+ */
+function remoteip_in_list($list){
+    $inlist = false;
+    $client_ip = getremoteaddr(null);
 
-    if (empty($CFG->unzip)) {    // Use built-in php-based zip function
-        $strname = get_string("name");
-        $strsize = get_string("size");
-        $strmodified = get_string("modified");
-        $strstatus = get_string("status");
-        echo "<table width=\"640\">";
-        echo "<tr><th class=\"header\" scope=\"col\">$strname</th>";
-        echo "<th class=\"header\" align=\"right\" scope=\"col\">$strsize</th>";
-        echo "<th class=\"header\" align=\"right\" scope=\"col\">$strmodified</th>";
-        echo "<th class=\"header\" align=\"right\" scope=\"col\">$strstatus</th></tr>";
-        foreach ($list as $item) {
-            echo "<tr>";
-            $item['filename'] = str_replace(cleardoubleslashes($removepath).'/', "", $item['filename']);
-            $item['filename'] = str_replace(cleardoubleslashes($removepath2).'/', "", $item['filename']);
-            echo '<td align="left" style="white-space:nowrap ">'.s(clean_param($item['filename'], PARAM_PATH)).'</td>';
-            if (! $item['folder']) {
-                echo '<td align="right" style="white-space:nowrap ">'.display_size($item['size']).'</td>';
-            } else {
-                echo "<td>&nbsp;</td>";
-            }
-            $filedate  = userdate($item['mtime'], get_string("strftimedatetime"));
-            echo '<td align="right" style="white-space:nowrap ">'.$filedate.'</td>';
-            echo '<td align="right" style="white-space:nowrap ">'.$item['status'].'</td>';
-            echo "</tr>";
+    if(!$client_ip){
+        // ensure access on cli
+        return true;
         }
-        echo "</table>";
 
-    } else {                   // Use external zip program
-        print_simple_box_start("center");
-        echo "<pre>";
-        foreach ($list as $item) {
-            $item = str_replace(cleardoubleslashes($removepath.'/'), '', $item);
-            $item = str_replace(cleardoubleslashes($removepath2.'/'), '', $item);
-            echo s($item).'<br />';
+    $list = explode("\n", $list);
+    foreach($list as $subnet) {
+        $subnet = trim($subnet);
+        if (address_in_subnet($client_ip, $subnet)) {
+            $inlist = true;
+            break;
         }
-        echo "</pre>";
-        print_simple_box_end();
     }
+    return $inlist;
 }
 
 /**
  * Returns most reliable client address
  *
+ * @global object
+ * @param string $default If an address can't be determined, then return this
  * @return string The remote IP address
  */
-define('GETREMOTEADDR_SKIP_HTTP_CLIENT_IP', '1');
-define('GETREMOTEADDR_SKIP_HTTP_X_FORWARDED_FOR', '2');
-function getremoteaddr() {
+function getremoteaddr($default='0.0.0.0') {
     global $CFG;
 
     if (empty($CFG->getremoteaddrconf)) {
@@ -7860,197 +9116,168 @@ function getremoteaddr() {
     }
     if (!($variablestoskip & GETREMOTEADDR_SKIP_HTTP_CLIENT_IP)) {
         if (!empty($_SERVER['HTTP_CLIENT_IP'])) {
-            return cleanremoteaddr($_SERVER['HTTP_CLIENT_IP']);
+            $address = cleanremoteaddr($_SERVER['HTTP_CLIENT_IP']);
+            return $address ? $address : $default;
         }
     }
     if (!($variablestoskip & GETREMOTEADDR_SKIP_HTTP_X_FORWARDED_FOR)) {
         if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) {
-            return cleanremoteaddr($_SERVER['HTTP_X_FORWARDED_FOR']);
+            $address = cleanremoteaddr($_SERVER['HTTP_X_FORWARDED_FOR']);
+            return $address ? $address : $default;
         }
     }
     if (!empty($_SERVER['REMOTE_ADDR'])) {
-        return cleanremoteaddr($_SERVER['REMOTE_ADDR']);
+        $address = cleanremoteaddr($_SERVER['REMOTE_ADDR']);
+        return $address ? $address : $default;
     } else {
-        return null;
+        return $default;
     }
 }
 
 /**
- * Cleans a remote address ready to put into the log table
+ * Cleans an ip address. Internal addresses are now allowed.
+ * (Originally local addresses were not allowed.)
+ *
+ * @param string $addr IPv4 or IPv6 address
+ * @param bool $compress use IPv6 address compression
+ * @return string normalised ip address string, null if error
  */
-function cleanremoteaddr($addr) {
-    $originaladdr = $addr;
-    $matches = array();
-    // first get all things that look like IP addresses.
-    if (!preg_match_all('/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/',$addr,$matches,PREG_SET_ORDER)) {
-        return '';
+function cleanremoteaddr($addr, $compress=false) {
+    $addr = trim($addr);
+
+    //TODO: maybe add a separate function is_addr_public() or something like this
+
+    if (strpos($addr, ':') !== false) {
+        // can be only IPv6
+        $parts = explode(':', $addr);
+        $count = count($parts);
+
+        if (strpos($parts[$count-1], '.') !== false) {
+            //legacy ipv4 notation
+            $last = array_pop($parts);
+            $ipv4 = cleanremoteaddr($last, true);
+            if ($ipv4 === null) {
+                return null;
     }
-    $goodmatches = array();
-    $lanmatches = array();
-    foreach ($matches as $match) {
-        //        print_r($match);
-        // check to make sure it's not an internal address.
-        // the following are reserved for private lans...
-        // 10.0.0.0 - 10.255.255.255
-        // 172.16.0.0 - 172.31.255.255
-        // 192.168.0.0 - 192.168.255.255
-        // 169.254.0.0 -169.254.255.255
-        $bits = explode('.',$match[0]);
-        if (count($bits) != 4) {
-            // weird, preg match shouldn't give us it.
-            continue;
+            $bits = explode('.', $ipv4);
+            $parts[] = dechex($bits[0]).dechex($bits[1]);
+            $parts[] = dechex($bits[2]).dechex($bits[3]);
+            $count = count($parts);
+            $addr = implode(':', $parts);
         }
-        if (($bits[0] == 10)
-            || ($bits[0] == 172 && $bits[1] >= 16 && $bits[1] <= 31)
-            || ($bits[0] == 192 && $bits[1] == 168)
-            || ($bits[0] == 169 && $bits[1] == 254)) {
-            $lanmatches[] = $match[0];
-            continue;
+
+        if ($count < 3 or $count > 8) {
+            return null; // severly malformed
         }
-        // finally, it's ok
-        $goodmatches[] = $match[0];
+
+        if ($count != 8) {
+            if (strpos($addr, '::') === false) {
+                return null; // malformed
     }
-    if (!count($goodmatches)) {
-        // perhaps we have a lan match, it's probably better to return that.
-        if (!count($lanmatches)) {
-            return '';
-        } else {
-            return array_pop($lanmatches);
+            // uncompress ::
+            $insertat = array_search('', $parts, true);
+            $missing = array_fill(0, 1 + 8 - $count, '0');
+            array_splice($parts, $insertat, 1, $missing);
+            foreach ($parts as $key=>$part) {
+                if ($part === '') {
+                    $parts[$key] = '0';
         }
     }
-    if (count($goodmatches) == 1) {
-        return $goodmatches[0];
     }
-    //Commented out following because there are so many, and it clogs the logs   MDL-13544
-    //error_log("NOTICE: cleanremoteaddr gives us something funny: $originaladdr had ".count($goodmatches)." matches");
-
-    // We need to return something, so return the first
-    return array_pop($goodmatches);
-}
 
-/**
- * file_put_contents is only supported by php 5.0 and higher
- * so if it is not predefined, define it here
- *
- * @param $file full path of the file to write
- * @param $contents contents to be sent
- * @return number of bytes written (false on error)
- */
-if(!function_exists('file_put_contents')) {
-    function file_put_contents($file, $contents) {
-        $result = false;
-        if ($f = fopen($file, 'w')) {
-            $result = fwrite($f, $contents);
-            fclose($f);
+        $adr = implode(':', $parts);
+        if (!preg_match('/^([0-9a-f]{1,4})(:[0-9a-f]{1,4})*$/i', $adr)) {
+            return null; // incorrect format - sorry
         }
+
+        // normalise 0s and case
+        $parts = array_map('hexdec', $parts);
+        $parts = array_map('dechex', $parts);
+
+        $result = implode(':', $parts);
+
+        if (!$compress) {
         return $result;
     }
-}
 
-/**
- * The clone keyword is only supported from PHP 5 onwards.
- * The behaviour of $obj2 = $obj1 differs fundamentally
- * between PHP 4 and PHP 5. In PHP 4 a copy of $obj1 was
- * created, in PHP 5 $obj1 is referenced. To create a copy
- * in PHP 5 the clone keyword was introduced. This function
- * simulates this behaviour for PHP < 5.0.0.
- * See also: http://mjtsai.com/blog/2004/07/15/php-5-object-references/
- *
- * Modified 2005-09-29 by Eloy (from Julian Sedding proposal)
- * Found a better implementation (more checks and possibilities) from PEAR:
- * http://cvs.php.net/co.php/pear/PHP_Compat/Compat/Function/clone.php
- *
- * @param object $obj
- * @return object
- */
-if(!check_php_version('5.0.0')) {
-// the eval is needed to prevent PHP 5 from getting a parse error!
-eval('
-    function clone($obj) {
-    /// Sanity check
-        if (!is_object($obj)) {
-            user_error(\'clone() __clone method called on non-object\', E_USER_WARNING);
-            return;
+        if ($result === '0:0:0:0:0:0:0:0') {
+            return '::'; // all addresses
         }
 
-    /// Use serialize/unserialize trick to deep copy the object
-        $obj = unserialize(serialize($obj));
-
-    /// If there is a __clone method call it on the "new" class
-        if (method_exists($obj, \'__clone\')) {
-            $obj->__clone();
+        $compressed = preg_replace('/(:0)+:0$/', '::', $result, 1);
+        if ($compressed !== $result) {
+            return $compressed;
         }
 
-        return $obj;
+        $compressed = preg_replace('/^(0:){2,7}/', '::', $result, 1);
+        if ($compressed !== $result) {
+            return $compressed;
     }
 
-    // Supply the PHP5 function scandir() to older versions.
-    function scandir($directory) {
-        $files = array();
-        if ($dh = opendir($directory)) {
-            while (($file = readdir($dh)) !== false) {
-               $files[] = $file;
-            }
-            closedir($dh);
+        $compressed = preg_replace('/(:0){2,6}:/', '::', $result, 1);
+        if ($compressed !== $result) {
+            return $compressed;
         }
-        return $files;
+
+        return $result;
     }
 
-    // Supply the PHP5 function array_combine() to older versions.
-    function array_combine($keys, $values) {
-        if (!is_array($keys) || !is_array($values) || count($keys) != count($values)) {
-            return false;
+    // first get all things that look like IPv4 addresses
+    $parts = array();
+    if (!preg_match('/^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/', $addr, $parts)) {
+        return null;
         }
-        reset($values);
-        $result = array();
-        foreach ($keys as $key) {
-            $result[$key] = current($values);
-            next($values);
+    unset($parts[0]);
+
+    foreach ($parts as $key=>$match) {
+        if ($match > 255) {
+            return null;
         }
-        return $result;
+        $parts[$key] = (int)$match; // normalise 0s
     }
-');
+
+    return implode('.', $parts);
 }
 
 /**
  * This function will make a complete copy of anything it's given,
  * regardless of whether it's an object or not.
- * @param mixed $thing
- * @return mixed
+ *
+ * @param mixed $thing Something you want cloned
+ * @return mixed What ever it is you passed it
  */
 function fullclone($thing) {
     return unserialize(serialize($thing));
 }
 
 
-/*
+/**
  * This function expects to called during shutdown
  * should be set via register_shutdown_function()
  * in lib/setup.php .
  *
- * Right now we do it only if we are under apache, to
- * make sure apache children that hog too much mem are
- * killed.
- *
+ * @return void
  */
 function moodle_request_shutdown() {
-
     global $CFG;
 
-    // initially, we are only ever called under apache
-    // but check just in case
-    if (function_exists('apache_child_terminate')
-        && function_exists('memory_get_usage')
+    // help apache server if possible
+    $apachereleasemem = false;
+    if (function_exists('apache_child_terminate') && function_exists('memory_get_usage')
         && ini_get_bool('child_terminate')) {
-        if (empty($CFG->apachemaxmem)) {
-            $CFG->apachemaxmem = 25000000; // default 25MiB
-        }
-        if (memory_get_usage() > (int)$CFG->apachemaxmem) {
-            trigger_error('Mem usage over $CFG->apachemaxmem: marking child for reaping.');
+
+        $limit = (empty($CFG->apachemaxmem) ? 64*1024*1024 : $CFG->apachemaxmem); //64MB default
+        if (memory_get_usage() > get_real_size($limit)) {
+            $apachereleasemem = $limit;
             @apache_child_terminate();
         }
     }
+
+    // deal with perf logging
     if (defined('MDL_PERF') || (!empty($CFG->perfdebug) and $CFG->perfdebug > 7)) {
+        if ($apachereleasemem) {
+            error_log('Mem usage over '.$apachereleasemem.': marking Apache child for reaping.');
+        }
         if (defined('MDL_PERFTOLOG')) {
             $perf = get_performance_info();
             error_log("PERF: " . $perf['txt']);
@@ -8077,38 +9304,126 @@ function moodle_request_shutdown() {
     }
 }
 
-/**
- * If new messages are waiting for the current user, then return
- * Javascript code to create a popup window
+ /**
+  * If new messages are waiting for the current user, then insert
+  * JavaScript to pop up the messaging window into the page
  *
- * @return string Javascript code
+  * @global moodle_page $PAGE
+  * @return void
  */
 function message_popup_window() {
-    global $USER;
+    global $USER, $DB, $PAGE, $CFG, $SITE;
+
+    if (!$PAGE->get_popup_notification_allowed() || empty($CFG->messaging)) {
+        return;
+    }
 
-    $popuplimit = 30;     // Minimum seconds between popups
+    if (!isloggedin() || isguestuser()) {
+        return;
+    }
 
-    if (!defined('MESSAGE_WINDOW')) {
-        if (!empty($USER->id) and !isguestuser()) {
             if (!isset($USER->message_lastpopup)) {
                 $USER->message_lastpopup = 0;
+    } else if ($USER->message_lastpopup > (time()-120)) {
+        //dont run the query to check whether to display a popup if its been run in the last 2 minutes
+        return;
             }
-            if ((time() - $USER->message_lastpopup) > $popuplimit) {  /// It's been long enough
-                if (get_user_preferences('message_showmessagewindow', 1) == 1) {
-                    if (count_records_select('message', 'useridto = \''.$USER->id.'\' AND timecreated > \''.$USER->message_lastpopup.'\'')) {
-                        $USER->message_lastpopup = time();
-                        return '<script type="text/javascript">'."\n//<![CDATA[\n openpopup('/message/index.php', 'message',
-                        'menubar=0,location=0,scrollbars,status,resizable,width=400,height=500', 0);\n//]]>\n</script>";
+
+    //a quick query to check whether the user has new messages
+    $messagecount = $DB->count_records('message', array('useridto' => $USER->id));
+    if ($messagecount<1) {
+        return;
+    }
+
+    //got unread messages so now do another query that joins with the user table
+    $messagesql = "SELECT m.id, m.smallmessage, m.fullmessageformat, m.notification, u.firstname, u.lastname
+                     FROM {message} m
+                     JOIN {message_working} mw ON m.id=mw.unreadmessageid
+                     JOIN {message_processors} p ON mw.processorid=p.id
+                     JOIN {user} u ON m.useridfrom=u.id
+                    WHERE m.useridto = :userid
+                      AND p.name='popup'";
+
+    //if the user was last notified over an hour ago we can renotify them of old messages
+    //so don't worry about when the new message was sent
+    $lastnotifiedlongago = $USER->message_lastpopup < (time()-3600);
+    if (!$lastnotifiedlongago) {
+        $messagesql .= 'AND m.timecreated > :lastpopuptime';
+    }
+
+    $message_users = $DB->get_records_sql($messagesql, array('userid'=>$USER->id, 'lastpopuptime'=>$USER->message_lastpopup));
+
+    //if we have new messages to notify the user about
+    if (!empty($message_users)) {
+
+        $strmessages = '';
+        if (count($message_users)>1) {
+            $strmessages = get_string('unreadnewmessages', 'message', count($message_users));
+        } else {
+            $message_users = reset($message_users);
+
+            //show who the message is from if its not a notification
+            if (!$message_users->notification) {
+                $strmessages = get_string('unreadnewmessage', 'message', fullname($message_users) );
+            }
+
+            //try to display the small version of the message
+            $smallmessage = null;
+            if (!empty($message_users->smallmessage)) {
+                //display the first 200 chars of the message in the popup
+                $textlib = textlib_get_instance();
+                $smallmessage = null;
+                if ($textlib->strlen($message_users->smallmessage) > 200) {
+                    $smallmessage = $textlib->substr($message_users->smallmessage,0,200).'...';
+                } else {
+                    $smallmessage = $message_users->smallmessage;
                     }
+
+                //prevent html symbols being displayed
+                if ($message_users->fullmessageformat == FORMAT_HTML) {
+                    $smallmessage = html_to_text($smallmessage);
+                } else {
+                    $smallmessage = s($smallmessage);
                 }
+            } else if ($message_users->notification) {
+                //its a notification with no smallmessage so just say they have a notification
+                $smallmessage = get_string('unreadnewnotification', 'message');
             }
+            if (!empty($smallmessage)) {
+                $strmessages .= '<div id="usermessage">'.s($smallmessage).'</div>';
         }
     }
 
-    return '';
+        $strgomessage = get_string('gotomessages', 'message');
+        $strstaymessage = get_string('ignore','admin');
+
+        $url = $CFG->wwwroot.'/message/index.php';
+        $content =  html_writer::start_tag('div', array('id'=>'newmessageoverlay','class'=>'mdl-align')).
+                        html_writer::start_tag('div', array('id'=>'newmessagetext')).
+                            $strmessages.
+                        html_writer::end_tag('div').
+
+                        html_writer::start_tag('div', array('id'=>'newmessagelinks')).
+                            html_writer::link($url, $strgomessage, array('id'=>'notificationyes')).'&nbsp;&nbsp;&nbsp;'.
+                            html_writer::link('', $strstaymessage, array('id'=>'notificationno')).
+                        html_writer::end_tag('div');
+                    html_writer::end_tag('div');
+
+        $PAGE->requires->js_init_call('M.core_message.init_notification', array('', $content, $url));
+
+        $USER->message_lastpopup = time();
+    }
 }
 
-// Used to make sure that $min <= $value <= $max
+/**
+ * Used to make sure that $min <= $value <= $max
+ *
+ * Make sure that value is between min, and max
+ *
+ * @param int $min The minimum value
+ * @param int $value The value to check
+ * @param int $max The maximum value
+ */
 function bounded_number($min, $value, $max) {
     if($value < $min) {
         return $min;
@@ -8119,6 +9434,12 @@ function bounded_number($min, $value, $max) {
     return $value;
 }
 
+/**
+ * Check if there is a nested array within the passed array
+ *
+ * @param array $array
+ * @return bool true if there is a nested array false otherwise
+ */
 function array_is_nested($array) {
     foreach ($array as $value) {
         if (is_array($value)) {
@@ -8129,14 +9450,18 @@ function array_is_nested($array) {
 }
 
 /**
- *** get_performance_info() pairs up with init_performance_info()
- *** loaded in setup.php. Returns an array with 'html' and 'txt'
- *** values ready for use, and each of the individual stats provided
- *** separately as well.
- ***
- **/
+ * get_performance_info() pairs up with init_performance_info()
+ * loaded in setup.php. Returns an array with 'html' and 'txt'
+ * values ready for use, and each of the individual stats provided
+ * separately as well.
+ *
+ * @global object
+ * @global object
+ * @global object
+ * @return array
+ */
 function get_performance_info() {
-    global $CFG, $PERF, $rcache;
+    global $CFG, $PERF, $DB, $PAGE;
 
     $info = array();
     $info['html'] = '';         // holds userfriendly HTML representation
@@ -8166,18 +9491,63 @@ function get_performance_info() {
     $info['html'] .= '<span class="included">Included '.$info['includecount'].' files</span> ';
     $info['txt']  .= 'includecount: '.$info['includecount'].' ';
 
-    if (!empty($PERF->dbqueries)) {
-        $info['dbqueries'] = $PERF->dbqueries;
-        $info['html'] .= '<span class="dbqueries">DB queries '.$info['dbqueries'].'</span> ';
-        $info['txt'] .= 'dbqueries: '.$info['dbqueries'].' ';
+    $filtermanager = filter_manager::instance();
+    if (method_exists($filtermanager, 'get_performance_summary')) {
+        list($filterinfo, $nicenames) = $filtermanager->get_performance_summary();
+        $info = array_merge($filterinfo, $info);
+        foreach ($filterinfo as $key => $value) {
+            $info['html'] .= "<span class='$key'>$nicenames[$key]: $value </span> ";
+            $info['txt'] .= "$key: $value ";
+        }
+    }
+
+    $stringmanager = get_string_manager();
+    if (method_exists($stringmanager, 'get_performance_summary')) {
+        list($filterinfo, $nicenames) = $stringmanager->get_performance_summary();
+        $info = array_merge($filterinfo, $info);
+        foreach ($filterinfo as $key => $value) {
+            $info['html'] .= "<span class='$key'>$nicenames[$key]: $value </span> ";
+            $info['txt'] .= "$key: $value ";
+        }
+    }
+
+     $jsmodules = $PAGE->requires->get_loaded_modules();
+     if ($jsmodules) {
+         $yuicount = 0;
+         $othercount = 0;
+         $details = '';
+         foreach ($jsmodules as $module => $backtraces) {
+             if (strpos($module, 'yui') === 0) {
+                 $yuicount += 1;
+             } else {
+                 $othercount += 1;
+             }
+             $details .= "<div class='yui-module'><p>$module</p>";
+             foreach ($backtraces as $backtrace) {
+                 $details .= "<div class='backtrace'>$backtrace</div>";
+             }
+             $details .= '</div>';
+         }
+         $info['html'] .= "<span class='includedyuimodules'>Included YUI modules: $yuicount</span> ";
+         $info['txt'] .= "includedyuimodules: $yuicount ";
+         $info['html'] .= "<span class='includedjsmodules'>Other JavaScript modules: $othercount</span> ";
+         $info['txt'] .= "includedjsmodules: $othercount ";
+         // Slightly odd to output the details in a display: none div. The point
+         // Is that it takes a lot of space, and if you care you can reveal it
+         // using firebug.
+         $info['html'] .= '<div id="yui-module-debug" class="notifytiny">'.$details.'</div>';
     }
 
     if (!empty($PERF->logwrites)) {
         $info['logwrites'] = $PERF->logwrites;
-        $info['html'] .= '<span class="logwrites">Log writes '.$info['logwrites'].'</span> ';
+        $info['html'] .= '<span class="logwrites">Log DB writes '.$info['logwrites'].'</span> ';
         $info['txt'] .= 'logwrites: '.$info['logwrites'].' ';
     }
 
+    $info['dbqueries'] = $DB->perf_get_reads().'/'.($DB->perf_get_writes() - $PERF->logwrites);
+    $info['html'] .= '<span class="dbqueries">DB reads/writes: '.$info['dbqueries'].'</span> ';
+    $info['txt'] .= 'db reads/writes: '.$info['dbqueries'].' ';
+
     if (!empty($PERF->profiling) && $PERF->profiling) {
         require_once($CFG->dirroot .'/lib/profilerlib.php');
         $info['html'] .= '<span class="profilinginfo">'.Profiler::get_profiling(array('-R')).'</span>';
@@ -8213,24 +9583,35 @@ function get_performance_info() {
         $info['txt'] .= "serverload: {$info['serverload']} ";
     }
 
-    if (isset($rcache->hits) && isset($rcache->misses)) {
+    // Display size of session if session started
+    if (session_id()) {
+        $info['sessionsize'] = display_size(strlen(session_encode()));
+        $info['html'] .= '<span class="sessionsize">Session: ' . $info['sessionsize'] . '</span> ';
+        $info['txt'] .= "Session: {$info['sessionsize']} ";
+    }
+
+/*    if (isset($rcache->hits) && isset($rcache->misses)) {
         $info['rcachehits'] = $rcache->hits;
         $info['rcachemisses'] = $rcache->misses;
         $info['html'] .= '<span class="rcache">Record cache hit/miss ratio : '.
             "{$rcache->hits}/{$rcache->misses}</span> ";
         $info['txt'] .= 'rcache: '.
             "{$rcache->hits}/{$rcache->misses} ";
-    }
-    $info['html'] = '<div class="performanceinfo">'.$info['html'].'</div>';
+    }*/
+    $info['html'] = '<div class="performanceinfo siteinfo">'.$info['html'].'</div>';
     return $info;
 }
 
+/**
+ * @todo Document this function linux people
+ */
 function apd_get_profiling() {
     return shell_exec('pprofp -u ' . ini_get('apd.dumpdir') . '/pprof.' . getmypid() . '.*');
 }
 
 /**
  * Delete directory or only it's content
+ *
  * @param string $dir directory path
  * @param bool $content_only
  * @return bool success, true also if dir does not exist
@@ -8255,93 +9636,13 @@ function remove_dir($dir, $content_only=false) {
     if ($content_only) {
         return $result;
     }
-    return rmdir($dir); // if anything left the result will be false, noo need for && $result
-}
-
-/**
- * Function to check if a directory exists and optionally create it.
- *
- * @param string absolute directory path (must be under $CFG->dataroot)
- * @param boolean create directory if does not exist
- * @param boolean create directory recursively
- *
- * @return boolean true if directory exists or created
- */
-function check_dir_exists($dir, $create=false, $recursive=false) {
-
-    global $CFG;
-
-    if (strstr(cleardoubleslashes($dir), cleardoubleslashes($CFG->dataroot.'/')) === false) {
-        debugging('Warning. Wrong call to check_dir_exists(). $dir must be an absolute path under $CFG->dataroot ("' . $dir . '" is incorrect)', DEBUG_DEVELOPER);
-    }
-
-    $status = true;
-
-    if(!is_dir($dir)) {
-        if (!$create) {
-            $status = false;
-        } else {
-            umask(0000);
-            if ($recursive) {
-            /// We are going to make it recursive under $CFG->dataroot only
-            /// (will help sites running open_basedir security and others)
-                $dir = str_replace(cleardoubleslashes($CFG->dataroot . '/'), '', cleardoubleslashes($dir));
-            /// PHP 5.0 has recursive mkdir parameter, but 4.x does not :-(
-                $dirs = explode('/', $dir); /// Extract path parts
-            /// Iterate over each part with start point $CFG->dataroot
-                $dir = $CFG->dataroot . '/';
-                foreach ($dirs as $part) {
-                    if ($part == '') {
-                        continue;
-                    }
-                    $dir .= $part.'/';
-                    if (!is_dir($dir)) {
-                        if (!mkdir($dir, $CFG->directorypermissions)) {
-                            $status = false;
-                            break;
-                        }
-                    }
-                }
-            } else {
-                $status = mkdir($dir, $CFG->directorypermissions);
-            }
-        }
-    }
-    return $status;
-}
-
-function report_session_error() {
-    global $CFG, $FULLME;
-
-    if (empty($CFG->lang)) {
-        $CFG->lang = "en";
-    }
-    // Set up default theme and locale
-    theme_setup();
-    moodle_setlocale();
-
-    //clear session cookies
-    if (check_php_version('5.2.0')) {
-        //PHP 5.2.0
-        setcookie('MoodleSession'.$CFG->sessioncookie, '', time() - 3600, $CFG->sessioncookiepath, $CFG->sessioncookiedomain, $CFG->cookiesecure, $CFG->cookiehttponly);
-        setcookie('MoodleSessionTest'.$CFG->sessioncookie, '', time() - 3600, $CFG->sessioncookiepath, $CFG->sessioncookiedomain, $CFG->cookiesecure, $CFG->cookiehttponly);
-    } else {
-        setcookie('MoodleSession'.$CFG->sessioncookie, '', time() - 3600, $CFG->sessioncookiepath, $CFG->sessioncookiedomain, $CFG->cookiesecure);
-        setcookie('MoodleSessionTest'.$CFG->sessioncookie, '', time() - 3600, $CFG->sessioncookiepath, $CFG->sessioncookiedomain, $CFG->cookiesecure);
-    }
-    //increment database error counters
-    if (isset($CFG->session_error_counter)) {
-        set_config('session_error_counter', 1 + $CFG->session_error_counter);
-    } else {
-        set_config('session_error_counter', 1);
-    }
-    redirect($FULLME, get_string('sessionerroruser2', 'error'), 5);
+    return rmdir($dir); // if anything left the result will be false, no need for && $result
 }
 
-
 /**
  * Detect if an object or a class contains a given property
  * will take an actual object or the name of a class
+ *
  * @param mix $obj Name of class or real object to test
  * @param string $property name of property to find
  * @return bool true if property exists
@@ -8360,9 +9661,9 @@ function object_property_exists( $obj, $property ) {
 /**
  * Detect a custom script replacement in the data directory that will
  * replace an existing moodle script
+ *
  * @param string $urlpath path to the original script
- * @return string full path name if a custom script exists
- * @return bool false if no custom script exists
+ * @return string|bool full path name if a custom script exists, false if no custom script exists
  */
 function custom_script_path($urlpath='') {
     global $CFG;
@@ -8402,22 +9703,10 @@ function custom_script_path($urlpath='') {
 }
 
 /**
- * Wrapper function to load necessary editor scripts
- * to $CFG->editorsrc array. Params can be coursei id
- * or associative array('courseid' => value, 'name' => 'editorname').
- * @uses $CFG
- * @param mixed $args Courseid or associative array.
- */
-function loadeditor($args) {
-    global $CFG;
-    include($CFG->libdir .'/editorlib.php');
-    return editorObject::loadeditor($args);
-}
-
-/**
  * Returns whether or not the user object is a remote MNET user. This function
  * is in moodlelib because it does not rely on loading any of the MNET code.
  *
+ * @global object
  * @param object $user A valid user object
  * @return bool        True if the user is from a remote Moodle.
  */
@@ -8435,24 +9724,12 @@ function is_mnet_remote_user($user) {
 }
 
 /**
- * Checks if a given plugin is in the list of enabled enrolment plugins.
- *
- * @param string $auth Enrolment plugin.
- * @return boolean Whether the plugin is enabled.
- */
-function is_enabled_enrol($enrol='') {
-    global $CFG;
-
-    // use the global default if not specified
-    if ($enrol == '') {
-        $enrol = $CFG->enrol;
-    }
-    return in_array($enrol, explode(',', $CFG->enrol_plugins_enabled));
-}
-
-/**
  * This function will search for browser prefereed languages, setting Moodle
  * to use the best one available if $SESSION->lang is undefined
+ *
+ * @global object
+ * @global object
+ * @global object
  */
 function setup_lang_from_browser() {
 
@@ -8486,15 +9763,10 @@ function setup_lang_from_browser() {
     }
     krsort($langs, SORT_NUMERIC);
 
-    $langlist = get_list_of_languages();
-
 /// Look for such langs under standard locations
     foreach ($langs as $lang) {
-        $lang = strtolower(clean_param($lang.'_utf8', PARAM_SAFEDIR)); // clean it properly for include
-        if (!array_key_exists($lang, $langlist)) {
-            continue; // language not allowed, try next one
-        }
-        if (file_exists($CFG->dataroot .'/lang/'. $lang) or file_exists($CFG->dirroot .'/lang/'. $lang)) {
+        $lang = strtolower(clean_param($lang, PARAM_SAFEDIR)); // clean it properly for include
+        if (get_string_manager()->translation_exists($lang, false)) {
             $SESSION->lang = $lang; /// Lang exists, set it in session
             break; /// We have finished. Go out
         }
@@ -8502,9 +9774,64 @@ function setup_lang_from_browser() {
     return;
 }
 
+/**
+ * check if $url matches anything in proxybypass list
+ *
+ * any errors just result in the proxy being used (least bad)
+ *
+ * @global object
+ * @param string $url url to check
+ * @return boolean true if we should bypass the proxy
+ */
+function is_proxybypass( $url ) {
+    global $CFG;
+
+    // sanity check
+    if (empty($CFG->proxyhost) or empty($CFG->proxybypass)) {
+        return false;
+    }
+
+    // get the host part out of the url
+    if (!$host = parse_url( $url, PHP_URL_HOST )) {
+        return false;
+    }
+
+    // get the possible bypass hosts into an array
+    $matches = explode( ',', $CFG->proxybypass );
+
+    // check for a match
+    // (IPs need to match the left hand side and hosts the right of the url,
+    // but we can recklessly check both as there can't be a false +ve)
+    $bypass = false;
+    foreach ($matches as $match) {
+        $match = trim($match);
+
+        // try for IP match (Left side)
+        $lhs = substr($host,0,strlen($match));
+        if (strcasecmp($match,$lhs)==0) {
+            return true;
+        }
+
+        // try for host match (Right side)
+        $rhs = substr($host,-strlen($match));
+        if (strcasecmp($match,$rhs)==0) {
+            return true;
+        }
+    }
+
+    // nothing matched.
+    return false;
+}
+
 
 ////////////////////////////////////////////////////////////////////////////////
 
+/**
+ * Check if the passed navigation is of the new style
+ *
+ * @param mixed $navigation
+ * @return bool true for yes false for no
+ */
 function is_newnav($navigation) {
     if (is_array($navigation) && !empty($navigation['newnav'])) {
         return true;
@@ -8515,7 +9842,9 @@ function is_newnav($navigation) {
 
 /**
  * Checks whether the given variable name is defined as a variable within the given object.
- * @note This will NOT work with stdClass objects, which have no class variables.
+ *
+ * This will NOT work with stdClass objects, which have no class variables.
+ *
  * @param string $var The variable name
  * @param object $object The object to check
  * @return boolean
@@ -8530,9 +9859,9 @@ function in_object_vars($var, $object) {
  * Returns an array without repeated objects.
  * This function is similar to array_unique, but for arrays that have objects as values
  *
- * @param unknown_type $array
- * @param unknown_type $keep_key_assoc
- * @return unknown
+ * @param array $array
+ * @param bool $keep_key_assoc
+ * @return array
  */
 function object_array_unique($array, $keep_key_assoc = true) {
     $duplicate_keys = array();
@@ -8559,48 +9888,9 @@ function object_array_unique($array, $keep_key_assoc = true) {
 }
 
 /**
- * Returns the language string for the given plugin.
- *
- * @param string $plugin the plugin code name
- * @param string $type the type of plugin (mod, block, filter)
- * @return string The plugin language string
- */
-function get_plugin_name($plugin, $type='mod') {
-    $plugin_name = '';
-
-    switch ($type) {
-        case 'mod':
-            $plugin_name = get_string('modulename', $plugin);
-            break;
-        case 'blocks':
-            $plugin_name = get_string('blockname', "block_$plugin");
-            if (empty($plugin_name) || $plugin_name == '[[blockname]]') {
-                if (($block = block_instance($plugin)) !== false) {
-                    $plugin_name = $block->get_title();
-                } else {
-                    $plugin_name = "[[$plugin]]";
-                }
-            }
-            break;
-        case 'filter':
-            $plugin_name = trim(get_string('filtername', $plugin));
-            if (empty($plugin_name) or ($plugin_name == '[[filtername]]')) {
-                $textlib = textlib_get_instance();
-                $plugin_name = $textlib->strtotitle($plugin);
-            }
-            break;
-        default:
-            $plugin_name = $plugin;
-            break;
-    }
-
-    return $plugin_name;
-}
-
-/**
  * Is a userid the primary administrator?
  *
- * @param $userid int id of user to check
+ * @param int $userid int id of user to check
  * @return boolean
  */
 function is_primary_admin($userid){
@@ -8614,6 +9904,9 @@ function is_primary_admin($userid){
 }
 
 /**
+ * Returns the site identifier
+ *
+ * @global object
  * @return string $CFG->siteidentifier, first making sure it is properly initialised.
  */
 function get_site_identifier() {
@@ -8626,5 +9919,165 @@ function get_site_identifier() {
     return $CFG->siteidentifier;
 }
 
-// vim:autoindent:expandtab:shiftwidth=4:tabstop=4:tw=140:
-?>
+/**
+ * Check whether the given password has no more than the specified
+ * number of consecutive identical characters.
+ *
+ * @param string $password   password to be checked against the password policy
+ * @param integer $maxchars  maximum number of consecutive identical characters
+ */
+function check_consecutive_identical_characters($password, $maxchars) {
+
+    if ($maxchars < 1) {
+        return true; // 0 is to disable this check
+    }
+    if (strlen($password) <= $maxchars) {
+        return true; // too short to fail this test
+    }
+
+    $previouschar = '';
+    $consecutivecount = 1;
+    foreach (str_split($password) as $char) {
+        if ($char != $previouschar) {
+            $consecutivecount = 1;
+        }
+        else {
+            $consecutivecount++;
+            if ($consecutivecount > $maxchars) {
+                return false; // check failed already
+            }
+        }
+
+        $previouschar = $char;
+    }
+
+    return true;
+}
+
+/**
+ * helper function to do partial function binding
+ * so we can use it for preg_replace_callback, for example
+ * this works with php functions, user functions, static methods and class methods
+ * it returns you a callback that you can pass on like so:
+ *
+ * $callback = partial('somefunction', $arg1, $arg2);
+ *     or
+ * $callback = partial(array('someclass', 'somestaticmethod'), $arg1, $arg2);
+ *     or even
+ * $obj = new someclass();
+ * $callback = partial(array($obj, 'somemethod'), $arg1, $arg2);
+ *
+ * and then the arguments that are passed through at calltime are appended to the argument list.
+ *
+ * @param mixed $function a php callback
+ * $param mixed $arg1.. $argv arguments to partially bind with
+ *
+ * @return callback
+ */
+function partial() {
+    if (!class_exists('partial')) {
+        class partial{
+            var $values = array();
+            var $func;
+
+            function __construct($func, $args) {
+                $this->values = $args;
+                $this->func = $func;
+            }
+
+            function method() {
+                $args = func_get_args();
+                return call_user_func_array($this->func, array_merge($this->values, $args));
+            }
+        }
+    }
+    $args = func_get_args();
+    $func = array_shift($args);
+    $p = new partial($func, $args);
+    return array($p, 'method');
+}
+
+/**
+ * helper function to load up and initialise the mnet environment
+ * this must be called before you use mnet functions.
+ *
+ * @return mnet_environment the equivalent of old $MNET global
+ */
+function get_mnet_environment() {
+    global $CFG;
+    require_once($CFG->dirroot . '/mnet/lib.php');
+    static $instance = null;
+    if (empty($instance)) {
+        $instance = new mnet_environment();
+        $instance->init();
+    }
+    return $instance;
+}
+
+/**
+ * during xmlrpc server code execution, any code wishing to access
+ * information about the remote peer must use this to get it.
+ *
+ * @return mnet_remote_client the equivalent of old $MNET_REMOTE_CLIENT global
+ */
+function get_mnet_remote_client() {
+    if (!defined('MNET_SERVER')) {
+        debugging(get_string('notinxmlrpcserver', 'mnet'));
+        return false;
+    }
+    global $MNET_REMOTE_CLIENT;
+    if (isset($MNET_REMOTE_CLIENT)) {
+        return $MNET_REMOTE_CLIENT;
+    }
+    return false;
+}
+
+/**
+ * during the xmlrpc server code execution, this will be called
+ * to setup the object returned by {@see get_mnet_remote_client}
+ *
+ * @param mnet_remote_client $client the client to set up
+ */
+function set_mnet_remote_client($client) {
+    if (!defined('MNET_SERVER')) {
+        throw new moodle_exception('notinxmlrpcserver', 'mnet');
+    }
+    global $MNET_REMOTE_CLIENT;
+    $MNET_REMOTE_CLIENT = $client;
+}
+
+/**
+ * return the jump url for a given remote user
+ * this is used for rewriting forum post links in emails, etc
+ *
+ * @param stdclass $user the user to get the idp url for
+ */
+function mnet_get_idp_jump_url($user) {
+    global $CFG;
+
+    static $mnetjumps = array();
+    if (!array_key_exists($user->mnethostid, $mnetjumps)) {
+        $idp = mnet_get_peer_host($user->mnethostid);
+        $idpjumppath = mnet_get_app_jumppath($idp->applicationid);
+        $mnetjumps[$user->mnethostid] = $idp->wwwroot . $idpjumppath . '?hostwwwroot=' . $CFG->wwwroot . '&wantsurl=';
+    }
+    return $mnetjumps[$user->mnethostid];
+}
+
+/**
+ * Gets the homepage to use for the current user
+ *
+ * @return int One of HOMEPAGE_*
+ */
+function get_home_page() {
+    global $CFG;
+
+    if (isloggedin() && !isguestuser() && !empty($CFG->defaulthomepage)) {
+        if ($CFG->defaulthomepage == HOMEPAGE_MY) {
+            return HOMEPAGE_MY;
+        } else {
+            return (int)get_user_preferences('user_home_page_preference', HOMEPAGE_MY);
+        }
+    }
+    return HOMEPAGE_SITE;
+}
