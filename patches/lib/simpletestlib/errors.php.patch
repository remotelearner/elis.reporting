diff --git a/lib/simpletestlib/errors.php b/lib/simpletestlib/errors.php
index 169997a..204f0b1 100644
--- a/lib/simpletestlib/errors.php
+++ b/lib/simpletestlib/errors.php
@@ -1,29 +1,32 @@
 <?php
-    /**
+/**
      *	base include file for SimpleTest
      *	@package	SimpleTest
      *	@subpackage	UnitTester
      *	@version	$Id$
      */
 
-    /** @ignore - PHP5 compatibility fix. */
-    if (! defined('E_STRICT')) {
+/**
+ * @ignore - PHP5 compatibility fix.
+ */
+if (! defined('E_STRICT')) {
         define('E_STRICT', 2048);
-    }
+}
 
-    /**#@+
+/**#@+
      * Includes SimpleTest files.
      */
-    require_once(dirname(__FILE__) . '/invoker.php');
-    require_once(dirname(__FILE__) . '/test_case.php');
-    require_once(dirname(__FILE__) . '/expectation.php');
+require_once dirname(__FILE__) . '/invoker.php';
+require_once dirname(__FILE__) . '/test_case.php';
+require_once dirname(__FILE__) . '/expectation.php';
+/**#@-*/
 
-    /**
+/**
      *    Extension that traps errors into an error queue.
 	 *	  @package SimpleTest
 	 *	  @subpackage UnitTester
      */
-    class SimpleErrorTrappingInvoker extends SimpleInvokerDecorator {
+class SimpleErrorTrappingInvoker extends SimpleInvokerDecorator {
 
         /**
          *    Stores the invoker to wrap.
@@ -41,30 +44,49 @@
          *    @access public
          */
         function invoke($method) {
-            $context = &SimpleTest::getContext();
-            $queue = &$context->get('SimpleErrorQueue');
-            $queue->setTestCase($this->GetTestCase());
+        $queue = &$this->_createErrorQueue();
             set_error_handler('SimpleTestErrorHandler');
+        //moodle hack start
+        // note: this breaks PHP4 compatibility!
+        $rethrow = null;
+        try {
             parent::invoke($method);
-            while (list($severity, $message, $file, $line) = $queue->extract()) {
-                $severity = SimpleErrorQueue::getSeverityAsString($severity);
-                $test = &$this->getTestCase();
-                $test->error($severity, $message, $file, $line);
+        } catch (Exception $e) {
+            $rethrow = $e;
             }
             restore_error_handler();
+        $queue->tally();
+        if ($rethrow) {
+            throw $rethrow;
         }
+        //moodle hack end
     }
 
     /**
-     *    Singleton error queue used to record trapped
+     *    Wires up the error queue for a single test.
+     *    @return SimpleErrorQueue    Queue connected to the test.
+     *    @access private
+     */
+    function &_createErrorQueue() {
+        $context = &SimpleTest::getContext();
+        $test = &$this->getTestCase();
+        $queue = &$context->get('SimpleErrorQueue');
+        $queue->setTestCase($test);
+        return $queue;
+    }
+}
+
+/**
+ *    Error queue used to record trapped
      *    errors.
 	 *	  @package	SimpleTest
 	 *	  @subpackage	UnitTester
      */
-    class SimpleErrorQueue {
+class SimpleErrorQueue {
         var $_queue;
         var $_expectation_queue;
         var $_test;
+    var $_using_expect_style = false;
 
         /**
          *    Starts with an empty queue.
@@ -74,6 +96,15 @@
         }
 
         /**
+     *    Discards the contents of the error queue.
+     *    @access public
+     */
+    function clear() {
+        $this->_queue = array();
+        $this->_expectation_queue = array();
+    }
+
+    /**
          *    Sets the currently running test case.
          *    @param SimpleTestCase $test    Test case to send messages to.
          *    @access public
@@ -83,6 +114,20 @@
         }
 
         /**
+     *    Sets up an expectation of an error. If this is
+     *    not fulfilled at the end of the test, a failure
+     *    will occour. If the error does happen, then this
+     *    will cancel it out and send a pass message.
+     *    @param SimpleExpectation $expected    Expected error match.
+     *    @param string $message                Message to display.
+     *    @access public
+     */
+    function expectError($expected, $message) {
+        $this->_using_expect_style = true;
+        array_push($this->_expectation_queue, array($expected, $message));
+    }
+
+    /**
          *    Adds an error to the front of the queue.
          *    @param integer $severity       PHP error code.
          *    @param string $content         Text of error.
@@ -92,7 +137,7 @@
          */
         function add($severity, $content, $filename, $line) {
 			$content = str_replace('%', '%%', $content);
-            if (count($this->_expectation_queue)) {
+        if ($this->_using_expect_style) {
                 $this->_testLatestError($severity, $content, $filename, $line);
             } else {
                 array_push(
@@ -102,6 +147,21 @@
         }
 
         /**
+     *    Any errors still in the queue are sent to the test
+     *    case. Any unfulfilled expectations trigger failures.
+     *    @access public
+     */
+    function tally() {
+        while (list($severity, $message, $file, $line) = $this->extract()) {
+            $severity = $this->getSeverityAsString($severity);
+            $this->_test->error($severity, $message, $file, $line);
+        }
+        while (list($expected, $message) = $this->_extractExpectation()) {
+            $this->_test->assert($expected, false, "%s -> Expected error not caught");
+        }
+    }
+
+    /**
          *    Tests the error against the most recent expected
          *    error.
          *    @param integer $severity       PHP error code.
@@ -111,20 +171,21 @@
          *    @access private
          */
         function _testLatestError($severity, $content, $filename, $line) {
-            list($expected, $message) = array_shift($this->_expectation_queue);
-            $severity = $this->getSeverityAsString($severity);
-            $is_match = $this->_test->assert(
-                    $expected,
-                    $content,
-                    sprintf($message, "%s -> PHP error [$content] severity [$severity] in [$filename] line [$line]"));
-            if (! $is_match) {
+        if ($expectation = $this->_extractExpectation()) {
+            list($expected, $message) = $expectation;
+            $this->_test->assert($expected, $content, sprintf(
+                    $message,
+                    "%s -> PHP error [$content] severity [" .
+                            $this->getSeverityAsString($severity) .
+                            "] in [$filename] line [$line]"));
+        } else {
                 $this->_test->error($severity, $content, $filename, $line);
             }
         }
 
         /**
          *    Pulls the earliest error from the queue.
-         *    @return     False if none, or a list of error
+     *    @return  mixed    False if none, or a list of error
          *                information. Elements are: severity
          *                as the PHP error code, the error message,
          *                the file with the error, the line number
@@ -139,12 +200,15 @@
         }
 
         /**
-         *    Discards the contents of the error queue.
-         *    @access public
+     *    Pulls the earliest expectation from the queue.
+     *    @return     SimpleExpectation    False if none.
+     *    @access private
          */
-        function clear() {
-            $this->_queue = array();
-            $this->_expectation_queue = array();
+    function _extractExpectation() {
+        if (count($this->_expectation_queue)) {
+            return array_shift($this->_expectation_queue);
+        }
+        return false;
         }
 
         /**
@@ -174,21 +238,6 @@
         }
 
         /**
-         *    Sets up an expectation of an error. If this is
-         *    not fulfilled at the end of the test, a failure
-         *    will occour. If the error does happen, then this
-         *    will cancel it out and send a pass message.
-         *    @param SimpleExpectation $expected    Expected error match.
-         *    @param string $message                Message to display.
-         *    @access public
-         */
-        function expectError($expected, $message) {
-            array_push(
-                    $this->_expectation_queue,
-                    array($expected, $message));
-        }
-
-        /**
          *    Converts an error code into it's string
          *    representation.
          *    @param $severity  PHP integer error code.
@@ -210,19 +259,17 @@
                     E_USER_ERROR => 'E_USER_ERROR',
                     E_USER_WARNING => 'E_USER_WARNING',
                     E_USER_NOTICE => 'E_USER_NOTICE');
-            // Moodle additions, to prevent notices in PHP5.
             if (defined('E_RECOVERABLE_ERROR')) {
                 $map[E_RECOVERABLE_ERROR] = 'E_RECOVERABLE_ERROR';
             }
             if (defined('E_DEPRECATED')) {
                 $map[E_DEPRECATED] = 'E_DEPRECATED';
             }
-            // End Moodle additions.
             return $map[$severity];
         }
-    }
+}
 
-    /**
+/**
      *    Error handler that simply stashes any errors into the global
      *    error queue. Simulates the existing behaviour with respect to
      *    logging errors, but this feature may be removed in future.
@@ -234,8 +281,9 @@
      *    @static
      *    @access public
      */
-    function SimpleTestErrorHandler($severity, $message, $filename, $line, $super_globals) {
-        if ($severity = $severity & error_reporting()) {
+function SimpleTestErrorHandler($severity, $message, $filename = null, $line = null, $super_globals = null, $mask = null) {
+    $severity = $severity & error_reporting();
+    if ($severity) {
             restore_error_handler();
             if (ini_get('log_errors')) {
                 $label = SimpleErrorQueue::getSeverityAsString($severity);
@@ -246,5 +294,6 @@
             $queue->add($severity, $message, $filename, $line);
             set_error_handler('SimpleTestErrorHandler');
         }
-    }
+    return true;
+}
 ?>
\ No newline at end of file
