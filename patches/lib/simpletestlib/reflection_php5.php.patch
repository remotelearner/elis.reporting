diff --git a/lib/simpletestlib/reflection_php5.php b/lib/simpletestlib/reflection_php5.php
index 7e023f3..0f2e50b 100644
--- a/lib/simpletestlib/reflection_php5.php
+++ b/lib/simpletestlib/reflection_php5.php
@@ -1,17 +1,17 @@
 <?php
-    /**
+/**
      *	base include file for SimpleTest
      *	@package	SimpleTest
      *	@subpackage	UnitTester
      *	@version	$Id$
      */
 
-    /**
+/**
      *    Version specific reflection API.
      *    @package SimpleTest
      *    @subpackage UnitTester
      */
-    class SimpleReflection {
+class SimpleReflection {
         var $_interface;
 
         /**
@@ -87,8 +87,7 @@
 
         /**
          *    Gets the list of methods on a class or
-         *    interface. Needs to recursively look at all of
-         *    the interfaces included.
+     *    interface.
          *    @returns array              List of method names.
          *    @access public
          */
@@ -151,7 +150,7 @@
         }
 
         /**
-         *    Determines if the class is abstract.
+     *    Trivially determines if the class is abstract.
          *    @returns boolean      True if abstract.
          *    @access public
          */
@@ -161,8 +160,34 @@
         }
 
         /**
-         *    Wittles a list of interfaces down to only the top
-         *    level parents.
+     *    Trivially determines if the class is an interface.
+     *    @returns boolean      True if interface.
+     *    @access public
+     */
+    function isInterface() {
+        $reflection = new ReflectionClass($this->_interface);
+        return $reflection->isInterface();
+    }
+
+    /**
+     *    Scans for final methods, as they screw up inherited
+     *    mocks by not allowing you to override them.
+     *    @returns boolean   True if the class has a final method.
+     *    @access public
+     */
+    function hasFinal() {
+        $reflection = new ReflectionClass($this->_interface);
+        foreach ($reflection->getMethods() as $method) {
+            if ($method->isFinal()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     *    Whittles a list of interfaces down to only the
+     *    necessary top level parents.
          *    @param array $interfaces     Reflection API interfaces
          *                                 to reduce.
          *    @returns array               List of parent interface names.
@@ -170,22 +195,84 @@
          */
         function _onlyParents($interfaces) {
             $parents = array();
+        $blacklist = array();
             foreach ($interfaces as $interface) {
                 foreach($interfaces as $possible_parent) {
                     if ($interface->getName() == $possible_parent->getName()) {
                         continue;
                     }
                     if ($interface->isSubClassOf($possible_parent)) {
-                        break;
+                    $blacklist[$possible_parent->getName()] = true;
                     }
                 }
+            if (!isset($blacklist[$interface->getName()])) {
                 $parents[] = $interface->getName();
             }
+        }
             return $parents;
         }
 
         /**
-         *    Gets the source code matching the declaration
+     * Checks whether a method is abstract or not.
+     * @param   string   $name  Method name.
+     * @return  bool            true if method is abstract, else false
+     * @access  private
+     */
+    function _isAbstractMethod($name) {
+        $interface = new ReflectionClass($this->_interface);
+        if (! $interface->hasMethod($name)) {
+            return false;
+        }
+        return $interface->getMethod($name)->isAbstract();
+    }
+
+    /**
+     * Checks whether a method is the constructor.
+     * @param   string   $name  Method name.
+     * @return  bool            true if method is the constructor
+     * @access  private
+     */
+    function _isConstructor($name) {
+        return ($name == '__construct') || ($name == $this->_interface);
+    }
+
+    /**
+     * Checks whether a method is abstract in all parents or not.
+     * @param   string   $name  Method name.
+     * @return  bool            true if method is abstract in parent, else false
+     * @access  private
+     */
+    function _isAbstractMethodInParents($name) {
+        $interface = new ReflectionClass($this->_interface);
+        $parent = $interface->getParentClass();
+        while($parent) {
+            if (! $parent->hasMethod($name)) {
+                return false;
+            }
+            if ($parent->getMethod($name)->isAbstract()) {
+                return true;
+            }
+            $parent = $parent->getParentClass();
+        }
+        return false;
+    }
+
+    /**
+     * Checks whether a method is static or not.
+     * @param   string  $name   Method name
+     * @return  bool            true if method is static, else false
+     * @access  private
+     */
+    function _isStaticMethod($name) {
+        $interface = new ReflectionClass($this->_interface);
+        if (! $interface->hasMethod($name)) {
+            return false;
+        }
+        return $interface->getMethod($name)->isStatic();
+    }
+
+    /**
+     *    Writes the source code matching the declaration
          *    of a method.
          *    @param string $name    Method name.
          *    @return string         Method signature up to last
@@ -204,10 +291,13 @@
                     return "function {$name}(\$key)";
                 }
             }
-        	if (! is_callable(array($this->_interface, $name))) {
+        if ($name == '__toString') {
         		return "function $name()";
         	}
-        	if ($this->_isInterfaceMethod($name)) {
+        if ($this->_isInterfaceMethod($name) ||
+                $this->_isAbstractMethod($name) ||
+                $this->_isAbstractMethodInParents($name) ||
+                $this->_isStaticMethod($name)) {
         	    return $this->_getFullSignature($name);
         	}
         	return "function $name()";
@@ -225,7 +315,8 @@
             $interface = new ReflectionClass($this->_interface);
             $method = $interface->getMethod($name);
             $reference = $method->returnsReference() ? '&' : '';
-            return "function $reference$name(" .
+        $static = $method->isStatic() ? 'static ' : '';
+        return "{$static}function $reference$name(" .
                     implode(', ', $this->_getParameterSignatures($method)) .
                     ")";
         }
@@ -241,12 +332,21 @@
         function _getParameterSignatures($method) {
             $signatures = array();
             foreach ($method->getParameters() as $parameter) {
+            $signature = '';
                 $type = $parameter->getClass();
-            	$signatures[] =
-                        (! is_null($type) ? $type->getName() . ' ' : '') .
-                        ($parameter->isPassedByReference() ? '&' : '') .
-                        '$' . $this->_suppressSpurious($parameter->getName()) .
-                        ($this->_isOptional($parameter) ? ' = null' : '');
+            if (is_null($type) && version_compare(phpversion(), '5.1.0', '>=') && $parameter->isArray()) {
+                $signature .= 'array ';
+            } elseif (!is_null($type)) {
+                $signature .= $type->getName() . ' ';
+            }
+            if ($parameter->isPassedByReference()) {
+                $signature .= '&';
+            }
+            $signature .= '$' . $this->_suppressSpurious($parameter->getName());
+            if ($this->_isOptional($parameter)) {
+                $signature .= ' = null';
+            }
+            $signatures[] = $signature;
             }
             return $signatures;
         }
@@ -276,5 +376,5 @@
             }
             return false;
         }
-    }
+}
 ?>
\ No newline at end of file
