diff --git a/lib/simpletestlib/mock_objects.php b/lib/simpletestlib/mock_objects.php
index aefdd31..f37fc76 100644
--- a/lib/simpletestlib/mock_objects.php
+++ b/lib/simpletestlib/mock_objects.php
@@ -1,37 +1,37 @@
 <?php
-    /**
+/**
      *	base include file for SimpleTest
      *	@package	SimpleTest
      *	@subpackage	MockObjects
      *	@version	$Id$
      */
 
-    /**#@+
+/**#@+
      * include SimpleTest files
      */
-    require_once(dirname(__FILE__) . '/expectation.php');
-    require_once(dirname(__FILE__) . '/simpletest.php');
-    require_once(dirname(__FILE__) . '/dumper.php');
-    if (version_compare(phpversion(), '5') >= 0) {
+require_once(dirname(__FILE__) . '/expectation.php');
+require_once(dirname(__FILE__) . '/simpletest.php');
+require_once(dirname(__FILE__) . '/dumper.php');
+if (version_compare(phpversion(), '5') >= 0) {
         require_once(dirname(__FILE__) . '/reflection_php5.php');
-    } else {
+} else {
         require_once(dirname(__FILE__) . '/reflection_php4.php');
-    }
-    /**#@-*/
+}
+/**#@-*/
 
-    /**
+/**
      * Default character simpletest will substitute for any value
      */
-    if (! defined('MOCK_ANYTHING')) {
+if (! defined('MOCK_ANYTHING')) {
         define('MOCK_ANYTHING', '*');
-    }
+}
 
-    /**
+/**
      *    Parameter comparison assertion.
 	 *    @package SimpleTest
 	 *    @subpackage MockObjects
      */
-    class ParametersExpectation extends SimpleExpectation {
+class ParametersExpectation extends SimpleExpectation {
         var $_expected;
 
         /**
@@ -151,18 +151,20 @@
             $descriptions = array();
             if (is_array($args)) {
                 foreach ($args as $arg) {
-                    $dumper = &new SimpleDumper();
+                $dumper = new SimpleDumper();
                     $descriptions[] = $dumper->describeValue($arg);
                 }
             }
             return implode(', ', $descriptions);
         }
-    }
+}
 
-    /**
+/**
      *    Confirms that the number of calls on a method is as expected.
+ *  @package    SimpleTest
+ *  @subpackage MockObjects
      */
-    class CallCountExpectation extends SimpleExpectation {
+class CallCountExpectation extends SimpleExpectation {
         var $_method;
         var $_count;
 
@@ -200,12 +202,14 @@
                     '] was [' . $this->_count .
                     '] got [' . $compare . ']';
         }
-    }
+}
 
-    /**
+/**
      *    Confirms that the number of calls on a method is as expected.
+ *  @package    SimpleTest
+ *  @subpackage MockObjects
      */
-    class MinimumCallCountExpectation extends SimpleExpectation {
+class MinimumCallCountExpectation extends SimpleExpectation {
         var $_method;
         var $_count;
 
@@ -243,12 +247,14 @@
                     '] was [' . $this->_count .
                     '] got [' . $compare . ']';
         }
-    }
+}
 
-    /**
+/**
      *    Confirms that the number of calls on a method is as expected.
+ *    @package      SimpleTest
+ *    @subpackage   MockObjects
      */
-    class MaximumCallCountExpectation extends SimpleExpectation {
+class MaximumCallCountExpectation extends SimpleExpectation {
         var $_method;
         var $_count;
 
@@ -286,46 +292,36 @@
                     '] was [' . $this->_count .
                     '] got [' . $compare . ']';
         }
-    }
+}
 
-    /**
-     *    Retrieves values and references by searching the
-     *    parameter lists until a match is found.
+/**
+ *    Retrieves method actions by searching the
+ *    parameter lists until an expected match is found.
 	 *    @package SimpleTest
 	 *    @subpackage MockObjects
      */
-    class CallMap {
+class SimpleSignatureMap {
         var $_map;
 
         /**
          *    Creates an empty call map.
          *    @access public
          */
-        function CallMap() {
+    function SimpleSignatureMap() {
             $this->_map = array();
         }
 
         /**
-         *    Stashes a value against a method call.
-         *    @param array $parameters    Arguments including wildcards.
-         *    @param mixed $value         Value copied into the map.
-         *    @access public
-         */
-        function addValue($parameters, $value) {
-            $this->addReference($parameters, $value);
-        }
-
-        /**
          *    Stashes a reference against a method call.
          *    @param array $parameters    Array of arguments (including wildcards).
-         *    @param mixed $reference     Array reference placed in the map.
+     *    @param mixed $action        Reference placed in the map.
          *    @access public
          */
-        function addReference($parameters, &$reference) {
+    function add($parameters, &$action) {
             $place = count($this->_map);
             $this->_map[$place] = array();
-            $this->_map[$place]["params"] = new ParametersExpectation($parameters);
-            $this->_map[$place]["content"] = &$reference;
+        $this->_map[$place]['params'] = new ParametersExpectation($parameters);
+        $this->_map[$place]['content'] = &$action;
         }
 
         /**
@@ -337,14 +333,14 @@
          *                                slot, otherwise null.
          *    @access public
          */
-        function &findFirstMatch($parameters) {
+    function &findFirstAction($parameters) {
             $slot = $this->_findFirstSlot($parameters);
-            if (!isset($slot)) {
+        if (isset($slot) && isset($slot['content'])) {
+            return $slot['content'];
+        }
                 $null = null;
                 return $null;
             }
-            return $slot["content"];
-        }
 
         /**
          *    Searches the call list for a matching parameter
@@ -359,6 +355,18 @@
         }
 
         /**
+     *    Compares the incoming parameters with the
+     *    internal expectation. Uses the incoming $test
+     *    to dispatch the test message.
+     *    @param SimpleTestCase $test   Test to dispatch to.
+     *    @param array $parameters      The actual calling arguments.
+     *    @param string $message        The message to overlay.
+     *    @access public
+     */
+    function test(&$test, $parameters, $message) {
+    }
+
+    /**
          *    Searches the map for a matching item.
          *    @param array $parameters    Parameters to search by
          *                                without wildcards.
@@ -375,22 +383,263 @@
             $null = null;
             return $null;
         }
+}
+
+/**
+ *    Allows setting of actions against call signatures either
+ *    at a specific time, or always. Specific time settings
+ *    trump lasting ones, otherwise the most recently added
+ *    will mask an earlier match.
+ *    @package SimpleTest
+ *    @subpackage MockObjects
+ */
+class SimpleCallSchedule {
+    var $_wildcard = MOCK_ANYTHING;
+    var $_always;
+    var $_at;
+    
+    /**
+     *    Sets up an empty response schedule.
+     *    Creates an empty call map.
+     */
+    function SimpleCallSchedule() {
+        $this->_always = array();
+        $this->_at = array();
+    }
+    
+    /**
+     *    Stores an action against a signature that
+     *    will always fire unless masked by a time
+     *    specific one.
+     *    @param string $method        Method name.
+     *    @param array $args           Calling parameters.
+     *    @param SimpleAction $action  Actually simpleByValue, etc.
+     *    @access public
+     */
+    function register($method, $args, &$action) {
+        $args = $this->_replaceWildcards($args);
+        $method = strtolower($method);
+        if (! isset($this->_always[$method])) {
+            $this->_always[$method] = new SimpleSignatureMap();
+        }
+        $this->_always[$method]->add($args, $action);
+    }
+    
+    /**
+     *    Stores an action against a signature that
+     *    will fire at a specific time in the future.
+     *    @param integer $step         delay of calls to this method,
+     *                                 0 is next.
+     *    @param string $method        Method name.
+     *    @param array $args           Calling parameters.
+     *    @param SimpleAction $action  Actually SimpleByValue, etc.
+     *    @access public
+     */
+    function registerAt($step, $method, $args, &$action) {
+        $args = $this->_replaceWildcards($args);
+        $method = strtolower($method);
+        if (! isset($this->_at[$method])) {
+            $this->_at[$method] = array();
+        }
+        if (! isset($this->_at[$method][$step])) {
+            $this->_at[$method][$step] = new SimpleSignatureMap();
+        }
+        $this->_at[$method][$step]->add($args, $action);
+    }
+    
+    function expectArguments($method, $args, $message) {
+        $args = $this->_replaceWildcards($args);
+        $message .= Mock::getExpectationLine();
+        $this->_expected_args[strtolower($method)] =
+                new ParametersExpectation($args, $message);
+
+    }
+    
+    /**
+     *    Actually carry out the action stored previously,
+     *    if the parameters match.
+     *    @param integer $step      Time of call.
+     *    @param string $method     Method name.
+     *    @param array $args        The parameters making up the
+     *                              rest of the call.
+     *    @return mixed             The result of the action.
+     *    @access public.
+     */
+    function &respond($step, $method, $args) {
+        $method = strtolower($method);
+        if (isset($this->_at[$method][$step])) {
+            if ($this->_at[$method][$step]->isMatch($args)) {
+                $action = &$this->_at[$method][$step]->findFirstAction($args);
+                if (isset($action)) {
+                    return $action->act();
+                }
+            }
+        }
+        if (isset($this->_always[$method])) {
+            $action = &$this->_always[$method]->findFirstAction($args);
+            if (isset($action)) {
+                return $action->act();
+            }
+        }
+        $null = null;
+        return $null;
+    }
+    
+    /**
+     *    Replaces wildcard matches with wildcard
+     *    expectations in the argument list.
+     *    @param array $args      Raw argument list.
+     *    @return array           Argument list with
+     *                            expectations.
+     *    @access private
+     */
+    function _replaceWildcards($args) {
+        if ($args === false) {
+            return false;
+        }
+        for ($i = 0; $i < count($args); $i++) {
+            if ($args[$i] === $this->_wildcard) {
+                $args[$i] = new AnythingExpectation();
+            }
+        }
+        return $args;
+    }
+}
+
+/**
+ *    A type of SimpleMethodAction.
+ *    Stashes a reference for returning later.
+ *    @package SimpleTest
+ *    @subpackage MockObjects
+ */
+class SimpleByReference {
+    var $_reference;
+    
+    /**
+     *    Stashes it for later.
+     *    @param mixed $reference     Actual PHP4 style reference.
+     *    @access public
+     */
+    function SimpleByReference(&$reference) {
+        $this->_reference = &$reference;
+    }
+    
+    /**
+     *    Returns the reference stored earlier.
+     *    @return mixed    Whatever was stashed.
+     *    @access public
+     */
+    function &act() {
+        return $this->_reference;
+    }
+}
+
+/**
+ *    A type of SimpleMethodAction.
+ *    Stashes a value for returning later.
+ *    @package SimpleTest
+ *    @subpackage MockObjects
+ */
+class SimpleByValue {
+    var $_value;
+    
+    /**
+     *    Stashes it for later.
+     *    @param mixed $value     You need to clone objects
+     *                            if you want copy semantics
+     *                            for these.
+     *    @access public
+     */
+    function SimpleByValue($value) {
+        $this->_value = $value;
+    }
+    
+    /**
+     *    Returns the value stored earlier.
+     *    @return mixed    Whatever was stashed.
+     *    @access public
+     */
+    function &act() {
+        $dummy = $this->_value;
+        return $dummy;
+    }
+}
+
+/**
+ *    A type of SimpleMethodAction.
+ *    Stashes an exception for throwing later.
+ *    @package SimpleTest
+ *    @subpackage MockObjects
+ */
+class SimpleThrower {
+    var $_exception;
+    
+    /**
+     *    Stashes it for later.
+     *    @param Exception $exception    The exception object to throw.
+     *    @access public
+     */
+    function SimpleThrower($exception) {
+        $this->_exception = $exception;
+    }
+    
+    /**
+     *    Throws the exceptins stashed earlier.
+     *    @access public
+     */
+    function act() {
+        eval('throw $this->_exception;');
+    }
+}
+
+/**
+ *    A type of SimpleMethodAction.
+ *    Stashes an error for emitting later.
+ *    @package SimpleTest
+ *    @subpackage MockObjects
+ */
+class SimpleErrorThrower {
+    var $_error;
+    var $_severity;
+    
+    /**
+     *    Stashes an error to throw later.
+     *    @param string $error      Error message.
+     *    @param integer $severity  PHP error constant, e.g E_USER_ERROR.
+     *    @access public
+     */
+    function SimpleErrorThrower($error, $severity) {
+        $this->_error = $error;
+        $this->_severity = $severity;
     }
 
     /**
-     *    An empty collection of methods that can have their
+     *    Triggers the stashed error.
+     *    @return null        The usual PHP4.4 shenanigans are needed here.
+     *    @access public
+     */
+    function &act() {
+        trigger_error($this->_error, $this->_severity);
+        $null = null;
+        return $null;
+    }
+}
+
+/**
+ *    A base class or delegate that extends an
+ *    empty collection of methods that can have their
      *    return values set and expectations made of the
      *    calls upon them. The mock will assert the
      *    expectations against it's attached test case in
-     *    addition to the server stub behaviour.
+ *    addition to the server stub behaviour or returning
+ *    preprogrammed responses.
 	 *    @package SimpleTest
 	 *    @subpackage MockObjects
      */
-    class SimpleMock {
+class SimpleMock {
+    var $_actions;
         var $_wildcard = MOCK_ANYTHING;
         var $_is_strict = true;
-        var $_returns;
-        var $_return_sequence;
         var $_call_counts;
         var $_expected_counts;
         var $_max_counts;
@@ -398,23 +647,20 @@
         var $_expected_args_at;
 
         /**
-         *    Creates an empty return list and expectation list.
+     *    Creates an empty action list and expectation list.
          *    All call counts are set to zero.
-         *    @param SimpleTestCase $test    Test case to test expectations in.
-         *    @param mixed $wildcard         Parameter matching wildcard.
-         *    @param boolean $is_strict      Enables method name checks on
-         *                                   expectations.
+     *    @access public
          */
         function SimpleMock() {
-            $this->_returns = array();
-            $this->_return_sequence = array();
+        $this->_actions = new SimpleCallSchedule();
+        $this->_expectations = new SimpleCallSchedule();
             $this->_call_counts = array();
-            $test = &$this->_getCurrentTestCase();
-            $test->tell($this);
             $this->_expected_counts = array();
             $this->_max_counts = array();
             $this->_expected_args = array();
             $this->_expected_args_at = array();
+        $test = &$this->_getCurrentTestCase();
+        $test->tell($this);
         }
 
         /**
@@ -427,15 +673,6 @@
         }
 
         /**
-         *    Changes the default wildcard object.
-         *    @param mixed $wildcard         Parameter matching wildcard.
-         *    @access public
-         */
-        function setWildcard($wildcard) {
-            $this->_wildcard = $wildcard;
-        }
-
-        /**
          *    Finds currently running test.
          *    @return SimpeTestCase    Current test case.
          *    @access protected
@@ -446,7 +683,7 @@
         }
 
         /**
-         *    Die if bad arguments array is passed
+     *    Die if bad arguments array is passed.
          *    @param mixed $args     The arguments value to be checked.
          *    @param string $task    Description of task attempt.
          *    @return boolean        Valid arguments
@@ -502,7 +739,7 @@
          *    @access protected
          */
         function _addCall($method, $args) {
-            if (!isset($this->_call_counts[$method])) {
+        if (! isset($this->_call_counts[$method])) {
                 $this->_call_counts[$method] = 0;
             }
             $this->_call_counts[$method]++;
@@ -511,7 +748,7 @@
         /**
          *    Fetches the call count of a method so far.
          *    @param string $method        Method name called.
-         *    @return                      Number of calls so far.
+     *    @return integer              Number of calls so far.
          *    @access public
          */
         function getCallCount($method) {
@@ -534,12 +771,7 @@
          */
         function setReturnValue($method, $value, $args = false) {
             $this->_dieOnNoMethod($method, "set return value");
-            $args = $this->_replaceWildcards($args);
-            $method = strtolower($method);
-            if (! isset($this->_returns[$method])) {
-                $this->_returns[$method] = new CallMap();
-            }
-            $this->_returns[$method]->addValue($args, $value);
+        $this->_actions->register($method, $args, new SimpleByValue($value));
         }
 
         /**
@@ -558,15 +790,7 @@
          */
         function setReturnValueAt($timing, $method, $value, $args = false) {
             $this->_dieOnNoMethod($method, "set return value sequence");
-            $args = $this->_replaceWildcards($args);
-            $method = strtolower($method);
-            if (! isset($this->_return_sequence[$method])) {
-                $this->_return_sequence[$method] = array();
-            }
-            if (! isset($this->_return_sequence[$method][$timing])) {
-                $this->_return_sequence[$method][$timing] = new CallMap();
-            }
-            $this->_return_sequence[$method][$timing]->addValue($args, $value);
+        $this->_actions->registerAt($timing, $method, $args, new SimpleByValue($value));
         }
 
         /**
@@ -580,12 +804,7 @@
          */
         function setReturnReference($method, &$reference, $args = false) {
             $this->_dieOnNoMethod($method, "set return reference");
-            $args = $this->_replaceWildcards($args);
-            $method = strtolower($method);
-            if (! isset($this->_returns[$method])) {
-                $this->_returns[$method] = new CallMap();
-            }
-            $this->_returns[$method]->addReference($args, $reference);
+        $this->_actions->register($method, $args, new SimpleByReference($reference));
         }
 
         /**
@@ -604,15 +823,7 @@
          */
         function setReturnReferenceAt($timing, $method, &$reference, $args = false) {
             $this->_dieOnNoMethod($method, "set return reference sequence");
-            $args = $this->_replaceWildcards($args);
-            $method = strtolower($method);
-            if (! isset($this->_return_sequence[$method])) {
-                $this->_return_sequence[$method] = array();
-            }
-            if (! isset($this->_return_sequence[$method][$timing])) {
-                $this->_return_sequence[$method][$timing] = new CallMap();
-            }
-            $this->_return_sequence[$method][$timing]->addReference($args, $reference);
+        $this->_actions->registerAt($timing, $method, $args, new SimpleByReference($reference));
         }
 
         /**
@@ -629,6 +840,7 @@
         function expect($method, $args, $message = '%s') {
             $this->_dieOnNoMethod($method, 'set expected arguments');
             $this->_checkArgumentsIsArray($args, 'set expected arguments');
+        $this->_expectations->expectArguments($method, $args, $message);
             $args = $this->_replaceWildcards($args);
             $message .= Mock::getExpectationLine();
             $this->_expected_args[strtolower($method)] =
@@ -747,7 +959,7 @@
         function expectOnce($method, $args = false, $message = '%s') {
             $this->expectCallCount($method, 1, $message);
             if ($args !== false) {
-                $this->expectArguments($method, $args, $message);
+            $this->expect($method, $args, $message);
             }
         }
 
@@ -763,8 +975,47 @@
         function expectAtLeastOnce($method, $args = false, $message = '%s') {
             $this->expectMinimumCallCount($method, 1, $message);
             if ($args !== false) {
-                $this->expectArguments($method, $args, $message);
+            $this->expect($method, $args, $message);
+        }
+    }
+    
+    /**
+     *    Sets up a trigger to throw an exception upon the
+     *    method call.
+     *    @param string $method     Method name to throw on.
+     */
+    function throwOn($method, $exception = false, $args = false) {
+        $this->_dieOnNoMethod($method, "throw on");
+        $this->_actions->register($method, $args,
+                new SimpleThrower($exception ? $exception : new Exception()));
+    }
+    
+    /**
+     *    Sets up a trigger to throw an exception upon the
+     *    method call.
+     */
+    function throwAt($timing, $method, $exception = false, $args = false) {
+        $this->_dieOnNoMethod($method, "throw at");
+        $this->_actions->registerAt($timing, $method, $args,
+                new SimpleThrower($exception ? $exception : new Exception()));
+    }
+    
+    /**
+     *    Sets up a trigger to throw an error upon the
+     *    method call.
+     */
+    function errorOn($method, $error = 'A mock error', $args = false, $severity = E_USER_ERROR) {
+        $this->_dieOnNoMethod($method, "error on");
+        $this->_actions->register($method, $args, new SimpleErrorThrower($error, $severity));
             }
+    
+    /**
+     *    Sets up a trigger to throw an error upon the
+     *    method call.
+     */
+    function errorAt($timing, $method, $error = 'A mock error', $args = false, $severity = E_USER_ERROR) {
+        $this->_dieOnNoMethod($method, "error at");
+        $this->_actions->registerAt($timing, $method, $args, new SimpleErrorThrower($error, $severity));
         }
 
         /**
@@ -808,9 +1059,10 @@
             $step = $this->getCallCount($method);
             $this->_addCall($method, $args);
             $this->_checkExpectations($method, $args, $step);
-            $result = &$this->_getReturn($method, $args, $step);
+        $result = &$this->_emulateCall($method, $args, $step);
             return $result;
         }
+    
         /**
          *    Finds the return value matching the incoming
          *    arguments. If there is no matching value found
@@ -819,22 +1071,11 @@
          *    @param array $args         Calling arguments.
          *    @param integer $step       Current position in the
          *                               call history.
-         *    @return mixed              Stored return.
+     *    @return mixed              Stored return or other action.
          *    @access protected
          */
-        function &_getReturn($method, $args, $step) {
-            if (isset($this->_return_sequence[$method][$step])) {
-                if ($this->_return_sequence[$method][$step]->isMatch($args)) {
-                    $result = &$this->_return_sequence[$method][$step]->findFirstMatch($args);
-                    return $result;
-                }
-            }
-            if (isset($this->_returns[$method])) {
-                $result = &$this->_returns[$method]->findFirstMatch($args);
-                return $result;
-            }
-            $null = null;
-            return $null;
+    function &_emulateCall($method, $args, $step) {
+        return $this->_actions->respond($step, $method, $args);
         }
 
         /**
@@ -864,15 +1105,15 @@
                         "Mock method [$method] -> %s");
             }
         }
-    }
+}
 
-    /**
+/**
      *    Static methods only service class for code generation of
      *    mock objects.
 	 *    @package SimpleTest
 	 *    @subpackage MockObjects
      */
-    class Mock {
+class Mock {
 
         /**
          *    Factory for mock object classes.
@@ -890,7 +1131,7 @@
          *                                 the old name with "Mock"
          *                                 prepended.
          *    @param array $methods        Additional methods to add beyond
-         *                                 those in th cloned class. Use this
+     *                                 those in the cloned class. Use this
          *                                 to emulate the dynamic addition of
          *                                 methods in the cloned class or when
          *                                 the class hasn't been written yet.
@@ -899,7 +1140,7 @@
          */
         function generate($class, $mock_class = false, $methods = false) {
             $generator = new MockGenerator($class, $mock_class);
-            return $generator->generate($methods);
+        return $generator->generateSubclass($methods);
         }
 
         /**
@@ -928,28 +1169,39 @@
             $trace = new SimpleStackTrace(array('expect'));
             return $trace->traceMethod();
         }
-    }
+}
 
-    /**
+/**
+ *    @package  SimpleTest
+ *    @subpackage   MockObjects
      *    @deprecated
      */
-    class Stub extends Mock {
-    }
+class Stub extends Mock {
+}
 
-    /**
+/**
      *    Service class for code generation of mock objects.
 	 *    @package SimpleTest
 	 *    @subpackage MockObjects
      */
-    class MockGenerator {
+class MockGenerator {
         var $_class;
         var $_mock_class;
         var $_mock_base;
         var $_reflection;
 
+    /**
+     *    Builds initial reflection object.
+     *    @param string $class        Class to be mocked.
+     *    @param string $mock_class   New class with identical interface,
+     *                                but no behaviour.
+     */
         function MockGenerator($class, $mock_class) {
             $this->_class = $class;
             $this->_mock_class = $mock_class;
+        if (! $this->_mock_class) {
+            $this->_mock_class = 'Mock' . $this->_class;
+        }
             $this->_mock_base = SimpleTest::getMockBaseClass();
             $this->_reflection = new SimpleReflection($this->_class);
         }
@@ -968,16 +1220,40 @@
             if (! $this->_reflection->classOrInterfaceExists()) {
                 return false;
             }
-            if (! $this->_mock_class) {
-                $this->_mock_class = 'Mock' . $this->_class;
+        $mock_reflection = new SimpleReflection($this->_mock_class);
+        if ($mock_reflection->classExistsSansAutoload()) {
+            return false;
+        }
+        $code = $this->_createClassCode($methods ? $methods : array());
+        return eval("$code return \$code;");
+    }
+    
+    /**
+     *    Subclasses a class and overrides every method with a mock one
+     *    that can have return values and expectations set. Chains
+     *    to an aggregated SimpleMock.
+     *    @param array $methods        Additional methods to add beyond
+     *                                 those in the cloned class. Use this
+     *                                 to emulate the dynamic addition of
+     *                                 methods in the cloned class or when
+     *                                 the class hasn't been written yet.
+     *    @access public
+     */
+    function generateSubclass($methods) {
+        if (! $this->_reflection->classOrInterfaceExists()) {
+            return false;
             }
             $mock_reflection = new SimpleReflection($this->_mock_class);
             if ($mock_reflection->classExistsSansAutoload()) {
                 return false;
             }
-            return eval(
-                    $this->_createClassCode($methods ? $methods : array()) .
-                    " return true;");
+        if ($this->_reflection->isInterface() || $this->_reflection->hasFinal()) {
+            $code = $this->_createClassCode($methods ? $methods : array());
+            return eval("$code return \$code;");
+        } else {
+            $code = $this->_createSubclassCode($methods ? $methods : array());
+            return eval("$code return \$code;");
+        }
         }
 
         /**
@@ -998,7 +1274,8 @@
                 trigger_error('Partial mock class [' . $this->_mock_class . '] already exists');
                 return false;
             }
-            return eval($this->_extendClassCode($methods));
+        $code = $this->_extendClassCode($methods);
+        return eval("$code return \$code;");
         }
 
         /**
@@ -1020,12 +1297,42 @@
             $code .= "    function " . $this->_mock_class . "() {\n";
             $code .= "        \$this->" . $this->_mock_base . "();\n";
             $code .= "    }\n";
+        if (in_array('__construct', $this->_reflection->getMethods())) {
+            $code .= "    " . $this->_reflection->getSignature('__construct') . " {\n";
+            $code .= "        \$this->" . $this->_mock_base . "();\n";
+            $code .= "    }\n";
+        }
             $code .= $this->_createHandlerCode($methods);
             $code .= "}\n";
             return $code;
         }
 
         /**
+     *    The new mock class code as a string. The mock will
+     *    be a subclass of the original mocked class.
+     *    @param array $methods          Additional methods.
+     *    @return string                 Code for new mock class.
+     *    @access private
+     */
+    function _createSubclassCode($methods) {
+        $code  = "class " . $this->_mock_class . " extends " . $this->_class . " {\n";
+        $code .= "    var \$_mock;\n";
+        $code .= $this->_addMethodList(array_merge($methods, $this->_reflection->getMethods()));
+        $code .= "\n";
+        $code .= "    function " . $this->_mock_class . "() {\n";
+        $code .= "        \$this->_mock = new " . $this->_mock_base . "();\n";
+        $code .= "        \$this->_mock->disableExpectationNameChecks();\n";
+        $code .= "    }\n";
+        $code .= $this->_chainMockReturns();
+        $code .= $this->_chainMockExpectations();
+        $code .= $this->_chainThrowMethods();
+        $code .= $this->_overrideMethods($this->_reflection->getMethods());
+        $code .= $this->_createNewMethodCode($methods);
+        $code .= "}\n";
+        return $code;
+    }
+
+    /**
          *    The extension class code as a string. The class
          *    composites a mock object and chains mocked methods
          *    to it.
@@ -1039,11 +1346,12 @@
             $code .= $this->_addMethodList($methods);
             $code .= "\n";
             $code .= "    function " . $this->_mock_class . "() {\n";
-            $code .= "        \$this->_mock = &new " . $this->_mock_base . "();\n";
+        $code .= "        \$this->_mock = new " . $this->_mock_base . "();\n";
             $code .= "        \$this->_mock->disableExpectationNameChecks();\n";
             $code .= "    }\n";
             $code .= $this->_chainMockReturns();
             $code .= $this->_chainMockExpectations();
+        $code .= $this->_chainThrowMethods();
             $code .= $this->_overrideMethods($methods);
             $code .= "}\n";
             return $code;
@@ -1078,6 +1386,33 @@
         }
 
         /**
+     *    Creates code within a class to generate a new
+     *    methods. All methods call the _invoke() handler
+     *    on the internal mock with the method name and
+     *    the arguments in an array.
+     *    @param array $methods    Additional methods.
+     *    @access private
+     */
+    function _createNewMethodCode($methods) {
+        $code = '';
+        foreach ($methods as $method) {
+            if ($this->_isConstructor($method)) {
+                continue;
+            }
+            $mock_reflection = new SimpleReflection($this->_mock_base);
+            if (in_array($method, $mock_reflection->getMethods())) {
+                continue;
+            }
+            $code .= "    " . $this->_reflection->getSignature($method) . " {\n";
+            $code .= "        \$args = func_get_args();\n";
+            $code .= "        \$result = &\$this->_mock->_invoke(\"$method\", \$args);\n";
+            $code .= "        return \$result;\n";
+            $code .= "    }\n";
+        }
+        return $code;
+    }
+
+    /**
          *    Tests to see if a special PHP method is about to
          *    be stubbed by mistake.
          *    @param string $method    Method name.
@@ -1087,7 +1422,7 @@
         function _isConstructor($method) {
             return in_array(
                     strtolower($method),
-                    array('__construct', '__destruct', '__clone'));
+                array('__construct', '__destruct'));
         }
 
         /**
@@ -1097,7 +1432,9 @@
          *    @access private
          */
         function _addMethodList($methods) {
-            return "    var \$_mocked_methods = array('" . implode("', '", $methods) . "');\n";
+        return "    var \$_mocked_methods = array('" .
+                implode("', '", array_map('strtolower', $methods)) .
+                "');\n";
         }
 
         /**
@@ -1107,7 +1444,7 @@
          *    @access private
          */
         function _bailOutIfNotMocked($alias) {
-            $code  = "        if (! in_array($alias, \$this->_mocked_methods)) {\n";
+        $code  = "        if (! in_array(strtolower($alias), \$this->_mocked_methods)) {\n";
             $code .= "            trigger_error(\"Method [$alias] is not mocked\");\n";
             $code .= "            \$null = null;\n";
             $code .= "            return \$null;\n";
@@ -1148,48 +1485,72 @@
          *    @access private
          */
         function _chainMockExpectations() {
-            $code  = "    function expect(\$method, \$args = false) {\n";
+        $code  = "    function expect(\$method, \$args = false, \$msg = '%s') {\n";
             $code .= $this->_bailOutIfNotMocked("\$method");
-            $code .= "        \$this->_mock->expect(\$method, \$args);\n";
+        $code .= "        \$this->_mock->expect(\$method, \$args, \$msg);\n";
             $code .= "    }\n";
-            $code .= "    function expectArguments(\$method, \$args = false) {\n";
+        $code .= "    function expectArguments(\$method, \$args = false, \$msg = '%s') {\n";
             $code .= $this->_bailOutIfNotMocked("\$method");
-            $code .= "        \$this->_mock->expectArguments(\$method, \$args);\n";
+        $code .= "        \$this->_mock->expectArguments(\$method, \$args, \$msg);\n";
             $code .= "    }\n";
-            $code .= "    function expectAt(\$timing, \$method, \$args = false) {\n";
+        $code .= "    function expectAt(\$timing, \$method, \$args = false, \$msg = '%s') {\n";
             $code .= $this->_bailOutIfNotMocked("\$method");
-            $code .= "        \$this->_mock->expectArgumentsAt(\$timing, \$method, \$args);\n";
+        $code .= "        \$this->_mock->expectArgumentsAt(\$timing, \$method, \$args, \$msg);\n";
             $code .= "    }\n";
-            $code .= "    function expectArgumentsAt(\$timing, \$method, \$args = false) {\n";
+        $code .= "    function expectArgumentsAt(\$timing, \$method, \$args = false, \$msg = '%s') {\n";
             $code .= $this->_bailOutIfNotMocked("\$method");
-            $code .= "        \$this->_mock->expectArgumentsAt(\$timing, \$method, \$args);\n";
+        $code .= "        \$this->_mock->expectArgumentsAt(\$timing, \$method, \$args, \$msg);\n";
             $code .= "    }\n";
             $code .= "    function expectCallCount(\$method, \$count) {\n";
             $code .= $this->_bailOutIfNotMocked("\$method");
-            $code .= "        \$this->_mock->expectCallCount(\$method, \$count);\n";
+        $code .= "        \$this->_mock->expectCallCount(\$method, \$count, \$msg = '%s');\n";
             $code .= "    }\n";
-            $code .= "    function expectMaximumCallCount(\$method, \$count) {\n";
+        $code .= "    function expectMaximumCallCount(\$method, \$count, \$msg = '%s') {\n";
             $code .= $this->_bailOutIfNotMocked("\$method");
-            $code .= "        \$this->_mock->expectMaximumCallCount(\$method, \$count);\n";
+        $code .= "        \$this->_mock->expectMaximumCallCount(\$method, \$count, \$msg = '%s');\n";
             $code .= "    }\n";
-            $code .= "    function expectMinimumCallCount(\$method, \$count) {\n";
+        $code .= "    function expectMinimumCallCount(\$method, \$count, \$msg = '%s') {\n";
             $code .= $this->_bailOutIfNotMocked("\$method");
-            $code .= "        \$this->_mock->expectMinimumCallCount(\$method, \$count);\n";
+        $code .= "        \$this->_mock->expectMinimumCallCount(\$method, \$count, \$msg = '%s');\n";
             $code .= "    }\n";
             $code .= "    function expectNever(\$method) {\n";
             $code .= $this->_bailOutIfNotMocked("\$method");
             $code .= "        \$this->_mock->expectNever(\$method);\n";
             $code .= "    }\n";
-            $code .= "    function expectOnce(\$method, \$args = false) {\n";
+        $code .= "    function expectOnce(\$method, \$args = false, \$msg = '%s') {\n";
             $code .= $this->_bailOutIfNotMocked("\$method");
-            $code .= "        \$this->_mock->expectOnce(\$method, \$args);\n";
+        $code .= "        \$this->_mock->expectOnce(\$method, \$args, \$msg);\n";
             $code .= "    }\n";
-            $code .= "    function expectAtLeastOnce(\$method, \$args = false) {\n";
+        $code .= "    function expectAtLeastOnce(\$method, \$args = false, \$msg = '%s') {\n";
             $code .= $this->_bailOutIfNotMocked("\$method");
-            $code .= "        \$this->_mock->expectAtLeastOnce(\$method, \$args);\n";
+        $code .= "        \$this->_mock->expectAtLeastOnce(\$method, \$args, \$msg);\n";
             $code .= "    }\n";
             $code .= "    function tally() {\n";
-            $code .= "        \$this->_mock->tally();\n";
+        $code .= "    }\n";
+        return $code;
+    }
+    
+    /**
+     *    Adds code for chaining the throw methods.
+     *    @return string           Code for chains.
+     *    @access private
+     */
+    function _chainThrowMethods() {
+        $code  = "    function throwOn(\$method, \$exception = false, \$args = false) {\n";
+        $code .= $this->_bailOutIfNotMocked("\$method");
+        $code .= "        \$this->_mock->throwOn(\$method, \$exception, \$args);\n";
+        $code .= "    }\n";
+        $code .= "    function throwAt(\$timing, \$method, \$exception = false, \$args = false) {\n";
+        $code .= $this->_bailOutIfNotMocked("\$method");
+        $code .= "        \$this->_mock->throwAt(\$timing, \$method, \$exception, \$args);\n";
+        $code .= "    }\n";
+        $code .= "    function errorOn(\$method, \$error = 'A mock error', \$args = false, \$severity = E_USER_ERROR) {\n";
+        $code .= $this->_bailOutIfNotMocked("\$method");
+        $code .= "        \$this->_mock->errorOn(\$method, \$error, \$args, \$severity);\n";
+        $code .= "    }\n";
+        $code .= "    function errorAt(\$timing, \$method, \$error = 'A mock error', \$args = false, \$severity = E_USER_ERROR) {\n";
+        $code .= $this->_bailOutIfNotMocked("\$method");
+        $code .= "        \$this->_mock->errorAt(\$timing, \$method, \$error, \$args, \$severity);\n";
             $code .= "    }\n";
             return $code;
         }
@@ -1205,6 +1566,9 @@
         function _overrideMethods($methods) {
             $code = "";
             foreach ($methods as $method) {
+            if ($this->_isConstructor($method)) {
+                continue;
+            }
                 $code .= "    " . $this->_reflection->getSignature($method) . " {\n";
                 $code .= "        \$args = func_get_args();\n";
                 $code .= "        \$result = &\$this->_mock->_invoke(\"$method\", \$args);\n";
@@ -1213,5 +1577,5 @@
             }
             return $code;
         }
-    }
+}
 ?>
\ No newline at end of file
