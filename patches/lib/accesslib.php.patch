diff --git a/lib/accesslib.php b/lib/accesslib.php
old mode 100755
new mode 100644
index 0ab769e..e447cbf
--- a/lib/accesslib.php
+++ b/lib/accesslib.php
@@ -1,31 +1,24 @@
-<?php // $Id$
-
-///////////////////////////////////////////////////////////////////////////
-//                                                                       //
-// NOTICE OF COPYRIGHT                                                   //
-//                                                                       //
-// Moodle - Modular Object-Oriented Dynamic Learning Environment         //
-//          http://moodle.org                                            //
-//                                                                       //
-// Copyright (C) 1999 onwards Martin Dougiamas  http://dougiamas.com     //
-//                                                                       //
-// This program is free software; you can redistribute it and/or modify  //
-// it under the terms of the GNU General Public License as published by  //
-// the Free Software Foundation; either version 2 of the License, or     //
-// (at your option) any later version.                                   //
-//                                                                       //
-// This program is distributed in the hope that it will be useful,       //
-// but WITHOUT ANY WARRANTY; without even the implied warranty of        //
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
-// GNU General Public License for more details:                          //
-//                                                                       //
-//          http://www.gnu.org/copyleft/gpl.html                         //
-//                                                                       //
-///////////////////////////////////////////////////////////////////////////
-
-/**
- * Public API vs internals 
- * -----------------------
+<?php
+
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
+/**
+ * This file contains functions for managing user access
+ *
+ * <b>Public API vs internals</b>
  * 
  * General users probably only care about
  *
@@ -56,26 +49,23 @@
  * Advanced use
  * - load_all_capabilities()
  * - reload_all_capabilities()
- * - $ACCESS global
  * - has_capability_in_accessdata()
  * - is_siteadmin()
  * - get_user_access_sitewide()
  * - load_subcontext()
  * - get_role_access_bycontext()
  *
- * Name conventions
- * ----------------
+ * <b>Name conventions</b>
  * 
- * - "ctx" means context
+ * "ctx" means context
  *
- * accessdata
- * ----------
+ * <b>accessdata</b>
  *
  * Access control data is held in the "accessdata" array
  * which - for the logged-in user, will be in $USER->access
  * 
- * For other users can be generated and passed around (but see
- * the $ACCESS global).
+ * For other users can be generated and passed around (but may also be cached
+ * against userid in $ACCESSLIB_PRIVATE->accessdatabyuser.
  *
  * $accessdata is a multidimensional array, holding
  * role assignments (RAs), role-capabilities-perm sets 
@@ -84,17 +74,20 @@
  *
  * Things are keyed on "contextpaths" (the path field of 
  * the context table) for fast walking up/down the tree.
- * 
+ * <code>
  * $accessdata[ra][$contextpath]= array($roleid)
  *                [$contextpath]= array($roleid)
  *                [$contextpath]= array($roleid) 
+ * </code>
  *
  * Role definitions are stored like this
  * (no cap merge is done - so it's compact)
  *
+ * <code>
  * $accessdata[rdef][$contextpath:$roleid][mod/forum:viewpost] = 1
  *                                        [mod/forum:editallpost] = -1
  *                                        [mod/forum:startdiscussion] = -1000
+ * </code>
  *
  * See how has_capability_in_accessdata() walks up/down the tree.
  *
@@ -103,22 +96,21 @@
  * keeps accessdata small and compact. Below-the-course ra/rdef
  * are loaded as needed. We keep track of which courses we
  * have loaded ra/rdef in 
- *
+ * <code>
  * $accessdata[loaded] = array($contextpath, $contextpath) 
+ * </code>
  *
- * Stale accessdata
- * ----------------
+ * <b>Stale accessdata</b>
  *
  * For the logged-in user, accessdata is long-lived.
  *
- * On each pageload we load $DIRTYPATHS which lists
+ * On each pageload we load $ACCESSLIB_PRIVATE->dirtycontexts which lists
  * context paths affected by changes. Any check at-or-below
  * a dirty context will trigger a transparent reload of accessdata.
  * 
- * Changes at the sytem level will force the reload for everyone.
+ * Changes at the system level will force the reload for everyone.
  *
- * Default role caps
- * -----------------
+ * <b>Default role caps</b>
  * The default role assignment is not in the DB, so we 
  * add it manually to accessdata. 
  *
@@ -126,333 +118,1595 @@
  * DB need to ensure that the default role caps
  * are dealt with appropriately. 
  *
+ * @package    core
+ * @subpackage role
+ * @copyright  1999 onwards Martin Dougiamas  http://dougiamas.com
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
  */
 
-require_once $CFG->dirroot.'/lib/blocklib.php';
+defined('MOODLE_INTERNAL') || die();
 
-// permission definitions
+/** permission definitions */
 define('CAP_INHERIT', 0);
+/** permission definitions */
 define('CAP_ALLOW', 1);
+/** permission definitions */
 define('CAP_PREVENT', -1);
+/** permission definitions */
 define('CAP_PROHIBIT', -1000);
 
-// context definitions
+/** context definitions */
 define('CONTEXT_SYSTEM', 10);
+/** context definitions */
 define('CONTEXT_USER', 30);
+/** context definitions */
 define('CONTEXT_COURSECAT', 40);
+/** context definitions */
 define('CONTEXT_COURSE', 50);
+/** context definitions */
 define('CONTEXT_MODULE', 70);
+/** context definitions */
 define('CONTEXT_BLOCK', 80);
 
-// capability risks - see http://docs.moodle.org/dev/Hardening_new_Roles_system
+/** capability risks - see {@link http://docs.moodle.org/dev/Hardening_new_Roles_system} */
 define('RISK_MANAGETRUST', 0x0001);
+/** capability risks - see {@link http://docs.moodle.org/dev/Hardening_new_Roles_system} */
 define('RISK_CONFIG',      0x0002);
+/** capability risks - see {@link http://docs.moodle.org/dev/Hardening_new_Roles_system} */
 define('RISK_XSS',         0x0004);
+/** capability risks - see {@link http://docs.moodle.org/dev/Hardening_new_Roles_system} */
 define('RISK_PERSONAL',    0x0008);
+/** capability risks - see {@link http://docs.moodle.org/dev/Hardening_new_Roles_system} */
 define('RISK_SPAM',        0x0010);
+/** capability risks - see {@link http://docs.moodle.org/dev/Hardening_new_Roles_system} */
 define('RISK_DATALOSS',    0x0020);
 
-// rolename displays
-define('ROLENAME_ORIGINAL', 0);// the name as defined in the role definition
-define('ROLENAME_ALIAS', 1);   // the name as defined by a role alias 
-define('ROLENAME_BOTH', 2);    // Both, like this:  Role alias (Original)
+/** rolename displays - the name as defined in the role definition */
+define('ROLENAME_ORIGINAL', 0);
+/** rolename displays - the name as defined by a role alias */
+define('ROLENAME_ALIAS', 1);
+/** rolename displays - Both, like this:  Role alias (Original)*/
+define('ROLENAME_BOTH', 2);
+/** rolename displays - the name as defined in the role definition and the shortname in brackets*/
+define('ROLENAME_ORIGINALANDSHORT', 3);
+/** rolename displays - the name as defined by a role alias, in raw form suitable for editing*/
+define('ROLENAME_ALIAS_RAW', 4);
+/** rolename displays - the name is simply short role name*/
+define('ROLENAME_SHORT', 5);
 
-require_once($CFG->dirroot.'/group/lib.php');
+/**
+ * Internal class provides a cache of context information. The cache is
+ * restricted in size.
+ *
+ * This cache should NOT be used outside accesslib.php!
+ *
+ * @private
+ * @author Sam Marshall
+ */
+class context_cache {
+    private $contextsbyid;
+    private $contexts;
+    private $count;
 
-if (!defined('MAX_CONTEXT_CACHE_SIZE')) { 
-    define('MAX_CONTEXT_CACHE_SIZE', 5000);
-}
+    /**
+     * @var int Maximum number of contexts that will be cached.
+     */
+    const MAX_SIZE = 2500;
+    /**
+     * @var int Once contexts reach maximum number, this many will be removed from cache.
+     */
+    const REDUCE_SIZE = 1000;
 
-$context_cache    = array();    // Cache of all used context objects for performance (by level and instance)
-$context_cache_id = array();    // Index to above cache by id
+    /**
+     * Initialises (empty)
+     */
+    public function __construct() {
+        $this->reset();
+    }
 
-$DIRTYCONTEXTS = null; // dirty contexts cache
-$ACCESS = array(); // cache of caps for cron user switching and has_capability for other users (==not $USER)
-$RDEFS = array(); // role definitions cache - helps a lot with mem usage in cron
+    /**
+     * Resets the cache to remove all data.
+     */
+    public function reset() {
+        $this->contexts     = array();
+        $this->contextsbyid = array();
+        $this->count        = 0;
+    }
 
-/**
- * Adds a context to the cache.
- * @param object $context Context object to be cached
+    /**
+     * Adds a context to the cache. If the cache is full, discards a batch of
+     * older entries.
+     * @param stdClass $context New context to add
  */
-function cache_context($context) {
-    global $context_cache, $context_cache_id;
+    public function add(stdClass $context) {
+        if ($this->count >= self::MAX_SIZE) {
+            for ($i=0; $i<self::REDUCE_SIZE; $i++) {
+                if ($first = reset($this->contextsbyid)) {
+                    unset($this->contextsbyid[$first->id]);
+                    unset($this->contexts[$first->contextlevel][$first->instanceid]);
+                }
+            }
+            $this->count -= self::REDUCE_SIZE;
+            if ($this->count < 0) {
+                // most probably caused by the drift, the reset() above
+                // might have returned false because there might not be any more elements
+                $this->count = 0;
+            }
+        }
+
+        $this->contexts[$context->contextlevel][$context->instanceid] = $context;
+        $this->contextsbyid[$context->id] = $context;
 
-    // If there are too many items in the cache already, remove items until
-    // there is space
-    while (count($context_cache_id) >= MAX_CONTEXT_CACHE_SIZE) {
-        $first = reset($context_cache_id);
-        unset($context_cache_id[$first->id]);
-        unset($context_cache[$first->contextlevel][$first->instanceid]);
+        // Note the count may get out of synch slightly if you cache a context
+        // that is already cached, but it doesn't really matter much and I
+        // didn't think it was worth the performance hit.
+        $this->count++;
     }
 
-    // Add this context to the cache
-    $context_cache_id[$context->id] = $context;
-    $context_cache[$context->contextlevel][$context->instanceid] = $context;
-}
+    /**
+     * Removes a context from the cache.
+     * @param stdClass $context Context object to remove (must include fields
+     *   ->id, ->contextlevel, ->instanceid at least)
+     */
+    public function remove(stdClass $context) {
+        unset($this->contexts[$context->contextlevel][$context->instanceid]);
+        unset($this->contextsbyid[$context->id]);
 
-function get_role_context_caps($roleid, $context) {
-    //this is really slow!!!! - do not use above course context level!
-    $result = array();
-    $result[$context->id] = array();
+        // Again the count may get a bit out of synch if you remove things
+        // that don't exist
+        $this->count--;
 
-    // first emulate the parent context capabilities merging into context
-    $searchcontexts = array_reverse(get_parent_contexts($context));
-    array_push($searchcontexts, $context->id);
-    foreach ($searchcontexts as $cid) {
-        if ($capabilities = get_records_select('role_capabilities', "roleid = $roleid AND contextid = $cid")) {
-            foreach ($capabilities as $cap) {
-                if (!array_key_exists($cap->capability, $result[$context->id])) {
-                    $result[$context->id][$cap->capability] = 0;
-                }
-                $result[$context->id][$cap->capability] += $cap->permission;
-            }
+        if ($this->count < 0) {
+            $this->count = 0;
         }
     }
 
-    // now go through the contexts bellow given context
-    $searchcontexts = array_keys(get_child_contexts($context));
-    foreach ($searchcontexts as $cid) {
-        if ($capabilities = get_records_select('role_capabilities', "roleid = $roleid AND contextid = $cid")) {
-            foreach ($capabilities as $cap) {
-                if (!array_key_exists($cap->contextid, $result)) {
-                    $result[$cap->contextid] = array();
+    /**
+     * Gets a context from the cache.
+     * @param int $contextlevel Context level
+     * @param int $instance Instance ID
+     * @return stdClass|bool Context or false if not in cache
+     */
+    public function get($contextlevel, $instance) {
+        if (isset($this->contexts[$contextlevel][$instance])) {
+            return $this->contexts[$contextlevel][$instance];
                 }
-                $result[$cap->contextid][$cap->capability] = $cap->permission;
+        return false;
             }
+
+    /**
+     * Gets a context from the cache based on its id.
+     * @param int $id Context ID
+     * @return stdClass|bool Context or false if not in cache
+     */
+    public function get_by_id($id) {
+        if (isset($this->contextsbyid[$id])) {
+            return $this->contextsbyid[$id];
         }
+        return false;
     }
 
-    return $result;
+    /**
+     * @return int Count of contexts in cache (approximately)
+     */
+    public function get_approx_count() {
+        return $this->count;
+    }
 }
 
 /**
- * Gets the accessdata for role "sitewide" 
- * (system down to course)
+ * Although this looks like a global variable, it isn't really.
  *
- * @return array
+ * It is just a private implementation detail to accesslib that MUST NOT be used elsewhere.
+ * It is used to cache various bits of data between function calls for performance reasons.
+ * Sadly, a PHP global variable is the only way to implement this, without rewriting everything
+ * as methods of a class, instead of functions.
+ *
+ * @global stdClass $ACCESSLIB_PRIVATE
+ * @name $ACCESSLIB_PRIVATE
  */
-function get_role_access($roleid, $accessdata=NULL) {
+global $ACCESSLIB_PRIVATE;
+$ACCESSLIB_PRIVATE = new stdClass();
+$ACCESSLIB_PRIVATE->contexcache      = new context_cache();
+$ACCESSLIB_PRIVATE->systemcontext    = null; // Used in get_system_context
+$ACCESSLIB_PRIVATE->dirtycontexts    = null; // Dirty contexts cache
+$ACCESSLIB_PRIVATE->accessdatabyuser = array(); // Holds the $accessdata structure for users other than $USER
+$ACCESSLIB_PRIVATE->roledefinitions  = array(); // role definitions cache - helps a lot with mem usage in cron
+$ACCESSLIB_PRIVATE->croncache        = array(); // Used in get_role_access
+$ACCESSLIB_PRIVATE->preloadedcourses = array(); // Used in preload_course_contexts.
+$ACCESSLIB_PRIVATE->capabilities     = null; // detailed information about the capabilities
 
-    global $CFG;
+/**
+ * Abstract class for context levels.  The context level classes encapsulate
+ * context level-specific logic.
+ */
+abstract class context_level_base {
+    /**
+     * The numeric value for the context level.  Used by cleanup_contexts_sql.
+     */
+    protected $level;
 
-    /* Get it in 1 cheap DB query...
-     * - relevant role caps at the root and down
-     *   to the course level - but not below
+    /**
+     * Primary table used for the data records represented by this context
+     * level, or null if there is no table.  Used by cleanup_contexts_sql.
      */
-    if (is_null($accessdata)) {
-        $accessdata           = array(); // named list
-        $accessdata['ra']     = array();
-        $accessdata['rdef']   = array();
-        $accessdata['loaded'] = array();
+    protected $table = null;
+
+    private static $allcontextlevels;
+
+    /**
+     * Returns an array of all the context levels defined in the system.
+     *
+     * @return array
+     */
+    static function get_all_context_levels() {
+        if (!isset(context_level_base::$allcontextlevels)) {
+            context_level_base::$allcontextlevels =
+                array(
+                    CONTEXT_SYSTEM      => new context_level_system(),
+                    CONTEXT_USER        => new context_level_user(),
+                    CONTEXT_COURSECAT   => new context_level_coursecat(),
+                    CONTEXT_COURSE      => new context_level_course(),
+                    CONTEXT_MODULE      => new context_level_module(),
+                    CONTEXT_BLOCK       => new context_level_block(),
+                    );
+
+            // find all the components that have defined context levels
+            context_level_base::load_custom_context_levels();
+            $components = context_level_base::$customctxlevels;
+            if ($components === null) {
+                $components = array();
+            }
+            foreach (array_keys($components) as $component) {
+                $contextlevels = array();
+                $accessfile = get_component_directory($component).'/db/access.php';
+                if (file_exists($accessfile)) {
+                    include($accessfile);
+                    foreach ($contextlevels as $name=>$object) {
+                        $contextlevel = context_level_base::get_custom_context_level($name, $component);
+                        context_level_base::$allcontextlevels[$contextlevel] = $object;
+                        $object->level = $contextlevel;
+                    }
+                }
+            }
     }
 
-    //
-    // Overrides for the role IN ANY CONTEXTS
-    // down to COURSE - not below -
-    //
-    $sql = "SELECT ctx.path,
-                   rc.capability, rc.permission
-            FROM {$CFG->prefix}context ctx
-            JOIN {$CFG->prefix}role_capabilities rc
-              ON rc.contextid=ctx.id
-            WHERE rc.roleid = {$roleid}
-                  AND ctx.contextlevel <= ".CONTEXT_COURSE."
-            ORDER BY ctx.depth, ctx.path";
+        return context_level_base::$allcontextlevels;
+    }
+
+    /**
+     * Returns the context level object for the specified context level.
+     *
+     * @param int $level
+     * @return mixed
+     */
+    static function get_context_level($level) {
+        // make sure $all_context_levels is loaded
+        context_level_base::get_all_context_levels();
 
-    // we need extra caching in cron only
-    if (defined('FULLME') and FULLME === 'cron') {
-        static $cron_cache = array();
+        if (is_object($level)) {
+            // if $level is a context object
+            $level = $level->contextlevel;
+        }
 
-        if (!isset($cron_cache[$roleid])) {
-            $cron_cache[$roleid] = array();
-            if ($rs = get_recordset_sql($sql)) {
-                while ($rd = rs_fetch_next_record($rs)) {
-                    $cron_cache[$roleid][] = $rd;
+        return context_level_base::$allcontextlevels[$level];
                 }
-                rs_close($rs);
+
+    /**
+     * Determines whether the specified context level is a valid level.
+     *
+     * @param int $level
+     * @return bool
+     */
+    static function context_level_exists($level) {
+        // make sure $all_context_levels is loaded
+        context_level_base::get_all_context_levels();
+
+        if (is_object($level)) {
+            // if $level is a context object
+            $level = $level->contextlevel;
             }
+
+        return isset(context_level_base::$allcontextlevels[$level]);
         }
 
-        foreach ($cron_cache[$roleid] as $rd) {
-            $k = "{$rd->path}:{$roleid}";
-            $accessdata['rdef'][$k][$rd->capability] = $rd->permission;
+    private static $customctxlevels = null;
+
+    private static function load_custom_context_levels() {
+        global $DB;
+        if (context_level_base::$customctxlevels === null) {
+            if (!$DB->get_manager()->table_exists('context_levels') ||
+                !($ctxlevel = $DB->get_records('context_levels'))) {
+                return;
+            }
+            context_level_base::$customctxlevels = array();
+            foreach($ctxlevel as $rec) {
+                context_level_base::$customctxlevels[$rec->component][$rec->name] = $rec->id + 1000;
+            }
+        }
         }
         
-    } else {
-        if ($rs = get_recordset_sql($sql)) {
-            while ($rd = rs_fetch_next_record($rs)) {
-                $k = "{$rd->path}:{$roleid}";
-                $accessdata['rdef'][$k][$rd->capability] = $rd->permission;
+    static function get_custom_context_level($name, $component) {
+        context_level_base::load_custom_context_levels();
+
+        if (!isset(context_level_base::$customctxlevels[$component])
+            || !isset(context_level_base::$customctxlevels[$component][$name])) {
+            return null;
             }
-            unset($rd);
-            rs_close($rs);
+        return context_level_base::$customctxlevels[$component][$name];
         }
+
+    static function clear_custom_context_level_cache() {
+        context_level_base::$customctxlevels = null;
+        context_level_base::$allcontextlevels = null;
     }
 
-    return $accessdata;
-}
+    /**
+     * @return string the name for this type of context.
+     */
+    abstract public function get_contextlevel_name();
 
-/**
- * Gets the accessdata for role "sitewide" 
- * (system down to course)
+    /**
+     * Retrieves information for an instance necessary for creating a new
+     * context instance.  (Used by create_context.)
+     *
+     * @param int $instanceid
+     *
+     * @return array (boolean instance OK, string base path, int base depth,
+     * string error message)
+     */
+    abstract public function get_context_info($instanceid, $strictness);
+
+    /**
+     * Prints human readable context identifier.
+     *
+     * @param object $context the context.
+     * @param boolean $withprefix whether to prefix the name of the context with the
+     *      type of context, e.g. User, Course, Forum, etc.
+     * @param boolean $short whether to user the short name of the thing. Only applies
+     *      to course contexts
+     * @return string the human readable context name.
+     */
+    abstract public function print_context_name($context, $withprefix = true, $short = false);
+
+    /**
+     * Get a URL for a context, if there is a natural one. For example, for
+     * CONTEXT_COURSE, this is the course page. For CONTEXT_USER it is the
+     * user profile page.
+     *
+     * @param object $context the context.
+     * @return moodle_url
+     */
+    abstract public function get_context_url($context);
+
+    /**
+     * Extracts the relevant capabilities given a contextid.
+     * All case based, example an instance of forum context.
+     * Will fetch all forum related capabilities, while course contexts
+     * Will fetch all capabilities
+     * @param object context
+     * @return array();
+     *
+     *  capabilities
+     * `name` varchar(150) NOT NULL,
+     * `captype` varchar(50) NOT NULL,
+     * `contextlevel` int(10) NOT NULL,
+     * `component` varchar(100) NOT NULL,
  *
+     * @global object
+     * @param object context
  * @return array
  */
-function get_default_frontpage_role_access($roleid, $accessdata=NULL) {
+    public function fetch_context_capabilities($context) {
+        global $DB;
 
-    global $CFG;
+        $sort = 'ORDER BY contextlevel,component,name';    // To group them sensibly for display
     
-    $frontpagecontext = get_context_instance(CONTEXT_COURSE, SITEID);
-    $base = '/'. SYSCONTEXTID .'/'. $frontpagecontext->id;
+        list($SQL, $params) = $this->fetch_context_capabilities_sql($context);
  
-    //
-    // Overrides for the role in any contexts related to the course
-    //
-    $sql = "SELECT ctx.path,
-                   rc.capability, rc.permission
-            FROM {$CFG->prefix}context ctx
-            JOIN {$CFG->prefix}role_capabilities rc
-              ON rc.contextid=ctx.id
-            WHERE rc.roleid = {$roleid}
-                  AND (ctx.id = ".SYSCONTEXTID." OR ctx.path LIKE '$base/%')
-                  AND ctx.contextlevel <= ".CONTEXT_COURSE."
-            ORDER BY ctx.depth, ctx.path";             
+        if (!$records = $DB->get_records_sql($SQL.' '.$sort, $params)) {
+            $records = array();
+        }
             
-    if ($rs = get_recordset_sql($sql)) {
-        while ($rd = rs_fetch_next_record($rs)) {
-            $k = "{$rd->path}:{$roleid}";
-            $accessdata['rdef'][$k][$rd->capability] = $rd->permission;
+        return $records;
         }
-        unset($rd);
-        rs_close($rs);
+
+    /**
+     * sql for the removal of stale contexts
+     *
+     * @return string
+     */
+    public function cleanup_contexts_sql() {
+        global $CFG;
+
+        if (empty($this->table)) {
+            return null;
     }
 
-    return $accessdata;
-}
+        $sql = " SELECT c.contextlevel,
+                        c.instanceid
+                 FROM {context} c
+                 LEFT OUTER JOIN {{$this->table}} t
+                   ON c.instanceid = t.id
+                 WHERE t.id IS NULL AND c.contextlevel = {$this->level}";
 
+        return $sql;
+    }
 
-/**
- * Get the default guest role
- * @return object role
+    /**
+     * returns sql string needed for fetch context capabilities
+     *
+     * @param object $context
+     * @return array - $sql and $params
  */
-function get_guest_role() {
-    global $CFG;
+    abstract protected function fetch_context_capabilities_sql($context);
 
-    if (empty($CFG->guestroleid)) {
-        if ($roles = get_roles_with_capability('moodle/legacy:guest', CAP_ALLOW)) {
-            $guestrole = array_shift($roles);   // Pick the first one
-            set_config('guestroleid', $guestrole->id);
-            return $guestrole;
+    /**
+     * Recursive function which, given a context, finds all its children context ids.
+     *
+     * When called for a course context, it will return the modules and blocks
+     * displayed in the course page.
+     *
+     * For course category contexts it will return categories and courses. It will
+     * NOT recurse into courses - if you want to do that, call it on the returned
+     * courses.
+     *
+     * If called on a course context it _will_ populate the cache with the appropriate
+     * contexts ;-)
+     *
+     * @param object $context.
+     * @return array of child records
+     */
+    abstract public function get_child_contexts($context);
+
+    /**
+     * Populate context.path and context.depth where missing.
+     *
+     * @param string $base base path for top-level context
+     * @param string $emptyclause clause to filter out the records that should
+     * not be updated.  $a in the string should be replaced by the table name
+     * or alias for the context table.
+     */
+    abstract public function build_context_path($base, $emptyclause);
+
+    /**
+     * Flush the contents of the context_temp table to the context table, and
+     * reset context_temp to empty.
+     */
+    static protected function flush_context_temp() {
+        global $DB;
+
+        static $updatesql;
+
+        if (!isset($updatesql)) {
+            /* MDL-11347:
+             *  - mysql does not allow to use FROM in UPDATE statements
+             *  - using two tables after UPDATE works in mysql, but might give unexpected
+             *    results in pg 8 (depends on configuration)
+             *  - using table alias in UPDATE does not work in pg < 8.2
+             *
+             * Different code for each database - mostly for performance reasons
+             */
+            $dbfamily = $DB->get_dbfamily();
+            if ($dbfamily == 'mysql') {
+                $updatesql = "UPDATE {context} ct, {context_temp} temp
+                                 SET ct.path  = temp.path,
+                                     ct.depth = temp.depth
+                               WHERE ct.id = temp.id";
+            } else if ($dbfamily == 'oracle') {
+                $updatesql = "UPDATE {context} ct
+                                 SET (ct.path, ct.depth) =
+                                     (SELECT temp.path, temp.depth
+                                        FROM {context_temp} temp
+                                       WHERE temp.id=ct.id)
+                               WHERE EXISTS (SELECT 'x'
+                                             FROM {context_temp} temp
+                                             WHERE temp.id = ct.id)";
+            } else if ($dbfamily == 'postgres' or $dbfamily == 'mssql') {
+                $updatesql = "UPDATE {context}
+                                 SET path  = temp.path,
+                                     depth = temp.depth
+                                FROM {context_temp} temp
+                               WHERE temp.id={context}.id";
         } else {
-            debugging('Can not find any guest role!');
-            return false;
+                // sqlite and others
+                $updatesql = "UPDATE {context}
+                                 SET path  = (SELECT path FROM {context_temp} WHERE id = {context}.id),
+                                     depth = (SELECT depth FROM {context_temp} WHERE id = {context}.id)
+                               WHERE id IN (SELECT id FROM {context_temp})";
         }
-    } else {
-        if ($guestrole = get_record('role','id', $CFG->guestroleid)) {
-            return $guestrole;
-        } else {
-            //somebody is messing with guest roles, remove incorrect setting and try to find a new one
-            set_config('guestroleid', '');
-            return get_guest_role();
         }
+
+        $DB->execute($updatesql);
+        $DB->delete_records('context_temp');
     }
 }
 
 /**
- * This function returns whether the current user has the capability of performing a function
- * For example, we can do has_capability('mod/forum:replypost',$context) in forum
- * @param string $capability - name of the capability (or debugcache or clearcache)
- * @param object $context - a context object (record from context table)
- * @param integer $userid - a userid number, empty if current $USER
- * @param bool $doanything - if false, ignore do anything
- * @return bool
+ * Class representing the system context level.
  */
-function has_capability($capability, $context, $userid=NULL, $doanything=true) {
-    global $USER, $ACCESS, $CFG, $DIRTYCONTEXTS;
-
-    // the original $CONTEXT here was hiding serious errors
-    // for security reasons do not reuse previous context
-    if (empty($context)) {
-        debugging('Incorrect context specified');
-        return false;
+class context_level_system extends context_level_base {
+    public function get_context_info($instanceid, $strictness) {
+        return array(false, '', 1, ''); // this should never be called
     }
 
-/// Some sanity checks
-    if (debugging('',DEBUG_DEVELOPER)) {
-        if (!is_valid_capability($capability)) {
-            debugging('Capability "'.$capability.'" was not found! This should be fixed in code.');
-        }
-        if (!is_bool($doanything)) {
-            debugging('Capability parameter "doanything" is wierd ("'.$doanything.'"). This should be fixed in code.');
+    public function get_contextlevel_name() {
+        return get_string('coresystem');
         }
+
+    public function print_context_name($context, $withprefix = true, $short = false) {
+        return get_string('coresystem');
     }
 
-    if (empty($userid)) { // we must accept null, 0, '0', '' etc. in $userid
-        $userid = $USER->id;
+    public function get_context_url($context) {
+        return null;
     }
 
-    if (is_null($context->path) or $context->depth == 0) {
-        //this should not happen
-        $contexts = array(SYSCONTEXTID, $context->id);
-        $context->path = '/'.SYSCONTEXTID.'/'.$context->id;
-        debugging('Context id '.$context->id.' does not have valid path, please use build_context_path()', DEBUG_DEVELOPER);
+    public function fetch_context_capabilities_sql($context) {
+        $SQL = "SELECT *
+                  FROM {capabilities}";
 
-    } else {
-        $contexts = explode('/', $context->path);
-        array_shift($contexts);
+        return array($SQL, array());
     }
 
-    if (defined('FULLME') && FULLME === 'cron' && !isset($USER->access)) {
-        // In cron, some modules setup a 'fake' $USER,
-        // ensure we load the appropriate accessdata.
-        if (isset($ACCESS[$userid])) {
-            $DIRTYCONTEXTS = NULL; //load fresh dirty contexts
-        } else {
-            load_user_accessdata($userid);
-            $DIRTYCONTEXTS = array();
-        }
-        $USER->access = $ACCESS[$userid];
+    public function get_child_contexts($context) {
+        global $DB;
 
-    } else if ($USER->id == $userid && !isset($USER->access)) {
-        // caps not loaded yet - better to load them to keep BC with 1.8
-        // not-logged-in user or $USER object set up manually first time here
-        load_all_capabilities();
-        $ACCESS = array(); // reset the cache for other users too, the dirty contexts are empty now
-        $RDEFS = array();
+        $array = array();
+
+        // Just get all the contexts except for CONTEXT_SYSTEM level
+        // and hope we don't OOM in the process - don't cache
+        $sql = "SELECT c.*
+                  FROM {context} c
+                 WHERE contextlevel != ".CONTEXT_SYSTEM;
+
+        $records = $DB->get_records_sql($sql);
+        foreach ($records as $rec) {
+            $array[$rec->id] = $rec;
+        }
+        return $array;
+    }
+
+    public function build_context_path($base, $emptyclause) {
+        global $DB;
+
+        // Sitecourse
+        $sitecoursectx = $DB->get_record('context', array('contextlevel'=>CONTEXT_COURSE, 'instanceid'=>SITEID));
+        if (!$emptyclause || $sitecoursectx->path !== "$base/{$sitecoursectx->id}") {
+            $DB->set_field('context', 'path',  "$base/{$sitecoursectx->id}", array('id'=>$sitecoursectx->id));
+            $DB->set_field('context', 'depth', 2, array('id'=>$sitecoursectx->id));
+            $sitecoursectx = $DB->get_record('context', array('contextlevel'=>CONTEXT_COURSE, 'instanceid'=>SITEID));
+        }
+    }
+}
+
+/**
+ * Class representing the user context level.
+ */
+class context_level_user extends context_level_base {
+    protected $level = CONTEXT_USER;
+    protected $table = 'user';
+
+    public function get_context_info($instanceid, $strictness) {
+        $basepath  = '/' . SYSCONTEXTID;
+        $basedepth = 1;
+        $result = true;
+        $error_message = null;
+
+        return array($result, $basepath, $basedepth, $error_message);
+    }
+
+    public function get_contextlevel_name() {
+        return get_string('user');
+    }
+
+    public function print_context_name($context, $withprefix = true, $short = false) {
+        global $DB;
+
+        $name = '';
+        $user = $DB->get_record('user', array('id'=>$context->instanceid));
+
+        if (!empty($user)) {
+            if ($withprefix){
+                $name = get_string('user').': ';
+            }
+            $name .= fullname($user);
+        }
+
+        return $name;
+    }
+
+    public function get_context_url($context) {
+        global $CFG, $COURSE;
+
+        if ($COURSE->id == SITEID) {
+            $url = new moodle_url('/user/profile.php', array('id'=>$context->instanceid));
+        } else {
+            $url = new moodle_url('/user/view.php', array('id'=>$context->instanceid, 'courseid'=>$COURSE->id));
+        }
+        return $url;
+    }
+
+    public function fetch_context_capabilities_sql($context) {
+        global $DB;
+
+        $extracaps = array('moodle/grade:viewall');
+        list($extra, $params) = $DB->get_in_or_equal($extracaps, SQL_PARAMS_NAMED, 'cap');
+        $SQL = "SELECT *
+                  FROM {capabilities}
+                 WHERE contextlevel = ".CONTEXT_USER."
+                       OR name $extra";
+
+        return array($SQL, $params);
+    }
+
+    public function get_child_contexts($context) {
+        global $DB, $ACCESSLIB_PRIVATE;
+
+        $array = array();
+        $cache = $ACCESSLIB_PRIVATE->contexcache;
+
+        // Find
+        // - blocks under this context path.
+        $sql = " SELECT ctx.*
+                       FROM {context} ctx
+                      WHERE ctx.path LIKE ?
+                            AND ctx.contextlevel = ".CONTEXT_BLOCK;
+        $params = array("{$context->path}/%", $context->instanceid);
+        $records = $DB->get_recordset_sql($sql, $params);
+        foreach ($records as $rec) {
+            $cache->add($rec);
+            $array[$rec->id] = $rec;
+        }
+        return $array;
+    }
+
+    public function build_context_path($base, $emptyclause) {
+        global $DB;
+
+        $a = '{context}';
+        eval('$emptyclause = "'.$emptyclause.'";');
+
+        // User
+        $sql = "UPDATE {context}
+                   SET depth=2, path=".$DB->sql_concat("'$base/'", 'id')."
+                 WHERE contextlevel=".CONTEXT_USER."
+                       AND EXISTS (SELECT 'x'
+                                     FROM {user} u
+                                    WHERE u.id = {context}.instanceid)
+                       $emptyclause ";
+        $DB->execute($sql);
+    }
+}
+
+/**
+ * Class representing the course category context level.
+ */
+class context_level_coursecat extends context_level_base {
+    protected $level = CONTEXT_COURSECAT;
+    protected $table = 'course_categories';
+
+    public function get_context_info($instanceid, $strictness) {
+        global $DB;
+
+        $basepath  = '/' . SYSCONTEXTID;
+        $basedepth = 1;
+        $result = true;
+        $error_message = null;
+
+        $sql = "SELECT ctx.path, ctx.depth
+                  FROM {context}           ctx
+                  JOIN {course_categories} cc
+                       ON (cc.parent=ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSECAT.")
+                 WHERE cc.id=?";
+        $params = array($instanceid);
+        if ($p = $DB->get_record_sql($sql, $params)) {
+            $basepath  = $p->path;
+            $basedepth = $p->depth;
+        } else if ($category = $DB->get_record('course_categories', array('id'=>$instanceid), '*', $strictness)) {
+            if (empty($category->parent)) {
+                // ok - this is a top category
+            } else if ($parent = get_context_instance(CONTEXT_COURSECAT, $category->parent)) {
+                $basepath  = $parent->path;
+                $basedepth = $parent->depth;
+            } else {
+                // wrong parent category - no big deal, this can be fixed later
+                $basepath  = null;
+                $basedepth = 0;
+            }
+        } else {
+            // incorrect category id
+            $error_message = "incorrect course category id ($instanceid)";
+            $result = false;
+        }
+
+        return array($result, $basepath, $basedepth, $error_message);
+    }
+
+    public function get_contextlevel_name() {
+        return get_string('category');
+    }
+
+    public function print_context_name($context, $withprefix = true, $short = false) {
+        global $DB;
+
+        $name = '';
+
+        if ($category = $DB->get_record('course_categories', array('id'=>$context->instanceid))) {
+            if ($withprefix){
+                $name = get_string('category').': ';
+            }
+            $name .= format_string($category->name, true, array('context' => $context));
+        }
+
+        return $name;
+    }
+
+    public function get_context_url($context) {
+        global $CFG;
+
+        return new moodle_url('/course/category.php', array('id'=>$context->instanceid));
+    }
+
+    public function fetch_context_capabilities_sql($context) {
+        $SQL = "SELECT *
+                  FROM {capabilities}
+                 WHERE contextlevel IN (".CONTEXT_COURSECAT.",".CONTEXT_COURSE.",".CONTEXT_MODULE.",".CONTEXT_BLOCK.")";
+
+        return array($SQL, array());
+    }
+
+    public function get_child_contexts($context) {
+        global $DB, $ACCESSLIB_PRIVATE;
+
+        $array = array();
+        $cache = $ACCESSLIB_PRIVATE->contexcache;
+
+        // Find
+        // - categories
+        // - courses
+        $sql = " SELECT ctx.*
+                       FROM {context} ctx
+                      WHERE ctx.path LIKE ?
+                            AND ctx.contextlevel IN (".CONTEXT_COURSECAT.",".CONTEXT_COURSE.")";
+        $params = array("{$context->path}/%");
+        $records = $DB->get_recordset_sql($sql, $params);
+        foreach ($records as $rec) {
+            $cache->add($rec);
+            $array[$rec->id] = $rec;
+        }
+        return $array;
+    }
+
+    public function build_context_path($base, $emptyclause) {
+        global $DB;
+
+        $a = 'ctx';
+        eval('$ctxemptyclause = "'.$emptyclause.'";');
+        $a = '{context}';
+        eval('$emptyclause = "'.$emptyclause.'";');
+
+        // Top level categories
+        $sql = "UPDATE {context}
+                   SET depth=2, path=" . $DB->sql_concat("'$base/'", 'id') . "
+                 WHERE contextlevel=".CONTEXT_COURSECAT."
+                       AND EXISTS (SELECT 'x'
+                                     FROM {course_categories} cc
+                                    WHERE cc.id = {context}.instanceid
+                                          AND cc.depth=1)
+                       $emptyclause";
+
+        $DB->execute($sql);
+
+        // Deeper categories - one query per depthlevel
+        $maxdepth = $DB->get_field_sql("SELECT MAX(depth)
+                                          FROM {course_categories}");
+        for ($n=2;$n<=$maxdepth;$n++) {
+            $sql = "INSERT INTO {context_temp} (id, path, depth)
+                    SELECT ctx.id, ".$DB->sql_concat('pctx.path', "'/'", 'ctx.id').", $n+1
+                      FROM {context} ctx
+                      JOIN {course_categories} c ON ctx.instanceid=c.id
+                      JOIN {context} pctx ON c.parent=pctx.instanceid
+                     WHERE ctx.contextlevel=".CONTEXT_COURSECAT."
+                           AND pctx.contextlevel=".CONTEXT_COURSECAT."
+                           AND c.depth=$n
+                           AND NOT EXISTS (SELECT 'x'
+                                           FROM {context_temp} temp
+                                           WHERE temp.id = ctx.id)
+                           $ctxemptyclause";
+            $DB->execute($sql);
+
+            // this is needed after every loop
+            // MDL-11532
+            context_level_base::flush_context_temp();
+        }
+
+    }
+}
+
+/**
+ * Class representing the course context level.
+ */
+class context_level_course extends context_level_base {
+    protected $level = CONTEXT_COURSE;
+    protected $table = 'course';
+
+    public function get_context_info($instanceid, $strictness) {
+        global $DB;
+
+        $basepath  = '/' . SYSCONTEXTID;
+        $basedepth = 1;
+        $result = true;
+        $error_message = null;
+
+        $sql = "SELECT ctx.path, ctx.depth
+                  FROM {context} ctx
+                  JOIN {course}  c
+                       ON (c.category=ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSECAT.")
+                 WHERE c.id=? AND c.id !=" . SITEID;
+        $params = array($instanceid);
+        if ($p = $DB->get_record_sql($sql, $params, '*', $strictness)) {
+            $basepath  = $p->path;
+            $basedepth = $p->depth;
+        } else if ($course = $DB->get_record('course', array('id'=>$instanceid))) {
+            if ($course->id == SITEID) {
+                //ok - no parent category
+            } else if ($parent = get_context_instance(CONTEXT_COURSECAT, $course->category)) {
+                $basepath  = $parent->path;
+                $basedepth = $parent->depth;
+            } else {
+                // wrong parent category of course - no big deal, this can be fixed later
+                $basepath  = null;
+                $basedepth = 0;
+            }
+        } else if ($instanceid == SITEID) {
+            // no errors for missing site course during installation
+            return false;
+        } else {
+            // incorrect course id
+            $error_message = "incorrect course id ($instanceid)";
+            $result = false;
+        }
+
+        return array($result, $basepath, $basedepth, $error_message);
+    }
+
+    public function get_contextlevel_name() {
+        return get_string('course');
+    }
+
+    public function print_context_name($context, $withprefix = true, $short = false) {
+        if ($context->instanceid == SITEID) {
+            $name = get_string('frontpage', 'admin');
+        } else {
+            global $DB;
+            if ($course = $DB->get_record('course', array('id'=>$context->instanceid))) {
+                $name = '';
+
+                if ($withprefix){
+                    $name .= get_string('course').': ';
+                }
+
+                if ($short){
+                    $name .= format_string($course->shortname, true, array('context' => $context));
+                } else {
+                    $name .= format_string($course->fullname);
+                }
+            }
+        }
+
+        return $name;
+    }
+
+    public function get_context_url($context) {
+        global $CFG;
+
+        if ($context->instanceid != SITEID) {
+            return new moodle_url('/course/view.php', array('id'=>$context->instanceid));
+        }
+        return null;
+    }
+
+    public function fetch_context_capabilities_sql($context) {
+        $SQL = "SELECT *
+                  FROM {capabilities}
+                 WHERE contextlevel IN (".CONTEXT_COURSE.",".CONTEXT_MODULE.",".CONTEXT_BLOCK.")";
+
+        return array($SQL, array());
+    }
+
+    public function get_child_contexts($context) {
+        global $DB, $ACCESSLIB_PRIVATE;
+
+        $array = array();
+        $cache = $ACCESSLIB_PRIVATE->contexcache;
+
+        // Find
+        // - modules and blocks under this context path.
+        $sql = " SELECT ctx.*
+                   FROM {context} ctx
+                  WHERE ctx.path LIKE ?
+                        AND ctx.contextlevel IN (".CONTEXT_MODULE.",".CONTEXT_BLOCK.")";
+        $params = array("{$context->path}/%", $context->instanceid);
+        $records = $DB->get_recordset_sql($sql, $params);
+        foreach ($records as $rec) {
+            $cache->add($rec);
+            $array[$rec->id] = $rec;
+        }
+        return $array;
+    }
+
+    public function build_context_path($base, $emptyclause) {
+        global $DB;
+
+        $a = 'ctx';
+        eval('$ctxemptyclause = "'.$emptyclause.'";');
+
+        // Courses -- except sitecourse
+        $sql = "INSERT INTO {context_temp} (id, path, depth)
+                SELECT ctx.id, ".$DB->sql_concat('pctx.path', "'/'", 'ctx.id').", pctx.depth+1
+                  FROM {context} ctx
+                  JOIN {course} c ON ctx.instanceid=c.id
+                  JOIN {context} pctx ON c.category=pctx.instanceid
+                 WHERE ctx.contextlevel=".CONTEXT_COURSE."
+                       AND c.id!=".SITEID."
+                       AND pctx.contextlevel=".CONTEXT_COURSECAT."
+                           AND NOT EXISTS (SELECT 'x'
+                                           FROM {context_temp} temp
+                                           WHERE temp.id = ctx.id)
+                       $ctxemptyclause";
+        $DB->execute($sql);
+
+        context_level_base::flush_context_temp();
+    }
+}
+
+/**
+ * Class representing the module context level.
+ */
+class context_level_module extends context_level_base {
+    protected $level = CONTEXT_MODULE;
+    protected $table = 'course_modules';
+
+    public function get_context_info($instanceid, $strictness) {
+        global $DB;
+
+        $basepath  = '/' . SYSCONTEXTID;
+        $basedepth = 1;
+        $result = true;
+        $error_message = null;
+
+        $sql = "SELECT ctx.path, ctx.depth
+                  FROM {context}        ctx
+                  JOIN {course_modules} cm
+                       ON (cm.course=ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSE.")
+                 WHERE cm.id=?";
+        $params = array($instanceid);
+        if ($p = $DB->get_record_sql($sql, $params)) {
+            $basepath  = $p->path;
+            $basedepth = $p->depth;
+        } else if ($cm = $DB->get_record('course_modules', array('id'=>$instanceid), '*', $strictness)) {
+            if ($parent = get_context_instance(CONTEXT_COURSE, $cm->course, $strictness)) {
+                $basepath  = $parent->path;
+                $basedepth = $parent->depth;
+            } else {
+                // course does not exist - modules can not exist without a course
+                $error_message = "course does not exist ($cm->course) - modules can not exist without a course";
+                $result = false;
+            }
+        } else {
+            // cm does not exist
+            $error_message = "cm with id $instanceid does not exist";
+            $result = false;
+        }
+
+        return array($result, $basepath, $basedepth, $error_message);
+    }
+
+    public function get_contextlevel_name() {
+        return get_string('activitymodule');
+    }
+
+    public function print_context_name($context, $withprefix = true, $short = false) {
+        global $DB;
+
+        $name = '';
+
+        if ($cm = $DB->get_record_sql('SELECT cm.*, md.name AS modname FROM {course_modules} cm ' .
+                'JOIN {modules} md ON md.id = cm.module WHERE cm.id = ?', array($context->instanceid))) {
+            if ($mod = $DB->get_record($cm->modname, array('id' => $cm->instance))) {
+                if ($withprefix){
+                    $name = get_string('activitymodule').': ';
+                }
+                $name .= $mod->name;
+            }
+        }
+
+        return $name;
+    }
+
+    public function get_context_url($context) {
+        global $CFG, $DB;
+
+        if ($modname = $DB->get_field_sql('SELECT md.name AS modname FROM {course_modules} cm ' .
+                'JOIN {modules} md ON md.id = cm.module WHERE cm.id = ?', array($context->instanceid))) {
+            return new moodle_url('/mod/' . $modname . '/view.php', array('id'=>$context->instanceid));
+        }
+        return null;
+    }
+
+    public function fetch_context_capabilities_sql($context) {
+        global $CFG, $DB;
+
+        $cm = $DB->get_record('course_modules', array('id'=>$context->instanceid));
+        $module = $DB->get_record('modules', array('id'=>$cm->module));
+
+            $subcaps = array();
+            $subpluginsfile = "$CFG->dirroot/mod/$module->name/db/subplugins.php";
+            if (file_exists($subpluginsfile)) {
+                $subplugins = array();  // should be redefined in the file
+                include($subpluginsfile);
+                if (!empty($subplugins)) {
+                    foreach (array_keys($subplugins) as $subplugintype) {
+                        foreach (array_keys(get_plugin_list($subplugintype)) as $subpluginname) {
+                            $subcaps = array_merge($subcaps, array_keys(load_capability_def($subplugintype.'_'.$subpluginname)));
+                        }
+                    }
+                }
+            }
+
+        $modfile = "$CFG->dirroot/mod/$module->name/lib.php";
+        if (file_exists($modfile)) {
+            include_once($modfile);
+            $modfunction = $module->name.'_get_extra_capabilities';
+            if (function_exists($modfunction)) {
+                $extracaps = $modfunction();
+            }
+        }
+        if (empty($extracaps)) {
+            $extracaps = array();
+        }
+
+            $extracaps = array_merge($subcaps, $extracaps);
+
+        // All modules allow viewhiddenactivities. This is so you can hide
+        // the module then override to allow specific roles to see it.
+        // The actual check is in course page so not module-specific
+        $extracaps[]="moodle/course:viewhiddenactivities";
+        list($extra, $params) = $DB->get_in_or_equal(
+            $extracaps, SQL_PARAMS_NAMED, 'cap0');
+        $extra = "OR name $extra";
+
+        $SQL = "SELECT *
+                  FROM {capabilities}
+                 WHERE (contextlevel = ".CONTEXT_MODULE."
+                       AND component = :component)
+                       $extra";
+        $params['component'] = "mod_$module->name";
+
+        return array($SQL, $params);
+    }
+
+    public function get_child_contexts($context) {
+        global $DB, $ACCESSLIB_PRIVATE;
+
+        $array = array();
+        $cache = $ACCESSLIB_PRIVATE->contexcache;
+
+        // Find
+        // - blocks under this context path.
+        $sql = " SELECT ctx.*
+                       FROM {context} ctx
+                      WHERE ctx.path LIKE ?
+                            AND ctx.contextlevel = ".CONTEXT_BLOCK;
+        $params = array("{$context->path}/%", $context->instanceid);
+        $records = $DB->get_recordset_sql($sql, $params);
+        foreach ($records as $rec) {
+            $cache->add($rec);
+            $array[$rec->id] = $rec;
+        }
+        return $array;
+    }
+
+    public function build_context_path($base, $emptyclause) {
+        global $DB;
+
+        $a = 'ctx';
+        eval('$ctxemptyclause = "'.$emptyclause.'";');
+
+        // Module instances
+        $sql = "INSERT INTO {context_temp} (id, path, depth)
+                SELECT ctx.id, ".$DB->sql_concat('pctx.path', "'/'", 'ctx.id').", pctx.depth+1
+                  FROM {context} ctx
+                  JOIN {course_modules} cm ON ctx.instanceid=cm.id
+                  JOIN {context} pctx ON cm.course=pctx.instanceid
+                 WHERE ctx.contextlevel=".CONTEXT_MODULE."
+                       AND pctx.contextlevel=".CONTEXT_COURSE."
+                           AND NOT EXISTS (SELECT 'x'
+                                           FROM {context_temp} temp
+                                           WHERE temp.id = ctx.id)
+                       $ctxemptyclause";
+        $DB->execute($sql);
+
+        context_level_base::flush_context_temp();
+    }
+}
+
+/**
+ * Class representing the block context level.
+ */
+class context_level_block extends context_level_base {
+    protected $level = CONTEXT_BLOCK;
+    protected $table = 'block_instances';
+
+    public function get_context_info($instanceid, $strictness) {
+        global $DB;
+
+        $basepath  = '/' . SYSCONTEXTID;
+        $basedepth = 1;
+        $result = true;
+        $error_message = null;
+
+        $sql = "SELECT ctx.path, ctx.depth
+                  FROM {context} ctx
+                  JOIN {block_instances} bi ON (bi.parentcontextid=ctx.id)
+                 WHERE bi.id = ?";
+        $params = array($instanceid, CONTEXT_COURSE);
+        if ($p = $DB->get_record_sql($sql, $params, '*', $strictness)) {
+            $basepath  = $p->path;
+            $basedepth = $p->depth;
+        } else {
+            // block does not exist
+            $error_message = 'block or parent context does not exist';
+            $result = false;
+        }
+
+        return array($result, $basepath, $basedepth, $error_message);
+    }
+
+    public function get_contextlevel_name() {
+        return get_string('block');
+    }
+
+    public function print_context_name($context, $withprefix = true, $short = false) {
+        global $DB;
+
+        $name = '';
+
+        if ($blockinstance = $DB->get_record('block_instances', array('id'=>$context->instanceid))) {
+            global $CFG;
+            require_once("$CFG->dirroot/blocks/moodleblock.class.php");
+            require_once("$CFG->dirroot/blocks/$blockinstance->blockname/block_$blockinstance->blockname.php");
+            $blockname = "block_$blockinstance->blockname";
+            if ($blockobject = new $blockname()) {
+                if ($withprefix){
+                    $name = get_string('block').': ';
+                }
+                $name .= $blockobject->title;
+            }
+        }
+
+        return $name;
+    }
+
+    public function get_context_url($context) {
+        $parentcontexts = get_parent_contexts($context, false);
+        $parent = reset($parentcontexts);
+        $parent = get_context_instance_by_id($parent);
+        return get_context_url($parent);
+    }
+
+    public function fetch_context_capabilities_sql($context) {
+        global $DB;
+
+        $bi = $DB->get_record('block_instances', array('id' => $context->instanceid));
+
+        $extra = '';
+        $extracaps = block_method_result($bi->blockname, 'get_extra_capabilities');
+        if ($extracaps) {
+            list($extra, $params) = $DB->get_in_or_equal($extracaps, SQL_PARAMS_NAMED, 'cap');
+            $extra = "OR name $extra";
+        }
+
+        $SQL = "SELECT *
+                  FROM {capabilities}
+                 WHERE (contextlevel = ".CONTEXT_BLOCK."
+                       AND component = :component)
+                       $extra";
+        $params['component'] = 'block_' . $bi->blockname;
+
+        return array($SQL, $params);
+    }
+
+    public function get_child_contexts($context) {
+        //no children by default
+        return array();
+    }
+
+    public function build_context_path($base, $emptyclause) {
+        global $DB;
+
+        $a = 'ctx';
+        eval('$ctxemptyclause = "'.$emptyclause.'";');
+
+    // pctx.path IS NOT NULL prevents fatal problems with broken block instances that point to invalid context parent
+        $sql = "INSERT INTO {context_temp} (id, path, depth)
+            SELECT ctx.id, ".$DB->sql_concat('pctx.path', "'/'", 'ctx.id').", pctx.depth+1
+              FROM {context} ctx
+              JOIN {block_instances} bi ON ctx.instanceid = bi.id
+              JOIN {context} pctx ON bi.parentcontextid = pctx.id
+             WHERE ctx.contextlevel=".CONTEXT_BLOCK."
+                   AND pctx.path IS NOT NULL
+                   AND NOT EXISTS (SELECT 'x'
+                                   FROM {context_temp} temp
+                                   WHERE temp.id = ctx.id)
+                   $ctxemptyclause";
+        $DB->execute($sql);
+
+        context_level_base::flush_context_temp();
+    }
+}
+
+/**
+ * Clears accesslib's private caches. ONLY BE USED BY UNIT TESTS
+ *
+ * This method should ONLY BE USED BY UNIT TESTS. It clears all of
+ * accesslib's private caches. You need to do this before setting up test data,
+ * and also at the end of the tests.
+ */
+function accesslib_clear_all_caches_for_unit_testing() {
+    global $UNITTEST, $USER, $ACCESSLIB_PRIVATE;
+    if (empty($UNITTEST->running)) {
+        throw new coding_exception('You must not call clear_all_caches outside of unit tests.');
+    }
+    $ACCESSLIB_PRIVATE->contexcache      = new context_cache();
+    $ACCESSLIB_PRIVATE->systemcontext    = null;
+    $ACCESSLIB_PRIVATE->dirtycontexts    = null;
+    $ACCESSLIB_PRIVATE->accessdatabyuser = array();
+    $ACCESSLIB_PRIVATE->roledefinitions  = array();
+    $ACCESSLIB_PRIVATE->croncache        = array();
+    $ACCESSLIB_PRIVATE->preloadedcourses = array();
+    $ACCESSLIB_PRIVATE->capabilities     = null;
+
+    unset($USER->access);
+}
+
+/**
+ * This is really slow!!! do not use above course context level
+ *
+ * @param int $roleid
+ * @param object $context
+ * @return array
+ */
+function get_role_context_caps($roleid, $context) {
+    global $DB;
+
+    //this is really slow!!!! - do not use above course context level!
+    $result = array();
+    $result[$context->id] = array();
+
+    // first emulate the parent context capabilities merging into context
+    $searchcontexts = array_reverse(get_parent_contexts($context));
+    array_push($searchcontexts, $context->id);
+    foreach ($searchcontexts as $cid) {
+        if ($capabilities = $DB->get_records('role_capabilities', array('roleid'=>$roleid, 'contextid'=>$cid))) {
+            foreach ($capabilities as $cap) {
+                if (!array_key_exists($cap->capability, $result[$context->id])) {
+                    $result[$context->id][$cap->capability] = 0;
+                }
+                $result[$context->id][$cap->capability] += $cap->permission;
+            }
+        }
+    }
+
+    // now go through the contexts bellow given context
+    $searchcontexts = array_keys(get_child_contexts($context));
+    foreach ($searchcontexts as $cid) {
+        if ($capabilities = $DB->get_records('role_capabilities', array('roleid'=>$roleid, 'contextid'=>$cid))) {
+            foreach ($capabilities as $cap) {
+                if (!array_key_exists($cap->contextid, $result)) {
+                    $result[$cap->contextid] = array();
+                }
+                $result[$cap->contextid][$cap->capability] = $cap->permission;
+            }
+        }
+    }
+
+    return $result;
+}
+
+/**
+ * Gets the accessdata for role "sitewide" (system down to course)
+ *
+ * @param int $roleid
+ * @param array $accessdata defaults to null
+ * @return array
+ */
+function get_role_access($roleid, $accessdata = null) {
+    global $CFG, $DB;
+
+    /* Get it in 1 cheap DB query...
+     * - relevant role caps at the root and down
+     *   to the course level - but not below
+     */
+    if (is_null($accessdata)) {
+        $accessdata           = array(); // named list
+        $accessdata['ra']     = array();
+        $accessdata['rdef']   = array();
+        $accessdata['loaded'] = array();
+    }
+
+    //
+    // Overrides for the role IN ANY CONTEXTS
+    // down to COURSE - not below -
+    //
+    $sql = "SELECT ctx.path,
+                   rc.capability, rc.permission
+              FROM {context} ctx
+              JOIN {role_capabilities} rc
+                   ON rc.contextid=ctx.id
+             WHERE rc.roleid = ?
+                   AND ctx.contextlevel <= ".CONTEXT_COURSE."
+          ORDER BY ctx.depth, ctx.path";
+    $params = array($roleid);
+
+    // we need extra caching in CLI scripts and cron
+    if (CLI_SCRIPT) {
+        global $ACCESSLIB_PRIVATE;
+
+        if (!isset($ACCESSLIB_PRIVATE->croncache[$roleid])) {
+            $ACCESSLIB_PRIVATE->croncache[$roleid] = array();
+            $rs = $DB->get_recordset_sql($sql, $params);
+            foreach ($rs as $rd) {
+                $ACCESSLIB_PRIVATE->croncache[$roleid][] = $rd;
+            }
+            $rs->close();
+        }
+
+        foreach ($ACCESSLIB_PRIVATE->croncache[$roleid] as $rd) {
+            $k = "{$rd->path}:{$roleid}";
+            $accessdata['rdef'][$k][$rd->capability] = $rd->permission;
+        }
+
+    } else {
+        $rs = $DB->get_recordset_sql($sql, $params);
+        if ($rs->valid()) {
+            foreach ($rs as $rd) {
+                $k = "{$rd->path}:{$roleid}";
+                $accessdata['rdef'][$k][$rd->capability] = $rd->permission;
+            }
+            unset($rd);
+        }
+        $rs->close();
+    }
+
+    return $accessdata;
+}
+
+/**
+ * Gets the accessdata for role "sitewide" (system down to course)
+ *
+ * @param int $roleid
+ * @param array $accessdata defaults to null
+ * @return array
+ */
+function get_default_frontpage_role_access($roleid, $accessdata = null) {
+
+    global $CFG, $DB;
+
+    $frontpagecontext = get_context_instance(CONTEXT_COURSE, SITEID);
+    $base = '/'. SYSCONTEXTID .'/'. $frontpagecontext->id;
+
+    //
+    // Overrides for the role in any contexts related to the course
+    //
+    $sql = "SELECT ctx.path,
+                   rc.capability, rc.permission
+              FROM {context} ctx
+              JOIN {role_capabilities} rc
+                   ON rc.contextid=ctx.id
+             WHERE rc.roleid = ?
+                   AND (ctx.id = ".SYSCONTEXTID." OR ctx.path LIKE ?)
+                   AND ctx.contextlevel <= ".CONTEXT_COURSE."
+          ORDER BY ctx.depth, ctx.path";
+    $params = array($roleid, "$base/%");
+
+    $rs = $DB->get_recordset_sql($sql, $params);
+    if ($rs->valid()) {
+        foreach ($rs as $rd) {
+            $k = "{$rd->path}:{$roleid}";
+            $accessdata['rdef'][$k][$rd->capability] = $rd->permission;
+        }
+        unset($rd);
+    }
+    $rs->close();
+
+    return $accessdata;
+}
+
+
+/**
+ * Get the default guest role
+ *
+ * @return stdClass role
+ */
+function get_guest_role() {
+    global $CFG, $DB;
+
+    if (empty($CFG->guestroleid)) {
+        if ($roles = $DB->get_records('role', array('archetype'=>'guest'))) {
+            $guestrole = array_shift($roles);   // Pick the first one
+            set_config('guestroleid', $guestrole->id);
+            return $guestrole;
+        } else {
+            debugging('Can not find any guest role!');
+            return false;
+        }
+    } else {
+        if ($guestrole = $DB->get_record('role', array('id'=>$CFG->guestroleid))) {
+            return $guestrole;
+        } else {
+            //somebody is messing with guest roles, remove incorrect setting and try to find a new one
+            set_config('guestroleid', '');
+            return get_guest_role();
+        }
+    }
+}
+
+/**
+ * Check whether a user has a particular capability in a given context.
+ *
+ * For example::
+ *      $context = get_context_instance(CONTEXT_MODULE, $cm->id);
+ *      has_capability('mod/forum:replypost',$context)
+ *
+ * By default checks the capabilities of the current user, but you can pass a
+ * different userid. By default will return true for admin users, but you can override that with the fourth argument.
+ *
+ * Guest and not-logged-in users can never get any dangerous capability - that is any write capability
+ * or capabilities with XSS, config or data loss risks.
+ *
+ * @param string $capability the name of the capability to check. For example mod/forum:view
+ * @param object $context the context to check the capability in. You normally get this with {@link get_context_instance}.
+ * @param integer|object $user A user id or object. By default (null) checks the permissions of the current user.
+ * @param boolean $doanything If false, ignores effect of admin role assignment
+ * @return boolean true if the user has this capability. Otherwise false.
+ */
+function has_capability($capability, $context, $user = null, $doanything = true) {
+    global $USER, $CFG, $DB, $SCRIPT, $ACCESSLIB_PRIVATE;
+
+    if (during_initial_install()) {
+        if ($SCRIPT === "/$CFG->admin/index.php" or $SCRIPT === "/$CFG->admin/cliupgrade.php") {
+            // we are in an installer - roles can not work yet
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    if (strpos($capability, 'moodle/legacy:') === 0) {
+        throw new coding_exception('Legacy capabilities can not be used any more!');
+    }
+
+    // the original $CONTEXT here was hiding serious errors
+    // for security reasons do not reuse previous context
+    if (empty($context)) {
+        debugging('Incorrect context specified');
+        return false;
+    }
+    if (!is_bool($doanything)) {
+        throw new coding_exception('Capability parameter "doanything" is wierd ("'.$doanything.'"). This has to be fixed in code.');
+    }
+
+    // make sure there is a real user specified
+    if ($user === null) {
+        $userid = isset($USER->id) ? $USER->id : 0;
+    } else {
+        $userid = is_object($user) ? $user->id : $user;
+    }
+
+    // capability must exist
+    if (!$capinfo = get_capability_info($capability)) {
+        debugging('Capability "'.$capability.'" was not found! This should be fixed in code.');
+        return false;
+    }
+    // make sure the guest account and not-logged-in users never get any risky caps no matter what the actual settings are.
+    if (($capinfo->captype === 'write') or ((int)$capinfo->riskbitmask & (RISK_XSS | RISK_CONFIG | RISK_DATALOSS))) {
+        if (isguestuser($userid) or $userid == 0) {
+            return false;
+        }
+    }
+
+    if (is_null($context->path) or $context->depth == 0) {
+        //this should not happen
+        $contexts = array(SYSCONTEXTID, $context->id);
+        $context->path = '/'.SYSCONTEXTID.'/'.$context->id;
+        debugging('Context id '.$context->id.' does not have valid path, please use build_context_path()', DEBUG_DEVELOPER);
+
+    } else {
+        $contexts = explode('/', $context->path);
+        array_shift($contexts);
+    }
+
+    if (CLI_SCRIPT && !isset($USER->access)) {
+        // In cron, some modules setup a 'fake' $USER,
+        // ensure we load the appropriate accessdata.
+        if (isset($ACCESSLIB_PRIVATE->accessdatabyuser[$userid])) {
+            $ACCESSLIB_PRIVATE->dirtycontexts = null; //load fresh dirty contexts
+        } else {
+            load_user_accessdata($userid);
+            $ACCESSLIB_PRIVATE->dirtycontexts = array();
+        }
+        $USER->access = $ACCESSLIB_PRIVATE->accessdatabyuser[$userid];
+
+    } else if (isset($USER->id) && ($USER->id == $userid) && !isset($USER->access)) {
+        // caps not loaded yet - better to load them to keep BC with 1.8
+        // not-logged-in user or $USER object set up manually first time here
+        load_all_capabilities();
+        $ACCESSLIB_PRIVATE->accessdatabyuser = array(); // reset the cache for other users too, the dirty contexts are empty now
+        $ACCESSLIB_PRIVATE->roledefinitions = array();
     }
 
     // Load dirty contexts list if needed
-    if (!isset($DIRTYCONTEXTS)) {
+    if (!isset($ACCESSLIB_PRIVATE->dirtycontexts)) {
         if (isset($USER->access['time'])) {
-            $DIRTYCONTEXTS = get_dirty_contexts($USER->access['time']);
+            $ACCESSLIB_PRIVATE->dirtycontexts = get_dirty_contexts($USER->access['time']);
         }
         else {
-            $DIRTYCONTEXTS = array();
+            $ACCESSLIB_PRIVATE->dirtycontexts = array();
         }
     }
 
     // Careful check for staleness...
-    if (count($DIRTYCONTEXTS) !== 0 and is_contextpath_dirty($contexts, $DIRTYCONTEXTS)) {
+    if (count($ACCESSLIB_PRIVATE->dirtycontexts) !== 0 and is_contextpath_dirty($contexts, $ACCESSLIB_PRIVATE->dirtycontexts)) {
         // reload all capabilities - preserving loginas, roleswitches, etc
         // and then cleanup any marks of dirtyness... at least from our short
         // term memory! :-)
-        $ACCESS = array();
-        $RDEFS = array();
+        $ACCESSLIB_PRIVATE->accessdatabyuser = array();
+        $ACCESSLIB_PRIVATE->roledefinitions = array();
 
-        if (defined('FULLME') && FULLME === 'cron') {
+        if (CLI_SCRIPT) {
             load_user_accessdata($userid);
-            $USER->access = $ACCESS[$userid];
-            $DIRTYCONTEXTS = array();
+            $USER->access = $ACCESSLIB_PRIVATE->accessdatabyuser[$userid];
+            $ACCESSLIB_PRIVATE->dirtycontexts = array();
 
         } else {
             reload_all_capabilities();
         }
     }
 
+    // Find out if user is admin - it is not possible to override the doanything in any way
+    // and it is not possible to switch to admin role either.
+    if ($doanything) {
+        if (is_siteadmin($userid)) {
+            if ($userid != $USER->id) {
+                return true;
+            }
+            // make sure switchrole is not used in this context
+            if (empty($USER->access['rsw'])) {
+                return true;
+            }
+            $parts = explode('/', trim($context->path, '/'));
+            $path = '';
+            $switched = false;
+            foreach ($parts as $part) {
+                $path .= '/' . $part;
+                if (!empty($USER->access['rsw'][$path])) {
+                    $switched = true;
+                    break;
+                }
+            }
+            if (!$switched) {
+                return true;
+            }
+            //ok, admin switched role in this context, let's use normal access control rules
+        }
+    }
+
     // divulge how many times we are called
     //// error_log("has_capability: id:{$context->id} path:{$context->path} userid:$userid cap:$capability");
 
-    if ($USER->id == $userid) { // we must accept strings and integers in $userid
+    if (isset($USER->id) && ($USER->id == $userid)) { // we must accept strings and integers in $userid
         //
         // For the logged in user, we have $USER->access
         // which will have all RAs and caps preloaded for
@@ -464,7 +1718,7 @@ function has_capability($capability, $context, $userid=NULL, $doanything=true) {
         //
         if ($context->contextlevel <= CONTEXT_COURSE) {
             // Course and above are always preloaded
-            return has_capability_in_accessdata($capability, $context, $USER->access, $doanything);
+            return has_capability_in_accessdata($capability, $context, $USER->access);
         }
         // Load accessdata for below-the-course contexts
         if (!path_inaccessdata($context->path,$USER->access)) {
@@ -473,40 +1727,49 @@ function has_capability($capability, $context, $userid=NULL, $doanything=true) {
             // error_log("bt {$bt[0]['file']} {$bt[0]['line']}");
             load_subcontext($USER->id, $context, $USER->access);
         }
-        return has_capability_in_accessdata($capability, $context, $USER->access, $doanything);
+        return has_capability_in_accessdata($capability, $context, $USER->access);
     }
 
-    if (!isset($ACCESS[$userid])) {
+    if (!isset($ACCESSLIB_PRIVATE->accessdatabyuser[$userid])) {
         load_user_accessdata($userid);
     }
+
     if ($context->contextlevel <= CONTEXT_COURSE) {
         // Course and above are always preloaded
-        return has_capability_in_accessdata($capability, $context, $ACCESS[$userid], $doanything);
+        return has_capability_in_accessdata($capability, $context, $ACCESSLIB_PRIVATE->accessdatabyuser[$userid]);
     }
     // Load accessdata for below-the-course contexts as needed
-    if (!path_inaccessdata($context->path, $ACCESS[$userid])) {
+    if (!path_inaccessdata($context->path, $ACCESSLIB_PRIVATE->accessdatabyuser[$userid])) {
         // error_log("loading access for context {$context->path} for $capability at {$context->contextlevel} {$context->id}");
         // $bt = debug_backtrace();
         // error_log("bt {$bt[0]['file']} {$bt[0]['line']}");
-        load_subcontext($userid, $context, $ACCESS[$userid]);
+        load_subcontext($userid, $context, $ACCESSLIB_PRIVATE->accessdatabyuser[$userid]);
     }
-    return has_capability_in_accessdata($capability, $context, $ACCESS[$userid], $doanything);
+    return has_capability_in_accessdata($capability, $context, $ACCESSLIB_PRIVATE->accessdatabyuser[$userid]);
 }
 
 /**
- * This function returns whether the current user has any of the capabilities in the
- * $capabilities array. This is a simple wrapper around has_capability for convinience.
+ * Check if the user has any one of several capabilities from a list.
+ *
+ * This is just a utility method that calls has_capability in a loop. Try to put
+ * the capabilities that most users are likely to have first in the list for best
+ * performance.
  *
  * There are probably tricks that could be done to improve the performance here, for example,
  * check the capabilities that are already cached first.
  *
- * @param array $capabilities - an array of capability names.
- * @param object $context - a context object (record from context table)
- * @param integer $userid - a userid number, empty if current $USER
- * @param bool $doanything - if false, ignore do anything
- * @return bool
+ * @see has_capability()
+ * @param array $capabilities an array of capability names.
+ * @param object $context the context to check the capability in. You normally get this with {@link get_context_instance}.
+ * @param integer $userid A user id. By default (null) checks the permissions of the current user.
+ * @param boolean $doanything If false, ignore effect of admin role assignment
+ * @return boolean true if the user has any of these capabilities. Otherwise false.
  */
-function has_any_capability($capabilities, $context, $userid=NULL, $doanything=true) {
+function has_any_capability($capabilities, $context, $userid = null, $doanything = true) {
+    if (!is_array($capabilities)) {
+        debugging('Incorrect $capabilities parameter in has_any_capabilities() call - must be an array');
+        return false;
+    }
     foreach ($capabilities as $capability) {
         if (has_capability($capability, $context, $userid, $doanything)) {
             return true;
@@ -516,19 +1779,23 @@ function has_any_capability($capabilities, $context, $userid=NULL, $doanything=t
 }
 
 /**
- * This function returns whether the current user has all of the capabilities in the
- * $capabilities array. This is a simple wrapper around has_capability for convinience.
+ * Check if the user has all the capabilities in a list.
+ *
+ * This is just a utility method that calls has_capability in a loop. Try to put
+ * the capabilities that fewest users are likely to have first in the list for best
+ * performance.
  *
  * There are probably tricks that could be done to improve the performance here, for example,
  * check the capabilities that are already cached first.
  *
- * @param array $capabilities - an array of capability names.
- * @param object $context - a context object (record from context table)
- * @param integer $userid - a userid number, empty if current $USER
- * @param bool $doanything - if false, ignore do anything
- * @return bool
+ * @see has_capability()
+ * @param array $capabilities an array of capability names.
+ * @param object $context the context to check the capability in. You normally get this with {@link get_context_instance}.
+ * @param integer $userid A user id. By default (null) checks the permissions of the current user.
+ * @param boolean $doanything If false, ignore effect of admin role assignment
+ * @return boolean true if the user has all of these capabilities. Otherwise false.
  */
-function has_all_capabilities($capabilities, $context, $userid=NULL, $doanything=true) {
+function has_all_capabilities($capabilities, $context, $userid = null, $doanything = true) {
     if (!is_array($capabilities)) {
         debugging('Incorrect $capabilities parameter in has_all_capabilities() call - must be an array');
         return false;
@@ -542,38 +1809,59 @@ function has_all_capabilities($capabilities, $context, $userid=NULL, $doanything
 }
 
 /**
- * Uses 1 DB query to answer whether a user is an admin at the sitelevel.
- * It depends on DB schema >=1.7 but does not depend on the new datastructures
- * in v1.9 (context.path, or $USER->access)
+ * Check if the user is an admin at the site level.
  *
- * Will return true if the userid has any of
- *  - moodle/site:config
- *  - moodle/legacy:admin
- *  - moodle/site:doanything
+ * Please note that use of proper capabilities is always encouraged,
+ * this function is supposed to be used from core or for temporary hacks.
  *
- * @param   int  $userid
- * @returns bool $isadmin
+ * @param   int|object  $user_or_id user id or user object
+ * @returns bool true if user is one of the administrators, false otherwise
  */
-function is_siteadmin($userid) {
-    global $CFG;
+function is_siteadmin($user_or_id = null) {
+    global $CFG, $USER;
+
+    if ($user_or_id === null) {
+        $user_or_id = $USER;
+    }
+
+    if (empty($user_or_id)) {
+        return false;
+    }
+    if (!empty($user_or_id->id)) {
+        // we support
+        $userid = $user_or_id->id;
+    } else {
+        $userid = $user_or_id;
+    }
+
+    $siteadmins = explode(',', $CFG->siteadmins);
+    return in_array($userid, $siteadmins);
+}
 
-    $sql = "SELECT SUM(rc.permission)
-            FROM " . $CFG->prefix . "role_capabilities rc
-            JOIN " . $CFG->prefix . "context ctx 
-              ON ctx.id=rc.contextid
-            JOIN " . $CFG->prefix . "role_assignments ra
-              ON ra.roleid=rc.roleid AND ra.contextid=ctx.id
-            WHERE ctx.contextlevel=10
-              AND ra.userid={$userid}
-              AND rc.capability IN ('moodle/site:config', 'moodle/legacy:admin', 'moodle/site:doanything')       
-            GROUP BY rc.capability
-            HAVING SUM(rc.permission) > 0";
+/**
+ * Returns true if user has at least one role assign
+ * of 'coursecontact' role (is potentially listed in some course descriptions).
+ *
+ * @param $userid
+ * @return stdClass
+ */
+function has_coursecontact_role($userid) {
+    global $DB, $CFG;
 
-    $isadmin = record_exists_sql($sql);
-    return $isadmin;
+    if (empty($CFG->coursecontact)) {
+        return false;
+    }
+    $sql = "SELECT 1
+              FROM {role_assignments}
+             WHERE userid = :userid AND roleid IN ($CFG->coursecontact)";
+    return $DB->record_exists_sql($sql, array('userid'=>$userid));
 }
 
-function get_course_from_path ($path) {
+/**
+ * @param string $path
+ * @return string
+ */
+function get_course_from_path($path) {
     // assume that nothing is more than 1 course deep
     if (preg_match('!^(/.+)/\d+$!', $path, $matches)) {
         return $matches[1];
@@ -581,7 +1869,15 @@ function get_course_from_path ($path) {
     return false;
 }
 
+/**
+ * @param string $path
+ * @param array $accessdata
+ * @return bool
+ */
 function path_inaccessdata($path, $accessdata) {
+    if (empty($accessdata['loaded'])) {
+        return false;
+    }
 
     // assume that contexts hang from sys or from a course
     // this will only work well with stuff that hangs from a course
@@ -603,6 +1899,8 @@ function path_inaccessdata($path, $accessdata) {
 }
 
 /**
+ * Does the user have a capability to do something?
+ *
  * Walk the accessdata array and return true/false.
  * Deals with prohibits, roleswitching, aggregating
  * capabilities, etc.
@@ -613,7 +1911,7 @@ function path_inaccessdata($path, $accessdata) {
  * Notes:
  *
  * Switch Roles exits early
- * -----------------------
+ * ------------------------
  * cap checks within a switchrole need to exit early
  * in our bottom up processing so they don't "see" that
  * there are real RAs that can do all sorts of things.
@@ -625,215 +1923,88 @@ function path_inaccessdata($path, $accessdata) {
  * course you'll have techer+defaultloggedinuser.
  * We try to mimic that in switchrole.
  *
- * Local-most role definition and role-assignment wins
- * ---------------------------------------------------
- * So if the local context has said 'allow', it wins
- * over a high-level context that says 'deny'.
- * This is applied when walking rdefs, and RAs.
- * Only at the same context the values are SUM()med.
- *
- * The exception is CAP_PROHIBIT.
- *
- * "Guest default role" exception
- * ------------------------------
- *
- * See MDL-7513 and $ignoreguest below for details.
- *
- * The rule is that
- *
- *    IF we are being asked about moodle/legacy:guest
- *                             OR moodle/course:view
- *    FOR a real, logged-in user
- *    AND we reached the top of the path in ra and rdef
- *    AND that role has moodle/legacy:guest === 1...
- *    THEN we act as if we hadn't seen it.
- *
- * Note that this function must be kept in synch with has_capability_in_accessdata.
- *
- * To Do:
- *
- * - Document how it works
- * - Rewrite in ASM :-)
+ * Permission evaluation
+ * ---------------------
+ * Originally there was an extremely complicated way
+ * to determine the user access that dealt with
+ * "locality" or role assignments and role overrides.
+ * Now we simply evaluate access for each role separately
+ * and then verify if user has at least one role with allow
+ * and at the same time no role with prohibit.
  *
+ * @param string $capability
+ * @param object $context
+ * @param array $accessdata
+ * @return bool
  */
-function has_capability_in_accessdata($capability, $context, $accessdata, $doanything) {
-
+function has_capability_in_accessdata($capability, $context, array $accessdata) {
     global $CFG;
 
-    $path = $context->path;
-
-    // build $contexts as a list of "paths" of the current
-    // contexts and parents with the order top-to-bottom
-    $contexts = array($path);
-    while (preg_match('!^(/.+)/\d+$!', $path, $matches)) {
-        $path = $matches[1];
-        array_unshift($contexts, $path);
+    if (empty($context->id)) {
+        throw new coding_exception('Invalid context specified');
     }
 
-    $ignoreguest = false;
-    if (isset($accessdata['dr'])
-        && ($capability    == 'moodle/course:view'
-            || $capability == 'moodle/legacy:guest')) {
-        // At the base, ignore rdefs where moodle/legacy:guest
-        // is set
-        $ignoreguest = $accessdata['dr'];
+    // Build $paths as a list of current + all parent "paths" with order bottom-to-top
+    $contextids = explode('/', trim($context->path, '/'));
+    $paths = array($context->path);
+    while ($contextids) {
+        array_pop($contextids);
+        $paths[] = '/' . implode('/', $contextids);
     }
+    unset($contextids);
 
-    // Coerce it to an int
-    $CAP_PROHIBIT = (int)CAP_PROHIBIT;
-
-    $cc = count($contexts);
-
-    $can = 0;
-    $capdepth = 0;
+    $roles = array();
+    $switchedrole = false;
 
-    //
-    // role-switches loop
-    //
-    if (isset($accessdata['rsw'])) {
-        // check for isset() is fast 
-        // empty() is slow...
-        if (empty($accessdata['rsw'])) {
-            unset($accessdata['rsw']); // keep things fast and unambiguous
-            break;
-        }
+    // Find out if role switched
+    if (!empty($accessdata['rsw'])) {
         // From the bottom up...
-        for ($n=$cc-1;$n>=0;$n--) {
-            $ctxp = $contexts[$n];
-            if (isset($accessdata['rsw'][$ctxp])) {
-                // Found a switchrole assignment
-                // check for that role _plus_ the default user role
-                $ras = array($accessdata['rsw'][$ctxp],$CFG->defaultuserroleid);
-                for ($rn=0;$rn<2;$rn++) {
-                    $roleid = (int)$ras[$rn];
-                    // Walk the path for capabilities
-                    // from the bottom up...
-                    for ($m=$cc-1;$m>=0;$m--) {
-                        $capctxp = $contexts[$m];
-                        if (isset($accessdata['rdef']["{$capctxp}:$roleid"][$capability])) {
-                            $perm = (int)$accessdata['rdef']["{$capctxp}:$roleid"][$capability];
-
-                            // The most local permission (first to set) wins
-                            // the only exception is CAP_PROHIBIT
-                            if ($can === 0) {
-                                $can = $perm;
-                            } elseif ($perm === $CAP_PROHIBIT) {
-                                $can = $perm;
+        foreach ($paths as $path) {
+            if (isset($accessdata['rsw'][$path])) {
+                // Found a switchrole assignment - check for that role _plus_ the default user role
+                $roles = array($accessdata['rsw'][$path]=>null, $CFG->defaultuserroleid=>null);
+                $switchedrole = true;
                                 break;
                             }
                         }
                     }
-                }
-                // As we are dealing with a switchrole,
-                // we return _here_, do _not_ walk up 
-                // the hierarchy any further
-                if ($can < 1) {
-                    if ($doanything) {
-                        // didn't find it as an explicit cap,
-                        // but maybe the user can doanything in this context...
-                        return has_capability_in_accessdata('moodle/site:doanything', $context, $accessdata, false);
-                    } else {
-                        return false;
-                    }
-                } else {
-                    return true;
-                }
                 
+    if (!$switchedrole) {
+        // get all users roles in this context and above
+        foreach ($paths as $path) {
+            if (isset($accessdata['ra'][$path])) {
+                foreach ($accessdata['ra'][$path] as $roleid) {
+                    $roles[$roleid] = null;
             }
         }
     }
-
-    //
-    // Main loop for normal RAs
-    // From the bottom up...
-    //
-    for ($n=$cc-1;$n>=0;$n--) {
-        $ctxp = $contexts[$n];
-        if (isset($accessdata['ra'][$ctxp])) {
-            // Found role assignments on this leaf
-            $ras = $accessdata['ra'][$ctxp];
-
-            $rc          = count($ras);
-            $ctxcan      = 0;
-            $ctxcapdepth = 0;
-            for ($rn=0;$rn<$rc;$rn++) {
-                $roleid  = (int)$ras[$rn];
-                $rolecan = 0;
-                $rolecapdepth = 0;
-                // Walk the path for capabilities
-                // from the bottom up...
-                for ($m=$cc-1;$m>=0;$m--) {
-                    $capctxp = $contexts[$m];
-                    // ignore some guest caps
-                    // at base ra and rdef
-                    if ($ignoreguest == $roleid
-                        && $n === 0
-                        && $m === 0
-                        && isset($accessdata['rdef']["{$capctxp}:$roleid"]['moodle/legacy:guest'])
-                        && $accessdata['rdef']["{$capctxp}:$roleid"]['moodle/legacy:guest'] > 0) {
-                            continue;
-                    }
-                    if (isset($accessdata['rdef']["{$capctxp}:$roleid"][$capability])) {
-                        $perm = (int)$accessdata['rdef']["{$capctxp}:$roleid"][$capability];
-                        // The most local permission (first to set) wins
-                        // the only exception is CAP_PROHIBIT
-                        if ($rolecan === 0) {
-                            $rolecan      = $perm;
-                            $rolecapdepth = $m;
-                        } elseif ($perm === $CAP_PROHIBIT) {
-                            $rolecan      = $perm;
-                            $rolecapdepth = $m;
-                            break;
-                        }
                     }
+
+    // Now find out what access is given to each role, going bottom-->up direction
+    foreach ($roles as $roleid => $ignored) {
+        foreach ($paths as $path) {
+            if (isset($accessdata['rdef']["{$path}:$roleid"][$capability])) {
+                $perm = (int)$accessdata['rdef']["{$path}:$roleid"][$capability];
+                if ($perm === CAP_PROHIBIT or is_null($roles[$roleid])) {
+                    $roles[$roleid] = $perm;
                 }
-                // Rules for RAs at the same context...
-                // - prohibits always wins
-                // - permissions at the same ctxlevel & capdepth are added together
-                // - deeper capdepth wins
-                if ($ctxcan === $CAP_PROHIBIT || $rolecan === $CAP_PROHIBIT) {
-                    $ctxcan      = $CAP_PROHIBIT;
-                    $ctxcapdepth = 0;
-                } elseif ($ctxcapdepth === $rolecapdepth) {
-                    $ctxcan += $rolecan;
-                } elseif ($ctxcapdepth < $rolecapdepth) {
-                    $ctxcan      = $rolecan;
-                    $ctxcapdepth = $rolecapdepth;
-                } else { // ctxcaptdepth is deeper
-                    // rolecap ignored
-                }
-            }
-            // The most local RAs with a defined
-            // permission ($ctxcan) win, except
-            // for CAP_PROHIBIT
-            // NOTE: If we want the deepest RDEF to
-            // win regardless of the depth of the RA,
-            // change the elseif below to read
-            // ($can === 0 || $capdepth < $ctxcapdepth) {
-            if ($ctxcan === $CAP_PROHIBIT) {
-                $can = $ctxcan;
-                break;
-            } elseif ($can === 0) { // see note above
-                $can      = $ctxcan;
-                $capdepth = $ctxcapdepth;
             }
         }
     }
-
-    if ($can < 1) {
-        if ($doanything) {
-            // didn't find it as an explicit cap,
-            // but maybe the user can doanything in this context...
-            return has_capability_in_accessdata('moodle/site:doanything', $context, $accessdata, false);
-        } else {
+    // any CAP_PROHIBIT found means no permission for the user
+    if (array_search(CAP_PROHIBIT, $roles) !== false) {
             return false;
         }
-    } else {
-        return true;
-    }
 
+    // at least one CAP_ALLOW means the user has a permission
+    return (array_search(CAP_ALLOW, $roles) !== false);
 }
 
+/**
+ * @param object $context
+ * @param array $accessdata
+ * @return array
+ */
 function aggregate_roles_from_accessdata($context, $accessdata) {
 
     $path = $context->path;
@@ -850,7 +2021,7 @@ function aggregate_roles_from_accessdata($context, $accessdata) {
 
     $roles = array();
     // From the bottom up...
-    for ($n=$cc-1;$n>=0;$n--) {
+    for ($n=$cc-1; $n>=0; $n--) {
         $ctxp = $contexts[$n];
         if (isset($accessdata['ra'][$ctxp]) && count($accessdata['ra'][$ctxp])) {
             // Found assignments on this leaf
@@ -863,303 +2034,81 @@ function aggregate_roles_from_accessdata($context, $accessdata) {
 }
 
 /**
- * This is an easy to use function, combining has_capability() with require_course_login().
- * And will call those where needed.
- * 
- * It checks for a capability assertion being true.  If it isn't
- * then the page is terminated neatly with a standard error message.
- *
- * If the user is not logged in, or is using 'guest' access or other special "users,
- * it provides a logon prompt.
- *
- * @param string $capability - name of the capability
- * @param object $context - a context object (record from context table)
- * @param integer $userid - a userid number
- * @param bool $doanything - if false, ignore do anything
- * @param string $errorstring - an errorstring
- * @param string $stringfile - which stringfile to get it from
- */
-function require_capability($capability, $context, $userid=NULL, $doanything=true,
-                            $errormessage='nopermissions', $stringfile='') {
-
-    global $USER, $CFG;
-
-    /* Empty $userid means current user, if the current user is not logged in,
-     * then make sure they are (if needed).
-     * Originally there was a check for loaded permissions - it is not needed here.
-     * Context is now required parameter, the cached $CONTEXT was only hiding errors.
+ * A convenience function that tests has_capability, and displays an error if
+ * the user does not have that capability.
+ *
+ * NOTE before Moodle 2.0, this function attempted to make an appropriate
+ * require_login call before checking the capability. This is no longer the case.
+ * You must call require_login (or one of its variants) if you want to check the
+ * user is logged in, before you call this function.
+ *
+ * @see has_capability()
+ *
+ * @param string $capability the name of the capability to check. For example mod/forum:view
+ * @param object $context the context to check the capability in. You normally get this with {@link get_context_instance}.
+ * @param integer $userid A user id. By default (null) checks the permissions of the current user.
+ * @param bool $doanything If false, ignore effect of admin role assignment
+ * @param string $errorstring The error string to to user. Defaults to 'nopermissions'.
+ * @param string $stringfile The language file to load the error string from. Defaults to 'error'.
+ * @return void terminates with an error if the user does not have the given capability.
      */
-    $errorlink = '';
-
-    if (empty($userid)) {
-        if ($context->contextlevel == CONTEXT_COURSE) {
-            require_login($context->instanceid);
-
-        } else if ($context->contextlevel == CONTEXT_MODULE) {
-            if (!$cm = get_record('course_modules', 'id', $context->instanceid)) {
-                error('Incorrect module');
-            }
-            if (!$course = get_record('course', 'id', $cm->course)) {
-                error('Incorrect course.');
-            }
-            require_course_login($course, true, $cm);
-            $errorlink = $CFG->wwwroot.'/course/view.php?id='.$cm->course;
-
-        } else if ($context->contextlevel == CONTEXT_SYSTEM) {
-            if (!empty($CFG->forcelogin)) {
-                require_login();
-            }
-
-        } else {
-            require_login();
-        }
-    }
-
-/// OK, if they still don't have the capability then print a nice error message
-
+function require_capability($capability, $context, $userid = null, $doanything = true,
+                            $errormessage = 'nopermissions', $stringfile = '') {
     if (!has_capability($capability, $context, $userid, $doanything)) {
-        $capabilityname = get_capability_string($capability);
-        print_error($errormessage, $stringfile, $errorlink, $capabilityname);
+        throw new required_capability_exception($context, $capability, $errormessage, $stringfile);
     }
 }
 
 /**
- * Get an array of courses (with magic extra bits)
- * where the accessdata and in DB enrolments show
- * that the cap requested is available.
- *
- * The main use is for get_my_courses().
- *
- * Notes
- *
- * - $fields is an array of fieldnames to ADD
- *   so name the fields you really need, which will
- *   be added and uniq'd
- *
- * - the course records have $c->context which is a fully
- *   valid context object. Saves you a query per course!
- *
- * - the course records have $c->categorypath to make
- *   category lookups cheap
- *
- * - current implementation is split in -
- *
- *   - if the user has the cap systemwide, stupidly
- *     grab *every* course for a capcheck. This eats
- *     a TON of bandwidth, specially on large sites 
- *     with separate DBs...
- *
- *   - otherwise, fetch "likely" courses with a wide net
- *     that should get us _cheaply_ at least the courses we need, and some
- *     we won't - we get courses that...
- *      - are in a category where user has the cap
- *      - or where use has a role-assignment (any kind)
- *      - or where the course has an override on for this cap
- *
- *   - walk the courses recordset checking the caps oneach one
- *     the checks are all in memory and quite fast
- *     (though we could implement a specialised variant of the
- *     has_capability_in_accessdata() code to speed it up)
+ * Get an array of courses where cap requested is available
+ * and user is enrolled, this can be relatively slow.
  *
  * @param string $capability - name of the capability
- * @param array  $accessdata - accessdata session array
- * @param bool   $doanything - if false, ignore do anything
+ * @param array  $accessdata_ignored
+ * @param bool   $doanything_ignored
  * @param string $sort - sorting fields - prefix each fieldname with "c."
  * @param array  $fields - additional fields you are interested in...
- * @param int    $limit  - set if you want to limit the number of courses
+ * @param int    $limit_ignored
  * @return array $courses - ordered array of course objects - see notes above
- *
  */
-function get_user_courses_bycap($userid, $cap, $accessdata, $doanything, $sort='c.sortorder ASC', $fields=NULL, $limit=0) {
-
-    global $CFG;
-
-    // Slim base fields, let callers ask for what they need...
-    $basefields = array('id', 'sortorder', 'shortname', 'idnumber');
-
-    if (!is_null($fields)) {
-        $fields = array_merge($basefields, $fields);
-        $fields = array_unique($fields);
-    } else {
-        $fields = $basefields;
-    }
-    // If any of the fields is '*', leave it alone, discarding the rest
-    // to avoid ambiguous columns under some silly DBs. See MDL-18746 :-D
-    if (in_array('*', $fields)) {
-        $fields = array('*');
-    }
-    $coursefields = 'c.' .implode(',c.', $fields);
+function get_user_courses_bycap($userid, $cap, $accessdata_ignored, $doanything_ignored, $sort = 'c.sortorder ASC', $fields = null, $limit_ignored = 0) {
 
-    $sort = trim($sort);
-    if ($sort !== '') {
-        $sort = "ORDER BY $sort";
-    }
+    //TODO: this should be most probably deprecated
 
-    $sysctx = get_context_instance(CONTEXT_SYSTEM);
-    if (has_capability_in_accessdata($cap, $sysctx, $accessdata, $doanything)) {
-        //
-        // Apparently the user has the cap sitewide, so walk *every* course
-        // (the cap checks are moderately fast, but this moves massive bandwidth w the db)
-        // Yuck.
-        //
-        $sql = "SELECT $coursefields,
-                       ctx.id AS ctxid, ctx.path AS ctxpath,
-                       ctx.depth AS ctxdepth, ctx.contextlevel AS ctxlevel,
-                       cc.path AS categorypath
-                FROM {$CFG->prefix}course c
-                JOIN {$CFG->prefix}course_categories cc
-                  ON c.category=cc.id
-                JOIN {$CFG->prefix}context ctx 
-                  ON (c.id=ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSE.")
-                $sort ";
-        $rs = get_recordset_sql($sql);
-    } else {
-        //
-        // narrow down where we have the caps to a few contexts
-        // this will be a combination of
-        // - courses    where user has an explicit enrolment
-        // - courses    that have an override (any status) on that capability
-        // - categories where user has the rights (granted status) on that capability
-        //
-        $sql = "SELECT ctx.*
-                FROM   {$CFG->prefix}context ctx
-                WHERE  ctx.contextlevel=".CONTEXT_COURSECAT."
-                ORDER BY ctx.depth";
-        $rs = get_recordset_sql($sql);
-        $catpaths = array();
-        while ($catctx = rs_fetch_next_record($rs)) {
-            if ($catctx->path != '' 
-                && has_capability_in_accessdata($cap, $catctx, $accessdata, $doanything)) {
-                $catpaths[] = $catctx->path;
-            }
+    $courses = enrol_get_users_courses($userid, true, $fields, $sort);
+    foreach ($courses as $id=>$course) {
+        $context = get_context_instance(CONTEXT_COURSE, $id);
+        if (!has_capability($cap, $context, $userid)) {
+            unset($courses[$id]);
         }
-        rs_close($rs);
-        $catclause = '';
-        if (count($catpaths)) {
-            $cc = count($catpaths);
-            for ($n=0;$n<$cc;$n++) {
-                $catpaths[$n] = "ctx.path LIKE '{$catpaths[$n]}/%'";
             }
-            $catclause = 'WHERE (' . implode(' OR ', $catpaths) .')';
-        }
-        unset($catpaths);
-
-        $capany = '';
-        if ($doanything) {
-            $capany = " OR rc.capability='moodle/site:doanything'";
-        }
-
-        /// UNION 3 queries:
-        /// - user role assignments in courses
-        /// - user capability (override - any status) in courses
-        /// - user right (granted status) in categories (optionally executed)
-        /// Enclosing the 3-UNION into an inline_view to avoid column names conflict and making the ORDER BY cross-db
-        /// and to allow selection of TEXT columns in the query (MSSQL and Oracle limitation). MDL-16209
-        $sql = "
-            SELECT $coursefields, ctxid, ctxpath, ctxdepth, ctxlevel, categorypath 
-              FROM (
-                    SELECT c.id,
-                           ctx.id AS ctxid, ctx.path AS ctxpath,
-                           ctx.depth AS ctxdepth, ctx.contextlevel AS ctxlevel,
-                           cc.path AS categorypath
-                    FROM {$CFG->prefix}course c
-                    JOIN {$CFG->prefix}course_categories cc
-                      ON c.category=cc.id
-                    JOIN {$CFG->prefix}context ctx
-                      ON (c.id=ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSE.")
-                    JOIN {$CFG->prefix}role_assignments ra
-                      ON (ra.contextid=ctx.id AND ra.userid=$userid)
-                    UNION
-                    SELECT c.id,
-                           ctx.id AS ctxid, ctx.path AS ctxpath,
-                           ctx.depth AS ctxdepth, ctx.contextlevel AS ctxlevel,
-                           cc.path AS categorypath
-                    FROM {$CFG->prefix}course c
-                    JOIN {$CFG->prefix}course_categories cc
-                      ON c.category=cc.id
-                    JOIN {$CFG->prefix}context ctx
-                      ON (c.id=ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSE.")
-                    JOIN {$CFG->prefix}role_capabilities rc
-                      ON (rc.contextid=ctx.id AND (rc.capability='$cap' $capany)) ";
-
-        if (!empty($catclause)) { /// If we have found the right in categories, add child courses here too
-            $sql .= "
-                    UNION
-                    SELECT c.id,
-                           ctx.id AS ctxid, ctx.path AS ctxpath,
-                           ctx.depth AS ctxdepth, ctx.contextlevel AS ctxlevel,
-                           cc.path AS categorypath
-                    FROM {$CFG->prefix}course c
-                    JOIN {$CFG->prefix}course_categories cc
-                      ON c.category=cc.id
-                    JOIN {$CFG->prefix}context ctx
-                      ON (c.id=ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSE.")
-                    $catclause";
-        }
-
-    /// Close the inline_view and join with courses table to get requested $coursefields
-        $sql .= "
-                ) inline_view
-                INNER JOIN {$CFG->prefix}course c
-                    ON inline_view.id = c.id";
-
-    /// To keep cross-db we need to strip any prefix in the ORDER BY clause for queries using UNION
-        $sql .= "
-                " . preg_replace('/[a-z]+\./i', '', $sort); /// Add ORDER BY clause
-
-        $rs = get_recordset_sql($sql);
-    }
-
-/// Confirm rights (granted capability) for each course returned
-    $courses = array();
-    $cc = 0; // keep count
-    while ($c = rs_fetch_next_record($rs)) {
-        // build the context obj
-        $c = make_context_subobj($c);
 
-        if (has_capability_in_accessdata($cap, $c->context, $accessdata, $doanything)) {
-            if ($limit > 0 && $cc >= $limit) {
-                break;
-            }
-            
-            $courses[] = $c;
-            $cc++;
-        }
-    }
-    rs_close($rs);
     return $courses;
 }
 
 
 /**
- * It will return a nested array showing role assignments
+ * Return a nested array showing role assignments
  * all relevant role capabilities for the user at
- * site/metacourse/course_category/course levels
+ * site/course_category/course levels
  *
  * We do _not_ delve deeper than courses because the number of
  * overrides at the module/block levels is HUGE.
  *
- * [ra]   => [/path/] = array(roleid, roleid)
+ * [ra]   => [/path/][]=roleid
  * [rdef] => [/path/:roleid][capability]=permission
  * [loaded] => array('/path', '/path')
  *
- * @param $userid integer - the id of the user
- *
+ * @param int $userid - the id of the user
+ * @return array
  */
 function get_user_access_sitewide($userid) {
-
-    global $CFG;
-
-    // this flag has not been set!
-    // (not clean install, or upgraded successfully to 1.7 and up)
-    if (empty($CFG->rolesactive)) {
-        return false;
-    }
+    global $CFG, $DB;
 
     /* Get in 3 cheap DB queries...
-     * - role assignments - with role_caps
+     * - role assignments
      * - relevant role caps
-     *   - above this user's RAs
+     *   - above and within this user's RAs
      *   - below this user's RAs - limited to course level
      */
 
@@ -1168,98 +2117,79 @@ function get_user_access_sitewide($userid) {
     $accessdata['rdef']   = array();
     $accessdata['loaded'] = array();
 
-    $sitectx = get_system_context();
-    $base = '/'.$sitectx->id;
-
     //
-    // Role assignments - and any rolecaps directly linked
-    // because it's cheap to read rolecaps here over many
-    // RAs
+    // Role assignments
     //
-    $sql = "SELECT ctx.path, ra.roleid, rc.capability, rc.permission
-            FROM {$CFG->prefix}role_assignments ra
-            JOIN {$CFG->prefix}context ctx
-               ON ra.contextid=ctx.id
-            LEFT OUTER JOIN {$CFG->prefix}role_capabilities rc
-               ON (rc.roleid=ra.roleid AND rc.contextid=ra.contextid)
-            WHERE ra.userid = $userid AND ctx.contextlevel <= ".CONTEXT_COURSE."
-            ORDER BY ctx.depth, ctx.path, ra.roleid";
-    $rs = get_recordset_sql($sql);
+    $sql = "SELECT ctx.path, ra.roleid
+              FROM {role_assignments} ra
+              JOIN {context} ctx ON ctx.id=ra.contextid
+             WHERE ra.userid = ? AND ctx.contextlevel <= ".CONTEXT_COURSE;
+    $params = array($userid);
+    $rs = $DB->get_recordset_sql($sql, $params);
+
     //
     // raparents collects paths & roles we need to walk up
     // the parenthood to build the rdef
     //
-    // the array will bulk up a bit with dups
-    // which we'll later clear up
-    //
     $raparents = array();
-    $lastseen  = '';
     if ($rs) {
-        while ($ra = rs_fetch_next_record($rs)) {
+        foreach ($rs as $ra) {
             // RAs leafs are arrays to support multi
             // role assignments...
             if (!isset($accessdata['ra'][$ra->path])) {
                 $accessdata['ra'][$ra->path] = array();
             }
-            // only add if is not a repeat caused
-            // by capability join...
-            // (this check is cheaper than in_array())
-            if ($lastseen !== $ra->path.':'.$ra->roleid) {
-                $lastseen = $ra->path.':'.$ra->roleid;
-                array_push($accessdata['ra'][$ra->path], $ra->roleid);
-                $parentids = explode('/', $ra->path);
-                array_shift($parentids); // drop empty leading "context"
-                array_pop($parentids);   // drop _this_ context
+            $accessdata['ra'][$ra->path][$ra->roleid] = $ra->roleid;
 
+            // Concatenate as string the whole path (all related context)
+            // for this role. This is damn faster than using array_merge()
+            // Will unique them later
                 if (isset($raparents[$ra->roleid])) {
-                    $raparents[$ra->roleid] = array_merge($raparents[$ra->roleid],
-                                                          $parentids);
+                $raparents[$ra->roleid] .= $ra->path;
                 } else {
-                    $raparents[$ra->roleid] = $parentids;
-                }
-            }
-            // Always add the roleded
-            if (!empty($ra->capability)) {
-                $k = "{$ra->path}:{$ra->roleid}";
-                $accessdata['rdef'][$k][$ra->capability] = $ra->permission;
+                $raparents[$ra->roleid] = $ra->path;
             }
         }
         unset($ra);
-        rs_close($rs);
+        $rs->close();
     }
 
     // Walk up the tree to grab all the roledefs
     // of interest to our user...
+    //
     // NOTE: we use a series of IN clauses here - which
     // might explode on huge sites with very convoluted nesting of
     // categories... - extremely unlikely that the number of categories
     // and roletypes is so large that we hit the limits of IN()
-    $clauses = array();
-    foreach ($raparents as $roleid=>$contexts) {
-        $contexts = implode(',', array_unique($contexts));
+    $clauses = '';
+    $cparams = array();
+    foreach ($raparents as $roleid=>$strcontexts) {
+        $contexts = implode(',', array_unique(explode('/', trim($strcontexts, '/'))));
         if ($contexts ==! '') {
-            $clauses[] = "(roleid=$roleid AND contextid IN ($contexts))";
+            if ($clauses) {
+                $clauses .= ' OR ';
         }
+            $clauses .= "(roleid=? AND contextid IN ($contexts))";
+            $cparams[] = $roleid;
     }
-    $clauses = implode(" OR ", $clauses);
+    }
+
     if ($clauses !== '') {
         $sql = "SELECT ctx.path, rc.roleid, rc.capability, rc.permission
-                FROM {$CFG->prefix}role_capabilities rc
-                JOIN {$CFG->prefix}context ctx
-                  ON rc.contextid=ctx.id
-                WHERE $clauses
-                ORDER BY ctx.depth ASC, ctx.path DESC, rc.roleid ASC ";
+                  FROM {role_capabilities} rc
+                  JOIN {context} ctx ON rc.contextid=ctx.id
+                 WHERE $clauses";
 
-        $rs = get_recordset_sql($sql);
         unset($clauses);
+        $rs = $DB->get_recordset_sql($sql, $cparams);
 
         if ($rs) {
-            while ($rd = rs_fetch_next_record($rs)) {
+            foreach ($rs as $rd) {
                 $k = "{$rd->path}:{$rd->roleid}";
                 $accessdata['rdef'][$k][$rd->capability] = $rd->permission;
             }
             unset($rd);
-            rs_close($rs);
+            $rs->close();
         }
     }
 
@@ -1274,42 +2204,40 @@ function get_user_access_sitewide($userid) {
     $sql = "SELECT sctx.path, ra.roleid,
                    ctx.path AS parentpath,
                    rco.capability, rco.permission
-            FROM {$CFG->prefix}role_assignments ra
-            JOIN {$CFG->prefix}context ctx
+              FROM {role_assignments} ra
+              JOIN {context} ctx
               ON ra.contextid=ctx.id
-            JOIN {$CFG->prefix}context sctx
-              ON (sctx.path LIKE " . sql_concat('ctx.path',"'/%'"). " )
-            JOIN {$CFG->prefix}role_capabilities rco
+              JOIN {context} sctx
+                   ON (sctx.path LIKE " . $DB->sql_concat('ctx.path',"'/%'"). " )
+              JOIN {role_capabilities} rco
               ON (rco.roleid=ra.roleid AND rco.contextid=sctx.id)
-            WHERE ra.userid = $userid
+             WHERE ra.userid = ?
               AND ctx.contextlevel <= ".CONTEXT_COURSECAT."
               AND sctx.contextlevel <= ".CONTEXT_COURSE."
             ORDER BY sctx.depth, sctx.path, ra.roleid";
-    $rs = get_recordset_sql($sql);
+    $params = array($userid);
+    $rs = $DB->get_recordset_sql($sql, $params);
     if ($rs) {
-        while ($rd = rs_fetch_next_record($rs)) {
+        foreach ($rs as $rd) {
             $k = "{$rd->path}:{$rd->roleid}";
             $accessdata['rdef'][$k][$rd->capability] = $rd->permission;
         }
         unset($rd);
-        rs_close($rs);
+        $rs->close();
     }
     return $accessdata;
 }
 
 /**
- * It add to the access ctrl array the data
- * needed by a user for a given context
+ * Add to the access ctrl array the data needed by a user for a given context
  *
- * @param $userid  integer - the id of the user
- * @param $context context obj - needs path!
- * @param $accessdata array  accessdata array
+ * @param integer $userid the id of the user
+ * @param object $context needs path!
+ * @param array $accessdata accessdata array
+ * @return void
  */
 function load_subcontext($userid, $context, &$accessdata) {
-
-    global $CFG;
-
-
+    global $CFG, $DB;
 
     /* Get the additional RAs and relevant rolecaps
      * - role assignments - with role_caps
@@ -1351,20 +2279,22 @@ function load_subcontext($userid, $context, &$accessdata) {
     // Role assignments in the context and below
     //
     $sql = "SELECT ctx.path, ra.roleid
-            FROM {$CFG->prefix}role_assignments ra
-            JOIN {$CFG->prefix}context ctx
+              FROM {role_assignments} ra
+              JOIN {context} ctx
                ON ra.contextid=ctx.id
-            WHERE ra.userid = $userid
-                  AND (ctx.path = '{$context->path}' OR ctx.path LIKE '{$context->path}/%')
+             WHERE ra.userid = ?
+                   AND (ctx.path = ? OR ctx.path LIKE ?)
             ORDER BY ctx.depth, ctx.path, ra.roleid";
-    $rs = get_recordset_sql($sql);
+    $params = array($userid, $context->path, $context->path."/%");
+    $rs = $DB->get_recordset_sql($sql, $params);
 
     //
     // Read in the RAs, preventing duplicates
     //
+    if ($rs) {
     $localroles = array();
     $lastseen  = '';
-    while ($ra = rs_fetch_next_record($rs)) {
+        foreach ($rs as $ra) {
         if (!isset($accessdata['ra'][$ra->path])) {
             $accessdata['ra'][$ra->path] = array();
         }
@@ -1373,11 +2303,12 @@ function load_subcontext($userid, $context, &$accessdata) {
         // (this check is cheaper than in_array())
         if ($lastseen !== $ra->path.':'.$ra->roleid) {
             $lastseen = $ra->path.':'.$ra->roleid;
-            array_push($accessdata['ra'][$ra->path], $ra->roleid);
+                $accessdata['ra'][$ra->path][$ra->roleid] = $ra->roleid;
             array_push($localroles,           $ra->roleid);
         }
     }
-    rs_close($rs);
+        $rs->close();
+    }
 
     //
     // Walk up and down the tree to grab all the roledefs
@@ -1389,7 +2320,14 @@ function load_subcontext($userid, $context, &$accessdata) {
     $courseroles    = aggregate_roles_from_accessdata($context, $accessdata);
 
     // Do we have any interesting "local" roles?
-    $localroles = array_diff($localroles,$courseroles); // only "new" local roles
+    if ($context->contextlevel <= CONTEXT_COURSE) {
+        // if the target context's context level is higher than the course
+        // level, then we're not guaranteed that we've loaded all the relevant
+        // role definitions, so we want to set $wherelocalroles whenever there
+        // are any $localroles defined
+        $localroles = array_diff($localroles,$courseroles); // only "new" local
+                                                            // roles
+    }
     $wherelocalroles='';
     if (count($localroles)) {
         // Role defs for local roles in 'higher' contexts...
@@ -1406,27 +2344,25 @@ function load_subcontext($userid, $context, &$accessdata) {
         $whereroles = "rc.roleid IN ($roleids) AND";
     }
     $sql = "SELECT ctx.path, rc.roleid, rc.capability, rc.permission
-            FROM {$CFG->prefix}role_capabilities rc
-            JOIN {$CFG->prefix}context ctx
+              FROM {role_capabilities} rc
+              JOIN {context} ctx
              ON rc.contextid=ctx.id
             WHERE ($whereroles
-                    (ctx.id={$context->id} OR ctx.path LIKE '{$context->path}/%'))
+                    (ctx.id=? OR ctx.path LIKE ?))
                     $wherelocalroles
             ORDER BY ctx.depth ASC, ctx.path DESC, rc.roleid ASC ";
+    $params = array($context->id, $context->path."/%");
 
     $newrdefs = array();
-    if ($rs = get_recordset_sql($sql)) {
-        while ($rd = rs_fetch_next_record($rs)) {
+    $rs = $DB->get_recordset_sql($sql, $params);
+    foreach ($rs as $rd) {
             $k = "{$rd->path}:{$rd->roleid}";
             if (!array_key_exists($k, $newrdefs)) {
                 $newrdefs[$k] = array();
             }
             $newrdefs[$k][$rd->capability] = $rd->permission;
         }
-        rs_close($rs);
-    } else {
-        debugging('Bad SQL encountered!');
-    }
+    $rs->close();
 
     compact_rdefs($newrdefs);
     foreach ($newrdefs as $key=>$value) {
@@ -1438,8 +2374,7 @@ function load_subcontext($userid, $context, &$accessdata) {
 }
 
 /**
- * It add to the access ctrl array the data
- * needed by a role for a given context.
+ * Add to the access ctrl array the data needed by a role for a given context.
  *
  * The data is added in the rdef key.
  *
@@ -1447,14 +2382,13 @@ function load_subcontext($userid, $context, &$accessdata) {
  * and to get an overview of what a role gets under a
  * given context and below...
  *
- * @param $roleid  integer - the id of the user
- * @param $context context obj - needs path!
- * @param $accessdata      accessdata array
- *
+ * @param integer $roleid the id of the user
+ * @param object $context needs path!
+ * @param array $accessdata accessdata array null by default
+ * @return array
  */
-function get_role_access_bycontext($roleid, $context, $accessdata=NULL) {
-
-    global $CFG;
+function get_role_access_bycontext($roleid, $context, $accessdata = null) {
+    global $CFG, $DB;
 
     /* Get the relevant rolecaps into rdef
      * - relevant role caps
@@ -1482,35 +2416,37 @@ function get_role_access_bycontext($roleid, $context, $accessdata=NULL) {
     // categories is so large that we hit the limits of IN()
     //
     $sql = "SELECT ctx.path, rc.capability, rc.permission
-            FROM {$CFG->prefix}role_capabilities rc
-            JOIN {$CFG->prefix}context ctx
+              FROM {role_capabilities} rc
+              JOIN {context} ctx
               ON rc.contextid=ctx.id
-            WHERE rc.roleid=$roleid AND
+             WHERE rc.roleid=? AND
                   ( ctx.id IN ($contexts) OR 
-                    ctx.path LIKE '{$context->path}/%' )
+                    ctx.path LIKE ? )
             ORDER BY ctx.depth ASC, ctx.path DESC, rc.roleid ASC ";
+    $params = array($roleid, $context->path."/%");
 
-    $rs = get_recordset_sql($sql);
-    while ($rd = rs_fetch_next_record($rs)) {
+    $rs = $DB->get_recordset_sql($sql, $params);
+    foreach ($rs as $rd) {
         $k = "{$rd->path}:{$roleid}";
         $accessdata['rdef'][$k][$rd->capability] = $rd->permission;
     }
-    rs_close($rs);
+    $rs->close();
 
     return $accessdata;
 }
 
 /**
- * Load accessdata for a user
- * into the $ACCESS global
+ * Load accessdata for a user into the $ACCESSLIB_PRIVATE->accessdatabyuser global
  *
  * Used by has_capability() - but feel free
  * to call it if you are about to run a BIG 
  * cron run across a bazillion users.
  *
+ * @param int $userid
+ * @return array returns ACCESSLIB_PRIVATE->accessdatabyuser[userid]
  */ 
 function load_user_accessdata($userid) {
-    global $ACCESS,$CFG;
+    global $CFG, $ACCESSLIB_PRIVATE;
 
     $base = '/'.SYSCONTEXTID;
 
@@ -1522,10 +2458,9 @@ function load_user_accessdata($userid) {
     if (!empty($CFG->defaultuserroleid)) {
         $accessdata = get_role_access($CFG->defaultuserroleid, $accessdata);
         if (!isset($accessdata['ra'][$base])) {
-            $accessdata['ra'][$base] = array($CFG->defaultuserroleid);
-        } else {
-            array_push($accessdata['ra'][$base], $CFG->defaultuserroleid);
+            $accessdata['ra'][$base] = array();
         }
+        $accessdata['ra'][$base][$CFG->defaultuserroleid] = $CFG->defaultuserroleid;
         $accessdata['dr'] = $CFG->defaultuserroleid;
     }
 
@@ -1536,38 +2471,38 @@ function load_user_accessdata($userid) {
         $base = '/'. SYSCONTEXTID .'/'. $frontpagecontext->id;
         $accessdata = get_default_frontpage_role_access($CFG->defaultfrontpageroleid, $accessdata);
         if (!isset($accessdata['ra'][$base])) {
-            $accessdata['ra'][$base] = array($CFG->defaultfrontpageroleid);
-        } else {
-            array_push($accessdata['ra'][$base], $CFG->defaultfrontpageroleid);
+            $accessdata['ra'][$base] = array();
         }
+        $accessdata['ra'][$base][$CFG->defaultfrontpageroleid] = $CFG->defaultfrontpageroleid;
     }
     // for dirty timestamps in cron
     $accessdata['time'] = time();
 
-    $ACCESS[$userid] = $accessdata;
-    compact_rdefs($ACCESS[$userid]['rdef']);
+    $ACCESSLIB_PRIVATE->accessdatabyuser[$userid] = $accessdata;
+    compact_rdefs($ACCESSLIB_PRIVATE->accessdatabyuser[$userid]['rdef']);
 
-    return true;
+    return $ACCESSLIB_PRIVATE->accessdatabyuser[$userid];
 }
 
 /**
- * Use shared copy of role definistions stored in $RDEFS;
+ * Use shared copy of role definitions stored in ACCESSLIB_PRIVATE->roledefinitions;
+ *
  * @param array $rdefs array of role definitions in contexts
  */
 function compact_rdefs(&$rdefs) {
-    global $RDEFS;
+    global $ACCESSLIB_PRIVATE;
 
     /*
      * This is a basic sharing only, we could also
      * use md5 sums of values. The main purpose is to
-     * reduce mem in cron jobs - many users in $ACCESS array.
+     * reduce mem in cron jobs - many users in $ACCESSLIB_PRIVATE->accessdatabyuser array.
      */
 
     foreach ($rdefs as $key => $value) {
-        if (!array_key_exists($key, $RDEFS)) {
-            $RDEFS[$key] = $rdefs[$key];
+        if (!array_key_exists($key, $ACCESSLIB_PRIVATE->roledefinitions)) {
+            $ACCESSLIB_PRIVATE->roledefinitions[$key] = $rdefs[$key];
         }
-        $rdefs[$key] =& $RDEFS[$key];
+        $rdefs[$key] =& $ACCESSLIB_PRIVATE->roledefinitions[$key];
     }
 }
 
@@ -1576,25 +2511,34 @@ function compact_rdefs(&$rdefs) {
  *  for the current user.   This is what gets called from complete_user_login()
  *  for example. Call it only _after_ you've setup $USER and called
  *  check_enrolment_plugins();
+ * @see check_enrolment_plugins()
  *
+ * @return void
  */
 function load_all_capabilities() {
-    global $USER, $CFG, $DIRTYCONTEXTS;
+    global $CFG, $ACCESSLIB_PRIVATE;
+
+    //NOTE: we can not use $USER here because it may no be linked to $_SESSION['USER'] yet!
+
+    // roles not installed yet - we are in the middle of installation
+    if (during_initial_install()) {
+        return;
+    }
 
     $base = '/'.SYSCONTEXTID;
 
-    if (isguestuser()) {
+    if (isguestuser($_SESSION['USER'])) {
         $guest = get_guest_role();
 
         // Load the rdefs
-        $USER->access = get_role_access($guest->id);
+        $_SESSION['USER']->access = get_role_access($guest->id);
         // Put the ghost enrolment in place...
-        $USER->access['ra'][$base] = array($guest->id);
+        $_SESSION['USER']->access['ra'][$base] = array($guest->id => $guest->id);
 
 
-    } else if (isloggedin()) {
+    } else if (!empty($_SESSION['USER']->id)) { // can not use isloggedin() yet
 
-        $accessdata = get_user_access_sitewide($USER->id);
+        $accessdata = get_user_access_sitewide($_SESSION['USER']->id);
 
         //
         // provide "default role" & set 'dr'
@@ -1602,10 +2546,9 @@ function load_all_capabilities() {
         if (!empty($CFG->defaultuserroleid)) {
             $accessdata = get_role_access($CFG->defaultuserroleid, $accessdata);
             if (!isset($accessdata['ra'][$base])) {
-                $accessdata['ra'][$base] = array($CFG->defaultuserroleid);
-            } else {
-                array_push($accessdata['ra'][$base], $CFG->defaultuserroleid);
+                $accessdata['ra'][$base] = array();
             }
+            $accessdata['ra'][$base][$CFG->defaultuserroleid] = $CFG->defaultuserroleid;
             $accessdata['dr'] = $CFG->defaultuserroleid;
         }
 
@@ -1618,24 +2561,23 @@ function load_all_capabilities() {
             $base = '/'. SYSCONTEXTID .'/'. $frontpagecontext->id;
             $accessdata = get_default_frontpage_role_access($CFG->defaultfrontpageroleid, $accessdata);
             if (!isset($accessdata['ra'][$base])) {
-                $accessdata['ra'][$base] = array($CFG->defaultfrontpageroleid);
-            } else {
-                array_push($accessdata['ra'][$base], $CFG->defaultfrontpageroleid);
+                $accessdata['ra'][$base] = array();
             }
+            $accessdata['ra'][$base][$CFG->defaultfrontpageroleid] = $CFG->defaultfrontpageroleid;
         } 
-        $USER->access = $accessdata;
+        $_SESSION['USER']->access = $accessdata;
     
     } else if (!empty($CFG->notloggedinroleid)) {
-        $USER->access = get_role_access($CFG->notloggedinroleid);
-        $USER->access['ra'][$base] = array($CFG->notloggedinroleid);
+        $_SESSION['USER']->access = get_role_access($CFG->notloggedinroleid);
+        $_SESSION['USER']->access['ra'][$base] = array($CFG->notloggedinroleid => $CFG->notloggedinroleid);
     }
 
     // Timestamp to read dirty context timestamps later
-    $USER->access['time'] = time();
-    $DIRTYCONTEXTS = array();
+    $_SESSION['USER']->access['time'] = time();
+    $ACCESSLIB_PRIVATE->dirtycontexts = array();
 
     // Clear to force a refresh
-    unset($USER->mycourses);
+    unset($_SESSION['USER']->mycourses);
 }
 
 /**
@@ -1647,9 +2589,10 @@ function load_all_capabilities() {
  * 
  * Note: rewrites $USER->access completely.
  *
+ * @return void
  */
 function reload_all_capabilities() {
-    global $USER,$CFG;
+    global $USER, $DB;
 
     // error_log("reloading");
     // copy switchroles
@@ -1665,13 +2608,13 @@ function reload_all_capabilities() {
     load_all_capabilities();
 
     foreach ($sw as $path => $roleid) {
-        $context = get_record('context', 'path', $path);
+        $context = $DB->get_record('context', array('path'=>$path));
         role_switch($roleid, $context);
     }
 
 }
 
-/*
+/**
  * Adds a temp role to an accessdata array.
  *
  * Useful for the "temporary guest" access
@@ -1679,10 +2622,13 @@ function reload_all_capabilities() {
  *
  * Note - assumes a course context!
  *
+ * @param object $content
+ * @param int $roleid
+ * @param array $accessdata
+ * @return array Returns access data
  */
-function load_temp_role($context, $roleid, $accessdata) {
-
-    global $CFG;
+function load_temp_role($context, $roleid, array $accessdata) {
+    global $CFG, $DB;
 
     //
     // Load rdefs for the role in -
@@ -1695,21 +2641,21 @@ function load_temp_role($context, $roleid, $accessdata) {
     $contexts = substr($context->path, 1); // kill leading slash
     $contexts = str_replace('/', ',', $contexts);
 
-    $sql = "SELECT ctx.path,
-                   rc.capability, rc.permission
-            FROM {$CFG->prefix}context ctx
-            JOIN {$CFG->prefix}role_capabilities rc
+    $sql = "SELECT ctx.path, rc.capability, rc.permission
+              FROM {context} ctx
+              JOIN {role_capabilities} rc
               ON rc.contextid=ctx.id
             WHERE (ctx.id IN ($contexts)
-                   OR ctx.path LIKE '{$context->path}/%')
-                  AND rc.roleid = {$roleid}
+                    OR ctx.path LIKE ?)
+                   AND rc.roleid = ?
             ORDER BY ctx.depth, ctx.path";
-    $rs = get_recordset_sql($sql);
-    while ($rd = rs_fetch_next_record($rs)) {
+    $params = array($context->path."/%", $roleid);
+    $rs = $DB->get_recordset_sql($sql, $params);
+    foreach ($rs as $rd) {
         $k = "{$rd->path}:{$roleid}";
         $accessdata['rdef'][$k][$rd->capability] = $rd->permission;
     }
-    rs_close($rs);
+    $rs->close();
 
     //
     // Say we loaded everything for the course context
@@ -1722,539 +2668,202 @@ function load_temp_role($context, $roleid, $accessdata) {
     //
     // Add the ghost RA
     //
-    if (isset($accessdata['ra'][$context->path])) {
-        array_push($accessdata['ra'][$context->path], $roleid);
-    } else {
-        $accessdata['ra'][$context->path] = array($roleid);
+    if (!isset($accessdata['ra'][$context->path])) {
+        $accessdata['ra'][$context->path] = array();
     }
+    $accessdata['ra'][$context->path][$roleid] = $roleid;
 
     return $accessdata;
 }
 
-
-/**
- * Check all the login enrolment information for the given user object
- * by querying the enrolment plugins
- */
-function check_enrolment_plugins(&$user) {
-    global $CFG;
-
-    static $inprogress;  // To prevent this function being called more than once in an invocation
-
-    if (!empty($inprogress[$user->id])) {
-        return;
-    }
-
-    $inprogress[$user->id] = true;  // Set the flag
-
-    require_once($CFG->dirroot .'/enrol/enrol.class.php');
-
-    if (!($plugins = explode(',', $CFG->enrol_plugins_enabled))) {
-        $plugins = array($CFG->enrol);
-    }
-
-    foreach ($plugins as $plugin) {
-        $enrol = enrolment_factory::factory($plugin);
-        if (method_exists($enrol, 'setup_enrolments')) {  /// Plugin supports Roles (Moodle 1.7 and later)
-            $enrol->setup_enrolments($user);
-        } else {                                          /// Run legacy enrolment methods
-            if (method_exists($enrol, 'get_student_courses')) {
-                $enrol->get_student_courses($user);
-            }
-            if (method_exists($enrol, 'get_teacher_courses')) {
-                $enrol->get_teacher_courses($user);
-            }
-
-        /// deal with $user->students and $user->teachers stuff
-            unset($user->student);
-            unset($user->teacher);
-        }
-        unset($enrol);
-    }
-
-    unset($inprogress[$user->id]);  // Unset the flag
-}
-
 /**
- * Installs the roles system.
- * This function runs on a fresh install as well as on an upgrade from the old
- * hard-coded student/teacher/admin etc. roles to the new roles system.
+ * Removes any extra guest roles from accessdata
+ * @param object $context
+ * @param array $accessdata
+ * @return array access data
  */
-function moodle_install_roles() {
-
-    global $CFG, $db;
-
-/// Create a system wide context for assignemnt.
-    $systemcontext = $context = get_context_instance(CONTEXT_SYSTEM);
-
-
-/// Create default/legacy roles and capabilities.
-/// (1 legacy capability per legacy role at system level).
-
-    $adminrole          = create_role(addslashes(get_string('administrator')), 'admin',
-                                      addslashes(get_string('administratordescription')), 'moodle/legacy:admin');
-    $coursecreatorrole  = create_role(addslashes(get_string('coursecreators')), 'coursecreator',
-                                      addslashes(get_string('coursecreatorsdescription')), 'moodle/legacy:coursecreator');
-    $editteacherrole    = create_role(addslashes(get_string('defaultcourseteacher')), 'editingteacher',
-                                      addslashes(get_string('defaultcourseteacherdescription')), 'moodle/legacy:editingteacher');
-    $noneditteacherrole = create_role(addslashes(get_string('noneditingteacher')), 'teacher',
-                                      addslashes(get_string('noneditingteacherdescription')), 'moodle/legacy:teacher');
-    $studentrole        = create_role(addslashes(get_string('defaultcoursestudent')), 'student',
-                                      addslashes(get_string('defaultcoursestudentdescription')), 'moodle/legacy:student');
-    $guestrole          = create_role(addslashes(get_string('guest')), 'guest',
-                                      addslashes(get_string('guestdescription')), 'moodle/legacy:guest');
-    $userrole           = create_role(addslashes(get_string('authenticateduser')), 'user',
-                                      addslashes(get_string('authenticateduserdescription')), 'moodle/legacy:user');
-
-/// Now is the correct moment to install capabilities - after creation of legacy roles, but before assigning of roles
-
-    if (!assign_capability('moodle/site:doanything', CAP_ALLOW, $adminrole, $systemcontext->id)) {
-        error('Could not assign moodle/site:doanything to the admin role');
-    }
-    if (!update_capabilities()) {
-        error('Had trouble upgrading the core capabilities for the Roles System');
-    }
-
-/// Look inside user_admin, user_creator, user_teachers, user_students and
-/// assign above new roles. If a user has both teacher and student role,
-/// only teacher role is assigned. The assignment should be system level.
-
-    $dbtables = $db->MetaTables('TABLES');
-
-/// Set up the progress bar
-
-    $usertables = array('user_admins', 'user_coursecreators', 'user_teachers', 'user_students');
-
-    $totalcount = $progresscount = 0;
-    foreach ($usertables as $usertable) {
-        if (in_array($CFG->prefix.$usertable, $dbtables)) {
-             $totalcount += count_records($usertable);
-        }
-    }
-
-    print_progress(0, $totalcount, 5, 1, 'Processing role assignments');
-
-/// Upgrade the admins.
-/// Sort using id ASC, first one is primary admin.
-
-    if (in_array($CFG->prefix.'user_admins', $dbtables)) {
-        if ($rs = get_recordset_sql('SELECT * from '.$CFG->prefix.'user_admins ORDER BY ID ASC')) {
-            while ($admin = rs_fetch_next_record($rs)) {
-                role_assign($adminrole, $admin->userid, 0, $systemcontext->id);
-                $progresscount++;
-                print_progress($progresscount, $totalcount, 5, 1, 'Processing role assignments');
-            }
-            rs_close($rs);
-        }
-    } else {
-        // This is a fresh install.
-    }
-
-
-/// Upgrade course creators.
-    if (in_array($CFG->prefix.'user_coursecreators', $dbtables)) {
-        if ($rs = get_recordset('user_coursecreators')) {
-            while ($coursecreator = rs_fetch_next_record($rs)) {
-                role_assign($coursecreatorrole, $coursecreator->userid, 0, $systemcontext->id);
-                $progresscount++;
-                print_progress($progresscount, $totalcount, 5, 1, 'Processing role assignments');
-            }
-            rs_close($rs);
-        }
-    }
-
-
-/// Upgrade editting teachers and non-editting teachers.
-    if (in_array($CFG->prefix.'user_teachers', $dbtables)) {
-        if ($rs = get_recordset('user_teachers')) {
-            while ($teacher = rs_fetch_next_record($rs)) {
-
-                // removed code here to ignore site level assignments
-                // since the contexts are separated now
-
-                // populate the user_lastaccess table
-                $access = new object();
-                $access->timeaccess = $teacher->timeaccess;
-                $access->userid = $teacher->userid;
-                $access->courseid = $teacher->course;
-                insert_record('user_lastaccess', $access);
-
-                // assign the default student role
-                $coursecontext = get_context_instance(CONTEXT_COURSE, $teacher->course); // needs cache
-                // hidden teacher
-                if ($teacher->authority == 0) {
-                    $hiddenteacher = 1;
-                } else {
-                    $hiddenteacher = 0;
-                }
-
-                if ($teacher->editall) { // editting teacher
-                    role_assign($editteacherrole, $teacher->userid, 0, $coursecontext->id, $teacher->timestart, $teacher->timeend, $hiddenteacher, $teacher->enrol, $teacher->timemodified);
+function remove_temp_roles($context, array $accessdata) {
+    global $DB, $USER;
+    $sql = "SELECT DISTINCT ra.roleid AS id
+              FROM {role_assignments} ra
+             WHERE ra.contextid = :contextid AND ra.userid = :userid";
+    $ras = $DB->get_records_sql($sql, array('contextid'=>$context->id, 'userid'=>$USER->id));
+
+    if ($ras) {
+        $accessdata['ra'][$context->path] = array_combine(array_keys($ras), array_keys($ras));
                 } else {
-                    role_assign($noneditteacherrole, $teacher->userid, 0, $coursecontext->id, $teacher->timestart, $teacher->timeend, $hiddenteacher, $teacher->enrol, $teacher->timemodified);
-                }
-                $progresscount++;
-                print_progress($progresscount, $totalcount, 5, 1, 'Processing role assignments');
-            }
-            rs_close($rs);
-        }
+        $accessdata['ra'][$context->path] = array();
     }
 
-
-/// Upgrade students.
-    if (in_array($CFG->prefix.'user_students', $dbtables)) {
-        if ($rs = get_recordset('user_students')) {
-            while ($student = rs_fetch_next_record($rs)) {
-
-                // populate the user_lastaccess table
-                $access = new object;
-                $access->timeaccess = $student->timeaccess;
-                $access->userid = $student->userid;
-                $access->courseid = $student->course;
-                insert_record('user_lastaccess', $access);
-
-                // assign the default student role
-                $coursecontext = get_context_instance(CONTEXT_COURSE, $student->course);
-                role_assign($studentrole, $student->userid, 0, $coursecontext->id, $student->timestart, $student->timeend, 0, $student->enrol, $student->time);
-                $progresscount++;
-                print_progress($progresscount, $totalcount, 5, 1, 'Processing role assignments');
-            }
-            rs_close($rs);
-        }
-    }
-
-
-/// Upgrade guest (only 1 entry).
-    if ($guestuser = get_record('user', 'username', 'guest')) {
-        role_assign($guestrole, $guestuser->id, 0, $systemcontext->id);
-    }
-    print_progress($totalcount, $totalcount, 5, 1, 'Processing role assignments');
-
-
-/// Insert the correct records for legacy roles
-    allow_assign($adminrole, $adminrole);
-    allow_assign($adminrole, $coursecreatorrole);
-    allow_assign($adminrole, $noneditteacherrole);
-    allow_assign($adminrole, $editteacherrole);
-    allow_assign($adminrole, $studentrole);
-    allow_assign($adminrole, $guestrole);
-
-    allow_assign($coursecreatorrole, $noneditteacherrole);
-    allow_assign($coursecreatorrole, $editteacherrole);
-    allow_assign($coursecreatorrole, $studentrole);
-    allow_assign($coursecreatorrole, $guestrole);
-
-    allow_assign($editteacherrole, $noneditteacherrole);
-    allow_assign($editteacherrole, $studentrole);
-    allow_assign($editteacherrole, $guestrole);
-
-/// Set up default allow override matrix
-    allow_override($adminrole, $adminrole);
-    allow_override($adminrole, $coursecreatorrole);
-    allow_override($adminrole, $noneditteacherrole);
-    allow_override($adminrole, $editteacherrole);
-    allow_override($adminrole, $studentrole);
-    allow_override($adminrole, $guestrole);
-    allow_override($adminrole, $userrole);
-
-    //See MDL-15841
-    //allow_override($editteacherrole, $noneditteacherrole);
-    //allow_override($editteacherrole, $studentrole);
-    //allow_override($editteacherrole, $guestrole);
-
-
-/// Delete the old user tables when we are done
-
-    $tables = array('user_students', 'user_teachers', 'user_coursecreators', 'user_admins');  
-    foreach ($tables as $tablename) {
-        $table = new XMLDBTable($tablename);
-        if (table_exists($table)) {
-            drop_table($table);
-        }
-    }
+    return $accessdata;
 }
 
 /**
- * Returns array of all legacy roles.
+ * Returns array of all role archetypes.
+ *
+ * @return array
  */
-function get_legacy_roles() {
+function get_role_archetypes() {
     return array(
-        'admin'          => 'moodle/legacy:admin',
-        'coursecreator'  => 'moodle/legacy:coursecreator',
-        'editingteacher' => 'moodle/legacy:editingteacher',
-        'teacher'        => 'moodle/legacy:teacher',
-        'student'        => 'moodle/legacy:student',
-        'guest'          => 'moodle/legacy:guest',
-        'user'           => 'moodle/legacy:user'
+        'manager'        => 'manager',
+        'coursecreator'  => 'coursecreator',
+        'editingteacher' => 'editingteacher',
+        'teacher'        => 'teacher',
+        'student'        => 'student',
+        'guest'          => 'guest',
+        'user'           => 'user',
+        'frontpage'      => 'frontpage'
     );
 }
 
-function get_legacy_type($roleid) {
-    $sitecontext = get_context_instance(CONTEXT_SYSTEM);
-    $legacyroles = get_legacy_roles();
-
-    $result = '';
-    foreach($legacyroles as $ltype=>$lcap) {
-        $localoverride = get_local_override($roleid, $sitecontext->id, $lcap);
-        if (!empty($localoverride->permission) and $localoverride->permission == CAP_ALLOW) {
-            //choose first selected legacy capability - reset the rest
-            if (empty($result)) {
-                $result = $ltype;
-            } else {
-                unassign_capability($lcap, $roleid);
-            }
-        }
-    }
-
-    return $result;
-}
-
 /**
- * Assign the defaults found in this capabality definition to roles that have
+ * Assign the defaults found in this capability definition to roles that have
  * the corresponding legacy capabilities assigned to them.
- * @param $legacyperms - an array in the format (example):
+ *
+ * @param string $capability
+ * @param array $legacyperms an array in the format (example):
  *                      'guest' => CAP_PREVENT,
  *                      'student' => CAP_ALLOW,
  *                      'teacher' => CAP_ALLOW,
  *                      'editingteacher' => CAP_ALLOW,
  *                      'coursecreator' => CAP_ALLOW,
- *                      'admin' => CAP_ALLOW
- * @return boolean - success or failure.
+ *                      'manager' => CAP_ALLOW
+ * @return boolean success or failure.
  */
 function assign_legacy_capabilities($capability, $legacyperms) {
 
-    $legacyroles = get_legacy_roles();
+    $archetypes = get_role_archetypes();
 
     foreach ($legacyperms as $type => $perm) {
 
-        $systemcontext = get_context_instance(CONTEXT_SYSTEM);
-
-        if (!array_key_exists($type, $legacyroles)) {
-            error('Incorrect legacy role definition for type: '.$type);
-        }
-
-        if ($roles = get_roles_with_capability($legacyroles[$type], CAP_ALLOW)) {
-            foreach ($roles as $role) {
-                // Assign a site level capability.
-                if (!assign_capability($capability, $perm, $role->id, $systemcontext->id)) {
-                    return false;
-                }
-            }
-        }
-    }
-    return true;
-}
-
-
-/**
- * Checks to see if a capability is a legacy capability.
- * @param $capabilityname
- * @return boolean
- */
-function islegacy($capabilityname) {
-    if (strpos($capabilityname, 'moodle/legacy') === 0) {
-        return true;
-    } else {
-        return false;
-    }
-}
-
-
-
-/**********************************
- * Context Manipulation functions *
- **********************************/
-
-/**
- * Create a new context record for use by all roles-related stuff
- * assumes that the caller has done the homework.
- *
- * @param $level
- * @param $instanceid
- *
- * @return object newly created context
- */
-function create_context($contextlevel, $instanceid) {
-
-    global $CFG;
-
-    if ($contextlevel == CONTEXT_SYSTEM) {
-        return create_system_context();
-    }
-
-    $context = new object();
-    $context->contextlevel = $contextlevel;
-    $context->instanceid = $instanceid;
-
-    // Define $context->path based on the parent
-    // context. In other words... Who is your daddy?
-    $basepath  = '/' . SYSCONTEXTID;
-    $basedepth = 1;
-
-    $result = true;
-
-    switch ($contextlevel) {
-        case CONTEXT_COURSECAT:
-            $sql = "SELECT ctx.path, ctx.depth 
-                    FROM {$CFG->prefix}context           ctx
-                    JOIN {$CFG->prefix}course_categories cc
-                      ON (cc.parent=ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSECAT.")
-                    WHERE cc.id={$instanceid}";
-            if ($p = get_record_sql($sql)) {
-                $basepath  = $p->path;
-                $basedepth = $p->depth;
-            } else if ($category = get_record('course_categories', 'id', $instanceid)) {
-                if (empty($category->parent)) {
-                    // ok - this is a top category
-                } else if ($parent = get_context_instance(CONTEXT_COURSECAT, $category->parent)) {
-                    $basepath  = $parent->path;
-                    $basedepth = $parent->depth;
-                } else {
-                    // wrong parent category - no big deal, this can be fixed later
-                    $basepath  = null;
-                    $basedepth = 0;
-                }
-            } else {
-                // incorrect category id
-                $result = false;
-            }
-            break;
-
-        case CONTEXT_COURSE:
-            $sql = "SELECT ctx.path, ctx.depth
-                    FROM {$CFG->prefix}context           ctx
-                    JOIN {$CFG->prefix}course            c
-                      ON (c.category=ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSECAT.")
-                    WHERE c.id={$instanceid} AND c.id !=" . SITEID;
-            if ($p = get_record_sql($sql)) {
-                $basepath  = $p->path;
-                $basedepth = $p->depth;
-            } else if ($course = get_record('course', 'id', $instanceid)) {
-                if ($course->id == SITEID) {
-                    //ok - no parent category
-                } else if ($parent = get_context_instance(CONTEXT_COURSECAT, $course->category)) {
-                    $basepath  = $parent->path;
-                    $basedepth = $parent->depth;
-                } else {
-                    // wrong parent category of course - no big deal, this can be fixed later
-                    $basepath  = null;
-                    $basedepth = 0;
-                }
-            } else if ($instanceid == SITEID) {
-                // no errors for missing site course during installation
-                return false;
-            } else {
-                // incorrect course id
-                $result = false;
-            }
-            break;
-
-        case CONTEXT_MODULE:
-            $sql = "SELECT ctx.path, ctx.depth
-                    FROM {$CFG->prefix}context           ctx
-                    JOIN {$CFG->prefix}course_modules    cm
-                      ON (cm.course=ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSE.")
-                    WHERE cm.id={$instanceid}";
-            if ($p = get_record_sql($sql)) {
-                $basepath  = $p->path;
-                $basedepth = $p->depth;
-            } else if ($cm = get_record('course_modules', 'id', $instanceid)) {
-                if ($parent = get_context_instance(CONTEXT_COURSE, $cm->course)) {
-                    $basepath  = $parent->path;
-                    $basedepth = $parent->depth;
-                } else {
-                    // course does not exist - modules can not exist without a course
-                    $result = false;
-                }
-            } else {
-                // cm does not exist
-                $result = false;
+        $systemcontext = get_context_instance(CONTEXT_SYSTEM);
+        if ($type === 'admin') {
+            debugging('Legacy type admin in access.php was renamed to manager, please update the code.');
+            $type = 'manager';
             }
-            break;
 
-        case CONTEXT_BLOCK:
-            // Only non-pinned & course-page based
-            $sql = "SELECT ctx.path, ctx.depth
-                    FROM {$CFG->prefix}context           ctx
-                    JOIN {$CFG->prefix}block_instance    bi
-                      ON (bi.pageid=ctx.instanceid AND ctx.contextlevel=".CONTEXT_COURSE.")
-                    WHERE bi.id={$instanceid} AND bi.pagetype='course-view'";
-            if ($p = get_record_sql($sql)) {
-                $basepath  = $p->path;
-                $basedepth = $p->depth;
-            } else if ($bi = get_record('block_instance', 'id', $instanceid)) {
-                if ($bi->pagetype != 'course-view') {
-                    // ok - not a course block
-                } else if ($parent = get_context_instance(CONTEXT_COURSE, $bi->pageid)) {
-                    $basepath  = $parent->path;
-                    $basedepth = $parent->depth;
-                } else {
-                    // parent course does not exist - course blocks can not exist without a course
-                    $result = false;
+        if (!array_key_exists($type, $archetypes)) {
+            print_error('invalidlegacy', '', '', $type);
                 }
-            } else {
-                // block does not exist
-                $result = false;
+
+        if ($roles = get_archetype_roles($type)) {
+            foreach ($roles as $role) {
+                // Assign a site level capability.
+                if (!assign_capability($capability, $perm, $role->id, $systemcontext->id)) {
+                    return false;
             }
-            break;
-        case CONTEXT_USER:
-            // default to basepath
-            break;
     }
+        }
+    }
+    return true;
+}
+
+/**
+ * @param object $capability a capability - a row from the capabilities table.
+ * @return boolean whether this capability is safe - that is, whether people with the
+ *      safeoverrides capability should be allowed to change it.
+ */
+function is_safe_capability($capability) {
+    return !((RISK_DATALOSS | RISK_MANAGETRUST | RISK_CONFIG | RISK_XSS | RISK_PERSONAL) & $capability->riskbitmask);
+}
+
+/**********************************
+ * Context Manipulation functions *
+ **********************************/
+
+/**
+ * Context creation - internal implementation.
+ *
+ * Create a new context record for use by all roles-related stuff
+ * assumes that the caller has done the homework.
+ *
+ * DO NOT CALL THIS DIRECTLY, instead use {@link get_context_instance}!
+ *
+ * @param int $contextlevel
+ * @param int $instanceid
+ * @param int $strictness
+ * @return object newly created context
+ */
+function create_context($contextlevel, $instanceid, $strictness = IGNORE_MISSING) {
+    global $CFG, $DB;
+
+    if ($contextlevel == CONTEXT_SYSTEM) {
+        return get_system_context();
+    }
+
+    $context = new stdClass();
+    $context->contextlevel = $contextlevel;
+    $context->instanceid = $instanceid;
+
+    // Define $context->path based on the parent
+    // context. In other words... Who is your daddy?
+    $basepath  = '/' . SYSCONTEXTID;
+    $basedepth = 1;
+
+    $result = true;
+    $error_message = null;
+
+    list($result, $basepath, $basedepth, $error_message) = context_level_base::get_context_level($contextlevel)->get_context_info($instanceid, $strictness);
 
     // if grandparents unknown, maybe rebuild_context_path() will solve it later
     if ($basedepth != 0) {
         $context->depth = $basedepth+1;
     }
 
-    if ($result and $id = insert_record('context', $context)) {
-        // can't set the full path till we know the id!
-        if ($basedepth != 0 and !empty($basepath)) {
-            set_field('context', 'path', $basepath.'/'. $id, 'id', $id);
-        }
-        return get_context_instance_by_id($id);
-
-    } else {
+    if (!$result) {
         debugging('Error: could not insert new context level "'.
                   s($contextlevel).'", instance "'.
-                  s($instanceid).'".');
+                  s($instanceid).'". ' . $error_message);
+
         return false;
     }
+
+    $id = $DB->insert_record('context', $context);
+    // can't set the full path till we know the id!
+    if ($basedepth != 0 and !empty($basepath)) {
+        $DB->set_field('context', 'path', $basepath.'/'. $id, array('id'=>$id));
+    }
+    return get_context_instance_by_id($id);
 }
 
 /**
- * This hacky function is needed because we can not change system context instanceid using normal upgrade routine.
+ * Returns system context or null if can not be created yet.
+ *
+ * @param bool $cache use caching
+ * @return mixed system context or null
  */
-function get_system_context($cache=true) {
-    static $cached = null;
+function get_system_context($cache = true) {
+    global $DB, $ACCESSLIB_PRIVATE;
     if ($cache and defined('SYSCONTEXTID')) {
-        if (is_null($cached)) {
-            $cached = new object();
-            $cached->id           = SYSCONTEXTID;
-            $cached->contextlevel = CONTEXT_SYSTEM;
-            $cached->instanceid   = 0;
-            $cached->path         = '/'.SYSCONTEXTID;
-            $cached->depth        = 1;
+        if (is_null($ACCESSLIB_PRIVATE->systemcontext)) {
+            $ACCESSLIB_PRIVATE->systemcontext = new stdClass();
+            $ACCESSLIB_PRIVATE->systemcontext->id           = SYSCONTEXTID;
+            $ACCESSLIB_PRIVATE->systemcontext->contextlevel = CONTEXT_SYSTEM;
+            $ACCESSLIB_PRIVATE->systemcontext->instanceid   = 0;
+            $ACCESSLIB_PRIVATE->systemcontext->path         = '/'.SYSCONTEXTID;
+            $ACCESSLIB_PRIVATE->systemcontext->depth        = 1;
         }
-        return $cached;
+        return $ACCESSLIB_PRIVATE->systemcontext;
+    }
+    try {
+        $context = $DB->get_record('context', array('contextlevel'=>CONTEXT_SYSTEM));
+    } catch (dml_exception $e) {
+        //table does not exist yet, sorry
+        return null;
     }
 
-    if (!$context = get_record('context', 'contextlevel', CONTEXT_SYSTEM)) {
-        $context = new object();
+    if (!$context) {
+        $context = new stdClass();
         $context->contextlevel = CONTEXT_SYSTEM;
         $context->instanceid   = 0;
         $context->depth        = 1;
-        $context->path         = NULL; //not known before insert
+        $context->path         = null; //not known before insert
 
-        if (!$context->id = insert_record('context', $context)) {
-            // better something than nothing - let's hope it will work somehow
-            if (!defined('SYSCONTEXTID')) {
-                define('SYSCONTEXTID', 1);
-            }
-            debugging('Can not create system context');
-            $context->id   = SYSCONTEXTID;
-            $context->path = '/'.SYSCONTEXTID;
-            return $context;
+        try {
+            $context->id = $DB->insert_record('context', $context);
+        } catch (dml_exception $e) {
+            // can not create context yet, sorry
+            return null;
         }
     }
 
@@ -2262,61 +2871,80 @@ function get_system_context($cache=true) {
         $context->instanceid   = 0;
         $context->path         = '/'.$context->id;
         $context->depth        = 1;
-        update_record('context', $context);
+        $DB->update_record('context', $context);
     }
 
     if (!defined('SYSCONTEXTID')) {
         define('SYSCONTEXTID', $context->id);
     }
 
-    $cached = $context;
-    return $cached;
+    $ACCESSLIB_PRIVATE->systemcontext = $context;
+    return $ACCESSLIB_PRIVATE->systemcontext;
 }
 
 /**
  * Remove a context record and any dependent entries,
  * removes context from static context cache too
- * @param $level
- * @param $instanceid
  *
- * @return bool properly deleted
+ * @param int $level
+ * @param int $instanceid
+ * @param bool $deleterecord false means keep record for now
+ * @return bool returns true or throws an exception
  */
-function delete_context($contextlevel, $instanceid) {
-    global $context_cache, $context_cache_id;
+function delete_context($contextlevel, $instanceid, $deleterecord = true) {
+    global $DB, $ACCESSLIB_PRIVATE, $CFG;
 
     // do not use get_context_instance(), because the related object might not exist,
     // or the context does not exist yet and it would be created now
-    if ($context = get_record('context', 'contextlevel', $contextlevel, 'instanceid', $instanceid)) {
-        $result = delete_records('role_assignments', 'contextid', $context->id) &&
-                  delete_records('role_capabilities', 'contextid', $context->id) &&
-                  delete_records('role_names', 'contextid', $context->id) &&
-                  delete_records('context', 'id', $context->id);
+    if ($context = $DB->get_record('context', array('contextlevel'=>$contextlevel, 'instanceid'=>$instanceid))) {
+        // delete these first because they might fetch the context and try to recreate it!
+        blocks_delete_all_for_context($context->id);
+        filter_delete_all_for_context($context->id);
+
+        require_once($CFG->dirroot . '/comment/lib.php');
+        comment::delete_comments(array('contextid'=>$context->id));
+
+        require_once($CFG->dirroot.'/rating/lib.php');
+        $delopt = new stdclass();
+        $delopt->contextid = $context->id;
+        $rm = new rating_manager();
+        $rm->delete_ratings($delopt);
+
+        // delete all files attached to this context
+        $fs = get_file_storage();
+        $fs->delete_area_files($context->id);
+
+        // now delete stuff from role related tables, role_unassign_all
+        // and unenrol should be called earlier to do proper cleanup
+        $DB->delete_records('role_assignments', array('contextid'=>$context->id));
+        $DB->delete_records('role_capabilities', array('contextid'=>$context->id));
+        $DB->delete_records('role_names', array('contextid'=>$context->id));
+
+        // and finally it is time to delete the context record if requested
+        if ($deleterecord) {
+            $DB->delete_records('context', array('id'=>$context->id));
+            // purge static context cache if entry present
+            $ACCESSLIB_PRIVATE->contexcache->remove($context);
+        }
 
         // do not mark dirty contexts if parents unknown
         if (!is_null($context->path) and $context->depth > 0) {
             mark_context_dirty($context->path);
         }
-
-        // purge static context cache if entry present
-        unset($context_cache[$contextlevel][$instanceid]);
-        unset($context_cache_id[$context->id]);
-
-        return $result;
-    } else {
+    }
 
         return true;
-    }
 }
 
 /**
  * Precreates all contexts including all parents
- * @param int $contextlevel, empty means all
+ *
+ * @param int $contextlevel empty means all
  * @param bool $buildpaths update paths and depths
- * @param bool $feedback show sql feedback
  * @return void
  */
-function create_contexts($contextlevel=null, $buildpaths=true, $feedback=false) {
-    global $CFG;
+function create_contexts($contextlevel = null, $buildpaths = true) {
+    global $DB;
 
     //make sure system context exists
     $syscontext = get_system_context(false);
@@ -2325,63 +2953,65 @@ function create_contexts($contextlevel=null, $buildpaths=true, $feedback=false)
                              or $contextlevel == CONTEXT_COURSE
                              or $contextlevel == CONTEXT_MODULE
                              or $contextlevel == CONTEXT_BLOCK) {
-        $sql = "INSERT INTO {$CFG->prefix}context (contextlevel, instanceid)
+        $sql = "INSERT INTO {context} (contextlevel, instanceid)
                 SELECT ".CONTEXT_COURSECAT.", cc.id
-                  FROM  {$CFG->prefix}course_categories cc
+                  FROM {course}_categories cc
                  WHERE NOT EXISTS (SELECT 'x'
-                                     FROM {$CFG->prefix}context cx
+                                     FROM {context} cx
                                     WHERE cc.id = cx.instanceid AND cx.contextlevel=".CONTEXT_COURSECAT.")";
-        execute_sql($sql, $feedback);
+        $DB->execute($sql);
 
     }
 
     if (empty($contextlevel) or $contextlevel == CONTEXT_COURSE
                              or $contextlevel == CONTEXT_MODULE
                              or $contextlevel == CONTEXT_BLOCK) {
-        $sql = "INSERT INTO {$CFG->prefix}context (contextlevel, instanceid)
+        $sql = "INSERT INTO {context} (contextlevel, instanceid)
                 SELECT ".CONTEXT_COURSE.", c.id
-                  FROM  {$CFG->prefix}course c
+                  FROM {course} c
                  WHERE NOT EXISTS (SELECT 'x'
-                                     FROM {$CFG->prefix}context cx
+                                     FROM {context} cx
                                     WHERE c.id = cx.instanceid AND cx.contextlevel=".CONTEXT_COURSE.")";
-        execute_sql($sql, $feedback);
+        $DB->execute($sql);
 
     }
 
-    if (empty($contextlevel) or $contextlevel == CONTEXT_MODULE) {
-        $sql = "INSERT INTO {$CFG->prefix}context (contextlevel, instanceid)
+    if (empty($contextlevel) or $contextlevel == CONTEXT_MODULE
+                             or $contextlevel == CONTEXT_BLOCK) {
+        $sql = "INSERT INTO {context} (contextlevel, instanceid)
                 SELECT ".CONTEXT_MODULE.", cm.id
-                  FROM  {$CFG->prefix}course_modules cm
+                  FROM {course}_modules cm
                  WHERE NOT EXISTS (SELECT 'x'
-                                     FROM {$CFG->prefix}context cx
+                                     FROM {context} cx
                                     WHERE cm.id = cx.instanceid AND cx.contextlevel=".CONTEXT_MODULE.")";
-        execute_sql($sql, $feedback);
-    }
-
-    if (empty($contextlevel) or $contextlevel == CONTEXT_BLOCK) {
-        $sql = "INSERT INTO {$CFG->prefix}context (contextlevel, instanceid)
-                SELECT ".CONTEXT_BLOCK.", bi.id
-                  FROM  {$CFG->prefix}block_instance bi
-                 WHERE NOT EXISTS (SELECT 'x'
-                                     FROM {$CFG->prefix}context cx
-                                    WHERE bi.id = cx.instanceid AND cx.contextlevel=".CONTEXT_BLOCK.")";
-        execute_sql($sql, $feedback);
+        $DB->execute($sql);
     }
 
-    if (empty($contextlevel) or $contextlevel == CONTEXT_USER) {
-        $sql = "INSERT INTO {$CFG->prefix}context (contextlevel, instanceid)
+    if (empty($contextlevel) or $contextlevel == CONTEXT_USER
+                             or $contextlevel == CONTEXT_BLOCK) {
+        $sql = "INSERT INTO {context} (contextlevel, instanceid)
                 SELECT ".CONTEXT_USER.", u.id
-                  FROM  {$CFG->prefix}user u
+                  FROM {user} u
                  WHERE u.deleted=0
                    AND NOT EXISTS (SELECT 'x'
-                                     FROM {$CFG->prefix}context cx
+                                     FROM {context} cx
                                     WHERE u.id = cx.instanceid AND cx.contextlevel=".CONTEXT_USER.")";
-        execute_sql($sql, $feedback);
+        $DB->execute($sql);
+
+    }
 
+    if (empty($contextlevel) or $contextlevel == CONTEXT_BLOCK) {
+        $sql = "INSERT INTO {context} (contextlevel, instanceid)
+                SELECT ".CONTEXT_BLOCK.", bi.id
+                  FROM {block_instances} bi
+                 WHERE NOT EXISTS (SELECT 'x'
+                                     FROM {context} cx
+                                    WHERE bi.id = cx.instanceid AND cx.contextlevel=".CONTEXT_BLOCK.")";
+        $DB->execute($sql);
     }
 
     if ($buildpaths) {
-        build_context_path(false, $feedback);
+        build_context_path(false);
     }
 }
 
@@ -2391,127 +3021,88 @@ function create_contexts($contextlevel=null, $buildpaths=true, $feedback=false)
  * @return bool
  */
 function cleanup_contexts() {
-    global $CFG;
+    global $DB;
 
-    $sql = "  SELECT c.contextlevel,
-                     c.instanceid AS instanceid
-              FROM {$CFG->prefix}context c
-              LEFT OUTER JOIN {$CFG->prefix}course_categories t
-                ON c.instanceid = t.id
-              WHERE t.id IS NULL AND c.contextlevel = " . CONTEXT_COURSECAT . "
-            UNION
-              SELECT c.contextlevel,
-                     c.instanceid
-              FROM {$CFG->prefix}context c
-              LEFT OUTER JOIN {$CFG->prefix}course t
-                ON c.instanceid = t.id
-              WHERE t.id IS NULL AND c.contextlevel = " . CONTEXT_COURSE . "
-            UNION
-              SELECT c.contextlevel,
-                     c.instanceid
-              FROM {$CFG->prefix}context c
-              LEFT OUTER JOIN {$CFG->prefix}course_modules t
-                ON c.instanceid = t.id
-              WHERE t.id IS NULL AND c.contextlevel = " . CONTEXT_MODULE . "
-            UNION
-              SELECT c.contextlevel,
-                     c.instanceid
-              FROM {$CFG->prefix}context c
-              LEFT OUTER JOIN {$CFG->prefix}user t
-                ON c.instanceid = t.id
-              WHERE t.id IS NULL AND c.contextlevel = " . CONTEXT_USER . "
-            UNION
-              SELECT c.contextlevel,
-                     c.instanceid
-              FROM {$CFG->prefix}context c
-              LEFT OUTER JOIN {$CFG->prefix}block_instance t
-                ON c.instanceid = t.id
-              WHERE t.id IS NULL AND c.contextlevel = " . CONTEXT_BLOCK . "
-           ";
-    if ($rs = get_recordset_sql($sql)) {
-        begin_sql();
-        $tx = true;
-        while ($tx && $ctx = rs_fetch_next_record($rs)) {
-            $tx = $tx && delete_context($ctx->contextlevel, $ctx->instanceid);
-        }
-        rs_close($rs);
-        if ($tx) {
-            commit_sql();
-            return true;
+    // context class will contain function with the sql returned
+    // iterate over all the contexts to generate the sql
+
+    $sqlarray = array();
+
+    foreach(context_level_base::get_all_context_levels() as $cl) {
+        $currentsql = $cl->cleanup_contexts_sql();
+
+        if(!empty($currentsql)) {
+            $sqlarray[] = $currentsql;
         }
-        rollback_sql();
-        return false;
-        rs_close($rs);
     }
+
+    $sql = implode("\n UNION \n", $sqlarray);
+
+    // transactions used only for performance reasons here
+    $transaction = $DB->start_delegated_transaction();
+
+    $rs = $DB->get_recordset_sql($sql);
+    foreach ($rs as $ctx) {
+        delete_context($ctx->contextlevel, $ctx->instanceid);
+    }
+    $rs->close();
+
+    $transaction->allow_commit();
     return true;
 }
 
 /**
- * Preloads all contexts relating to a course: course, modules, and blocks.
+ * Preloads all contexts relating to a course: course, modules. Block contexts
+ * are no longer loaded here. The contexts for all the blocks on the current
+ * page are now efficiently loaded by {@link block_manager::load_blocks()}.
  *
  * @param int $courseid Course ID
  * @return void
  */
 function preload_course_contexts($courseid) {
-    global $context_cache, $context_cache_id, $CFG;
+    global $DB, $ACCESSLIB_PRIVATE;
 
     // Users can call this multiple times without doing any harm
-    static $preloadedcourses = array();
-    if (array_key_exists($courseid, $preloadedcourses)) {
+    global $ACCESSLIB_PRIVATE;
+    if (array_key_exists($courseid, $ACCESSLIB_PRIVATE->preloadedcourses)) {
         return;
     }
 
+    $params = array($courseid, $courseid, $courseid);
     $sql = "SELECT x.instanceid, x.id, x.contextlevel, x.path, x.depth
-              FROM {$CFG->prefix}course_modules cm
-              JOIN {$CFG->prefix}context x ON x.instanceid=cm.id
-             WHERE cm.course={$courseid}
-                   AND x.contextlevel=".CONTEXT_MODULE."
-
-         UNION ALL
-
-            SELECT x.instanceid, x.id, x.contextlevel, x.path, x.depth
-              FROM {$CFG->prefix}block_instance bi
-              JOIN {$CFG->prefix}context x ON x.instanceid=bi.id
-             WHERE bi.pageid={$courseid}
-                   AND bi.pagetype='course-view'
-                   AND x.contextlevel=".CONTEXT_BLOCK."
+              FROM {course_modules} cm
+              JOIN {context} x ON x.instanceid=cm.id
+             WHERE cm.course=? AND x.contextlevel=".CONTEXT_MODULE."
 
         UNION ALL
 
            SELECT x.instanceid, x.id, x.contextlevel, x.path, x.depth
-             FROM {$CFG->prefix}context x
-            WHERE x.instanceid={$courseid}
-                  AND x.contextlevel=".CONTEXT_COURSE."";
+              FROM {context} x
+             WHERE x.instanceid=? AND x.contextlevel=".CONTEXT_COURSE."";
 
-    $rs = get_recordset_sql($sql);
-    while($context = rs_fetch_next_record($rs)) {
-        cache_context($context);
+    $rs = $DB->get_recordset_sql($sql, $params);
+    foreach($rs as $context) {
+        $ACCESSLIB_PRIVATE->contexcache->add($context);
     }
-    rs_close($rs);
-    $preloadedcourses[$courseid] = true;
+    $rs->close();
+    $ACCESSLIB_PRIVATE->preloadedcourses[$courseid] = true;
 }
 
 /**
  * Get the context instance as an object. This function will create the
  * context instance if it does not exist yet.
+ *
+ * @todo Remove code branch from previous fix MDL-9016 which is no longer needed
+ *
  * @param integer $level The context level, for example CONTEXT_COURSE, or CONTEXT_MODULE.
  * @param integer $instance The instance id. For $level = CONTEXT_COURSE, this would be $course->id,
- *      for $level = CONTEXT_MODULE, this would be $cm->id. And so on.
+ *      for $level = CONTEXT_MODULE, this would be $cm->id. And so on. Defaults to 0
+ * @param int $strictness IGNORE_MISSING means compatible mode, false returned if record not found, debug message if more found;
+ *      MUST_EXIST means throw exception if no record or multiple records found
  * @return object The context object.
  */
-function get_context_instance($contextlevel, $instance=0) {
-
-    global $context_cache, $context_cache_id, $CFG;
-    static $allowed_contexts = array(CONTEXT_SYSTEM, CONTEXT_USER, CONTEXT_COURSECAT, CONTEXT_COURSE, CONTEXT_MODULE, CONTEXT_BLOCK);
-
-    if ($contextlevel === 'clearcache') {
-        // TODO: Remove for v2.0
-        // No longer needed, but we'll catch it to avoid erroring out on custom code. 
-        // This used to be a fix for MDL-9016 
-        // "Restoring into existing course, deleting first 
-        //  deletes context and doesn't recreate it"
-        return false;
-    }
+function get_context_instance($contextlevel, $instance = 0, $strictness = IGNORE_MISSING) {
+    global $DB, $ACCESSLIB_PRIVATE;
 
 /// System context has special cache
     if ($contextlevel == CONTEXT_SYSTEM) {
@@ -2519,25 +3110,29 @@ function get_context_instance($contextlevel, $instance=0) {
     }
 
 /// check allowed context levels
-    if (!in_array($contextlevel, $allowed_contexts)) {
+    if (!context_level_base::context_level_exists($contextlevel)) {
         // fatal error, code must be fixed - probably typo or switched parameters
-        error('Error: get_context_instance() called with incorrect context level "'.s($contextlevel).'"');
+        print_error('invalidcourselevel');
     }
 
+    // Various operations rely on context cache
+    $cache = $ACCESSLIB_PRIVATE->contexcache;
+
     if (!is_array($instance)) {
     /// Check the cache
-        if (isset($context_cache[$contextlevel][$instance])) {  // Already cached
-            return $context_cache[$contextlevel][$instance];
+        $context = $cache->get($contextlevel, $instance);
+        if ($context) {
+            return $context;
         }
 
     /// Get it from the database, or create it
-        if (!$context = get_record('context', 'contextlevel', $contextlevel, 'instanceid', $instance)) {
-            $context = create_context($contextlevel, $instance);
+        if (!$context = $DB->get_record('context', array('contextlevel'=>$contextlevel, 'instanceid'=>$instance))) {
+            $context = create_context($contextlevel, $instance, $strictness);
         }
 
     /// Only add to cache if context isn't empty.
         if (!empty($context)) {
-            cache_context($context);
+            $cache->add($context);
         }
 
         return $context;
@@ -2550,684 +3145,1129 @@ function get_context_instance($contextlevel, $instance=0) {
 
     foreach ($instances as $key=>$instance) {
     /// Check the cache first
-        if (isset($context_cache[$contextlevel][$instance])) {  // Already cached
-            $result[$instance] = $context_cache[$contextlevel][$instance];
+        if ($context = $cache->get($contextlevel, $instance)) {  // Already cached
+            $result[$instance] = $context;
             unset($instances[$key]);
             continue;
         }
     }
 
     if ($instances) {
-        if (count($instances) > 1) {
-            $instanceids = implode(',', $instances);
-            $instanceids = "instanceid IN ($instanceids)";
+        list($instanceids, $params) = $DB->get_in_or_equal($instances, SQL_PARAMS_QM);
+        array_unshift($params, $contextlevel);
+        $sql = "SELECT instanceid, id, contextlevel, path, depth
+                  FROM {context}
+                 WHERE contextlevel=? AND instanceid $instanceids";
+
+        if (!$contexts = $DB->get_records_sql($sql, $params)) {
+            $contexts = array();
+        }
+
+        foreach ($instances as $instance) {
+            if (isset($contexts[$instance])) {
+                $context = $contexts[$instance];
         } else {
-            $instance = reset($instances);
-            $instanceids = "instanceid = $instance";
+                $context = create_context($contextlevel, $instance);
+            }
+
+            if (!empty($context)) {
+                $cache->add($context);
+            }
+
+            $result[$instance] = $context;
+        }
+    }
+
+    return $result;
+}
+
+
+/**
+ * Get a context instance as an object, from a given context id.
+ *
+ * @param int $id context id
+ * @param int $strictness IGNORE_MISSING means compatible mode, false returned if record not found, debug message if more found;
+ *                        MUST_EXIST means throw exception if no record or multiple records found
+ * @return stdClass|bool the context object or false if not found.
+ */
+function get_context_instance_by_id($id, $strictness = IGNORE_MISSING) {
+    global $DB, $ACCESSLIB_PRIVATE;
+
+    if ($id == SYSCONTEXTID) {
+        return get_system_context();
+    }
+
+    $cache = $ACCESSLIB_PRIVATE->contexcache;
+    if ($context = $cache->get_by_id($id)) {
+        return $context;
+    }
+
+    if ($context = $DB->get_record('context', array('id'=>$id), '*', $strictness)) {
+        $cache->add($context);
+        return $context;
+    }
+
+    return false;
+}
+
+
+/**
+ * Get the local override (if any) for a given capability in a role in a context
+ *
+ * @param int $roleid
+ * @param int $contextid
+ * @param string $capability
+ */
+function get_local_override($roleid, $contextid, $capability) {
+    global $DB;
+    return $DB->get_record('role_capabilities', array('roleid'=>$roleid, 'capability'=>$capability, 'contextid'=>$contextid));
+}
+
+/**
+ * Returns context instance plus related course and cm instances
+ * @param int $contextid
+ * @return array of ($context, $course, $cm)
+ */
+function get_context_info_array($contextid) {
+    global $DB;
+
+    $context = get_context_instance_by_id($contextid, MUST_EXIST);
+    $course  = null;
+    $cm      = null;
+
+    if ($context->contextlevel == CONTEXT_COURSE) {
+        $course = $DB->get_record('course', array('id'=>$context->instanceid), '*', MUST_EXIST);
+
+    } else if ($context->contextlevel == CONTEXT_MODULE) {
+        $cm = get_coursemodule_from_id('', $context->instanceid, 0, false, MUST_EXIST);
+        $course = $DB->get_record('course', array('id'=>$cm->course), '*', MUST_EXIST);
+
+    } else if ($context->contextlevel == CONTEXT_BLOCK) {
+        $parentcontexts = get_parent_contexts($context, false);
+        $parent = reset($parentcontexts);
+        $parent = get_context_instance_by_id($parent);
+
+        if ($parent->contextlevel == CONTEXT_COURSE) {
+            $course = $DB->get_record('course', array('id'=>$parent->instanceid), '*', MUST_EXIST);
+        } else if ($parent->contextlevel == CONTEXT_MODULE) {
+            $cm = get_coursemodule_from_id('', $parent->instanceid, 0, false, MUST_EXIST);
+            $course = $DB->get_record('course', array('id'=>$cm->course), '*', MUST_EXIST);
+        }
+    }
+
+    return array($context, $course, $cm);
+}
+
+/**
+ * Returns current course id or null if outside of course based on context parameter.
+ * @param object $context
+ * @return int|bool related course id or false
+ */
+function get_courseid_from_context($context) {
+    if (empty($context->contextlevel)) {
+        debugging('Invalid context object specified in get_courseid_from_context() call');
+        return false;
+    }
+    if ($context->contextlevel == CONTEXT_COURSE) {
+        return $context->instanceid;
+    }
+
+    if ($context->contextlevel < CONTEXT_COURSE) {
+        return false;
+    }
+
+    if ($context->contextlevel == CONTEXT_MODULE) {
+        $parentcontexts = get_parent_contexts($context, false);
+        $parent = reset($parentcontexts);
+        $parent = get_context_instance_by_id($parent);
+        return $parent->instanceid;
+    }
+
+    if ($context->contextlevel == CONTEXT_BLOCK) {
+        $parentcontexts = get_parent_contexts($context, false);
+        $parent = reset($parentcontexts);
+        return get_courseid_from_context(get_context_instance_by_id($parent));
+    }
+
+    return false;
+}
+
+
+//////////////////////////////////////
+//    DB TABLE RELATED FUNCTIONS    //
+//////////////////////////////////////
+
+/**
+ * function that creates a role
+ *
+ * @param string $name role name
+ * @param string $shortname role short name
+ * @param string $description role description
+ * @param string $archetype
+ * @return int id or dml_exception
+ */
+function create_role($name, $shortname, $description, $archetype = '') {
+    global $DB;
+
+    if (strpos($archetype, 'moodle/legacy:') !== false) {
+        throw new coding_exception('Use new role archetype parameter in create_role() instead of old legacy capabilities.');
+    }
+
+    // verify role archetype actually exists
+    $archetypes = get_role_archetypes();
+    if (empty($archetypes[$archetype])) {
+        $archetype = '';
+    }
+
+    // Get the system context.
+    $context = get_context_instance(CONTEXT_SYSTEM);
+
+    // Insert the role record.
+    $role = new stdClass();
+    $role->name        = $name;
+    $role->shortname   = $shortname;
+    $role->description = $description;
+    $role->archetype   = $archetype;
+
+    //find free sortorder number
+    $role->sortorder = $DB->get_field('role', 'MAX(sortorder) + 1', array());
+    if (empty($role->sortorder)) {
+        $role->sortorder = 1;
+    }
+    $id = $DB->insert_record('role', $role);
+
+    return $id;
+}
+
+/**
+ * Function that deletes a role and cleanups up after it
+ *
+ * @param int $roleid id of role to delete
+ * @return bool always true
+ */
+function delete_role($roleid) {
+    global $CFG, $DB;
+
+    // first unssign all users
+    role_unassign_all(array('roleid'=>$roleid));
+
+    // cleanup all references to this role, ignore errors
+    $DB->delete_records('role_capabilities',   array('roleid'=>$roleid));
+    $DB->delete_records('role_allow_assign',   array('roleid'=>$roleid));
+    $DB->delete_records('role_allow_assign',   array('allowassign'=>$roleid));
+    $DB->delete_records('role_allow_override', array('roleid'=>$roleid));
+    $DB->delete_records('role_allow_override', array('allowoverride'=>$roleid));
+    $DB->delete_records('role_names',          array('roleid'=>$roleid));
+    $DB->delete_records('role_context_levels', array('roleid'=>$roleid));
+
+    // finally delete the role itself
+    // get this before the name is gone for logging
+    $rolename = $DB->get_field('role', 'name', array('id'=>$roleid));
+
+    $DB->delete_records('role', array('id'=>$roleid));
+
+    add_to_log(SITEID, 'role', 'delete', 'admin/roles/action=delete&roleid='.$roleid, $rolename, '');
+
+    return true;
+}
+
+/**
+ * Function to write context specific overrides, or default capabilities.
+ *
+ * @param string $capability string name
+ * @param int $permission CAP_ constants
+ * @param int $roleid role id
+ * @param int $contextid context id
+ * @param bool $overwrite
+ * @return bool always true or exception
+ */
+function assign_capability($capability, $permission, $roleid, $contextid, $overwrite = false) {
+    global $USER, $DB;
+
+    if (empty($permission) || $permission == CAP_INHERIT) { // if permission is not set
+        unassign_capability($capability, $roleid, $contextid);
+        return true;
         }
         
-        if (!$contexts = get_records_sql("SELECT instanceid, id, contextlevel, path, depth
-                                            FROM {$CFG->prefix}context
-                                           WHERE contextlevel=$contextlevel AND $instanceids")) {
-            $contexts = array();
+    $existing = $DB->get_record('role_capabilities', array('contextid'=>$contextid, 'roleid'=>$roleid, 'capability'=>$capability));
+
+    if ($existing and !$overwrite) {   // We want to keep whatever is there already
+        return true;
         }
 
-        foreach ($instances as $instance) {
-            if (isset($contexts[$instance])) {
-                $context = $contexts[$instance];
+    $cap = new stdClass();
+    $cap->contextid    = $contextid;
+    $cap->roleid       = $roleid;
+    $cap->capability   = $capability;
+    $cap->permission   = $permission;
+    $cap->timemodified = time();
+    $cap->modifierid   = empty($USER->id) ? 0 : $USER->id;
+
+    if ($existing) {
+        $cap->id = $existing->id;
+        $DB->update_record('role_capabilities', $cap);
             } else {
-                $context = create_context($contextlevel, $instance);
+        $c = $DB->get_record('context', array('id'=>$contextid));
+        $DB->insert_record('role_capabilities', $cap);
             }
+    return true;
+}
 
-            if (!empty($context)) {
-                cache_context($context);
-            }
+/**
+ * Unassign a capability from a role.
+ *
+ * @param string $capability the name of the capability
+ * @param int $roleid the role id
+ * @param int $contextid null means all contexts
+ * @return boolean success or failure
+ */
+function unassign_capability($capability, $roleid, $contextid = null) {
+    global $DB;
 
-            $result[$instance] = $context;
-        }
+    if (!empty($contextid)) {
+        // delete from context rel, if this is the last override in this context
+        $DB->delete_records('role_capabilities', array('capability'=>$capability, 'roleid'=>$roleid, 'contextid'=>$contextid));
+    } else {
+        $DB->delete_records('role_capabilities', array('capability'=>$capability, 'roleid'=>$roleid));
     }
-
-    return $result;
+    return true;
 }
 
 
 /**
- * Get a context instance as an object, from a given context id.
- * @param mixed $id a context id or array of ids.
- * @return mixed object or array of the context object.
+ * Get the roles that have a given capability assigned to it
+ *
+ * This function does not resolve the actual permission of the capability.
+ * It just checks for permissions and overrides.
+ * Use get_roles_with_cap_in_context() if resolution is required.
+ *
+ * @param string $capability - capability name (string)
+ * @param string $permission - optional, the permission defined for this capability
+ *                      either CAP_ALLOW, CAP_PREVENT or CAP_PROHIBIT. Defaults to null which means any.
+ * @param stdClass $context, null means any
+ * @return array of role objects
  */
-function get_context_instance_by_id($id) {
+function get_roles_with_capability($capability, $permission = null, $context = null) {
+    global $DB;
 
-    global $context_cache, $context_cache_id;
-
-    if ($id == SYSCONTEXTID) {
-        return get_system_context();
+    if ($context) {
+        $contexts = get_parent_contexts($context, true);
+        list($insql, $params) = $DB->get_in_or_equal($contexts, SQL_PARAMS_NAMED, 'ctx');
+        $contextsql = "AND rc.contextid $insql";
+    } else {
+        $params = array();
+        $contextsql = '';
     }
 
-    if (isset($context_cache_id[$id])) {  // Already cached
-        return $context_cache_id[$id];
+    if ($permission) {
+        $permissionsql = " AND rc.permission = :permission";
+        $params['permission'] = $permission;
+    } else {
+        $permissionsql = '';
     }
 
-    if ($context = get_record('context', 'id', $id)) {   // Update the cache and return
-        cache_context($context);
-        return $context;
-    }
+    $sql = "SELECT r.*
+              FROM {role} r
+             WHERE r.id IN (SELECT rc.roleid
+                              FROM {role_capabilities} rc
+                             WHERE rc.capability = :capname
+                                   $contextsql
+                                   $permissionsql)";
+    $params['capname'] = $capability;
 
-    return false;
+
+    return $DB->get_records_sql($sql, $params);
 }
 
 
 /**
- * Get the local override (if any) for a given capability in a role in a context
- * @param $roleid
- * @param $contextid
- * @param $capability
+ * This function makes a role-assignment (a role for a user in a particular context)
+ *
+ * @param int $roleid the role of the id
+ * @param int $userid userid
+ * @param int $contextid id of the context
+ * @param string $component example 'enrol_ldap', defaults to '' which means manual assignment,
+ * @prama int $itemid id of enrolment/auth plugin
+ * @param string $timemodified defaults to current time
+ * @return int new/existing id of the assignment
  */
-function get_local_override($roleid, $contextid, $capability) {
-    return get_record('role_capabilities', 'roleid', $roleid, 'capability', $capability, 'contextid', $contextid);
-}
-
+function role_assign($roleid, $userid, $contextid, $component = '', $itemid = 0, $timemodified = '') {
+    global $USER, $CFG, $DB;
 
+    // first of all detect if somebody is using old style parameters
+    if ($contextid === 0 or is_numeric($component)) {
+        throw new coding_exception('Invalid call to role_assign(), code needs to be updated to use new order of parameters');
+    }
 
-/************************************
- *    DB TABLE RELATED FUNCTIONS    *
- ************************************/
-
-/**
- * function that creates a role
- * @param name - role name
- * @param shortname - role short name
- * @param description - role description
- * @param legacy - optional legacy capability
- * @return id or false
- */
-function create_role($name, $shortname, $description, $legacy='') {
+    // now validate all parameters
+    if (empty($roleid)) {
+        throw new coding_exception('Invalid call to role_assign(), roleid can not be empty');
+    }
 
-    // check for duplicate role name
+    if (empty($userid)) {
+        throw new coding_exception('Invalid call to role_assign(), userid can not be empty');
+    }
 
-    if ($role = get_record('role','name', $name)) {
-        error('there is already a role with this name!');
+    if ($itemid) {
+        if (strpos($component, '_') === false) {
+            throw new coding_exception('Invalid call to role_assign(), component must start with plugin type such as"enrol_" when itemid specified', 'component:'.$component);
+        }
+    } else {
+        $itemid = 0;
+        if ($component !== '' and strpos($component, '_') === false) {
+            throw new coding_exception('Invalid call to role_assign(), invalid component string', 'component:'.$component);
+        }
     }
 
-    if ($role = get_record('role','shortname', $shortname)) {
-        error('there is already a role with this shortname!');
+    if (!$DB->record_exists('user', array('id'=>$userid, 'deleted'=>0))) {
+        throw new coding_exception('User ID does not exist or is deleted!', 'userid:'.$userid);
     }
 
-    $role = new object();
-    $role->name = $name;
-    $role->shortname = $shortname;
-    $role->description = $description;
+    $context = get_context_instance_by_id($contextid, MUST_EXIST);
 
-    //find free sortorder number
-    $role->sortorder = count_records('role');
-    while (get_record('role','sortorder', $role->sortorder)) {
-        $role->sortorder += 1;
+    if (!$timemodified) {
+        $timemodified = time();
     }
 
-    if (!$context = get_context_instance(CONTEXT_SYSTEM)) {
-        return false;
+/// Check for existing entry
+    $ras = $DB->get_records('role_assignments', array('roleid'=>$roleid, 'contextid'=>$context->id, 'userid'=>$userid, 'component'=>$component, 'itemid'=>$itemid), 'id');
+
+    if ($ras) {
+        // role already assigned - this should not happen
+        if (count($ras) > 1) {
+            //very weird - remove all duplicates!
+            $ra = array_shift($ras);
+            foreach ($ras as $r) {
+                $DB->delete_records('role_assignments', array('id'=>$r->id));
+            }
+        } else {
+            $ra = reset($ras);
     }
 
-    if ($id = insert_record('role', $role)) {
-        if ($legacy) {
-            assign_capability($legacy, CAP_ALLOW, $id, $context->id);
+        // actually there is no need to update, reset anything or trigger any event, so just return
+        return $ra->id;
         }
 
-        /// By default, users with role:manage at site level
-        /// should be able to assign users to this new role, and override this new role's capabilities
+    // Create a new entry
+    $ra = new stdClass();
+    $ra->roleid       = $roleid;
+    $ra->contextid    = $context->id;
+    $ra->userid       = $userid;
+    $ra->component    = $component;
+    $ra->itemid       = $itemid;
+    $ra->timemodified = $timemodified;
+    $ra->modifierid   = empty($USER->id) ? 0 : $USER->id;
+
+    $ra->id = $DB->insert_record('role_assignments', $ra);
+
+    // mark context as dirty - again expensive, but needed
+    mark_context_dirty($context->path);
 
-        // find all admin roles
-        if ($adminroles = get_roles_with_capability('moodle/role:manage', CAP_ALLOW, $context)) {
-            // foreach admin role
-            foreach ($adminroles as $arole) {
-                // write allow_assign and allow_overrid
-                allow_assign($arole->id, $id);
-                allow_override($arole->id, $id);
+    if (!empty($USER->id) && $USER->id == $userid) {
+        // If the user is the current user, then do full reload of capabilities too.
+        load_all_capabilities();
             }
+
+    events_trigger('role_assigned', $ra);
+
+    return $ra->id;
+}
+
+/**
+ * Removes one role assignment
+ *
+ * @param int $roleid
+ * @param int  $userid
+ * @param int  $contextid
+ * @param string $component
+ * @param int  $itemid
+ * @return void
+ */
+function role_unassign($roleid, $userid, $contextid, $component = '', $itemid = 0) {
+    global $USER, $CFG, $DB;
+
+    // first make sure the params make sense
+    if ($roleid == 0 or $userid == 0 or $contextid == 0) {
+        throw new coding_exception('Invalid call to role_unassign(), please use role_unassign_all() when removing multiple role assignments');
         }
 
-        return $id;
+    if ($itemid) {
+        if (strpos($component, '_') === false) {
+            throw new coding_exception('Invalid call to role_assign(), component must start with plugin type such as "enrol_" when itemid specified', 'component:'.$component);
+        }
     } else {
-        return false;
+        $itemid = 0;
+        if ($component !== '' and strpos($component, '_') === false) {
+            throw new coding_exception('Invalid call to role_assign(), invalid component string', 'component:'.$component);
+        }
     }
 
+    role_unassign_all(array('roleid'=>$roleid, 'userid'=>$userid, 'contextid'=>$contextid, 'component'=>$component, 'itemid'=>$itemid), false, false);
 }
 
 /**
- * function that deletes a role and cleanups up after it
- * @param roleid - id of role to delete
- * @return success
+ * Removes multiple role assignments, parameters may contain:
+ *   'roleid', 'userid', 'contextid', 'component', 'enrolid'.
+ *
+ * @param array $params role assignment parameters
+ * @param bool $subcontexts unassign in subcontexts too
+ * @param bool $includmanual include manual role assignments too
+ * @return void
  */
-function delete_role($roleid) {
-    global $CFG, $USER;
-    $success = true;
-
-// mdl 10149, check if this is the last active admin role
-// if we make the admin role not deletable then this part can go
+function role_unassign_all(array $params, $subcontexts = false, $includemanual = false) {
+    global $USER, $CFG, $DB;
 
-    $systemcontext = get_context_instance(CONTEXT_SYSTEM);
+    if (!$params) {
+        throw new coding_exception('Missing parameters in role_unsassign_all() call');
+    }
 
-    if ($role = get_record('role', 'id', $roleid)) {
-        if (record_exists('role_capabilities', 'contextid', $systemcontext->id, 'roleid', $roleid, 'capability', 'moodle/site:doanything')) {
-            // deleting an admin role
-            $status = false;
-            if ($adminroles = get_roles_with_capability('moodle/site:doanything', CAP_ALLOW, $systemcontext)) {
-                foreach ($adminroles as $adminrole) {
-                    if ($adminrole->id != $roleid) {
-                        // some other admin role
-                        if (record_exists('role_assignments', 'roleid', $adminrole->id, 'contextid', $systemcontext->id)) {
-                            // found another admin role with at least 1 user assigned
-                            $status = true;
-                            break;
+    $allowed = array('roleid', 'userid', 'contextid', 'component', 'itemid');
+    foreach ($params as $key=>$value) {
+        if (!in_array($key, $allowed)) {
+            throw new coding_exception('Unknown role_unsassign_all() parameter key', 'key:'.$key);
                         }
                     }
+
+    if (isset($params['component']) and $params['component'] !== '' and strpos($params['component'], '_') === false) {
+        throw new coding_exception('Invalid component paramter in role_unsassign_all() call', 'component:'.$params['component']);
                 }
+
+    if ($includemanual) {
+        if (!isset($params['component']) or $params['component'] === '') {
+            throw new coding_exception('include manual parameter requires component parameter in role_unsassign_all() call');
             }
-            if ($status !== true) {
-                error ('You can not delete this role because there is no other admin roles with users assigned');
             }
+
+    if ($subcontexts) {
+        if (empty($params['contextid'])) {
+            throw new coding_exception('subcontexts paramtere requires component parameter in role_unsassign_all() call');
         }
     }
 
-// first unssign all users
-    if (!role_unassign($roleid)) {
-        debugging("Error while unassigning all users from role with ID $roleid!");
-        $success = false;
+    $ras = $DB->get_records('role_assignments', $params);
+    foreach($ras as $ra) {
+        $DB->delete_records('role_assignments', array('id'=>$ra->id));
+        if ($context = get_context_instance_by_id($ra->contextid)) {
+            // this is a bit expensive but necessary
+            mark_context_dirty($context->path);
+            /// If the user is the current user, then do full reload of capabilities too.
+            if (!empty($USER->id) && $USER->id == $ra->userid) {
+                load_all_capabilities();
     }
-
-// cleanup all references to this role, ignore errors
-    if ($success) {
-
-        // MDL-10679 find all contexts where this role has an override
-        $contexts = get_records_sql("SELECT contextid, contextid
-                                     FROM {$CFG->prefix}role_capabilities
-                                     WHERE roleid = $roleid");
-
-        delete_records('role_capabilities', 'roleid', $roleid);
-
-        delete_records('role_allow_assign', 'roleid', $roleid);
-        delete_records('role_allow_assign', 'allowassign', $roleid);
-        delete_records('role_allow_override', 'roleid', $roleid);
-        delete_records('role_allow_override', 'allowoverride', $roleid);
-        delete_records('role_names', 'roleid', $roleid);
     }
-
-// finally delete the role itself
-    // get this before the name is gone for logging
-    $rolename = get_field('role', 'name', 'id', $roleid);
-    
-    if ($success and !delete_records('role', 'id', $roleid)) {
-        debugging("Could not delete role record with ID $roleid!");
-        $success = false;
+        events_trigger('role_unassigned', $ra);
     }
+    unset($ras);
     
-    if ($success) {
-        add_to_log(SITEID, 'role', 'delete', 'admin/roles/action=delete&roleid='.$roleid, $rolename, '', $USER->id);
+    // process subcontexts
+    if ($subcontexts and $context = get_context_instance_by_id($params['contextid'])) {
+        $contexts = get_child_contexts($context);
+        $mparams = $params;
+        foreach($contexts as $context) {
+            $mparams['contextid'] = $context->id;
+            $ras = $DB->get_records('role_assignments', $mparams);
+            foreach($ras as $ra) {
+                $DB->delete_records('role_assignments', array('id'=>$ra->id));
+                // this is a bit expensive but necessary
+                mark_context_dirty($context->path);
+                /// If the user is the current user, then do full reload of capabilities too.
+                if (!empty($USER->id) && $USER->id == $ra->userid) {
+                    load_all_capabilities();
+                }
+                events_trigger('role_unassigned', $ra);
+            }
+        }
     }
 
-    return $success;
+    // do this once more for all manual role assignments
+    if ($includemanual) {
+        $params['component'] = '';
+        role_unassign_all($params, $subcontexts, false);
+    }
 }
 
+
 /**
- * Function to write context specific overrides, or default capabilities.
- * @param module - string name
- * @param capability - string name
- * @param contextid - context id
- * @param roleid - role id
- * @param permission - int 1,-1 or -1000
- * should not be writing if permission is 0
+ * Determines if a user is currently logged in
+ *
+ * @return bool
  */
-function assign_capability($capability, $permission, $roleid, $contextid, $overwrite=false) {
-
+function isloggedin() {
     global $USER;
 
-    if (empty($permission) || $permission == CAP_INHERIT) { // if permission is not set
-        unassign_capability($capability, $roleid, $contextid);
-        return true;
-    }
+    return (!empty($USER->id));
+}
 
-    $existing = get_record('role_capabilities', 'contextid', $contextid, 'roleid', $roleid, 'capability', $capability);
+/**
+ * Determines if a user is logged in as real guest user with username 'guest'.
+ *
+ * @param int|object $user mixed user object or id, $USER if not specified
+ * @return bool true if user is the real guest user, false if not logged in or other user
+ */
+function isguestuser($user = null) {
+    global $USER, $DB, $CFG;
 
-    if ($existing and !$overwrite) {   // We want to keep whatever is there already
-        return true;
+    // make sure we have the user id cached in config table, because we are going to use it a lot
+    if (empty($CFG->siteguest)) {
+        if (!$guestid = $DB->get_field('user', 'id', array('username'=>'guest', 'mnethostid'=>$CFG->mnet_localhost_id))) {
+            // guest does not exist yet, weird
+            return false;
+        }
+        set_config('siteguest', $guestid);
+    }
+    if ($user === null) {
+        $user = $USER;
     }
 
-    $cap = new object;
-    $cap->contextid = $contextid;
-    $cap->roleid = $roleid;
-    $cap->capability = $capability;
-    $cap->permission = $permission;
-    $cap->timemodified = time();
-    $cap->modifierid = empty($USER->id) ? 0 : $USER->id;
+    if ($user === null) {
+        // happens when setting the $USER
+        return false;
 
-    if ($existing) {
-        $cap->id = $existing->id;
-        return update_record('role_capabilities', $cap);
+    } else if (is_numeric($user)) {
+        return ($CFG->siteguest == $user);
+
+    } else if (is_object($user)) {
+        if (empty($user->id)) {
+            return false; // not logged in means is not be guest
     } else {
-        $c = get_record('context', 'id', $contextid);
-        return insert_record('role_capabilities', $cap);
+            return ($CFG->siteguest == $user->id);
     }
-}
-
-/**
- * Unassign a capability from a role.
- * @param $roleid - the role id
- * @param $capability - the name of the capability
- * @return boolean - success or failure
- */
-function unassign_capability($capability, $roleid, $contextid=NULL) {
 
-    if (isset($contextid)) {
-        // delete from context rel, if this is the last override in this context
-        $status = delete_records('role_capabilities', 'capability', $capability,
-                'roleid', $roleid, 'contextid', $contextid);
     } else {
-        $status = delete_records('role_capabilities', 'capability', $capability,
-                'roleid', $roleid);
+        throw new coding_exception('Invalid user parameter supplied for isguestuser() function!');
     }
-    return $status;
 }
 
-
 /**
- * Get the roles that have a given capability assigned to it. This function
- * does not resolve the actual permission of the capability. It just checks
- * for assignment only.
- * @param $capability - capability name (string)
- * @param $permission - optional, the permission defined for this capability
- *                      either CAP_ALLOW, CAP_PREVENT or CAP_PROHIBIT
- * @return array or role objects
+ * Does user have a (temporary or real) guest access to course?
+ *
+ * @param stdClass $context
+ * @param stdClass|int $user
+ * @return bool
  */
-function get_roles_with_capability($capability, $permission=NULL, $context='') {
+function is_guest($context, $user = null) {
+    global $USER;
 
-    global $CFG;
+    // first find the course context
+    $coursecontext = get_course_context($context);
 
-    if ($context) {
-        if ($contexts = get_parent_contexts($context)) {
-            $listofcontexts = '('.implode(',', $contexts).')';
+    // make sure there is a real user specified
+    if ($user === null) {
+        $userid = isset($USER->id) ? $USER->id : 0;
         } else {
-            $sitecontext = get_context_instance(CONTEXT_SYSTEM);
-            $listofcontexts = '('.$sitecontext->id.')'; // must be site
+        $userid = is_object($user) ? $user->id : $user;
         }
-        $contextstr = "AND (rc.contextid = '$context->id' OR  rc.contextid IN $listofcontexts)";
-    } else {
-        $contextstr = '';
+
+    if (isguestuser($userid)) {
+        // can not inspect or be enrolled
+        return true;
     }
 
-    $selectroles = "SELECT r.*
-                      FROM {$CFG->prefix}role r,
-                           {$CFG->prefix}role_capabilities rc
-                     WHERE rc.capability = '$capability'
-                       AND rc.roleid = r.id $contextstr";
+    if (has_capability('moodle/course:view', $coursecontext, $user)) {
+        // viewing users appear out of nowhere, they are neither guests nor participants
+        return false;
+    }
 
-    if (isset($permission)) {
-        $selectroles .= " AND rc.permission = '$permission'";
+    // consider only real active enrolments here
+    if (is_enrolled($coursecontext, $user, '', true)) {
+        return false;
     }
-    return get_records_sql($selectroles);
+
+    return true;
 }
 
 
 /**
- * This function makes a role-assignment (a role for a user or group in a particular context)
- * @param $roleid - the role of the id
- * @param $userid - userid
- * @param $groupid - group id
- * @param $contextid - id of the context
- * @param $timestart - time this assignment becomes effective
- * @param $timeend - time this assignemnt ceases to be effective
- * @uses $USER
- * @return id - new id of the assigment
+ * Returns true if the user has moodle/course:view capability in the course,
+ * this is intended for admins, managers (aka small admins), inspectors, etc.
+ *
+ * @param stdClass $context
+ * @param int|object $user, if null $USER is used
+ * @param string $withcapability extra capability name
+ * @return bool
  */
-function role_assign($roleid, $userid, $groupid, $contextid, $timestart=0, $timeend=0, $hidden=0, $enrol='manual',$timemodified='') {
-    global $USER, $CFG;
-
-/// Do some data validation
+function is_viewing($context, $user = null, $withcapability = '') {
+    // first find the course context
+    $coursecontext = get_course_context($context);
 
-    if (empty($roleid)) {
-        debugging('Role ID not provided');
+    if (isguestuser($user)) {
+        // can not inspect
         return false;
     }
 
-    if (empty($userid) && empty($groupid)) {
-        debugging('Either userid or groupid must be provided');
+    if (!has_capability('moodle/course:view', $coursecontext, $user)) {
+        // admins are allowed to inspect courses
         return false;
     }
 
-    if ($userid && !record_exists('user', 'id', $userid)) {
-        debugging('User ID '.intval($userid).' does not exist!');
+    if ($withcapability and !has_capability($withcapability, $context, $user)) {
+        // site admins always have the capability, but the enrolment above blocks
         return false;
     }
 
-    if ($groupid && !groups_group_exists($groupid)) {
-        debugging('Group ID '.intval($groupid).' does not exist!');
-        return false;
-    }
+    return true;
+}
 
-    if (!$context = get_context_instance_by_id($contextid)) {
-        debugging('Context ID '.intval($contextid).' does not exist!');
-        return false;
+/**
+ * Returns true if user is enrolled (is participating) in course
+ * this is intended for students and teachers.
+ *
+ * @param object $context
+ * @param int|object $user, if null $USER is used, otherwise user object or id expected
+ * @param string $withcapability extra capability name
+ * @param bool $onlyactive consider only active enrolments in enabled plugins and time restrictions
+ * @return bool
+ */
+function is_enrolled($context, $user = null, $withcapability = '', $onlyactive = false) {
+    global $USER, $DB;
+
+    // first find the course context
+    $coursecontext = get_course_context($context);
+
+    // make sure there is a real user specified
+    if ($user === null) {
+        $userid = isset($USER->id) ? $USER->id : 0;
+    } else {
+        $userid = is_object($user) ? $user->id : $user;
     }
 
-    if (($timestart and $timeend) and ($timestart > $timeend)) {
-        debugging('The end time can not be earlier than the start time');
+    if (empty($userid)) {
+        // not-logged-in!
+        return false;
+    } else if (isguestuser($userid)) {
+        // guest account can not be enrolled anywhere
         return false;
     }
 
-    if (!$timemodified) {
-        $timemodified = time();
+    if ($coursecontext->instanceid == SITEID) {
+        // everybody participates on frontpage
+    } else {
+        if ($onlyactive) {
+            $sql = "SELECT ue.*
+                      FROM {user_enrolments} ue
+                      JOIN {enrol} e ON (e.id = ue.enrolid AND e.courseid = :courseid)
+                      JOIN {user} u ON u.id = ue.userid
+                     WHERE ue.userid = :userid AND ue.status = :active AND e.status = :enabled AND u.deleted = 0";
+            $params = array('enabled'=>ENROL_INSTANCE_ENABLED, 'active'=>ENROL_USER_ACTIVE, 'userid'=>$userid, 'courseid'=>$coursecontext->instanceid);
+            // this result should be very small, better not do the complex time checks in sql for now ;-)
+            $enrolments = $DB->get_records_sql($sql, $params);
+            $now = time();
+            // make sure the enrol period is ok
+            $result = false;
+            foreach ($enrolments as $e) {
+                if ($e->timestart > $now) {
+                    continue;
+                }
+                if ($e->timeend and $e->timeend < $now) {
+                    continue;
+                }
+                $result = true;
+                break;
+            }
+            if (!$result) {
+                return false;
     }
 
-/// Check for existing entry
-    if ($userid) {
-        $ra = get_record('role_assignments', 'roleid', $roleid, 'contextid', $context->id, 'userid', $userid);
     } else {
-        $ra = get_record('role_assignments', 'roleid', $roleid, 'contextid', $context->id, 'groupid', $groupid);
+            // any enrolment is good for us here, even outdated, disabled or inactive
+            $sql = "SELECT 'x'
+                      FROM {user_enrolments} ue
+                      JOIN {enrol} e ON (e.id = ue.enrolid AND e.courseid = :courseid)
+                      JOIN {user} u ON u.id = ue.userid
+                     WHERE ue.userid = :userid AND u.deleted = 0";
+            $params = array('userid'=>$userid, 'courseid'=>$coursecontext->instanceid);
+            if (!$DB->record_exists_sql($sql, $params)) {
+                return false;
+            }
+        }
     }
 
-    if (empty($ra)) {             // Create a new entry
-        $ra = new object();
-        $ra->roleid = $roleid;
-        $ra->contextid = $context->id;
-        $ra->userid = $userid;
-        $ra->hidden = $hidden;
-        $ra->enrol = $enrol;
-    /// Always round timestart downto 100 secs to help DBs to use their own caching algorithms
-    /// by repeating queries with the same exact parameters in a 100 secs time window
-        $ra->timestart = round($timestart, -2);
-        $ra->timeend = $timeend;
-        $ra->timemodified = $timemodified;
-        $ra->modifierid = empty($USER->id) ? 0 : $USER->id;
-
-        if (!$ra->id = insert_record('role_assignments', $ra)) {
+    if ($withcapability and !has_capability($withcapability, $context, $userid)) {
             return false;
         }
 
-    } else {                      // We already have one, just update it
-        $ra->id = $ra->id;
-        $ra->hidden = $hidden;
-        $ra->enrol = $enrol;
-    /// Always round timestart downto 100 secs to help DBs to use their own caching algorithms
-    /// by repeating queries with the same exact parameters in a 100 secs time window
-        $ra->timestart = round($timestart, -2);
-        $ra->timeend = $timeend;
-        $ra->timemodified = $timemodified;
-        $ra->modifierid = empty($USER->id) ? 0 : $USER->id;
+    return true;
+}
 
-        if (!update_record('role_assignments', $ra)) {
-            return false;
-        }
-    }
+/**
+ * Returns true if the user is able to access the course.
+ *
+ * This function is in no way, shape, or form a substitute for require_login.
+ * It should only be used in circumstances where it is not possible to call require_login
+ * such as the navigation.
+ *
+ * This function checks many of the methods of access to a course such as the view
+ * capability, enrollments, and guest access. It also makes use of the cache
+ * generated by require_login for guest access.
+ *
+ * The flags within the $USER object that are used here should NEVER be used outside
+ * of this function can_access_course and require_login. Doing so WILL break future
+ * versions.
+ *
+ * @global moodle_database $DB
+ * @param stdClass $context
+ * @param stdClass|null $user
+ * @param string $withcapability Check for this capability as well.
+ * @param bool $onlyactive consider only active enrolments in enabled plugins and time restrictions
+ * @param boolean $trustcache If set to false guest access will always be checked
+ *                             against the enrolment plugins from the course, rather
+ *                             than the cache generated by require_login.
+ * @return boolean Returns true if the user is able to access the course
+ */
+function can_access_course($context, $user = null, $withcapability = '', $onlyactive = false, $trustcache = true) {
+    global $DB, $USER;
 
-/// mark context as dirty - modules might use has_capability() in xxx_role_assing()
-/// again expensive, but needed
-    mark_context_dirty($context->path);
+    $coursecontext = get_course_context($context);
+    $courseid = $coursecontext->instanceid;
 
-    if (!empty($USER->id) && $USER->id == $userid) {
-/// If the user is the current user, then do full reload of capabilities too.
-        load_all_capabilities();
+    // First check the obvious, is the user viewing or is the user enrolled.
+    if (is_viewing($coursecontext, $user, $withcapability) || is_enrolled($coursecontext, $user, $withcapability, $onlyactive)) {
+        // How easy was that!
+        return true;
     }
 
-/// Ask all the modules if anything needs to be done for this user
-    if ($mods = get_list_of_plugins('mod')) {
-        foreach ($mods as $mod) {
-            include_once($CFG->dirroot.'/mod/'.$mod.'/lib.php');
-            $functionname = $mod.'_role_assign';
-            if (function_exists($functionname)) {
-                $functionname($userid, $context, $roleid);
+    $access = false;
+    if (!isset($USER->enrol)) {
+        // Cache hasn't been generated yet so we can't trust it
+        $trustcache = false;
+        /**
+         * These flags within the $USER object should NEVER be used outside of this
+         * function can_access_course and the function require_login.
+         * Doing so WILL break future versions!!!!
+         */
+        $USER->enrol = array();
+        $USER->enrol['enrolled'] = array();
+        $USER->enrol['tempguest'] = array();
+    }
+
+    // If we don't trust the cache we need to check with the courses enrolment
+    // plugin instances to see if the user can access the course as a guest.
+    if (!$trustcache) {
+        // Ok, off to the database we go!
+        $instances = $DB->get_records('enrol', array('courseid'=>$courseid, 'status'=>ENROL_INSTANCE_ENABLED), 'sortorder, id ASC');
+        $enrols = enrol_get_plugins(true);
+        foreach($instances as $instance) {
+            if (!isset($enrols[$instance->enrol])) {
+                continue;
             }
+            $until = $enrols[$instance->enrol]->try_guestaccess($instance);
+            if ($until !== false) {
+                // Never use me anywhere but here and require_login
+                $USER->enrol['tempguest'][$courseid] = $until;
+                $access = true;
+                break;
         }
     }
-
-    /// now handle metacourse role assignments if in course context
-    if ($context->contextlevel == CONTEXT_COURSE) {
-        if ($parents = get_records('course_meta', 'child_course', $context->instanceid)) {
-            foreach ($parents as $parent) {
-                sync_metacourse($parent->parent_course);
             }
+
+    // If we don't already have access (from above) check the cache and see whether
+    // there is record of it in there.
+    if (!$access && isset($USER->enrol['tempguest'][$courseid])) {
+        // Never use me anywhere but here and require_login
+        if ($USER->enrol['tempguest'][$courseid] == 0) {
+            $access = true;
+        } else if ($USER->enrol['tempguest'][$courseid] > time()) {
+            $access = true;
+        } else {
+            //expired
+            unset($USER->enrol['tempguest'][$courseid]);
         }
     }
+    return $access;
+}
 
-    events_trigger('role_assigned', $ra);
+/**
+ * Returns array with sql code and parameters returning all ids
+ * of users enrolled into course.
+ *
+ * This function is using 'eu[0-9]+_' prefix for table names and parameters.
+ *
+ * @param object $context
+ * @param string $withcapability
+ * @param int $groupid 0 means ignore groups, any other value limits the result by group id
+ * @param bool $onlyactive consider only active enrolments in enabled plugins and time restrictions
+ * @return array list($sql, $params)
+ */
+function get_enrolled_sql($context, $withcapability = '', $groupid = 0, $onlyactive = false) {
+    global $DB, $CFG;
 
-    return true;
-}
+    // use unique prefix just in case somebody makes some SQL magic with the result
+    static $i = 0;
+    $i++;
+    $prefix = 'eu'.$i.'_';
+
+    // first find the course context
+    $coursecontext = get_course_context($context);
+
+    $isfrontpage = ($coursecontext->instanceid == SITEID);
 
+    $joins  = array();
+    $wheres = array();
+    $params = array();
 
-/**
- * Deletes one or more role assignments.   You must specify at least one parameter.
- * @param $roleid
- * @param $userid
- * @param $groupid
- * @param $contextid
- * @param $enrol unassign only if enrolment type matches, NULL means anything
- * @return boolean - success or failure
- */
-function role_unassign($roleid=0, $userid=0, $groupid=0, $contextid=0, $enrol=NULL) {
-    global $USER, $CFG;
-    require_once($CFG->dirroot.'/group/lib.php');
+    list($contextids, $contextpaths) = get_context_info_list($context);
 
-    $success = true;
+    // get all relevant capability info for all roles
+    if ($withcapability) {
+        list($incontexts, $cparams) = $DB->get_in_or_equal($contextids, SQL_PARAMS_NAMED, 'ctx');
+        $cparams['cap'] = $withcapability;
 
-    $args = array('roleid', 'userid', 'groupid', 'contextid');
-    $select = array();
-    foreach ($args as $arg) {
-        if ($$arg) {
-            $select[] = $arg.' = '.$$arg;
-        }
-    }
-    if (!empty($enrol)) {
-        $select[] = "enrol='$enrol'";
+        $defs = array();
+        $sql = "SELECT rc.id, rc.roleid, rc.permission, ctx.path
+                  FROM {role_capabilities} rc
+                  JOIN {context} ctx on rc.contextid = ctx.id
+                 WHERE rc.contextid $incontexts AND rc.capability = :cap";
+        $rcs = $DB->get_records_sql($sql, $cparams);
+        foreach ($rcs as $rc) {
+            $defs[$rc->path][$rc->roleid] = $rc->permission;
     }
 
-    if ($select) {
-        if ($ras = get_records_select('role_assignments', implode(' AND ', $select))) {
-            $mods = get_list_of_plugins('mod');
-            foreach($ras as $ra) {
-                $fireevent = false;
-                /// infinite loop protection when deleting recursively
-                if (!$ra = get_record('role_assignments', 'id', $ra->id)) {
+        $access = array();
+        if (!empty($defs)) {
+            foreach ($contextpaths as $path) {
+                if (empty($defs[$path])) {
                     continue;
                 }
-                if (delete_records('role_assignments', 'id', $ra->id)) {
-                    $fireevent = true;
-                } else {
-                    $success = false;
-                }
-
-                if (!$context = get_context_instance_by_id($ra->contextid)) {
-                    // strange error, not much to do
+                foreach($defs[$path] as $roleid => $perm) {
+                    if ($perm == CAP_PROHIBIT) {
+                        $access[$roleid] = CAP_PROHIBIT;
                     continue;
                 }
+                    if (!isset($access[$roleid])) {
+                        $access[$roleid] = (int)$perm;
+                    }
+                }
+            }
+        }
 
-                /* mark contexts as dirty here, because we need the refreshed
-                 * caps bellow to delete group membership and user_lastaccess!
-                 * and yes, this is very expensive for bulk operations :-(
-                 */
-                mark_context_dirty($context->path);
+        unset($defs);
 
-                /// If the user is the current user, then do full reload of capabilities too.
-                if (!empty($USER->id) && $USER->id == $ra->userid) {
-                    load_all_capabilities();
+        // make lists of roles that are needed and prohibited
+        $needed     = array(); // one of these is enough
+        $prohibited = array(); // must not have any of these
+        foreach ($access as $roleid => $perm) {
+            if ($perm == CAP_PROHIBIT) {
+                unset($needed[$roleid]);
+                $prohibited[$roleid] = true;
+            } else if ($perm == CAP_ALLOW and empty($prohibited[$roleid])) {
+                $needed[$roleid] = true;
+            }
                 }
 
-                /// Ask all the modules if anything needs to be done for this user
-                foreach ($mods as $mod) {
-                    include_once($CFG->dirroot.'/mod/'.$mod.'/lib.php');
-                    $functionname = $mod.'_role_unassign';
-                    if (function_exists($functionname)) {
-                        $functionname($ra->userid, $context); // watch out, $context might be NULL if something goes wrong
+        $defaultuserroleid      = isset($CFG->defaultuserroleid) ? $CFG->defaultuserroleid : 0;
+        $defaultfrontpageroleid = isset($CFG->defaultfrontpageroleid) ? $CFG->defaultfrontpageroleid : 0;
+
+        $nobody = false;
+
+        if ($isfrontpage) {
+            if (!empty($prohibited[$defaultuserroleid]) or !empty($prohibited[$defaultfrontpageroleid])) {
+                $nobody = true;
+            } else if (!empty($needed[$defaultuserroleid]) or !empty($needed[$defaultfrontpageroleid])) {
+                // everybody not having prohibit has the capability
+                $needed = array();
+            } else if (empty($needed)) {
+                $nobody = true;
+            }
+        } else {
+            if (!empty($prohibited[$defaultuserroleid])) {
+                $nobody = true;
+            } else if (!empty($needed[$defaultuserroleid])) {
+                // everybody not having prohibit has the capability
+                $needed = array();
+            } else if (empty($needed)) {
+                $nobody = true;
                     }
                 }
 
-                /// now handle metacourse role unassigment and removing from goups if in course context
-                if ($context->contextlevel == CONTEXT_COURSE) {
+        if ($nobody) {
+            // nobody can match so return some SQL that does not return any results
+            $wheres[] = "1 = 2";
 
-                    // cleanup leftover course groups/subscriptions etc when user has
-                    // no capability to view course
-                    // this may be slow, but this is the proper way of doing it
-                    if (!has_capability('moodle/course:view', $context, $ra->userid)) {
-                        // remove from groups
-                        groups_delete_group_members($context->instanceid, $ra->userid);
+        } else {
 
-                        // delete lastaccess records
-                        delete_records('user_lastaccess', 'userid', $ra->userid, 'courseid', $context->instanceid);
+            if ($needed) {
+                $ctxids = implode(',', $contextids);
+                $roleids = implode(',', array_keys($needed));
+                $joins[] = "JOIN {role_assignments} {$prefix}ra3 ON ({$prefix}ra3.userid = {$prefix}u.id AND {$prefix}ra3.roleid IN ($roleids) AND {$prefix}ra3.contextid IN ($ctxids))";
                     }
 
-                    //unassign roles in metacourses if needed
-                    if ($parents = get_records('course_meta', 'child_course', $context->instanceid)) {
-                        foreach ($parents as $parent) {
-                            sync_metacourse($parent->parent_course);
+            if ($prohibited) {
+                $ctxids = implode(',', $contextids);
+                $roleids = implode(',', array_keys($prohibited));
+                $joins[] = "LEFT JOIN {role_assignments} {$prefix}ra4 ON ({$prefix}ra4.userid = {$prefix}u.id AND {$prefix}ra4.roleid IN ($roleids) AND {$prefix}ra4.contextid IN ($ctxids))";
+                $wheres[] = "{$prefix}ra4.id IS NULL";
                         }
+
+            if ($groupid) {
+                $joins[] = "JOIN {groups_members} {$prefix}gm ON ({$prefix}gm.userid = {$prefix}u.id AND {$prefix}gm.groupid = :{$prefix}gmid)";
+                $params["{$prefix}gmid"] = $groupid;
                     }
                 }
 
-                if ($fireevent) {
-                    events_trigger('role_unassigned', $ra);
+    } else {
+        if ($groupid) {
+            $joins[] = "JOIN {groups_members} {$prefix}gm ON ({$prefix}gm.userid = {$prefix}u.id AND {$prefix}gm.groupid = :{$prefix}gmid)";
+            $params["{$prefix}gmid"] = $groupid;
                 }
             }
+
+    $wheres[] = "{$prefix}u.deleted = 0 AND {$prefix}u.id <> :{$prefix}guestid";
+    $params["{$prefix}guestid"] = $CFG->siteguest;
+
+    if ($isfrontpage) {
+        // all users are "enrolled" on the frontpage
+    } else {
+        $joins[] = "JOIN {user_enrolments} {$prefix}ue ON {$prefix}ue.userid = {$prefix}u.id";
+        $joins[] = "JOIN {enrol} {$prefix}e ON ({$prefix}e.id = {$prefix}ue.enrolid AND {$prefix}e.courseid = :{$prefix}courseid)";
+        $params[$prefix.'courseid'] = $coursecontext->instanceid;
+
+        if ($onlyactive) {
+            $wheres[] = "{$prefix}ue.status = :{$prefix}active AND {$prefix}e.status = :{$prefix}enabled";
+            $wheres[] = "{$prefix}ue.timestart < :{$prefix}now1 AND ({$prefix}ue.timeend = 0 OR {$prefix}ue.timeend > :{$prefix}now2)";
+            $now = round(time(), -2); // rounding helps caching in DB
+            $params = array_merge($params, array($prefix.'enabled'=>ENROL_INSTANCE_ENABLED,
+                                                 $prefix.'active'=>ENROL_USER_ACTIVE,
+                                                 $prefix.'now1'=>$now, $prefix.'now2'=>$now));
         }
     }
 
-    return $success;
+    $joins = implode("\n", $joins);
+    $wheres = "WHERE ".implode(" AND ", $wheres);
+
+    $sql = "SELECT DISTINCT {$prefix}u.id
+               FROM {user} {$prefix}u
+             $joins
+            $wheres";
+
+    return array($sql, $params);
 }
 
 /**
- * A convenience function to take care of the common case where you
- * just want to enrol someone using the default role into a course
- *
- * @param object $course
- * @param object $user
- * @param string $enrol - the plugin used to do this enrolment
+ * Returns list of users enrolled into course.
+ * @param object $context
+ * @param string $withcapability
+ * @param int $groupid 0 means ignore groups, any other value limits the result by group id
+ * @param string $userfields requested user record fields
+ * @param string $orderby
+ * @param int $limitfrom return a subset of records, starting at this point (optional, required if $limitnum is set).
+ * @param int $limitnum return a subset comprising this many records (optional, required if $limitfrom is set).
+ * @return array of user records
  */
-function enrol_into_course($course, $user, $enrol) {
-
-    $timestart = time();
-    // remove time part from the timestamp and keep only the date part
-    $timestart = make_timestamp(date('Y', $timestart), date('m', $timestart), date('d', $timestart), 0, 0, 0);
-    if ($course->enrolperiod) {
-        $timeend = $timestart + $course->enrolperiod;
-    } else {
-        $timeend = 0;
-    }
+function get_enrolled_users($context, $withcapability = '', $groupid = 0, $userfields = 'u.*', $orderby = '', $limitfrom = 0, $limitnum = 0) {
+    global $DB;
 
-    if ($role = get_default_course_role($course)) {
+    list($esql, $params) = get_enrolled_sql($context, $withcapability, $groupid);
+    $sql = "SELECT $userfields
+              FROM {user} u
+              JOIN ($esql) je ON je.id = u.id
+             WHERE u.deleted = 0";
 
-        $context = get_context_instance(CONTEXT_COURSE, $course->id);
-
-        if (!role_assign($role->id, $user->id, 0, $context->id, $timestart, $timeend, 0, $enrol)) {
-            return false;
+    if ($orderby) {
+        $sql = "$sql ORDER BY $orderby";
+    } else {
+        $sql = "$sql ORDER BY u.lastname ASC, u.firstname ASC";
         }
 
-        // force accessdata refresh for users visiting this context...
-        mark_context_dirty($context->path);
-
-        email_welcome_message_to_user($course, $user);
+    return $DB->get_records_sql($sql, $params, $limitfrom, $limitnum);
+}
 
-        add_to_log($course->id, 'course', 'enrol',
-                'view.php?id='.$course->id, $course->id);
+/**
+ * Counts list of users enrolled into course (as per above function)
+ * @param object $context
+ * @param string $withcapability
+ * @param int $groupid 0 means ignore groups, any other value limits the result by group id
+ * @return array of user records
+ */
+function count_enrolled_users($context, $withcapability = '', $groupid = 0) {
+    global $DB;
 
-        return true;
-    }
+    list($esql, $params) = get_enrolled_sql($context, $withcapability, $groupid);
+    $sql = "SELECT count(u.id)
+              FROM {user} u
+              JOIN ($esql) je ON je.id = u.id
+             WHERE u.deleted = 0";
 
-    return false;
+    return $DB->count_records_sql($sql, $params);
 }
 
+
 /**
+ * Loads the capability definitions for the component (from file).
+ *
  * Loads the capability definitions for the component (from file). If no
  * capabilities are defined for the component, we simply return an empty array.
- * @param $component - examples: 'moodle', 'mod/forum', 'block/quiz_results'
- * @return array of capabilities
+ *
+ * @param string $component full plugin name, examples: 'moodle', 'mod_forum'
+ * @return array array of capabilities
  */
 function load_capability_def($component) {
-    global $CFG;
-
-    if ($component == 'moodle') {
-        $defpath = $CFG->libdir.'/db/access.php';
-        $varprefix = 'moodle';
-    } else {
-        $compparts = explode('/', $component);
-
-        if ($compparts[0] == 'report') {
-            $defpath = $CFG->dirroot.'/'.$CFG->admin.'/report/'.$compparts[1].'/db/access.php';
-            $varprefix = $compparts[0].'_'.$compparts[1];
+    $defpath = get_component_directory($component).'/db/access.php';
 
-        } else if ($compparts[0] == 'block') {
-            // Blocks are an exception. Blocks directory is 'blocks', and not
-            // 'block'. So we need to jump through hoops.
-            $defpath = $CFG->dirroot.'/'.$compparts[0].
-                                's/'.$compparts[1].'/db/access.php';
-            $varprefix = $compparts[0].'_'.$compparts[1];
-
-        } else if ($compparts[0] == 'format') {
-            // Similar to the above, course formats are 'format' while they
-            // are stored in 'course/format'.
-            $defpath = $CFG->dirroot.'/course/'.$component.'/db/access.php';
-            $varprefix = $compparts[0].'_'.$compparts[1];
-
-        } else if ($compparts[0] == 'gradeimport') {
-            $defpath = $CFG->dirroot.'/grade/import/'.$compparts[1].'/db/access.php';
-            $varprefix = $compparts[0].'_'.$compparts[1];
-
-        } else if ($compparts[0] == 'gradeexport') {
-            $defpath = $CFG->dirroot.'/grade/export/'.$compparts[1].'/db/access.php';
-            $varprefix = $compparts[0].'_'.$compparts[1];
+    $capabilities = array();
+    if (file_exists($defpath)) {
+        require($defpath);
+        if (!empty(${$component.'_capabilities'})) {
+            // BC capability array name
+            // since 2.0 we prefer $capabilities instead - it is easier to use and matches db/* files
+            debugging('componentname_capabilities array is deprecated, please use capabilities array only in access.php files');
+            $capabilities = ${$component.'_capabilities'};
+        }
+    }
 
-        } else if ($compparts[0] == 'gradereport') {
-            $defpath = $CFG->dirroot.'/grade/report/'.$compparts[1].'/db/access.php';
-            $varprefix = $compparts[0].'_'.$compparts[1];
+    return $capabilities;
+}
 
-        } else if ($compparts[0] == 'coursereport') {
-            $defpath = $CFG->dirroot.'/course/report/'.$compparts[1].'/db/access.php';
-            $varprefix = $compparts[0].'_'.$compparts[1];
+/**
+ * Loads the context level definitions for the component (from file). If no
+ * context levels are defined for the component, we simply return an empty
+ * array.
+ * @param string $component - examples: 'moodle', 'mod_forum', 'block_quiz_results'
+ * @return array array of contexts levels
+ */
+function load_context_level_def($component='moodle') {
+    global $CFG;
 
-        } else {
-            $defpath = $CFG->dirroot.'/'.$component.'/db/access.php';
-            $varprefix = str_replace('/', '_', $component);
-        }
-    }
-    $capabilities = array();
+    $defpath = get_component_directory($component).'/db/access.php';
 
+    $contextlevels = array();
     if (file_exists($defpath)) {
         require($defpath);
-        $capabilities = ${$varprefix.'_capabilities'};
+        if (isset(${$component.'_contextlevels'})) {
+            $contextlevels = ${$component.'_contextlevels'};
     }
-    return $capabilities;
+    }
+
+    return array_keys($contextlevels);
 }
 
 
 /**
- * Gets the capabilities that have been cached in the database for this
- * component.
- * @param $component - examples: 'moodle', 'mod/forum', 'block/quiz_results'
- * @return array of capabilities
+ * Gets the capabilities that have been cached in the database for this component.
+ * @param string $component - examples: 'moodle', 'mod_forum'
+ * @return array array of capabilities
  */
-function get_cached_capabilities($component='moodle') {
-    if ($component == 'moodle') {
-        $storedcaps = get_records_select('capabilities',
-                        "name LIKE 'moodle/%:%'");
-    } else if ($component == 'local') {
-        $storedcaps = get_records_select('capabilities', 
-                        "name LIKE 'moodle/local:%'");
-    } else {
-        $storedcaps = get_records_select('capabilities',
-                        "name LIKE '$component:%'");
-    }
-    return $storedcaps;
+function get_cached_capabilities($component = 'moodle') {
+    global $DB;
+    return $DB->get_records('capabilities', array('component'=>$component));
 }
 
 /**
- * Returns default capabilities for given legacy role type.
- *
- * @param string legacy role name
+ * Returns default capabilities for given role archetype.
+ * @param string $archetype role archetype
  * @return array
  */
-function get_default_capabilities($legacyrole) {
-    if (!$allcaps = get_records('capabilities')) {
-        error('Error: no capabilitites defined!');
+function get_default_capabilities($archetype) {
+    global $DB;
+
+    if (!$archetype) {
+        return array();
     }
+
     $alldefs = array();
     $defaults = array();
     $components = array();
+    $allcaps = $DB->get_records('capabilities');
+
     foreach ($allcaps as $cap) {
         if (!in_array($cap->component, $components)) {
             $components[] = $cap->component;
@@ -3235,46 +4275,41 @@ function get_default_capabilities($legacyrole) {
         }
     }
     foreach($alldefs as $name=>$def) {
-        if (isset($def['legacy'][$legacyrole])) {
-            $defaults[$name] = $def['legacy'][$legacyrole];
+        // Use array 'archetypes if available. Only if not specified, use 'legacy'.
+        if (isset($def['archetypes'])) {
+            if (isset($def['archetypes'][$archetype])) {
+                $defaults[$name] = $def['archetypes'][$archetype];
         }
+        // 'legacy' is for backward compatibility with 1.9 access.php
+        } else {
+            if (isset($def['legacy'][$archetype])) {
+                $defaults[$name] = $def['legacy'][$archetype];
     }
-
-    //some exceptions
-    $defaults['moodle/legacy:'.$legacyrole] = CAP_ALLOW;
-    if ($legacyrole == 'admin') {
-        $defaults['moodle/site:doanything'] = CAP_ALLOW;
     }
+    }
+
     return $defaults;
 }
 
 /**
- * Reset role capabilitites to default according to selected legacy capability.
- * If several legacy caps selected, use the first from get_default_capabilities.
- * If no legacy selected, removes all capabilities.
- *
- * @param int @roleid
+ * Reset role capabilities to default according to selected role archetype.
+ * If no archetype selected, removes all capabilities.
+ * @param int $roleid
+ * @return void
  */
 function reset_role_capabilities($roleid) {
+    global $DB;
+
+    $role = $DB->get_record('role', array('id'=>$roleid), '*', MUST_EXIST);
+    $defaultcaps = get_default_capabilities($role->archetype);
+
     $sitecontext = get_context_instance(CONTEXT_SYSTEM);
-    $legacyroles = get_legacy_roles();
-
-    $defaultcaps = array();
-    foreach($legacyroles as $ltype=>$lcap) {
-        $localoverride = get_local_override($roleid, $sitecontext->id, $lcap);
-        if (!empty($localoverride->permission) and $localoverride->permission == CAP_ALLOW) {
-            //choose first selected legacy capability
-            $defaultcaps = get_default_capabilities($ltype);
-            break;
-        }
-    }
 
-    delete_records('role_capabilities', 'roleid', $roleid);
-    if (!empty($defaultcaps)) {
+    $DB->delete_records('role_capabilities', array('roleid'=>$roleid));
+
         foreach($defaultcaps as $cap=>$permission) {
             assign_capability($cap, $permission, $roleid, $sitecontext->id);
         }
-    }
 }
 
 /**
@@ -3286,13 +4321,35 @@ function reset_role_capabilities($roleid) {
  * will cause any stored capabilities for the component to be removed from
  * the database.
  *
- * @param $component - examples: 'moodle', 'mod/forum', 'block/quiz_results'
- * @return boolean
+ * @param string $component examples: 'moodle', 'mod/forum', 'block/quiz_results'
+ * @return boolean true if success, exception in case of any problems
  */
-function update_capabilities($component='moodle') {
+function update_capabilities($component = 'moodle') {
+    global $DB, $OUTPUT, $ACCESSLIB_PRIVATE;
 
     $storedcaps = array();
 
+    if ($DB->get_manager()->table_exists('context_levels')) {
+        $filectxlvl = load_context_level_def($component);
+
+        $oldctxlvl = $DB->get_records('context_levels', array('component' => $component), '', 'name');
+        foreach ($filectxlvl as $contextlevel) {
+            if (!isset($oldctxlvl[$contextlevel])) {
+                $level = new object;
+                $level->name = $contextlevel;
+                $level->component = $component;
+
+                if (!$DB->insert_record('context_levels', $level, false, 'id')) {
+                    return false;
+                }
+            }
+        }
+        // FIXME: remove old context levels
+        // what needs to be cleaned up?
+        // - contexts (and kill all sub-contexts?)
+        context_level_base::clear_custom_context_level_cache();
+    }
+
     $filecaps = load_capability_def($component);
     $cachedcaps = get_cached_capabilities($component);
     if ($cachedcaps) {
@@ -3303,25 +4360,27 @@ function update_capabilities($component='moodle') {
                 if (!array_key_exists('riskbitmask', $filecaps[$cachedcap->name])) {
                     $filecaps[$cachedcap->name]['riskbitmask'] = 0; // no risk if not specified
                 }
+                if ($cachedcap->captype != $filecaps[$cachedcap->name]['captype']) {
+                    $updatecap = new stdClass();
+                    $updatecap->id = $cachedcap->id;
+                    $updatecap->captype = $filecaps[$cachedcap->name]['captype'];
+                    $DB->update_record('capabilities', $updatecap);
+                }
                 if ($cachedcap->riskbitmask != $filecaps[$cachedcap->name]['riskbitmask']) {
-                    $updatecap = new object();
+                    $updatecap = new stdClass();
                     $updatecap->id = $cachedcap->id;
                     $updatecap->riskbitmask = $filecaps[$cachedcap->name]['riskbitmask'];
-                    if (!update_record('capabilities', $updatecap)) {
-                        return false;
-                    }
+                    $DB->update_record('capabilities', $updatecap);
                 }
 
                 if (!array_key_exists('contextlevel', $filecaps[$cachedcap->name])) {
                     $filecaps[$cachedcap->name]['contextlevel'] = 0; // no context level defined
                 }
                 if ($cachedcap->contextlevel != $filecaps[$cachedcap->name]['contextlevel']) {
-                    $updatecap = new object();
+                    $updatecap = new stdClass();
                     $updatecap->id = $cachedcap->id;
                     $updatecap->contextlevel = $filecaps[$cachedcap->name]['contextlevel'];
-                    if (!update_record('capabilities', $updatecap)) {
-                        return false;
-                    }
+                    $DB->update_record('capabilities', $updatecap);
                 }
             }
         }
@@ -3341,34 +4400,31 @@ function update_capabilities($component='moodle') {
     }
     // Add new capabilities to the stored definition.
     foreach ($newcaps as $capname => $capdef) {
-        $capability = new object;
+        $capability = new stdClass();
         $capability->name = $capname;
         $capability->captype = $capdef['captype'];
         $capability->contextlevel = $capdef['contextlevel'];
         $capability->component = $component;
         $capability->riskbitmask = $capdef['riskbitmask'];
 
-        if (!insert_record('capabilities', $capability, false, 'id')) {
-            return false;
-        }
-
+        $DB->insert_record('capabilities', $capability, false);
 
         if (isset($capdef['clonepermissionsfrom']) && in_array($capdef['clonepermissionsfrom'], $storedcaps)){
-            if ($rolecapabilities = get_records('role_capabilities', 'capability', $capdef['clonepermissionsfrom'])){
+            if ($rolecapabilities = $DB->get_records('role_capabilities', array('capability'=>$capdef['clonepermissionsfrom']))){
                 foreach ($rolecapabilities as $rolecapability){
                     //assign_capability will update rather than insert if capability exists
                     if (!assign_capability($capname, $rolecapability->permission,
                                             $rolecapability->roleid, $rolecapability->contextid, true)){
-                         notify('Could not clone capabilities for '.$capname);
+                         echo $OUTPUT->notification('Could not clone capabilities for '.$capname);
                     }
                 }
             }
-        // Do we need to assign the new capabilities to roles that have the
-        // legacy capabilities moodle/legacy:* as well?
-        // we ignore legacy key if we have cloned permissions
-        } else if (isset($capdef['legacy']) && is_array($capdef['legacy']) &&
-                    !assign_legacy_capabilities($capname, $capdef['legacy'])) {
-            notify('Could not assign legacy capabilities for '.$capname);
+        // we ignore archetype key if we have cloned permissions
+        } else if (isset($capdef['archetypes']) && is_array($capdef['archetypes'])) {
+            assign_legacy_capabilities($capname, $capdef['archetypes']);
+        // 'legacy' is for backward compatibility with 1.9 access.php
+        } else if (isset($capdef['legacy']) && is_array($capdef['legacy'])) {
+            assign_legacy_capabilities($capname, $capdef['legacy']);
         }
     }
     // Are there any capabilities that have been removed from the file
@@ -3377,7 +4433,7 @@ function update_capabilities($component='moodle') {
     capabilities_cleanup($component, $filecaps);
 
     // reset static caches
-    is_valid_capability('reset', false);
+    $ACCESSLIB_PRIVATE->capabilities = null;
 
     return true;
 }
@@ -3386,12 +4442,14 @@ function update_capabilities($component='moodle') {
 /**
  * Deletes cached capabilities that are no longer needed by the component.
  * Also unassigns these capabilities from any roles that have them.
- * @param $component - examples: 'moodle', 'mod/forum', 'block/quiz_results'
- * @param $newcapdef - array of the new capability definitions that will be
+ *
+ * @param string $component examples: 'moodle', 'mod_forum', 'block_quiz_results'
+ * @param array $newcapdef array of the new capability definitions that will be
  *                     compared with the cached capabilities
- * @return int - number of deprecated capabilities that have been removed
+ * @return int number of deprecated capabilities that have been removed
  */
-function capabilities_cleanup($component, $newcapdef=NULL) {
+function capabilities_cleanup($component, $newcapdef = null) {
+    global $DB;
 
     $removedcount = 0;
 
@@ -3401,17 +4459,13 @@ function capabilities_cleanup($component, $newcapdef=NULL) {
                         array_key_exists($cachedcap->name, $newcapdef) === false) {
 
                 // Remove from capabilities cache.
-                if (!delete_records('capabilities', 'name', $cachedcap->name)) {
-                    error('Could not delete deprecated capability '.$cachedcap->name);
-                } else {
+                $DB->delete_records('capabilities', array('name'=>$cachedcap->name));
                     $removedcount++;
-                }
                 // Delete from roles.
-                if($roles = get_roles_with_capability($cachedcap->name)) {
+                if ($roles = get_roles_with_capability($cachedcap->name)) {
                     foreach($roles as $role) {
                         if (!unassign_capability($cachedcap->name, $role->id)) {
-                            error('Could not unassign deprecated capability '.
-                                    $cachedcap->name.' from role '.$role->name);
+                            print_error('cannotunassigncap', 'error', '', (object)array('cap'=>$cachedcap->name, 'role'=>$role->name));
                         }
                     }
                 }
@@ -3423,216 +4477,110 @@ function capabilities_cleanup($component, $newcapdef=NULL) {
 
 
 
-/****************
- * UI FUNCTIONS *
- ****************/
+//////////////////
+// UI FUNCTIONS //
+//////////////////
 
+/**
+ * @param integer $contextlevel $context->context level. One of the CONTEXT_... constants.
+ * @return string the name for this type of context.
+ */
+function get_contextlevel_name($contextlevel) {
+    return context_level_base::get_context_level($contextlevel)->get_contextlevel_name();
+}
 
 /**
- * prints human readable context identifier.
+ * Prints human readable context identifier.
+ *
+ * @param object $context the context.
+ * @param boolean $withprefix whether to prefix the name of the context with the
+ *      type of context, e.g. User, Course, Forum, etc.
+ * @param boolean $short whether to user the short name of the thing. Only applies
+ *      to course contexts
+ * @return string the human readable context name.
  */
 function print_context_name($context, $withprefix = true, $short = false) {
-
-    $name = '';
-    switch ($context->contextlevel) {
-
-        case CONTEXT_SYSTEM: // by now it's a definite an inherit
-            $name = get_string('coresystem');
-            break;
-
-        case CONTEXT_USER:
-            if ($user = get_record('user', 'id', $context->instanceid)) {
-                if ($withprefix){
-                    $name = get_string('user').': ';
-                }
-                $name .= fullname($user);
-            }
-            break;
-
-        case CONTEXT_COURSECAT: // Coursecat -> coursecat or site
-            if ($category = get_record('course_categories', 'id', $context->instanceid)) {
-                if ($withprefix){
-                    $name = get_string('category').': ';
-                }
-                $name .=format_string($category->name);
-            }
-            break;
-
-        case CONTEXT_COURSE: // 1 to 1 to course cat
-            if ($context->instanceid == SITEID) {
-                $name = get_string('frontpage', 'admin');
-            } else {
-                if ($course = get_record('course', 'id', $context->instanceid)) {
-                    if ($withprefix){
-                        $name = get_string('course').': ';
-                    }
-                    if (!$short){
-                        $name .= format_string($course->shortname);
+    if (context_level_base::context_level_exists($context)) {
+        $context_level = context_level_base::get_context_level($context);
+        return $context_level->print_context_name($context, $withprefix, $short);
                     } else {
-                        $name .= format_string($course->fullname);
-                   }
-                }
-            }
-            break;
-
-        case CONTEXT_MODULE: // 1 to 1 to course
-            if ($cm = get_record('course_modules','id',$context->instanceid)) {
-                if ($module = get_record('modules','id',$cm->module)) {
-                    if ($mod = get_record($module->name, 'id', $cm->instance)) {
-                        if ($withprefix){
-                            $name = get_string('activitymodule').': ';
-                        }
-                        $name .= $mod->name;
-                    }
-                }
+        print_error('unknowncontext');
+        return false;
             }
-            break;
+}
 
-        case CONTEXT_BLOCK: // not necessarily 1 to 1 to course
-            if ($blockinstance = get_record('block_instance','id',$context->instanceid)) {
-                if ($block = get_record('block','id',$blockinstance->blockid)) {
-                    global $CFG;
-                    require_once("$CFG->dirroot/blocks/moodleblock.class.php");
-                    require_once("$CFG->dirroot/blocks/$block->name/block_$block->name.php");
-                    $blockname = "block_$block->name";
-                    if ($blockobject = new $blockname()) {
-                        if ($withprefix){
-                            $name = get_string('block').': ';
-                        }
-                        $name .= $blockobject->title;
-                    }
+/**
+ * Get a URL for a context, if there is a natural one. For example, for
+ * CONTEXT_COURSE, this is the course page. For CONTEXT_USER it is the
+ * user profile page.
+ *
+ * @param object $context the context.
+ * @return moodle_url
+ */
+function get_context_url($context) {
+    if(context_level_base::context_level_exists($context)) {
+        $context_level = context_level_base::get_context_level($context);
+        $rv = $context_level->get_context_url($context);
+        if ($rv != null) {
+            return $rv;
                 }
             }
-            break;
 
-        default:
-            error ('This is an unknown context (' . $context->contextlevel . ') in print_context_name!');
-            return false;
+    return new moodle_url('/');
+}
 
-    }
-    return $name;
+/**
+ * Returns an array of all the known types of risk
+ * The array keys can be used, for example as CSS class names, or in calls to
+ * print_risk_icon. The values are the corresponding RISK_ constants.
+ *
+ * @return array all the known types of risk.
+ */
+function get_all_risks() {
+    return array(
+        'riskmanagetrust' => RISK_MANAGETRUST,
+        'riskconfig'      => RISK_CONFIG,
+        'riskxss'         => RISK_XSS,
+        'riskpersonal'    => RISK_PERSONAL,
+        'riskspam'        => RISK_SPAM,
+        'riskdataloss'    => RISK_DATALOSS,
+    );
 }
 
+/**
+ * Return a link to moodle docs for a given capability name
+ *
+ * @param object $capability a capability - a row from the mdl_capabilities table.
+ * @return string the human-readable capability name as a link to Moodle Docs.
+ */
+function get_capability_docs_link($capability) {
+    global $CFG;
+    $url = get_docs_url('Capabilities/' . $capability->name);
+    return '<a onclick="this.target=\'docspopup\'" href="' . $url . '">' . get_capability_string($capability->name) . '</a>';
+}
 
 /**
  * Extracts the relevant capabilities given a contextid.
  * All case based, example an instance of forum context.
  * Will fetch all forum related capabilities, while course contexts
  * Will fetch all capabilities
- * @param object context
- * @return array();
  *
  *  capabilities
  * `name` varchar(150) NOT NULL,
  * `captype` varchar(50) NOT NULL,
  * `contextlevel` int(10) NOT NULL,
  * `component` varchar(100) NOT NULL,
+ *
+ * @param object context
+ * @return array
  */
 function fetch_context_capabilities($context) {
-
-    global $CFG;
-
-    $sort = 'ORDER BY contextlevel,component,name';   // To group them sensibly for display
-
-    switch ($context->contextlevel) {
-
-        case CONTEXT_SYSTEM: // all
-            $SQL = "SELECT *
-                      FROM {$CFG->prefix}capabilities";
-        break;
-
-        case CONTEXT_USER:
-            $extracaps = array('moodle/grade:viewall');
-            foreach ($extracaps as $key=>$value) {
-                $extracaps[$key]= "'$value'";
-            }
-            $extra = implode(',', $extracaps);
-            $SQL = "SELECT *
-                      FROM {$CFG->prefix}capabilities
-                     WHERE contextlevel = ".CONTEXT_USER."
-                           OR name IN ($extra)";
-        break;
-
-        case CONTEXT_COURSECAT: // course category context and bellow
-            $SQL = "SELECT *
-                      FROM {$CFG->prefix}capabilities
-                     WHERE contextlevel IN (".CONTEXT_COURSECAT.",".CONTEXT_COURSE.",".CONTEXT_MODULE.",".CONTEXT_BLOCK.")";
-        break;
-
-        case CONTEXT_COURSE: // course context and bellow
-            $SQL = "SELECT *
-                      FROM {$CFG->prefix}capabilities
-                     WHERE contextlevel IN (".CONTEXT_COURSE.",".CONTEXT_MODULE.",".CONTEXT_BLOCK.")";
-        break;
-
-        case CONTEXT_MODULE: // mod caps
-            $cm = get_record('course_modules', 'id', $context->instanceid);
-            $module = get_record('modules', 'id', $cm->module);
-
-            $modfile = "$CFG->dirroot/mod/$module->name/lib.php";
-            if (file_exists($modfile)) {
-                include_once($modfile);
-                $modfunction = $module->name.'_get_extra_capabilities';
-                if (function_exists($modfunction)) {
-                    $extracaps = $modfunction();
-                }
-            }
-            if(empty($extracaps)) {
-                $extracaps = array();
-            }
-
-            // All modules allow viewhiddenactivities. This is so you can hide
-            // the module then override to allow specific roles to see it.
-            // The actual check is in course page so not module-specific
-            $extracaps[]="moodle/course:viewhiddenactivities";
-            if (count($extracaps) == 1) {
-                $extra = "OR name = '".reset($extracaps)."'";
+    if(context_level_base::context_level_exists($context)) {
+        $context_level = context_level_base::get_context_level($context);
+        return $context_level->fetch_context_capabilities($context);
             } else {
-                foreach ($extracaps as $key=>$value) {
-                    $extracaps[$key]= "'$value'";
-                }
-                $extra = implode(',', $extracaps);
-                $extra = "OR name IN ($extra)";
-            }
-
-            $SQL = "SELECT *
-                      FROM {$CFG->prefix}capabilities
-                     WHERE (contextlevel = ".CONTEXT_MODULE."
-                           AND component = 'mod/$module->name')
-                           $extra";
-        break;
-
-        case CONTEXT_BLOCK: // block caps
-            $cb = get_record('block_instance', 'id', $context->instanceid);
-            $block = get_record('block', 'id', $cb->blockid);
-
-            $extra = "";
-            if ($blockinstance = block_instance($block->name)) {
-                if ($extracaps = $blockinstance->get_extra_capabilities()) {
-                    foreach ($extracaps as $key=>$value) {
-                        $extracaps[$key]= "'$value'";
-                    }
-                    $extra = implode(',', $extracaps);
-                    $extra = "OR name IN ($extra)";
-                }
-            }
-
-            $SQL = "SELECT *
-                      FROM {$CFG->prefix}capabilities
-                     WHERE (contextlevel = ".CONTEXT_BLOCK."
-                           AND component = 'block/$block->name')
-                           $extra";
-        break;
-
-        default:
-        return false;
-    }
-
-    if (!$records = get_records_sql($SQL.' '.$sort)) {
-        $records = array();
+        return false;
     }
-
-    return $records;
 }
 
 
@@ -3640,36 +4588,38 @@ function fetch_context_capabilities($context) {
  * This function pulls out all the resolved capabilities (overrides and
  * defaults) of a role used in capability overrides in contexts at a given
  * context.
+ *
  * @param obj $context
  * @param int $roleid
- * @param bool self - if set to true, resolve till this level, else stop at immediate parent level
- * @return array
+ * @param string $cap capability, optional, defaults to ''
+ * @return array of capabilities
  */
-function role_context_capabilities($roleid, $context, $cap='') {
-    global $CFG;
+function role_context_capabilities($roleid, $context, $cap = '') {
+    global $DB;
 
     $contexts = get_parent_contexts($context);
     $contexts[] = $context->id;
     $contexts = '('.implode(',', $contexts).')';
 
+    $params = array($roleid);
+
     if ($cap) {
-        $search = " AND rc.capability = '$cap' ";
+        $search = " AND rc.capability = ? ";
+        $params[] = $cap;
     } else {
         $search = '';
     }
 
-    $SQL = "SELECT rc.*
-            FROM {$CFG->prefix}role_capabilities rc,
-                 {$CFG->prefix}context c
+    $sql = "SELECT rc.*
+              FROM {role_capabilities} rc, {context} c
             WHERE rc.contextid in $contexts
-                 AND rc.roleid = $roleid
+                   AND rc.roleid = ?
                  AND rc.contextid = c.id $search
-            ORDER BY c.contextlevel DESC,
-                     rc.capability DESC";
+          ORDER BY c.contextlevel DESC, rc.capability DESC";
 
     $capabilities = array();
 
-    if ($records = get_records_sql($SQL)) {
+    if ($records = $DB->get_records_sql($sql, $params)) {
         // We are traversing via reverse order.
         foreach ($records as $record) {
             // If not set yet (i.e. inherit or not set at all), or currently we have a prohibit
@@ -3687,9 +4637,10 @@ function role_context_capabilities($roleid, $context, $cap='') {
  * parent, etc.
  *
  * @param object $context
- * @return array()
+ * @param bool $capability optional, defaults to false
+ * @return array
  */
-function get_parent_contexts($context) {
+function get_parent_contexts($context, $includeself = false) {
 
     if ($context->path == '') {
         return array();
@@ -3697,7 +4648,9 @@ function get_parent_contexts($context) {
 
     $parentcontexts = substr($context->path, 1); // kill leading slash
     $parentcontexts = explode('/', $parentcontexts);
+    if (!$includeself) {
     array_pop($parentcontexts); // and remove its own id
+    }
 
     return array_reverse($parentcontexts);
 }
@@ -3718,9 +4671,60 @@ function get_parent_contextid($context) {
 }
 
 /**
- * @param object $context a context object.
- * @return true if this context is the front page context, or a context inside it,
+ * Constructs array with contextids as first parameter and context paths,
+ * in both cases bottom top including self.
+ *
+ * @param object $context
+ * @return array
+ */
+function get_context_info_list($context) {
+    $contextids = explode('/', ltrim($context->path, '/'));
+    $contextpaths = array();
+    $contextids2 = $contextids;
+    while ($contextids2) {
+        $contextpaths[] = '/' . implode('/', $contextids2);
+        array_pop($contextids2);
+    }
+    return array($contextids, $contextpaths);
+}
+
+/**
+ * Find course context
+ * @param object $context - course or lower context
+ * @return object context of the enclosing course, throws exception when related course context can not be found
+ */
+function get_course_context($context) {
+    if (empty($context->contextlevel)) {
+        throw new coding_exception('Invalid context parameter.');
+
+    } if ($context->contextlevel == CONTEXT_COURSE) {
+        return $context;
+
+    } else if ($context->contextlevel == CONTEXT_MODULE) {
+        return get_context_instance_by_id(get_parent_contextid($context, MUST_EXIST));
+
+    } else if ($context->contextlevel == CONTEXT_BLOCK) {
+        $parentcontext = get_context_instance_by_id(get_parent_contextid($context, MUST_EXIST));
+        if ($parentcontext->contextlevel == CONTEXT_COURSE) {
+            return $parentcontext;
+        } else if ($parentcontext->contextlevel == CONTEXT_MODULE) {
+            return get_context_instance_by_id(get_parent_contextid($parentcontext, MUST_EXIST));
+        } else {
+            throw new coding_exception('Invalid level of block context parameter.');
+        }
+    }
+
+    throw new coding_exception('Invalid context level of parameter.');
+}
+
+/**
+ * Check if context is the front page context or a context inside it
+ *
+ * Returns true if this context is the front page context, or a context inside it,
  *      otherwise false.
+ *
+ * @param object $context a context object.
+ * @return bool
  */
 function is_inside_frontpage($context) {
     $frontpagecontext = get_context_instance(CONTEXT_COURSE, SITEID);
@@ -3728,96 +4732,56 @@ function is_inside_frontpage($context) {
 }
 
 /**
+ * Runs get_records select on context table and returns the result
+ * Does get_records_select on the context table, and returns the results ordered
+ * by contextlevel, and then the natural sort order within each level.
+ * for the purpose of $select, you need to know that the context table has been
+ * aliased to ctx, so for example, you can call get_sorted_contexts('ctx.depth = 3');
+ *
+ * @param string $select the contents of the WHERE clause. Remember to do ctx.fieldname.
+ * @param array $params any parameters required by $select.
+ * @return array the requested context records.
+ */
+function get_sorted_contexts($select, $params = array()) {
+    global $DB;
+    if ($select) {
+        $select = 'WHERE ' . $select;
+    }
+    return $DB->get_records_sql("
+            SELECT ctx.*
+              FROM {context} ctx
+              LEFT JOIN {user} u ON ctx.contextlevel = " . CONTEXT_USER . " AND u.id = ctx.instanceid
+              LEFT JOIN {course_categories} cat ON ctx.contextlevel = " . CONTEXT_COURSECAT . " AND cat.id = ctx.instanceid
+              LEFT JOIN {course} c ON ctx.contextlevel = " . CONTEXT_COURSE . " AND c.id = ctx.instanceid
+              LEFT JOIN {course_modules} cm ON ctx.contextlevel = " . CONTEXT_MODULE . " AND cm.id = ctx.instanceid
+              LEFT JOIN {block_instances} bi ON ctx.contextlevel = " . CONTEXT_BLOCK . " AND bi.id = ctx.instanceid
+           $select
+          ORDER BY ctx.contextlevel, bi.defaultregion, COALESCE(cat.sortorder, c.sortorder, cm.section, bi.defaultweight), u.lastname, u.firstname, cm.id
+            ", $params);
+}
+
+/**
  * Recursive function which, given a context, find all its children context ids.
  *
  * When called for a course context, it will return the modules and blocks
  * displayed in the course page.
  *
  * For course category contexts it will return categories and courses. It will
- * NOT recurse into courses - if you want to do that, call it on the returned
- * courses.
+ * NOT recurse into courses, nor return blocks on the category pages. If you
+ * want to do that, call it on the returned courses.
  *
  * If called on a course context it _will_ populate the cache with the appropriate
  * contexts ;-)
  *
  * @param object $context.
- * @return array of child records
+ * @return array Array of child records
  */
 function get_child_contexts($context) {
-
-    global $CFG, $context_cache;
-
-    // We *MUST* populate the context_cache as the callers
-    // will probably ask for the full record anyway soon after
-    // soon after calling us ;-)
-
-    switch ($context->contextlevel) {
-
-        case CONTEXT_BLOCK:
-            // No children.
-            return array();
-        break;
-
-        case CONTEXT_MODULE:
-            // No children.
-            return array();
-        break;
-
-        case CONTEXT_COURSE:
-            // Find
-            // - module instances - easy
-            // - blocks assigned to the course-view page explicitly - easy
-            $sql = " SELECT ctx.*
-                     FROM {$CFG->prefix}context ctx
-                     WHERE ctx.path LIKE '{$context->path}/%'
-                           AND ctx.contextlevel IN (".CONTEXT_MODULE.",".CONTEXT_BLOCK.")
-            ";
-            $rs  = get_recordset_sql($sql);
-            $records = array();
-            while ($rec = rs_fetch_next_record($rs)) {
-                $records[$rec->id] = $rec;
-                $context_cache[$rec->contextlevel][$rec->instanceid] = $rec;
-            }
-            rs_close($rs);
-            return $records;
-        break;
-
-        case CONTEXT_COURSECAT:
-            // Find
-            // - categories
-            // - courses
-            $sql = " SELECT ctx.*
-                     FROM {$CFG->prefix}context ctx
-                     WHERE ctx.path LIKE '{$context->path}/%'
-                           AND ctx.contextlevel IN (".CONTEXT_COURSECAT.",".CONTEXT_COURSE.")
-            ";
-            $rs  = get_recordset_sql($sql);
-            $records = array();
-            while ($rec = rs_fetch_next_record($rs)) {
-                $records[$rec->id] = $rec;
-                $context_cache[$rec->contextlevel][$rec->instanceid] = $rec;
-            }
-            rs_close($rs);
-            return $records;
-        break;
-
-        case CONTEXT_USER:
-            // No children.
-            return array();
-        break;
-
-        case CONTEXT_SYSTEM:
-            // Just get all the contexts except for CONTEXT_SYSTEM level
-            // and hope we don't OOM in the process - don't cache
-            $sql = 'SELECT c.*'.
-                     'FROM '.$CFG->prefix.'context c '.
-                    'WHERE contextlevel != '.CONTEXT_SYSTEM;
-
-            return get_records_sql($sql);
-        break;
-
-        default:
-            error('This is an unknown context (' . $context->contextlevel . ') in get_child_contexts!');
+    if(context_level_base::context_level_exists($context)) {
+        $context_level = context_level_base::get_context_level($context);
+        return $context_level->get_child_contexts($context);
+    } else {
+        print_error('unknowcontext', '', '', $context->contextlevel);
         return false;
     }
 }
@@ -3825,6 +4789,7 @@ function get_child_contexts($context) {
 
 /**
  * Gets a string for sql calls, searching for stuff in this context or above
+ *
  * @param object $context
  * @return string
  */
@@ -3837,258 +4802,232 @@ function get_related_contexts_string($context) {
 }
 
 /**
- * Verifies if given capability installed.
+ * Returns capability information (cached)
  *
  * @param string $capabilityname
- * @param bool $cached
- * @return book true if capability exists
+ * @return object or null if capability not found
  */
-function is_valid_capability($capabilityname, $cached=true) {
-    static $capsnames = null; // one request per page only
+function get_capability_info($capabilityname) {
+    global $ACCESSLIB_PRIVATE, $DB; // one request per page only
 
-    if (is_null($capsnames) or !$cached) {
-        $capsnames = get_records_menu('capabilities', '', '', '', 'name, 1');
+    // TODO: cache this in shared memory if available, use new $CFG->roledefrev for version check
+
+    if (empty($ACCESSLIB_PRIVATE->capabilities)) {
+        $ACCESSLIB_PRIVATE->capabilities = array();
+        $caps = $DB->get_records('capabilities', array(), 'id, name, captype, riskbitmask');
+        foreach ($caps as $cap) {
+            $capname = $cap->name;
+            unset($cap->id);
+            unset($cap->name);
+            $ACCESSLIB_PRIVATE->capabilities[$capname] = $cap;
+        }
     }
 
-    return array_key_exists($capabilityname, $capsnames);
+    return isset($ACCESSLIB_PRIVATE->capabilities[$capabilityname]) ? $ACCESSLIB_PRIVATE->capabilities[$capabilityname] : null;
 }
 
 /**
  * Returns the human-readable, translated version of the capability.
  * Basically a big switch statement.
- * @param $capabilityname - e.g. mod/choice:readresponses
+ *
+ * @param string $capabilityname e.g. mod/choice:readresponses
+ * @return string
  */
 function get_capability_string($capabilityname) {
 
-    // Typical capabilityname is mod/choice:readresponses
-
-    $names = split('/', $capabilityname);
-    $stringname = $names[1];                 // choice:readresponses
-    $components = split(':', $stringname);
-    $componentname = $components[0];               // choice
-
-    switch ($names[0]) {
-        case 'report':
-            $string = get_string($stringname, 'report_'.$componentname);
-        break;
-
-        case 'mod':
-            $string = get_string($stringname, $componentname);
-        break;
-
-        case 'block':
-            $string = get_string($stringname, 'block_'.$componentname);
-        break;
+    // Typical capability name is 'plugintype/pluginname:capabilityname'
+    list($type, $name, $capname) = preg_split('|[/:]|', $capabilityname);
 
-        case 'moodle':
-            if ($componentname == 'local') {
-                $string = get_string($stringname, 'local');
+    if ($type === 'moodle') {
+        $component = 'core_role';
+    } else if ($type === 'quizreport') {
+        //ugly hack!!
+        $component = 'quiz_'.$name;
             } else {
-                $string = get_string($stringname, 'role');
+        $component = $type.'_'.$name;
             }
-        break;
-
-        case 'enrol':
-            $string = get_string($stringname, 'enrol_'.$componentname);
-        break;
-
-        case 'format':
-            $string = get_string($stringname, 'format_'.$componentname);
-        break;
-
-        case 'gradeexport':
-            $string = get_string($stringname, 'gradeexport_'.$componentname);
-        break;
-
-        case 'gradeimport':
-            $string = get_string($stringname, 'gradeimport_'.$componentname);
-        break;
-
-        case 'gradereport':
-            $string = get_string($stringname, 'gradereport_'.$componentname);
-        break;
 
-        case 'coursereport':
-            $string = get_string($stringname, 'coursereport_'.$componentname);
-        break;
+    $stringname = $name.':'.$capname;
 
-        default:
-            $string = get_string($stringname);
-        break;
+    if ($component === 'core_role' or get_string_manager()->string_exists($stringname, $component)) {
+        return get_string($stringname, $component);
+    }
 
+    $dir = get_component_directory($component);
+    if (!file_exists($dir)) {
+        // plugin broken or does not exist, do not bother with printing of debug message
+        return $capabilityname.' ???';
     }
-    return $string;
+
+    // something is wrong in plugin, better print debug
+    return get_string($stringname, $component);
 }
 
 
 /**
  * This gets the mod/block/course/core etc strings.
- * @param $component
- * @param $contextlevel
+ *
+ * @param string $component
+ * @param int $contextlevel
+ * @return string|bool String is success, false if failed
  */
 function get_component_string($component, $contextlevel) {
 
+    if ($component === 'moodle' or $component === 'core') {
     switch ($contextlevel) {
-
-        case CONTEXT_SYSTEM:
-            if (preg_match('|^enrol/|', $component)) {
-                $langname = str_replace('/', '_', $component);
-                $string = get_string('enrolname', $langname);
-            } else if (preg_match('|^block/|', $component)) {
-                $langname = str_replace('/', '_', $component);
-                $string = get_string('blockname', $langname);
-            } else if (preg_match('|^local|', $component)) {
-                $langname = str_replace('/', '_', $component);
-                $string = get_string('local');
-            } else if (preg_match('|^report/|', $component)) {
-                $string = get_string('reports');
+            case CONTEXT_SYSTEM:    return get_string('coresystem');
+            case CONTEXT_USER:      return get_string('users');
+            case CONTEXT_COURSECAT: return get_string('categories');
+            case CONTEXT_COURSE:    return get_string('course');
+            case CONTEXT_MODULE:    return get_string('activities');
+            case CONTEXT_BLOCK:     return get_string('block');
+            default:                print_error('unknowncontext');
+        }
+    }
+
+    list($type, $name) = normalize_component($component);
+    $dir = get_plugin_directory($type, $name);
+    if (!file_exists($dir)) {
+        // plugin not installed, bad luck, there is no way to find the name
+        return $component.' ???';
+    }
+
+    switch ($type) {
+        // TODO this is really hacky
+        case 'quiz':         return get_string($name.':componentname', $component);// insane hack!!!
+        case 'repository':   return get_string('repository', 'repository').': '.get_string('pluginname', $component);
+        case 'gradeimport':  return get_string('gradeimport', 'grades').': '.get_string('pluginname', $component);
+        case 'gradeexport':  return get_string('gradeexport', 'grades').': '.get_string('pluginname', $component);
+        case 'gradereport':  return get_string('gradereport', 'grades').': '.get_string('pluginname', $component);
+        case 'webservice':   return get_string('webservice', 'webservice').': '.get_string('pluginname', $component);
+        case 'block':        return get_string('block').': '.get_string('pluginname', basename($component));
+        case 'mod':
+            if (get_string_manager()->string_exists('pluginname', $component)) {
+                return get_string('activity').': '.get_string('pluginname', $component);
             } else {
-                $string = get_string('coresystem');
+                return get_string('activity').': '.get_string('modulename', $component);
             }
-        break;
-
-        case CONTEXT_USER:
-            $string = get_string('users');
-        break;
+        default: return get_string('pluginname', $component);
+    }
+}
 
-        case CONTEXT_COURSECAT:
-            $string = get_string('categories');
-        break;
+/**
+ * Gets the list of roles assigned to this context and up (parents)
+ * from the list of roles that are visible on user profile page
+ * and participants page.
+ *
+ * @param object $context
+ * @return array
+ */
+function get_profile_roles($context) {
+    global $CFG, $DB;
 
-        case CONTEXT_COURSE:
-            if (preg_match('|^gradeimport/|', $component)
-                || preg_match('|^gradeexport/|', $component)
-                || preg_match('|^gradereport/|', $component)) {
-                $string = get_string('gradebook', 'admin');
-            } else if (preg_match('|^coursereport/|', $component)) {
-                $string = get_string('coursereports');
-            } else {
-                $string = get_string('course');
+    if (empty($CFG->profileroles)) {
+        return array();
             }
-        break;
 
-        case CONTEXT_MODULE:
-            $string = get_string('modulename', basename($component));
-        break;
+    $allowed = explode(',', $CFG->profileroles);
+    list($rallowed, $params) = $DB->get_in_or_equal($allowed, SQL_PARAMS_NAMED);
 
-        case CONTEXT_BLOCK:
-            if( $component == 'moodle' ){
-                $string = get_string('block');
-            }else{
-                $string = get_string('blockname', 'block_'.basename($component));
-            }
-        break;
+    $contextlist = get_related_contexts_string($context);
 
-        default:
-            error ('This is an unknown context $contextlevel (' . $contextlevel . ') in get_component_string!');
-        return false;
+    $sql = "SELECT DISTINCT r.id, r.name, r.shortname, r.sortorder
+              FROM {role_assignments} ra, {role} r
+             WHERE r.id = ra.roleid
+                   AND ra.contextid $contextlist
+                   AND r.id $rallowed
+          ORDER BY r.sortorder ASC";
 
-    }
-    return $string;
+    return $DB->get_records_sql($sql, $params);
 }
 
 /**
  * Gets the list of roles assigned to this context and up (parents)
+ *
  * @param object $context
- * @param view - set to true when roles are pulled for display only
- *               this is so that we can filter roles with no visible
- *               assignment, for example, you might want to "hide" all
- *               course creators when browsing the course participants
- *               list.
  * @return array
  */
-function get_roles_used_in_context($context, $view = false) {
-
-    global $CFG;
+function get_roles_used_in_context($context) {
+    global $DB;
 
-    // filter for roles with all hidden assignments
-    // no need to return when only pulling roles for reviewing
-    // e.g. participants page.
-    $hiddensql = ($view && !has_capability('moodle/role:viewhiddenassigns', $context))? ' AND ra.hidden = 0 ':'';
     $contextlist = get_related_contexts_string($context);
 
-    $sql = "SELECT DISTINCT r.id,
-                   r.name,
-                   r.shortname,
-                   r.sortorder
-              FROM {$CFG->prefix}role_assignments ra,
-                   {$CFG->prefix}role r
+    $sql = "SELECT DISTINCT r.id, r.name, r.shortname, r.sortorder
+              FROM {role_assignments} ra, {role} r
              WHERE r.id = ra.roleid
                AND ra.contextid $contextlist
-                   $hiddensql
           ORDER BY r.sortorder ASC";
 
-    return get_records_sql($sql);
+    return $DB->get_records_sql($sql);
 }
 
 /**
  * This function is used to print roles column in user profile page.
- * @param int userid
- * @param object context
+ * It is using the CFG->profileroles to limit the list to only interesting roles.
+ * (The permission tab has full details of user role assignments.)
+ *
+ * @param int $userid
+ * @param int $courseid
  * @return string
  */
-function get_user_roles_in_context($userid, $context, $view=true){
-    global $CFG, $USER;
+function get_user_roles_in_course($userid, $courseid) {
+    global $CFG, $DB,$USER;
 
-    $rolestring = '';
-    $SQL = 'select * from '.$CFG->prefix.'role_assignments ra, '.$CFG->prefix.'role r where ra.userid='.$userid.' and ra.contextid='.$context->id.' and ra.roleid = r.id';
-    $rolenames = array();
-    if ($roles = get_records_sql($SQL)) {
-        foreach ($roles as $userrole) {
-            // MDL-12544, if we are in view mode and current user has no capability to view hidden assignment, skip it
-            if ($userrole->hidden && $view && !has_capability('moodle/role:viewhiddenassigns', $context)) {
-                continue;
-            }
-            $rolenames[$userrole->roleid] = $userrole->name;
+    if (empty($CFG->profileroles)) {
+        return '';
         }
 
-        $rolenames = role_fix_names($rolenames, $context);   // Substitute aliases
-
-        foreach ($rolenames as $roleid => $rolename) {
-            $rolenames[$roleid] = '<a href="'.$CFG->wwwroot.'/user/index.php?contextid='.$context->id.'&amp;roleid='.$roleid.'">'.$rolename.'</a>';
+    if ($courseid == SITEID) {
+        $context = get_context_instance(CONTEXT_SYSTEM);
+    } else {
+        $context = get_context_instance(CONTEXT_COURSE, $courseid);
         }
-        $rolestring = implode(',', $rolenames);
+
+    if (empty($CFG->profileroles)) {
+        return array();
     }
-    return $rolestring;
-}
 
+    $allowed = explode(',', $CFG->profileroles);
+    list($rallowed, $params) = $DB->get_in_or_equal($allowed, SQL_PARAMS_NAMED);
 
-/**
- * Checks if a user can override capabilities of a particular role in this context
- * @param object $context
- * @param int targetroleid - the id of the role you want to override
- * @return boolean
- */
-function user_can_override($context, $targetroleid) {
+    $contextlist = get_related_contexts_string($context);
 
-// TODO: not needed anymore, remove in 2.0
+    $sql = "SELECT DISTINCT r.id, r.name, r.shortname, r.sortorder
+              FROM {role_assignments} ra, {role} r
+             WHERE r.id = ra.roleid
+                   AND ra.contextid $contextlist
+                   AND r.id $rallowed
+                   AND ra.userid = :userid
+          ORDER BY r.sortorder ASC";
+    $params['userid'] = $userid;
 
-    // first check if user has override capability
-    // if not return false;
-    if (!has_capability('moodle/role:override', $context)) {
-        return false;
-    }
-    // pull out all active roles of this user from this context(or above)
-    if ($userroles = get_user_roles($context)) {
-        foreach ($userroles as $userrole) {
-            // if any in the role_allow_override table, then it's ok
-            if (get_record('role_allow_override', 'roleid', $userrole->roleid, 'allowoverride', $targetroleid)) {
-                return true;
+    $rolestring = '';
+
+    if ($roles = $DB->get_records_sql($sql, $params)) {
+        foreach ($roles as $userrole) {
+            $rolenames[$userrole->id] = $userrole->name;
             }
+
+        $rolenames = role_fix_names($rolenames, $context);   // Substitute aliases
+
+        foreach ($rolenames as $roleid => $rolename) {
+            $rolenames[$roleid] = '<a href="'.$CFG->wwwroot.'/user/index.php?contextid='.$context->id.'&amp;roleid='.$roleid.'">'.$rolename.'</a>';
         }
+        $rolestring = implode(',', $rolenames);
     }
 
-    return false;
-
+    return $rolestring;
 }
 
 /**
  * Checks if a user can assign users to a particular role in this context
+ *
  * @param object $context
- * @param int targetroleid - the id of the role you want to assign users to
+ * @param int $targetroleid - the id of the role you want to assign users to
  * @return boolean
  */
 function user_can_assign($context, $targetroleid) {
+    global $DB;
 
     // first check if user has override capability
     // if not return false;
@@ -4099,7 +5038,7 @@ function user_can_assign($context, $targetroleid) {
     if ($userroles = get_user_roles($context)) {
         foreach ($userroles as $userrole) {
             // if any in the role_allow_override table, then it's ok
-            if (get_record('role_allow_assign', 'roleid', $userrole->roleid, 'allowassign', $targetroleid)) {
+            if ($DB->get_record('role_allow_assign', array('roleid'=>$userrole->roleid, 'allowassign'=>$targetroleid))) {
                 return true;
             }
         }
@@ -4108,30 +5047,40 @@ function user_can_assign($context, $targetroleid) {
     return false;
 }
 
-/** Returns all site roles in correct sort order.
+/**
+ * Returns all site roles in correct sort order.
  *
+ * @return array
  */
 function get_all_roles() {
-    return get_records('role', '', '', 'sortorder ASC');
+    global $DB;
+    return $DB->get_records('role', null, 'sortorder ASC');
+}
+
+/**
+ * Returns roles of a specified archetype
+ * @param string $archetype
+ * @return array of full role records
+ */
+function get_archetype_roles($archetype) {
+    global $DB;
+    return $DB->get_records('role', array('archetype'=>$archetype), 'sortorder ASC');
 }
 
 /**
- * gets all the user roles assigned in this context, or higher contexts
+ * Gets all the user roles assigned in this context, or higher contexts
  * this is mainly used when checking if a user can assign a role, or overriding a role
  * i.e. we need to know what this user holds, in order to verify against allow_assign and
  * allow_override tables
+ *
  * @param object $context
  * @param int $userid
- * @param view - set to true when roles are pulled for display only
- *               this is so that we can filter roles with no visible
- *               assignment, for example, you might want to "hide" all
- *               course creators when browsing the course participants
- *               list.
+ * @param bool $checkparentcontexts defaults to true
+ * @param string $order defaults to 'c.contextlevel DESC, r.sortorder ASC'
  * @return array
  */
-function get_user_roles($context, $userid=0, $checkparentcontexts=true, $order='c.contextlevel DESC, r.sortorder ASC', $view=false) {
-
-    global $USER, $CFG, $db;
+function get_user_roles($context, $userid = 0, $checkparentcontexts = true, $order = 'c.contextlevel DESC, r.sortorder ASC') {
+    global $USER, $DB;
 
     if (empty($userid)) {
         if (empty($USER->id)) {
@@ -4139,109 +5088,235 @@ function get_user_roles($context, $userid=0, $checkparentcontexts=true, $order='
         }
         $userid = $USER->id;
     }
-    // set up hidden sql
-    $hiddensql = ($view && !has_capability('moodle/role:viewhiddenassigns', $context))? ' AND ra.hidden = 0 ':'';
 
-    if ($checkparentcontexts && ($parents = get_parent_contexts($context))) {
-        $contexts = ' ra.contextid IN ('.implode(',' , $parents).','.$context->id.')';
+    if ($checkparentcontexts) {
+        $contextids = get_parent_contexts($context);
     } else {
-        $contexts = ' ra.contextid = \''.$context->id.'\'';
+        $contextids = array();
     }
+    $contextids[] = $context->id;
+
+    list($contextids, $params) = $DB->get_in_or_equal($contextids, SQL_PARAMS_QM);
+
+    array_unshift($params, $userid);
 
-    if (!$return = get_records_sql('SELECT ra.*, r.name, r.shortname
-                                      FROM '.$CFG->prefix.'role_assignments ra,
-                                           '.$CFG->prefix.'role r,
-                                           '.$CFG->prefix.'context c
-                                     WHERE ra.userid = '.$userid.'
+    $sql = "SELECT ra.*, r.name, r.shortname
+              FROM {role_assignments} ra, {role} r, {context} c
+             WHERE ra.userid = ?
                                            AND ra.roleid = r.id
                                            AND ra.contextid = c.id
-                                           AND '.$contexts . $hiddensql .'
-                                  ORDER BY '.$order)) {
-        $return = array();
-    }
+                   AND ra.contextid $contextids
+          ORDER BY $order";
 
-    return $return;
+    return $DB->get_records_sql($sql ,$params);
 }
 
 /**
- * Creates a record in the allow_override table
- * @param int sroleid - source roleid
- * @param int troleid - target roleid
- * @return int - id or false
+ * Creates a record in the role_allow_override table
+ *
+ * @param int $sroleid source roleid
+ * @param int $troleid target roleid
+ * @return void
  */
 function allow_override($sroleid, $troleid) {
-    $record = new object();
+    global $DB;
+
+    $record = new stdClass();
     $record->roleid = $sroleid;
     $record->allowoverride = $troleid;
-    return insert_record('role_allow_override', $record);
+    $DB->insert_record('role_allow_override', $record);
 }
 
 /**
- * Creates a record in the allow_assign table
- * @param int sroleid - source roleid
- * @param int troleid - target roleid
- * @return int - id or false
+ * Creates a record in the role_allow_assign table
+ *
+ * @param int $sroleid source roleid
+ * @param int $troleid target roleid
+ * @return void
  */
-function allow_assign($sroleid, $troleid) {
-    $record = new object;
-    $record->roleid = $sroleid;
-    $record->allowassign = $troleid;
-    return insert_record('role_allow_assign', $record);
+function allow_assign($fromroleid, $targetroleid) {
+    global $DB;
+
+    $record = new stdClass();
+    $record->roleid      = $fromroleid;
+    $record->allowassign = $targetroleid;
+    $DB->insert_record('role_allow_assign', $record);
+}
+
+/**
+ * Creates a record in the role_allow_switch table
+ *
+ * @param int $sroleid source roleid
+ * @param int $troleid target roleid
+ * @return void
+ */
+function allow_switch($fromroleid, $targetroleid) {
+    global $DB;
+
+    $record = new stdClass();
+    $record->roleid      = $fromroleid;
+    $record->allowswitch = $targetroleid;
+    $DB->insert_record('role_allow_switch', $record);
 }
 
 /**
  * Gets a list of roles that this user can assign in this context
- * @param object $context
- * @param string $field
- * @param int $rolenamedisplay
- * @return array
+ *
+ * @param object $context the context.
+ * @param int $rolenamedisplay the type of role name to display. One of the
+ *      ROLENAME_X constants. Default ROLENAME_ALIAS.
+ * @param bool $withusercounts if true, count the number of users with each role.
+ * @param integer|object $user A user id or object. By default (null) checks the permissions of the current user.
+ * @return array if $withusercounts is false, then an array $roleid => $rolename.
+ *      if $withusercounts is true, returns a list of three arrays,
+ *      $rolenames, $rolecounts, and $nameswithcounts.
  */
-function get_assignable_roles($context, $field='name', $rolenamedisplay=ROLENAME_ALIAS) {
-    global $USER, $CFG;
+function get_assignable_roles($context, $rolenamedisplay = ROLENAME_ALIAS, $withusercounts = false, $user = null) {
+    global $USER, $DB;
 
-    if (!has_capability('moodle/role:assign', $context)) {
+    // make sure there is a real user specified
+    if ($user === null) {
+        $userid = isset($USER->id) ? $USER->id : 0;
+    } else {
+        $userid = is_object($user) ? $user->id : $user;
+    }
+
+    if (!has_capability('moodle/role:assign', $context, $userid)) {
+        if ($withusercounts) {
+            return array(array(), array(), array());
+        } else {
         return array();
     } 
+    }
 
-    $parents = get_parent_contexts($context);
-    $parents[] = $context->id;
+    $parents = get_parent_contexts($context, true);
     $contexts = implode(',' , $parents);
 
-    if (!$roles = get_records_sql("SELECT ro.*
-                                     FROM {$CFG->prefix}role ro,
-                                          (
-                                              SELECT DISTINCT r.id
-                                                FROM {$CFG->prefix}role r,
-                                                     {$CFG->prefix}role_assignments ra,
-                                                     {$CFG->prefix}role_allow_assign raa
-                                               WHERE ra.userid = $USER->id AND ra.contextid IN ($contexts)
-                                                 AND raa.roleid = ra.roleid AND r.id = raa.allowassign
-                                          ) inline_view
-                                    WHERE ro.id = inline_view.id
-                                 ORDER BY ro.sortorder ASC")) {
-        return array();
+    $params = array();
+    $extrafields = '';
+    if ($rolenamedisplay == ROLENAME_ORIGINALANDSHORT or $rolenamedisplay == ROLENAME_SHORT) {
+        $extrafields .= ', r.shortname';
+    }
+
+    if ($withusercounts) {
+        $extrafields = ', (SELECT count(u.id)
+                             FROM {role_assignments} cra JOIN {user} u ON cra.userid = u.id
+                            WHERE cra.roleid = r.id AND cra.contextid = :conid AND u.deleted = 0
+                          ) AS usercount';
+        $params['conid'] = $context->id;
     }
 
+    if (is_siteadmin($userid)) {
+        // show all roles allowed in this context to admins
+        $assignrestriction = "";
+    } else {
+        $assignrestriction = "JOIN (SELECT DISTINCT raa.allowassign AS id
+                                      FROM {role_allow_assign} raa
+                                      JOIN {role_assignments} ra ON ra.roleid = raa.roleid
+                                     WHERE ra.userid = :userid AND ra.contextid IN ($contexts)
+                                   ) ar ON ar.id = r.id";
+        $params['userid'] = $userid;
+    }
+    $params['contextlevel'] = $context->contextlevel;
+    $sql = "SELECT r.id, r.name $extrafields
+              FROM {role} r
+              $assignrestriction
+              JOIN {role_context_levels} rcl ON r.id = rcl.roleid
+             WHERE rcl.contextlevel = :contextlevel
+          ORDER BY r.sortorder ASC";
+    $roles = $DB->get_records_sql($sql, $params);
+
+    $rolenames = array();
     foreach ($roles as $role) {
-        $roles[$role->id] = $role->$field;
+        if ($rolenamedisplay == ROLENAME_SHORT) {
+            $rolenames[$role->id] = $role->shortname;
+            continue;
+        }
+        $rolenames[$role->id] = $role->name;
+        if ($rolenamedisplay == ROLENAME_ORIGINALANDSHORT) {
+            $rolenames[$role->id] .= ' (' . $role->shortname . ')';
+        }
+    }
+    if ($rolenamedisplay != ROLENAME_ORIGINALANDSHORT and $rolenamedisplay != ROLENAME_SHORT) {
+        $rolenames = role_fix_names($rolenames, $context, $rolenamedisplay);
+    }
+
+    if (!$withusercounts) {
+        return $rolenames;
     }
 
-    return role_fix_names($roles, $context, $rolenamedisplay);
+    $rolecounts = array();
+    $nameswithcounts = array();
+    foreach ($roles as $role) {
+        $nameswithcounts[$role->id] = $rolenames[$role->id] . ' (' . $roles[$role->id]->usercount . ')';
+        $rolecounts[$role->id] = $roles[$role->id]->usercount;
+    }
+    return array($rolenames, $rolecounts, $nameswithcounts);
 }
 
 /**
- * Gets a list of roles that this user can assign in this context, for the switchrole menu
+ * Gets a list of roles that this user can switch to in a context
  *
- * @param object $context
- * @param string $field
- * @param int $rolenamedisplay
- * @return array
+ * Gets a list of roles that this user can switch to in a context, for the switchrole menu.
+ * This function just process the contents of the role_allow_switch table. You also need to
+ * test the moodle/role:switchroles to see if the user is allowed to switch in the first place.
+ *
+ * @param object $context a context.
+ * @return array an array $roleid => $rolename.
  */
-function get_assignable_roles_for_switchrole($context, $field='name', $rolenamedisplay=ROLENAME_ALIAS) {
-    global $USER, $CFG;
+function get_switchable_roles($context) {
+    global $USER, $DB;
 
-    if (!$CFG->allowuserswitchrolestheycantassign) { //config implemented for MDL-11313
-        if (!has_capability('moodle/role:assign', $context)) {
+    $systemcontext = get_context_instance(CONTEXT_SYSTEM);
+
+    $params = array();
+    $extrajoins = '';
+    $extrawhere = '';
+    if (!is_siteadmin()) {
+        // Admins are allowed to switch to any role with.
+        // Others are subject to the additional constraint that the switch-to role must be allowed by
+        // 'role_allow_switch' for some role they have assigned in this context or any parent.
+        $parents = get_parent_contexts($context);
+        $parents[] = $context->id;
+        $contexts = implode(',' , $parents);
+
+        $extrajoins = "JOIN {role_allow_switch} ras ON ras.allowswitch = rc.roleid
+        JOIN {role_assignments} ra ON ra.roleid = ras.roleid";
+        $extrawhere = "WHERE ra.userid = :userid AND ra.contextid IN ($contexts)";
+        $params['userid'] = $USER->id;
+    }
+
+    $query = "
+        SELECT r.id, r.name
+          FROM (SELECT DISTINCT rc.roleid
+                  FROM {role_capabilities} rc
+                  $extrajoins
+                  $extrawhere) idlist
+          JOIN {role} r ON r.id = idlist.roleid
+      ORDER BY r.sortorder";
+
+    $rolenames = $DB->get_records_sql_menu($query, $params);
+    return role_fix_names($rolenames, $context, ROLENAME_ALIAS);
+}
+
+/**
+ * Gets a list of roles that this user can override in this context.
+ *
+ * @param object $context the context.
+ * @param int $rolenamedisplay the type of role name to display. One of the
+ *      ROLENAME_X constants. Default ROLENAME_ALIAS.
+ * @param bool $withcounts if true, count the number of overrides that are set for each role.
+ * @return array if $withcounts is false, then an array $roleid => $rolename.
+ *      if $withusercounts is true, returns a list of three arrays,
+ *      $rolenames, $rolecounts, and $nameswithcounts.
+ */
+function get_overridable_roles($context, $rolenamedisplay = ROLENAME_ALIAS, $withcounts = false) {
+    global $USER, $DB;
+
+    if (!has_any_capability(array('moodle/role:safeoverride', 'moodle/role:override'), $context)) {
+        if ($withcounts) {
+            return array(array(), array(), array());
+        } else {
             return array();
         }
     }
@@ -4250,105 +5325,155 @@ function get_assignable_roles_for_switchrole($context, $field='name', $rolenamed
     $parents[] = $context->id;
     $contexts = implode(',' , $parents);
 
-    if (!$roles = get_records_sql("SELECT ro.*
-                                     FROM {$CFG->prefix}role ro,
-                                          (
-                                              SELECT DISTINCT r.id
-                                                FROM {$CFG->prefix}role r,
-                                                     {$CFG->prefix}role_assignments ra,
-                                                     {$CFG->prefix}role_allow_assign raa,
-                                                     {$CFG->prefix}role_capabilities rc
-                                               WHERE ra.userid = $USER->id AND ra.contextid IN ($contexts)
-                                                 AND raa.roleid = ra.roleid AND r.id = raa.allowassign
-                                                 AND r.id = rc.roleid AND rc.capability = 'moodle/course:view' AND rc.permission = " . CAP_ALLOW . "
-                                                 AND NOT EXISTS (SELECT 1 FROM {$CFG->prefix}role_capabilities irc
-                                                        WHERE irc.roleid = r.id AND irc.capability = 'moodle/site:doanything' AND irc.permission = " . CAP_ALLOW . ")
-                                          ) inline_view
-                                    WHERE ro.id = inline_view.id
-                                 ORDER BY ro.sortorder ASC")) {
-        return array();
+    $params = array();
+    $extrafields = '';
+    if ($rolenamedisplay == ROLENAME_ORIGINALANDSHORT) {
+        $extrafields .= ', ro.shortname';
+    }
+
+    $params['userid'] = $USER->id;
+    if ($withcounts) {
+        $extrafields = ', (SELECT count(rc.id) FROM {role_capabilities} rc
+                WHERE rc.roleid = ro.id AND rc.contextid = :conid) AS overridecount';
+        $params['conid'] = $context->id;
+    }
+
+    if (is_siteadmin()) {
+        // show all roles to admins
+        $roles = $DB->get_records_sql("
+            SELECT ro.id, ro.name$extrafields
+              FROM {role} ro
+          ORDER BY ro.sortorder ASC", $params);
+
+    } else {
+        $roles = $DB->get_records_sql("
+            SELECT ro.id, ro.name$extrafields
+              FROM {role} ro
+              JOIN (SELECT DISTINCT r.id
+                      FROM {role} r
+                      JOIN {role_allow_override} rao ON r.id = rao.allowoverride
+                      JOIN {role_assignments} ra ON rao.roleid = ra.roleid
+                     WHERE ra.userid = :userid AND ra.contextid IN ($contexts)
+                   ) inline_view ON ro.id = inline_view.id
+          ORDER BY ro.sortorder ASC", $params);
     }
 
+    $rolenames = array();
     foreach ($roles as $role) {
-        $roles[$role->id] = $role->$field;
+        $rolenames[$role->id] = $role->name;
+        if ($rolenamedisplay == ROLENAME_ORIGINALANDSHORT) {
+            $rolenames[$role->id] .= ' (' . $role->shortname . ')';
     }
+    }
+    if ($rolenamedisplay != ROLENAME_ORIGINALANDSHORT) {
+        $rolenames = role_fix_names($rolenames, $context, $rolenamedisplay);
+    }
+
+    if (!$withcounts) {
+        return $rolenames;
+}
 
-    return role_fix_names($roles, $context, $rolenamedisplay);
+    $rolecounts = array();
+    $nameswithcounts = array();
+    foreach ($roles as $role) {
+        $nameswithcounts[$role->id] = $rolenames[$role->id] . ' (' . $roles[$role->id]->overridecount . ')';
+        $rolecounts[$role->id] = $roles[$role->id]->overridecount;
+    }
+    return array($rolenames, $rolecounts, $nameswithcounts);
 }
 
 /**
- * Gets a list of roles that this user can override or safeoverride in this context
+ * Create a role menu suitable for default role selection in enrol plugins.
  * @param object $context
- * @param string $field
- * @param int $rolenamedisplay
- * @return array
+ * @param int $addroleid current or default role - always added to list
+ * @return array roleid=>localised role name
  */
-function get_overridable_roles($context, $field='name', $rolenamedisplay=ROLENAME_ALIAS) {
-    global $USER, $CFG;
-
-    if (!has_capability('moodle/role:override', $context) and !has_capability('moodle/role:safeoverride', $context)) {
-        return array();
-    } 
-
-    $parents = get_parent_contexts($context);
-    $parents[] = $context->id;
-    $contexts = implode(',' , $parents);
+function get_default_enrol_roles($context, $addroleid = null) {
+    global $DB;
 
-    if (!$roles = get_records_sql("SELECT ro.*
-                                     FROM {$CFG->prefix}role ro,
-                                          (
-                                              SELECT DISTINCT r.id
-                                                FROM {$CFG->prefix}role r,
-                                                     {$CFG->prefix}role_assignments ra,
-                                                     {$CFG->prefix}role_allow_override rao
-                                               WHERE ra.userid = $USER->id AND ra.contextid IN ($contexts)
-                                                 AND rao.roleid = ra.roleid AND r.id = rao.allowoverride
-                                          ) inline_view
-                                    WHERE ro.id = inline_view.id
-                                 ORDER BY ro.sortorder ASC")) {
-        return array();
+    $params = array('contextlevel'=>CONTEXT_COURSE);
+    if ($addroleid) {
+        $addrole = "OR r.id = :addroleid";
+        $params['addroleid'] = $addroleid;
+    } else {
+        $addrole = "";
     }
+    $sql = "SELECT r.id, r.name
+              FROM {role} r
+         LEFT JOIN {role_context_levels} rcl ON (rcl.roleid = r.id AND rcl.contextlevel = :contextlevel)
+             WHERE rcl.id IS NOT NULL $addrole
+          ORDER BY sortorder DESC";
 
-    foreach ($roles as $role) {
-        $roles[$role->id] = $role->$field;
-    }
+    $roles = $DB->get_records_sql_menu($sql, $params);
+    $roles = role_fix_names($roles, $context, ROLENAME_BOTH);
 
-    return role_fix_names($roles, $context, $rolenamedisplay);
+    return $roles;
 }
 
 /**
- *  Returns a role object that is the default role for new enrolments
- *  in a given course
- *
- *  @param object $course
- *  @return object $role
+ * @param integer $roleid the id of a role.
+ * @return array list of the context levels at which this role may be assigned.
  */
-function get_default_course_role($course) {
-    global $CFG;
+function get_role_contextlevels($roleid) {
+    global $DB;
+    return $DB->get_records_menu('role_context_levels', array('roleid' => $roleid),
+            'contextlevel', 'id,contextlevel');
+}
 
-/// First let's take the default role the course may have
-    if (!empty($course->defaultrole)) {
-        if ($role = get_record('role', 'id', $course->defaultrole)) {
-            return $role;
-        }
-    }
+/**
+ * @param integer $contextlevel a contextlevel.
+ * @return array list of role ids that are assignable at this context level.
+ */
+function get_roles_for_contextlevels($contextlevel) {
+    global $DB;
+    return $DB->get_records_menu('role_context_levels', array('contextlevel' => $contextlevel),
+            '', 'id,roleid');
+}
 
-/// Otherwise the site setting should tell us
-    if ($CFG->defaultcourseroleid) {
-        if ($role = get_record('role', 'id', $CFG->defaultcourseroleid)) {
-            return $role;
-        }
+/**
+ * @param string $rolearchetype one of the role archetypes - that is, one of the keys
+ *      from the array returned by get_role_archetypes();
+ * @return array list of the context levels at which this type of role may be assigned by default.
+ */
+function get_default_contextlevels($rolearchetype) {
+    static $defaults = array(
+        'manager'        => array(CONTEXT_SYSTEM, CONTEXT_COURSECAT, CONTEXT_COURSE),
+        'coursecreator'  => array(CONTEXT_SYSTEM, CONTEXT_COURSECAT),
+        'editingteacher' => array(CONTEXT_COURSE, CONTEXT_MODULE),
+        'teacher'        => array(CONTEXT_COURSE, CONTEXT_MODULE),
+        'student'        => array(CONTEXT_COURSE, CONTEXT_MODULE),
+        'guest'          => array(),
+        'user'           => array(),
+        'frontpage'      => array());
+
+    if (isset($defaults[$rolearchetype])) {
+        return $defaults[$rolearchetype];
+    } else {
+        return array();
     }
+}
 
-/// It's unlikely we'll get here, but just in case, try and find a student role
-    if ($studentroles = get_roles_with_capability('moodle/legacy:student', CAP_ALLOW)) {
-        return array_shift($studentroles);   /// Take the first one
+/**
+ * Set the context levels at which a particular role can be assigned.
+ * Throws exceptions in case of error.
+ *
+ * @param integer $roleid the id of a role.
+ * @param array $contextlevels the context levels at which this role should be assignable,
+ *      duplicate levels are removed.
+ * @return void
+ */
+function set_role_contextlevels($roleid, array $contextlevels) {
+    global $DB;
+    $DB->delete_records('role_context_levels', array('roleid' => $roleid));
+    $rcl = new stdClass();
+    $rcl->roleid = $roleid;
+    $contextlevels = array_unique($contextlevels);
+    foreach ($contextlevels as $level) {
+        $rcl->contextlevel = $level;
+        $DB->insert_record('role_context_levels', $rcl, false, true);
     }
-
-    return NULL;
 }
 
-
 /**
  * Who has this capability in this context?
  *
@@ -4359,39 +5484,40 @@ function get_default_course_role($course) {
  * which can get rather large - and has a serious perf impact
  * on some DBs.
  *
- * @param $context - object
- * @param $capability - string capability, or an array of capabilities, in which
- *               case users having any of those capabilities will be returned.
- *               For performance reasons, you are advised to put the capability
- *               that the user is most likely to have first.
- * @param $fields - fields to be pulled. The user table is aliased to 'u'. u.id MUST be included.
- * @param $sort - the sort order. Default is lastaccess time.
- * @param $limitfrom - number of records to skip (offset)
- * @param $limitnum - number of records to fetch
- * @param $groups - single group or array of groups - only return
+ * @param object $context
+ * @param string|array $capability - capability name(s)
+ * @param string $fields - fields to be pulled. The user table is aliased to 'u'. u.id MUST be included.
+ * @param string $sort - the sort order. Default is lastaccess time.
+ * @param mixed $limitfrom - number of records to skip (offset)
+ * @param mixed $limitnum - number of records to fetch
+ * @param string|array $groups - single group or array of groups - only return
  *               users who are in one of these group(s).
- * @param $exceptions - list of users to exclude
- * @param view - set to true when roles are pulled for display only
- *               this is so that we can filter roles with no visible
- *               assignment, for example, you might want to "hide" all
- *               course creators when browsing the course participants
- *               list.
- * @param boolean $useviewallgroups if $groups is set the return users who
+ * @param string|array $exceptions - list of users to exclude, comma separated or array
+ * @param bool $doanything_ignored not used any more, admin accounts are never returned
+ * @param bool $view_ignored - use get_enrolled_sql() instead
+ * @param bool $useviewallgroups if $groups is set the return users who
  *               have capability both $capability and moodle/site:accessallgroups
  *               in this context, as well as users who have $capability and who are
  *               in $groups.
+ * @return mixed
  */
-function get_users_by_capability($context, $capability, $fields='', $sort='',
-        $limitfrom='', $limitnum='', $groups='', $exceptions='', $doanything=true,
-        $view=false, $useviewallgroups=false) {
-    global $CFG;
+function get_users_by_capability($context, $capability, $fields = '', $sort = '', $limitfrom = '', $limitnum = '',
+                                 $groups = '', $exceptions = '', $doanything_ignored = null, $view_ignored = null, $useviewallgroups = false) {
+    global $CFG, $DB;
 
-    $ctxids = substr($context->path, 1); // kill leading slash
+    if (empty($context->id)) {
+        throw new coding_exception('Invalid context specified');
+    }
+
+    $defaultuserroleid      = isset($CFG->defaultuserroleid) ? $CFG->defaultuserroleid : 0;
+    $defaultfrontpageroleid = isset($CFG->defaultfrontpageroleid) ? $CFG->defaultfrontpageroleid : 0;
+
+    $ctxids = trim($context->path, '/');
     $ctxids = str_replace('/', ',', $ctxids);
 
     // Context is the frontpage
-    $isfrontpage = false;
     $iscoursepage = false; // coursepage other than fp
+    $isfrontpage = false;
     if ($context->contextlevel == CONTEXT_COURSE) {
         if ($context->instanceid == SITEID) {
             $isfrontpage = true;
@@ -4399,148 +5525,104 @@ function get_users_by_capability($context, $capability, $fields='', $sort='',
             $iscoursepage = true;
         }
     }
+    $isfrontpage = ($isfrontpage || is_inside_frontpage($context));
 
-    // What roles/rolecaps are interesting?
-    if (is_array($capability)) {
-        $caps = "'" . implode("','", $capability) . "'";
-        $capabilities = $capability;
-    } else {
-        $caps = "'" . $capability . "'";
-        $capabilities = array($capability);
-    }
-    if ($doanything===true) {
-        $caps .= ",'moodle/site:doanything'";
-        $capabilities[] = 'moodle/site:doanything';
-        $doanything_join='';
-        $doanything_cond='';
-    } else {
-        // This is an outer join against
-        // admin-ish roleids. Any row that succeeds
-        // in JOINing here ends up removed from
-        // the resultset. This means we remove
-        // rolecaps from roles that also have
-        // 'doanything' capabilities.
-        $doanything_join="LEFT OUTER JOIN (
-                              SELECT DISTINCT rc.roleid
-                              FROM {$CFG->prefix}role_capabilities rc
-                              WHERE rc.capability='moodle/site:doanything'
-                                    AND rc.permission=".CAP_ALLOW."
-                                    AND rc.contextid IN ($ctxids)
-                          ) dar
-                             ON rc.roleid=dar.roleid";
-        $doanything_cond="AND dar.roleid IS NULL";
-    }
-
-    // fetch all capability records - we'll walk several
-    // times over them, and should be a small set
-
-    $negperm = false; // has any negative (<0) permission?
-    $roleids = array();
-
-    $sql = "SELECT rc.id, rc.roleid, rc.permission, rc.capability,
-                   ctx.depth AS ctxdepth, ctx.contextlevel AS ctxlevel
-            FROM {$CFG->prefix}role_capabilities rc
-            JOIN {$CFG->prefix}context ctx on rc.contextid = ctx.id
-            $doanything_join
-            WHERE rc.capability IN ($caps) AND ctx.id IN ($ctxids)
-                  $doanything_cond
-            ORDER BY rc.roleid ASC, ctx.depth ASC";
-    if ($capdefs = get_records_sql($sql)) {
-        foreach ($capdefs AS $rcid=>$rc) {
-            $roleids[] = (int)$rc->roleid;
-            if ($rc->permission < 0) {
-                $negperm = true;
-            }
-        }
-    }
-        
-    $roleids = array_unique($roleids);
-
-    if (count($roleids)===0) { // noone here!
-        return false;
-    }
+    $caps = (array)$capability;
 
-    // is the default role interesting? does it have
-    // a relevant rolecap? (we use this a lot later)
-    if (in_array((int)$CFG->defaultuserroleid, $roleids, true)) {
-        $defaultroleinteresting = true;
-    } else {
-        $defaultroleinteresting = false;
+    // construct list of context paths bottom-->top
+    list($contextids, $paths) = get_context_info_list($context);
+
+    // we need to find out all roles that have these capabilities either in definition or in overrides
+    $defs = array();
+    list($incontexts, $params) = $DB->get_in_or_equal($contextids, SQL_PARAMS_NAMED, 'con');
+    list($incaps, $params2) = $DB->get_in_or_equal($caps, SQL_PARAMS_NAMED, 'cap');
+    $params = array_merge($params, $params2);
+    $sql = "SELECT rc.id, rc.roleid, rc.permission, rc.capability, ctx.path
+              FROM {role_capabilities} rc
+              JOIN {context} ctx on rc.contextid = ctx.id
+             WHERE rc.contextid $incontexts AND rc.capability $incaps";
+
+    $rcs = $DB->get_records_sql($sql, $params);
+    foreach ($rcs as $rc) {
+        $defs[$rc->capability][$rc->path][$rc->roleid] = $rc->permission;
     }
 
-    // is the default role interesting? does it have
-    // a relevant rolecap? (we use this a lot later)
-    if (($isfrontpage or is_inside_frontpage($context)) and !empty($CFG->defaultfrontpageroleid) and in_array((int)$CFG->defaultfrontpageroleid, $roleids, true)) {
-        if (!empty($CFG->fullusersbycapabilityonfrontpage)) {
-            // new in 1.9.6 - full support for defaultfrontpagerole MDL-19039
-            $frontpageroleinteresting = true;
-        } else {
-            // old style 1.9.0-1.9.5 - much faster + fewer negative override problems on frontpage
-            $frontpageroleinteresting = ($context->contextlevel == CONTEXT_COURSE);
+    // go through the permissions bottom-->top direction to evaluate the current permission,
+    // first one wins (prohibit is an exception that always wins)
+    $access = array();
+    foreach ($caps as $cap) {
+        foreach ($paths as $path) {
+            if (empty($defs[$cap][$path])) {
+                continue;
         }
-    } else {
-        $frontpageroleinteresting = false;
+            foreach($defs[$cap][$path] as $roleid => $perm) {
+                if ($perm == CAP_PROHIBIT) {
+                    $access[$cap][$roleid] = CAP_PROHIBIT;
+                    continue;
+                }
+                if (!isset($access[$cap][$roleid])) {
+                    $access[$cap][$roleid] = (int)$perm;
     }
-
-    //
-    // Prepare query clauses
-    //
-    $wherecond = array();
-
-    // Non-deleted users. We never return deleted users.
-    $wherecond['nondeleted'] = 'u.deleted = 0';
-
-    /// Groups
-    if ($groups) {
-        if (is_array($groups)) {
-            $grouptest = 'gm.groupid IN (' . implode(',', $groups) . ')';
-        } else {
-            $grouptest = 'gm.groupid = ' . $groups;
         }
-        $grouptest = 'u.id IN (SELECT userid FROM ' .
-            $CFG->prefix . 'groups_members gm WHERE ' . $grouptest . ')';
-
-        if ($useviewallgroups) {
-            $viewallgroupsusers = get_users_by_capability($context,
-                    'moodle/site:accessallgroups', 'u.id, u.id', '', '', '', '', $exceptions);
-            $wherecond['groups'] =  '('. $grouptest . ' OR u.id IN (' .
-                                    implode(',', array_keys($viewallgroupsusers)) . '))';
-        } else {
-            $wherecond['groups'] =  '(' . $grouptest .')';
         }
     }
 
-    /// User exceptions
-    if (!empty($exceptions)) {
-        $wherecond['userexceptions'] = ' u.id NOT IN ('.$exceptions.')';
+    // make lists of roles that are needed and prohibited in this context
+    $needed = array(); // one of these is enough
+    $prohibited = array(); // must not have any of these
+    foreach ($caps as $cap) {
+        if (empty($access[$cap])) {
+            continue;
+        }
+        foreach ($access[$cap] as $roleid => $perm) {
+            if ($perm == CAP_PROHIBIT) {
+                unset($needed[$cap][$roleid]);
+                $prohibited[$cap][$roleid] = true;
+            } else if ($perm == CAP_ALLOW and empty($prohibited[$cap][$roleid])) {
+                $needed[$cap][$roleid] = true;
+            }
+        }
+        if (empty($needed[$cap]) or !empty($prohibited[$cap][$defaultuserroleid])) {
+            // easy, nobody has the permission
+            unset($needed[$cap]);
+            unset($prohibited[$cap]);
+        } else if ($isfrontpage and !empty($prohibited[$cap][$defaultfrontpageroleid])) {
+            // everybody is disqualified on the frontapge
+            unset($needed[$cap]);
+            unset($prohibited[$cap]);
+        }
+        if (empty($prohibited[$cap])) {
+            unset($prohibited[$cap]);
+        }
     }
 
-    /// Set up hidden role-assignments sql
-    if ($view && !has_capability('moodle/role:viewhiddenassigns', $context)) {
-        $condhiddenra = 'AND ra.hidden = 0 ';
-        $sscondhiddenra = 'AND ssra.hidden = 0 ';
-    } else {
-        $condhiddenra = '';
-        $sscondhiddenra = '';
+    if (empty($needed)) {
+        // there can not be anybody if no roles match this request
+        return array();
     }
 
-    // Collect WHERE conditions
-    $where = implode(' AND ', array_values($wherecond));
-    if ($where != '') {
-        $where = 'WHERE ' . $where;
+    if (empty($prohibited)) {
+        // we can compact the needed roles
+        $n = array();
+        foreach ($needed as $cap) {
+            foreach ($cap as $roleid=>$unused) {
+                $n[$roleid] = true;
+            }
+        }
+        $needed = array('any'=>$n);
+        unset($n);
     }
 
-    /// Set up default fields
+    /// ***** Set up default fields ******
     if (empty($fields)) {
         if ($iscoursepage) {
-            $fields = 'u.*, ul.timeaccess as lastaccess';
+            $fields = 'u.*, ul.timeaccess AS lastaccess';
         } else {
             $fields = 'u.*';
         }
     } else {
-        if (debugging('', DEBUG_DEVELOPER) && strpos($fields, 'u.*') === false &&
-                strpos($fields, 'u.id') === false) {
-            debugging('u.id must be included in the list of fields passed to get_users_by_capability.', DEBUG_DEVELOPER);
+        if (debugging('', DEBUG_DEVELOPER) && strpos($fields, 'u.*') === false && strpos($fields, 'u.id') === false) {
+            debugging('u.id must be included in the list of fields passed to get_users_by_capability().', DEBUG_DEVELOPER);
         }
     }
 
@@ -4552,375 +5634,134 @@ function get_users_by_capability($context, $capability, $fields='', $sort='',
             $sort = 'u.lastaccess';
         }
     }
-    $sortby = $sort ? " ORDER BY $sort " : '';
+    $sortby = "ORDER BY $sort";
+
+    // Prepare query clauses
+    $wherecond = array();
+    $params    = array();
+    $joins     = array();
 
     // User lastaccess JOIN
-    if ((strpos($sort, 'ul.timeaccess') === FALSE) and (strpos($fields, 'ul.timeaccess') === FALSE)) {  // user_lastaccess is not required MDL-13810
-        $uljoin = '';
+    if ((strpos($sort, 'ul.timeaccess') === false) and (strpos($fields, 'ul.timeaccess') === false)) {
+         // user_lastaccess is not required MDL-13810
     } else {
-        $uljoin = "LEFT OUTER JOIN {$CFG->prefix}user_lastaccess ul 
-                         ON (ul.userid = u.id AND ul.courseid = {$context->instanceid})";
-    }
-
-    //
-    // Simple cases - No negative permissions means we can take shortcuts
-    //
-    if (!$negperm) { 
-
-        // at the frontpage, and all site users have it - easy!
-        if ($frontpageroleinteresting) {
-            return get_records_sql("SELECT $fields
-                                    FROM {$CFG->prefix}user u
-                                    WHERE u.deleted = 0
-                                    ORDER BY $sort",
-                                   $limitfrom, $limitnum);
-        }
-
-        // all site users have it, anyway
-        // TODO: NOT ALWAYS!  Check this case because this gets run for cases like this:
-        // 1) Default role has the permission for a module thing like mod/choice:choose
-        // 2) We are checking for an activity module context in a course
-        // 3) Thus all users are returned even though course:view is also required 
-        if ($defaultroleinteresting) {
-            $sql = "SELECT $fields
-                    FROM {$CFG->prefix}user u
-                    $uljoin
-                    $where
-                    ORDER BY $sort";
-            return get_records_sql($sql, $limitfrom, $limitnum);
-        }
-
-        /// Simple SQL assuming no negative rolecaps.
-        /// We use a subselect to grab the role assignments
-        /// ensuring only one row per user -- even if they
-        /// have many "relevant" role assignments.
-        $select = " SELECT $fields";
-        $from   = " FROM {$CFG->prefix}user u
-                    JOIN (SELECT DISTINCT ssra.userid
-                          FROM {$CFG->prefix}role_assignments ssra
-                          WHERE ssra.contextid IN ($ctxids)
-                                AND ssra.roleid IN (".implode(',',$roleids) .")
-                                $sscondhiddenra
-                          ) ra ON ra.userid = u.id
-                    $uljoin ";
-        return get_records_sql($select.$from.$where.$sortby, $limitfrom, $limitnum);
-    }
-
-    //
-    // If there are any negative rolecaps, we need to
-    // work through a subselect that will bring several rows
-    // per user (one per RA).
-    // Since we cannot do the job in pure SQL (not without SQL stored
-    // procedures anyway), we end up tied to processing the data in PHP
-    // all the way down to pagination.
-    //
-    // In some cases, this will mean bringing across a ton of data --
-    // when paginating, we have to walk the permisisons of all the rows
-    // in the _previous_ pages to get the pagination correct in the case
-    // of users that end up not having the permission - this removed.
-    //
-
-    // Prepare the role permissions datastructure for fast lookups
-    $roleperms = array(); // each role cap and depth
-    foreach ($capdefs AS $rcid=>$rc) {
-
-        $rid       = (int)$rc->roleid;
-        $perm      = (int)$rc->permission;
-        $rcdepth   = (int)$rc->ctxdepth;
-        if (!isset($roleperms[$rc->capability][$rid])) {
-            $roleperms[$rc->capability][$rid] = (object)array('perm'  => $perm,
-                                                              'rcdepth' => $rcdepth);
+        if ($iscoursepage) {
+            $joins[] = "LEFT OUTER JOIN {user_lastaccess} ul ON (ul.userid = u.id AND ul.courseid = {$context->instanceid})";
         } else {
-            if ($roleperms[$rc->capability][$rid]->perm == CAP_PROHIBIT) {
-                continue;
+            throw new coding_exception('Invalid sort in get_users_by_capability(), ul.timeaccess allowed only for course contexts.');
             }
-            // override - as we are going
-            // from general to local perms
-            // (as per the ORDER BY...depth ASC above)
-            // and local perms win...
-            $roleperms[$rc->capability][$rid] = (object)array('perm'  => $perm,
-                                                              'rcdepth' => $rcdepth);
-        }
-        
-    }
-
-    if ($context->contextlevel == CONTEXT_SYSTEM
-        || $frontpageroleinteresting
-        || $defaultroleinteresting) {
-
-        // Handle system / sitecourse / defaultrole-with-perhaps-neg-overrides
-        // with a SELECT FROM user LEFT OUTER JOIN against ra -
-        // This is expensive on the SQL and PHP sides -
-        // moves a ton of data across the wire.
-        $ss = "SELECT u.id as userid, ra.roleid,
-                      ctx.depth
-               FROM {$CFG->prefix}user u
-               LEFT OUTER JOIN {$CFG->prefix}role_assignments ra 
-                 ON (ra.userid = u.id
-                     AND ra.contextid IN ($ctxids)
-                     AND ra.roleid IN (".implode(',',$roleids) .")
-                     $condhiddenra)
-               LEFT OUTER JOIN {$CFG->prefix}context ctx
-                 ON ra.contextid=ctx.id
-               WHERE u.deleted=0";
-    } else {
-        // "Normal complex case" - the rolecaps we are after will
-        // be defined in a role assignment somewhere.
-        $ss = "SELECT ra.userid as userid, ra.roleid,
-                      ctx.depth
-               FROM {$CFG->prefix}role_assignments ra 
-               JOIN {$CFG->prefix}context ctx
-                 ON ra.contextid=ctx.id
-               WHERE ra.contextid IN ($ctxids)
-                     $condhiddenra
-                     AND ra.roleid IN (".implode(',',$roleids) .")";
     }
 
-    $select = "SELECT $fields ,ra.roleid, ra.depth ";
-    $from   = "FROM ($ss) ra
-               JOIN {$CFG->prefix}user u
-                 ON ra.userid=u.id
-               $uljoin ";
-
-    // Each user's entries MUST come clustered together
-    // and RAs ordered in depth DESC - the role/cap resolution
-    // code depends on this.
-    $sort .= ' , ra.userid ASC, ra.depth DESC';
-    $sortby .= ' , ra.userid ASC, ra.depth DESC ';
-
-    $rs = get_recordset_sql($select.$from.$where.$sortby);
-
-    //
-    // Process the user accounts+RAs, folding repeats together...
-    //
-    // The processing for this recordset is tricky - to fold
-    // the role/perms of users with multiple role-assignments
-    // correctly while still processing one-row-at-a-time
-    // we need to add a few additional 'private' fields to
-    // the results array - so we can treat the rows as a
-    // state machine to track the cap/perms and at what RA-depth
-    // and RC-depth they were defined.
-    //
-    // So what we do here is:
-    // - loop over rows, checking pagination limits
-    // - when we find a new user, if we are in the page add it to the
-    //   $results, and start building $ras array with its role-assignments
-    // - when we are dealing with the next user, or are at the end of the userlist
-    //   (last rec or last in page), trigger the check-permission idiom
-    // - the check permission idiom will
-    //   - add the default enrolment if needed
-    //   - call has_any_capability_from_rarc(), which based on RAs and RCs will return a bool
-    //     (should be fairly tight code ;-) )
-    // - if the user has permission, all is good, just $c++ (counter)
-    // - ...else, decrease the counter - so pagination is kept straight,
-    //      and (if we are in the page) remove from the results
-    // 
-    $results = array();
-
-    // pagination controls
-    $c = 0;
-    $limitfrom = (int)$limitfrom;
-    $limitnum = (int)$limitnum;
-
-    //
-    // Track our last user id so we know when we are dealing
-    // with a new user... 
-    //
-    $lastuserid  = 0;
-    //
-    // In this loop, we 
-    // $ras: role assignments, multidimensional array
-    // treat as a stack - going from local to general
-    // $ras = (( roleid=> x, $depth=>y) , ( roleid=> x, $depth=>y))
-    //
-    while ($user = rs_fetch_next_record($rs)) {
+    /// We never return deleted users or guest account.
+    $wherecond[] = "u.deleted = 0 AND u.id <> :guestid";
+    $params['guestid'] = $CFG->siteguest;
 
-        //error_log(" Record: " . print_r($user,1));
+    /// Groups
+    if ($groups) {
+        $groups = (array)$groups;
+        list($grouptest, $grpparams) = $DB->get_in_or_equal($groups, SQL_PARAMS_NAMED, 'grp');
+        $grouptest = "u.id IN (SELECT userid FROM {groups_members} gm WHERE gm.groupid $grouptest)";
+        $params = array_merge($params, $grpparams);
 
-        //
-        // Pagination controls 
-        // Note that we might end up removing a user
-        // that ends up _not_ having the rights,
-        // therefore rolling back $c
-        //
-        if ($lastuserid != $user->id) {
-
-            // Did the last user end up with a positive permission?
-            if ($lastuserid !=0) {
-                if ($frontpageroleinteresting) {
-                    // add frontpage role if interesting
-                    $ras[] = array('roleid' => $CFG->defaultfrontpageroleid,
-                                   'depth'  => $context->depth);
-                }
-                if ($defaultroleinteresting) {
-                    // add the role at the end of $ras
-                    $ras[] = array( 'roleid' => $CFG->defaultuserroleid,
-                                    'depth'  => 1 );
-                }
-                if (has_any_capability_from_rarc($ras, $roleperms, $capabilities)) {
-                    $c++;
+        if ($useviewallgroups) {
+            $viewallgroupsusers = get_users_by_capability($context, 'moodle/site:accessallgroups', 'u.id, u.id', '', '', '', '', $exceptions);
+            if (!empty($viewallgroupsusers)) {
+                $wherecond[] =  "($grouptest OR u.id IN (" . implode(',', array_keys($viewallgroupsusers)) . '))';
                 } else {
-                    // remove the user from the result set,
-                    // only if we are 'in the page'
-                    if ($limitfrom === 0 || $c >= $limitfrom) {
-                        unset($results[$lastuserid]);
-                    }
+                $wherecond[] =  "($grouptest)";
                 }
+        } else {
+            $wherecond[] =  "($grouptest)";
             }
-
-            // Did we hit pagination limit?
-            if ($limitnum !==0 && $c >= ($limitfrom+$limitnum)) { // we are done!
-                break;
             }
 
-            // New user setup, and $ras reset
-            $lastuserid = $user->id;
-            $ras = array();
-            if (!empty($user->roleid)) {
-                $ras[] = array( 'roleid' => (int)$user->roleid,
-                                'depth'  => (int)$user->depth );
+    /// User exceptions
+    if (!empty($exceptions)) {
+        $exceptions = (array)$exceptions;
+        list($exsql, $exparams) = $DB->get_in_or_equal($exceptions, SQL_PARAMS_NAMED, 'exc', false);
+        $params = array_merge($params, $exparams);
+        $wherecond[] = "u.id $exsql";
             }
 
-            // if we are 'in the page', also add the rec
-            // to the results...
-            if ($limitfrom === 0 || $c >= $limitfrom) {
-                $results[$user->id] = $user; // trivial
+    // now add the needed and prohibited roles conditions as joins
+    if (!empty($needed['any'])) {
+        // simple case - there are no prohibits involved
+        if (!empty($needed['any'][$defaultuserroleid]) or ($isfrontpage and !empty($needed['any'][$defaultfrontpageroleid]))) {
+            // everybody
+        } else {
+            $joins[] = "JOIN (SELECT DISTINCT userid
+                                FROM {role_assignments}
+                               WHERE contextid IN ($ctxids)
+                                     AND roleid IN (".implode(',', array_keys($needed['any'])) .")
+                             ) ra ON ra.userid = u.id";
             }
         } else {
-            // Additional RA for $lastuserid
-            $ras[] = array( 'roleid'=>(int)$user->roleid,
-                            'depth'=>(int)$user->depth );
+        $unions = array();
+        $everybody = false;
+        foreach ($needed as $cap=>$unused) {
+            if (empty($prohibited[$cap])) {
+                if (!empty($needed[$cap][$defaultuserroleid]) or ($isfrontpage and !empty($needed[$cap][$defaultfrontpageroleid]))) {
+                    $everybody = true;
+                    break;
+                } else {
+                    $unions[] = "SELECT userid
+                                   FROM {role_assignments}
+                                  WHERE contextid IN ($ctxids)
+                                        AND roleid IN (".implode(',', array_keys($needed[$cap])) .")";
         }
+            } else {
+                if (!empty($prohibited[$cap][$defaultuserroleid]) or ($isfrontpage and !empty($prohibited[$cap][$defaultfrontpageroleid]))) {
+                    // nobody can have this cap because it is prevented in default roles
+                    continue;
 
-    } // end while(fetch)
+                } else if (!empty($needed[$cap][$defaultuserroleid]) or ($isfrontpage and !empty($needed[$cap][$defaultfrontpageroleid]))) {
+                    // everybody except the prohibitted - hiding does not matter
+                    $unions[] = "SELECT id AS userid
+                                   FROM {user}
+                                  WHERE id NOT IN (SELECT userid
+                                                     FROM {role_assignments}
+                                                    WHERE contextid IN ($ctxids)
+                                                          AND roleid IN (".implode(',', array_keys($prohibited[$cap])) ."))";
 
-    // Prune last entry if necessary
-    if ($lastuserid !=0) {
-        if ($frontpageroleinteresting) {
-            // add frontpage role if interesting
-            $ras[] = array('roleid' => $CFG->defaultfrontpageroleid,
-                           'depth'  => $context->depth);
-        }
-        if ($defaultroleinteresting) {
-            // add the role at the end of $ras
-            $ras[] = array( 'roleid' => $CFG->defaultuserroleid,
-                            'depth'  => 1 );
+                } else {
+                    $unions[] = "SELECT userid
+                                   FROM {role_assignments}
+                                  WHERE contextid IN ($ctxids)
+                                        AND roleid IN (".implode(',', array_keys($needed[$cap])) .")
+                                        AND roleid NOT IN (".implode(',', array_keys($prohibited[$cap])) .")";
         }
-        if (!has_any_capability_from_rarc($ras, $roleperms, $capabilities)) {
-            // remove the user from the result set,
-            // only if we are 'in the page'
-            if ($limitfrom === 0 || $c >= $limitfrom) {
-                if (isset($results[$lastuserid])) {
-                    unset($results[$lastuserid]);
                 }
             }
+        if (!$everybody) {
+            if ($unions) {
+                $joins[] = "JOIN (SELECT DISTINCT userid FROM ( ".implode(' UNION ', $unions)." ) us) ra ON ra.userid = u.id";
+            } else {
+                // only prohibits found - nobody can be matched
+                $wherecond[] = "1 = 2";
         }
     }
-
-    return $results;
-}
-
-/*
- * Fast (fast!) utility function to resolve if any of a list of capabilities is
- * granted, based on Role Assignments and Role Capabilities.
- *
- * Used (at least) by get_users_by_capability().
- *
- * If PHP had fast built-in memoize functions, we could
- * add a $contextid parameter and memoize the return values.
- *
- * Note that this function must be kept in synch with has_capability_in_accessdata.
- *
- * @param array $ras - role assignments
- * @param array $roleperms - role permissions
- * @param string $capabilities - array of capability names
- * @return boolean
- */
-function has_any_capability_from_rarc($ras, $roleperms, $caps) {
-    // Mini-state machine, using $hascap
-    // $hascap[ 'moodle/foo:bar' ]->perm = CAP_SOMETHING (numeric constant)
-    // $hascap[ 'moodle/foo:bar' ]->radepth = depth of the role assignment that set it
-    // $hascap[ 'moodle/foo:bar' ]->rcdepth = depth of the rolecap that set it
-    // -- when resolving conflicts, we need to look into radepth first, if unresolved
-
-    $hascap = array();
-
-    //
-    // Compute which permission/roleassignment/rolecap
-    // wins for each capability we are walking
-    //
-    foreach ($ras as $ra) {
-        foreach ($caps as $cap) {
-            if (!isset($roleperms[$cap][$ra['roleid']])) {
-                // nothing set for this cap - skip
-                continue;
             }
-            // We explicitly clone here as we
-            // add more properties to it
-            // that must stay separate from the
-            // original roleperm data structure
-            $rp = clone($roleperms[$cap][$ra['roleid']]);
-            $rp->radepth = $ra['depth'];
 
-            // Trivial case, we are the first to set
-            if (!isset($hascap[$cap])) {
-                $hascap[$cap] = $rp;
+    // Collect WHERE conditions and needed joins
+    $where = implode(' AND ', $wherecond);
+    if ($where !== '') {
+        $where = 'WHERE ' . $where;
             }
+    $joins = implode("\n", $joins);
 
-            //
-            // Resolve who prevails, in order of precendence
-            // - Prohibits always wins
-            // - Locality of RA
-            // - Locality of RC
-            //
-            //// Prohibits...
-            if ($rp->perm === CAP_PROHIBIT) {
-                $hascap[$cap] = $rp;
-                continue;
-            }
-            if ($hascap[$cap]->perm === CAP_PROHIBIT) {
-                continue;
-            }
+    /// Ok, let's get the users!
+    $sql = "SELECT $fields
+              FROM {user} u
+            $joins
+            $where
+          ORDER BY $sort";
 
-            // Locality of RA - the look is ordered by depth DESC
-            // so from local to general -
-            // Higher RA loses to local RA... unless perm===0
-            /// Thanks to the order of the records, $rp->radepth <= $hascap[$cap]->radepth
-            if ($rp->radepth > $hascap[$cap]->radepth) {
-                error_log('Should not happen @ ' . __FUNCTION__.':'.__LINE__);
-            }
-            if ($rp->radepth < $hascap[$cap]->radepth) {
-                if ($hascap[$cap]->perm!==0) {
-                    // Wider RA loses to local RAs...
-                    continue;
-                } else {
-                    // "Higher RA resolves conflict" case,
-                    // local RAs had cancelled eachother
-                    $hascap[$cap] = $rp;
-                    continue;
-                }
-            }
-            // Same ralevel - locality of RC wins
-            if ($rp->rcdepth  > $hascap[$cap]->rcdepth) {
-                $hascap[$cap] = $rp;
-                continue;
-            }
-            if ($rp->rcdepth  > $hascap[$cap]->rcdepth) {
-                continue;
-            }
-            // We match depth - add them                
-            $hascap[$cap]->perm += $rp->perm;
-        }
-    }
-    foreach ($caps as $capability) {
-        if (isset($hascap[$capability]) && $hascap[$capability]->perm > 0) {
-            return true;
-        }
-    }
-    return false;
+    return $DB->get_records_sql($sql, $params, $limitfrom, $limitnum);
 }
 
 /**
+ * Re-sort a users array based on a sorting policy
+ *
  * Will re-sort a $users results array (from get_users_by_capability(), usually)
  * based on a sorting policy. This is to support the odd practice of
  * sorting teachers by 'authority', where authority was "lowest id of the role
@@ -4941,19 +5782,19 @@ function has_any_capability_from_rarc($ras, $roleperms, $caps) {
  * a good idea to see what roles have the capabilities you want
  * (array_diff() them against roiles that have 'can-do-anything'
  * to weed out admin-ish roles. Or fetch a list of roles from
- * variables like $CFG->coursemanagers .
+ * variables like $CFG->coursecontact .
  *
- * @param array users Users' array, keyed on userid
- * @param object context
- * @param array roles - ids of the roles to include, optional
- * @param string policy - defaults to locality, more about
- * @return array - sorted copy of the array
+ * @param array $users Users array, keyed on userid
+ * @param object $context
+ * @param array $roles ids of the roles to include, optional
+ * @param string $policy defaults to locality, more about
+ * @return array sorted copy of the array
  */
-function sort_by_roleassignment_authority($users, $context, $roles=array(), $sortpolicy='locality') {
-    global $CFG;
+function sort_by_roleassignment_authority($users, $context, $roles = array(), $sortpolicy = 'locality') {
+    global $DB;
 
     $userswhere = ' ra.userid IN (' . implode(',',array_keys($users)) . ')';
-    $contextwhere = ' ra.contextid IN ('.str_replace('/', ',',substr($context->path, 1)).')';
+    $contextwhere = 'AND ra.contextid IN ('.str_replace('/', ',',substr($context->path, 1)).')';
     if (empty($roles)) {
         $roleswhere = '';
     } else {
@@ -4961,30 +5802,28 @@ function sort_by_roleassignment_authority($users, $context, $roles=array(), $sor
     }
 
     $sql = "SELECT ra.userid
-            FROM {$CFG->prefix}role_assignments ra
-            JOIN {$CFG->prefix}role r
+              FROM {role_assignments} ra
+              JOIN {role} r
               ON ra.roleid=r.id
-            JOIN {$CFG->prefix}context ctx
+              JOIN {context} ctx
               ON ra.contextid=ctx.id
-            WHERE
-                    $userswhere
-                AND $contextwhere
-                $roleswhere
-            ";
+             WHERE $userswhere
+                   $contextwhere
+                   $roleswhere";
 
     // Default 'locality' policy -- read PHPDoc notes
     // about sort policies...
-    $orderby = 'ORDER BY
-                    ctx.depth DESC, /* locality wins */
-                    r.sortorder ASC, /* rolesorting 2nd criteria */
-                    ra.id           /* role assignment order tie-breaker */';
+    $orderby = 'ORDER BY '
+                    .'ctx.depth DESC, '  /* locality wins */
+                    .'r.sortorder ASC, ' /* rolesorting 2nd criteria */
+                    .'ra.id';            /* role assignment order tie-breaker */
     if ($sortpolicy === 'sortorder') {
-        $orderby = 'ORDER BY
-                        r.sortorder ASC, /* rolesorting 2nd criteria */
-                        ra.id           /* role assignment order tie-breaker */';
+        $orderby = 'ORDER BY '
+                        .'r.sortorder ASC, ' /* rolesorting 2nd criteria */
+                        .'ra.id';            /* role assignment order tie-breaker */
     }
 
-    $sortedids = get_fieldset_sql($sql . $orderby);
+    $sortedids = $DB->get_fieldset_sql($sql . $orderby);
     $sortedusers = array();
     $seen = array();
 
@@ -5002,28 +5841,33 @@ function sort_by_roleassignment_authority($users, $context, $roles=array(), $sor
 }
 
 /**
- * gets all the users assigned this role in this context or higher
- * @param int roleid (can also be an array of ints!)
- * @param int contextid
- * @param bool parent if true, get list of users assigned in higher context too
- * @param string fields - fields from user (u.) , role assignment (ra) or role (r.)
- * @param string sort  - sort from user (u.) , role assignment (ra) or role (r.)
- * @param bool gethidden - whether to fetch hidden enrolments too
- * @return array()
+ * Gets all the users assigned this role in this context or higher
+ *
+ * @param int $roleid (can also be an array of ints!)
+ * @param stdClass $context
+ * @param bool $parent if true, get list of users assigned in higher context too
+ * @param string $fields fields from user (u.) , role assignment (ra) or role (r.)
+ * @param string $sort sort from user (u.) , role assignment (ra) or role (r.)
+ * @param bool $gethidden_ignored use enrolments instead
+ * @param string $group defaults to ''
+ * @param mixed $limitfrom defaults to ''
+ * @param mixed $limitnum defaults to ''
+ * @param string $extrawheretest defaults to ''
+ * @param string|array $whereparams defaults to ''
+ * @return array
  */
-function get_role_users($roleid, $context, $parent=false, $fields='', $sort='u.lastname ASC, u.firstname ASC', $gethidden=true, $group='', $limitfrom='', $limitnum='') {
-    global $CFG;
+function get_role_users($roleid, $context, $parent = false, $fields = '',
+        $sort = 'u.lastname, u.firstname', $gethidden_ignored = null, $group = '',
+        $limitfrom = '', $limitnum = '', $extrawheretest = '', $whereparams = array()) {
+    global $DB;
 
     if (empty($fields)) {
         $fields = 'u.id, u.confirmed, u.username, u.firstname, u.lastname, '.
-                  'u.maildisplay, u.mailformat, u.maildigest, u.email, u.city, '.
+                  'u.maildisplay, u.mailformat, u.maildigest, u.email, u.emailstop, u.city, '.
                   'u.country, u.picture, u.idnumber, u.department, u.institution, '.
-                  'u.emailstop, u.lang, u.timezone, u.lastaccess, u.mnethostid, r.name as rolename';
+                  'u.lang, u.timezone, u.lastaccess, u.mnethostid, r.name AS rolename, r.sortorder';
     }
 
-    // whether this assignment is hidden
-    $hiddensql = $gethidden ? '': ' AND ra.hidden = 0 ';
-
     $parentcontexts = '';
     if ($parent) {
         $parentcontexts = substr($context->path, 1); // kill leading slash
@@ -5033,49 +5877,54 @@ function get_role_users($roleid, $context, $parent=false, $fields='', $sort='u.l
         }
     }
 
-    if (is_array($roleid)) {
-        $roleselect = ' AND ra.roleid IN (' . implode(',',$roleid) .')';
-    } elseif (!empty($roleid)) { // should not test for int, because it can come in as a string
-        $roleselect = "AND ra.roleid = $roleid";
+    if ($roleid) {
+        list($rids, $params) = $DB->get_in_or_equal($roleid, SQL_PARAMS_QM);
+        $roleselect = "AND ra.roleid $rids";
     } else {
+        $params = array();
         $roleselect = '';
     }
 
     if ($group) {
-        $groupjoin   = "JOIN {$CFG->prefix}groups_members gm
-                          ON gm.userid = u.id";
-        $groupselect = " AND gm.groupid = $group ";
+        $groupjoin   = "JOIN {groups_members} gm ON gm.userid = u.id";
+        $groupselect = " AND gm.groupid = ? ";
+        $params[] = $group;
     } else {
         $groupjoin   = '';
         $groupselect = '';
     }
 
-    $SQL = "SELECT $fields, ra.roleid
-            FROM {$CFG->prefix}role_assignments ra
-            JOIN {$CFG->prefix}user u
-              ON u.id = ra.userid
-            JOIN {$CFG->prefix}role r
-              ON ra.roleid = r.id
+    array_unshift($params, $context->id);
+
+    if ($extrawheretest) {
+        $extrawheretest = ' AND ' . $extrawheretest;
+        $params = array_merge($params, $whereparams);
+    }
+
+    $sql = "SELECT DISTINCT $fields, ra.roleid
+              FROM {role_assignments} ra
+              JOIN {user} u ON u.id = ra.userid
+              JOIN {role} r ON ra.roleid = r.id
             $groupjoin
-            WHERE (ra.contextid = $context->id $parentcontexts)
+             WHERE (ra.contextid = ? $parentcontexts)
             $roleselect
             $groupselect
-            $hiddensql
-            ORDER BY $sort
-            ";                  // join now so that we can just use fullname() later
+                   $extrawheretest
+          ORDER BY $sort";                  // join now so that we can just use fullname() later
 
-    return get_records_sql($SQL, $limitfrom, $limitnum);
+    return $DB->get_records_sql($sql, $params, $limitfrom, $limitnum);
 }
 
 /**
  * Counts all the users assigned this role in this context or higher
- * @param int roleid (can also be an array of ints!)
- * @param int contextid
- * @param bool parent if true, get list of users assigned in higher context too
- * @return array()
+ *
+ * @param mixed $roleid either int or an array of ints
+ * @param object $context
+ * @param bool $parent if true, get list of users assigned in higher context too
+ * @return int Returns the result count
  */
-function count_role_users($roleid, $context, $parent=false) {
-    global $CFG;
+function count_role_users($roleid, $context, $parent = false) {
+    global $DB;
 
     if ($parent) {
         if ($contexts = get_parent_contexts($context)) {
@@ -5087,28 +5936,30 @@ function count_role_users($roleid, $context, $parent=false) {
         $parentcontexts = '';
     }
 
-    $rolesql = '';
-    if (is_numeric($roleid)) {
-        $rolesql = "AND r.roleid = $roleid";
-    }
-    else if (is_array($roleid)) {
-        $rolesql = "AND r.roleid IN (" . implode(',', $roleid) . ")";
+    if ($roleid) {
+        list($rids, $params) = $DB->get_in_or_equal($roleid, SQL_PARAMS_QM);
+        $roleselect = "AND r.roleid $rids";
+    } else {
+        $params = array();
+        $roleselect = '';
     }
 
-    $SQL = "SELECT count(u.id)
-        FROM {$CFG->prefix}role_assignments r
-        JOIN {$CFG->prefix}user u 
-          ON u.id = r.userid
-        WHERE (r.contextid = $context->id $parentcontexts)
-        $rolesql
+    array_unshift($params, $context->id);
+
+    $sql = "SELECT count(u.id)
+              FROM {role_assignments} r
+              JOIN {user} u ON u.id = r.userid
+             WHERE (r.contextid = ? $parentcontexts)
+                   $roleselect
         AND u.deleted = 0";
 
-    return count_records_sql($SQL);
+    return $DB->count_records_sql($sql, $params);
 }
 
 /**
  * This function gets the list of courses that this user has a particular capability in.
  * It is still not very efficient.
+ *
  * @param string $capability Capability in question
  * @param int $userid User ID or null for current user
  * @param bool $doanything True if 'doanything' is permitted (default)
@@ -5118,73 +5969,69 @@ function count_role_users($roleid, $context, $parent=false) {
  *   table with sql modifiers (DESC) if needed
  * @return array Array of courses, may have zero entries. Or false if query failed.
  */
-function get_user_capability_course($capability, $userid=NULL,$doanything=true,$fieldsexceptid='',$orderby='') {
+function get_user_capability_course($capability, $userid = null, $doanything = true, $fieldsexceptid = '', $orderby = '') {
+    global $DB;
+
     // Convert fields list and ordering
-    $fieldlist='';
-    if($fieldsexceptid) {
-        $fields=explode(',',$fieldsexceptid);
+    $fieldlist = '';
+    if ($fieldsexceptid) {
+        $fields = explode(',', $fieldsexceptid);
         foreach($fields as $field) {
-            $fieldlist.=',c.'.$field;
+            $fieldlist .= ',c.'.$field;
         }
     }
-    if($orderby) {
-        $fields=explode(',',$orderby);
-        $orderby='';
+    if ($orderby) {
+        $fields = explode(',', $orderby);
+        $orderby = '';
         foreach($fields as $field) {
-            if($orderby) {
-                $orderby.=',';
+            if ($orderby) {
+                $orderby .= ',';
             }
-            $orderby.='c.'.$field;
+            $orderby .= 'c.'.$field;
         }
-        $orderby='ORDER BY '.$orderby;
+        $orderby = 'ORDER BY '.$orderby;
     }
 
     // Obtain a list of everything relevant about all courses including context.
     // Note the result can be used directly as a context (we are going to), the course
     // fields are just appended.
-    global $CFG;
-    $rs=get_recordset_sql("
-SELECT
-    x.*,c.id AS courseid$fieldlist
-FROM
-    {$CFG->prefix}course c
-    INNER JOIN {$CFG->prefix}context x ON c.id=x.instanceid AND x.contextlevel=".CONTEXT_COURSE."
-$orderby
-");
-    if(!$rs) {
-        return false;
-    }
 
+    $courses = array();
+    $rs = $DB->get_recordset_sql("SELECT x.*, c.id AS courseid $fieldlist
+                                    FROM {course} c
+                                   INNER JOIN {context} x
+                                         ON (c.id=x.instanceid AND x.contextlevel=".CONTEXT_COURSE.")
+                                $orderby");
     // Check capability for each course in turn
-    $courses=array();
-    while($coursecontext=rs_fetch_next_record($rs)) {
-        if(has_capability($capability,$coursecontext,$userid,$doanything)) {
+    foreach ($rs as $coursecontext) {
+        if (has_capability($capability, $coursecontext, $userid, $doanything)) {
             // We've got the capability. Make the record look like a course record
             // and store it
-            $coursecontext->id=$coursecontext->courseid;
+            $coursecontext->id = $coursecontext->courseid;
             unset($coursecontext->courseid);
             unset($coursecontext->contextlevel);
             unset($coursecontext->instanceid);
-            $courses[]=$coursecontext;
+            $courses[] = $coursecontext;
         }
     }
-    return $courses;
+    $rs->close();
+    return empty($courses) ? false : $courses;
 }
 
-/** This function finds the roles assigned directly to this context only
+/**
+ * This function finds the roles assigned directly to this context only
  * i.e. no parents role
+ *
  * @param object $context
  * @return array
  */
 function get_roles_on_exact_context($context) {
+    global $DB;
 
-    global $CFG;
-
-    return get_records_sql("SELECT r.*
-                            FROM {$CFG->prefix}role_assignments ra,
-                                 {$CFG->prefix}role r
-                            WHERE ra.roleid = r.id
-                                  AND ra.contextid = $context->id");
+    return $DB->get_records_sql("SELECT r.*
+                                   FROM {role_assignments} ra, {role} r
+                                  WHERE ra.roleid = r.id AND ra.contextid = ?",
+                                array($context->id));
 
 }
 
@@ -5194,20 +6041,19 @@ function get_roles_on_exact_context($context) {
  *
  * The caller *must* check
  * - that this op is allowed
- * - that the requested role can be assigned in this ctx
- *   (hint, use get_assignable_roles_for_switchrole())
+ * - that the requested role can be switched to in this context (use get_switchable_roles)
  * - that the requested role is NOT $CFG->defaultuserroleid
  *
  * To "unswitch" pass 0 as the roleid.
  *
  * This function *will* modify $USER->access - beware
  * 
- * @param integer $roleid
- * @param object $context
- * @return bool
+ * @param integer $roleid the role to switch to.
+ * @param object $context the context in which to perform the switch.
+ * @return bool success or failure.
  */
 function role_switch($roleid, $context) {
-    global $USER, $CFG;
+    global $USER;
 
     //
     // Plan of action
@@ -5216,7 +6062,7 @@ function role_switch($roleid, $context) {
     //   as $USER->access['rsw'][$path] = $roleid
     //
     // - Make sure $USER->access['rdef'] has the roledefs
-    //   it needs to honour the switcheroo
+    //   it needs to honour the switcherole
     //
     // Roledefs will get loaded "deep" here - down to the last child
     // context. Note that
@@ -5225,12 +6071,13 @@ function role_switch($roleid, $context) {
     //   will still work fine - though those ra/rdefs will be ignored
     //   appropriately while the switch is in place
     // 
-    // - If a switcheroo happens at a category with tons of courses 
+    // - If a switcherole happens at a category with tons of courses
     //   (that have many overrides for switched-to role), the session
     //   will get... quite large. Sometimes you just can't win.
     //
     // To un-switch just unset($USER->access['rsw'][$path])
     // 
+    // Note: it is not possible to switch to roles that do not have course:view
 
     // Add the switch RA
     if (!isset($USER->access['rsw'])) {
@@ -5251,87 +6098,135 @@ function role_switch($roleid, $context) {
     $USER->access = get_role_access_bycontext($roleid, $context,
                                               $USER->access);
 
-    /* DO WE NEED THIS AT ALL???
-    // Add some permissions we are really going 
-    // to always need, even if the role doesn't have them!
-
-    $USER->capabilities[$context->id]['moodle/course:view'] = CAP_ALLOW;
-    */
-
     return true;
 }
 
+/**
+ * Checks if the user has switched roles within the given course.
+ *
+ * Note: You can only switch roles within the course, hence it takes a courseid
+ * rather than a context. On that note Petr volunteered to implement this across
+ * all other contexts, all requests for this should be forwarded to him ;)
+ *
+ * @param int $courseid The id of the course to check
+ * @return bool True if the user has switched roles within the course.
+ */
+function is_role_switched($courseid) {
+    global $USER;
+    $context = get_context_instance(CONTEXT_COURSE, $courseid, MUST_EXIST);
+    return (!empty($USER->access['rsw'][$context->path]));
+}
 
-// get any role that has an override on exact context
+/**
+ * Get any role that has an override on exact context
+ *
+ * @global moodle_database
+ * @param stdClass $context The context to check
+ * @return array An array of roles
+ */
 function get_roles_with_override_on_context($context) {
+    global $DB;
 
-    global $CFG;
-
-    return get_records_sql("SELECT r.*
-                            FROM {$CFG->prefix}role_capabilities rc,
-                                 {$CFG->prefix}role r
-                            WHERE rc.roleid = r.id
-                            AND rc.contextid = $context->id");
+    return $DB->get_records_sql("SELECT r.*
+                                   FROM {role_capabilities} rc, {role} r
+                                  WHERE rc.roleid = r.id AND rc.contextid = ?",
+                                array($context->id));
 }
 
-// get all capabilities for this role on this context (overrids)
+/**
+ * Get all capabilities for this role on this context (overrides)
+ *
+ * @param object $role
+ * @param object $context
+ * @return array
+ */
 function get_capabilities_from_role_on_context($role, $context) {
+    global $DB;
 
-    global $CFG;
-
-    return get_records_sql("SELECT *
-                            FROM {$CFG->prefix}role_capabilities
-                            WHERE contextid = $context->id
-                                  AND roleid = $role->id");
+    return $DB->get_records_sql("SELECT *
+                                   FROM {role_capabilities}
+                                  WHERE contextid = ? AND roleid = ?",
+                                array($context->id, $role->id));
 }
 
-// find out which roles has assignment on this context
+/**
+ * Find out which roles has assignment on this context
+ *
+ * @param object $context
+ * @return array
+ *
+ */
 function get_roles_with_assignment_on_context($context) {
+    global $DB;
 
-    global $CFG;
-
-    return get_records_sql("SELECT r.*
-                            FROM {$CFG->prefix}role_assignments ra,
-                                 {$CFG->prefix}role r
-                            WHERE ra.roleid = r.id
-                            AND ra.contextid = $context->id");
+    return $DB->get_records_sql("SELECT r.*
+                                   FROM {role_assignments} ra, {role} r
+                                  WHERE ra.roleid = r.id AND ra.contextid = ?",
+                                array($context->id));
 }
 
 
 
 /**
- * Find all user assignemnt of users for this role, on this context
+ * Find all user assignment of users for this role, on this context
+ *
+ * @param object $role
+ * @param object $context
+ * @return array
  */
 function get_users_from_role_on_context($role, $context) {
+    global $DB;
 
-    global $CFG;
-
-    return get_records_sql("SELECT *
-                            FROM {$CFG->prefix}role_assignments
-                            WHERE contextid = $context->id
-                                  AND roleid = $role->id");
+    return $DB->get_records_sql("SELECT *
+                                   FROM {role_assignments}
+                                  WHERE contextid = ? AND roleid = ?",
+                                array($context->id, $role->id));
 }
 
 /**
- * Simple function returning a boolean true if roles exist, otherwise false
+ * Simple function returning a boolean true if user has roles
+ * in context or parent contexts, otherwise false.
+ *
+ * @param int $userid
+ * @param int $roleid
+ * @param int $contextid empty means any context
+ * @return bool
  */
-function user_has_role_assignment($userid, $roleid, $contextid=0) {
+function user_has_role_assignment($userid, $roleid, $contextid = 0) {
+    global $DB;
 
     if ($contextid) {
-        return record_exists('role_assignments', 'userid', $userid, 'roleid', $roleid, 'contextid', $contextid);
+        if (!$context = get_context_instance_by_id($contextid)) {
+            return false;
+        }
+        $parents = get_parent_contexts($context, true);
+        list($contexts, $params) = $DB->get_in_or_equal($parents, SQL_PARAMS_NAMED, 'r');
+        $params['userid'] = $userid;
+        $params['roleid'] = $roleid;
+
+        $sql = "SELECT COUNT(ra.id)
+                  FROM {role_assignments} ra
+                 WHERE ra.userid = :userid AND ra.roleid = :roleid AND ra.contextid $contexts";
+
+        $count = $DB->get_field_sql($sql, $params);
+        return ($count > 0);
+
     } else {
-        return record_exists('role_assignments', 'userid', $userid, 'roleid', $roleid);
+        return $DB->record_exists('role_assignments', array('userid'=>$userid, 'roleid'=>$roleid));
     }
 }
 
 /**
  * Get role name or alias if exists and format the text.
+ *
  * @param object $role role object
  * @param object $coursecontext
- * @return $string name of role in course context
+ * @return string name of role in course context
  */
 function role_get_name($role, $coursecontext) {
-    if ($r = get_record('role_names','roleid', $role->id,'contextid', $coursecontext->id)) {
+    global $DB;
+
+    if ($r = $DB->get_record('role_names', array('roleid'=>$role->id, 'contextid'=>$coursecontext->id))) {
         return strip_tags(format_string($r->name));
     } else {
         return strip_tags(format_string($role->name));
@@ -5340,54 +6235,86 @@ function role_get_name($role, $coursecontext) {
 
 /**
  * Prepare list of roles for display, apply aliases and format text
- * @param array $roleoptions array roleid=>rolename
- * @param object $context
- * @return array of role names
+ *
+ * @param array $roleoptions array roleid => rolename or roleid => roleobject
+ * @param object $context a context
+ * @return array Array of context-specific role names, or role objexts with a ->localname field added.
  */
-function role_fix_names($roleoptions, $context, $rolenamedisplay=ROLENAME_ALIAS) {
+function role_fix_names($roleoptions, $context, $rolenamedisplay = ROLENAME_ALIAS) {
+    global $DB;
+
+    // Make sure we are working with an array roleid => name. Normally we
+    // want to use the unlocalised name if the localised one is not present.
+    $newnames = array();
+    foreach ($roleoptions as $rid => $roleorname) {
+        if ($rolenamedisplay != ROLENAME_ALIAS_RAW) {
+            if (is_object($roleorname)) {
+                $newnames[$rid] = $roleorname->name;
+            } else {
+                $newnames[$rid] = $roleorname;
+            }
+        } else {
+            $newnames[$rid] = '';
+        }
+    }
+
+    // If necessary, get the localised names.
     if ($rolenamedisplay != ROLENAME_ORIGINAL && !empty($context->id)) {
-        if ($context->contextlevel == CONTEXT_MODULE || $context->contextlevel == CONTEXT_BLOCK) {  // find the parent course context
+        // Make sure we have a course context.
+        if ($context->contextlevel == CONTEXT_MODULE) {
             if ($parentcontextid = array_shift(get_parent_contexts($context))) {
                 $context = get_context_instance_by_id($parentcontextid);
             }
+        } else if ($context->contextlevel == CONTEXT_BLOCK) {
+            do {
+                if ($parentcontextid = array_shift(get_parent_contexts($context))) {
+                    $context = get_context_instance_by_id($parentcontextid);
         }
-        if ($aliasnames = get_records('role_names', 'contextid', $context->id)) {
-            if ($rolenamedisplay == ROLENAME_ALIAS) {
-                foreach ($aliasnames as $alias) {
-                    if (isset($roleoptions[$alias->roleid])) {
-                        $roleoptions[$alias->roleid] = format_string($alias->name);
-                    }
+            } while ($parentcontextid && $context->contextlevel != CONTEXT_COURSE);
                 }
-            } else if ($rolenamedisplay == ROLENAME_BOTH) {
+
+        // The get the relevant renames, and use them.
+        $aliasnames = $DB->get_records('role_names', array('contextid'=>$context->id));
                 foreach ($aliasnames as $alias) {
-                    if (isset($roleoptions[$alias->roleid])) {
-                        $roleoptions[$alias->roleid] = format_string($alias->name).' ('.format_string($roleoptions[$alias->roleid]).')';
+            if (isset($newnames[$alias->roleid])) {
+                if ($rolenamedisplay == ROLENAME_ALIAS || $rolenamedisplay == ROLENAME_ALIAS_RAW) {
+                    $newnames[$alias->roleid] = $alias->name;
+                } else if ($rolenamedisplay == ROLENAME_BOTH) {
+                    $newnames[$alias->roleid] = $alias->name . ' (' . $roleoptions[$alias->roleid] . ')';
+                }
                     }
                 }
             }
+
+    // Finally, apply format_string and put the result in the right place.
+    foreach ($roleoptions as $rid => $roleorname) {
+        if ($rolenamedisplay != ROLENAME_ALIAS_RAW) {
+            $newnames[$rid] = strip_tags(format_string($newnames[$rid]));
         }
+        if (is_object($roleorname)) {
+            $roleoptions[$rid]->localname = $newnames[$rid];
+        } else {
+            $roleoptions[$rid] = $newnames[$rid];
     }
-    foreach ($roleoptions as $rid => $name) {
-        $roleoptions[$rid] = strip_tags(format_string($name));
     }
     return $roleoptions;
 }
 
 /**
+ * Aids in detecting if a new line is required when reading a new capability
+ *
  * This function helps admin/roles/manage.php etc to detect if a new line should be printed
- * when we read in a new capability
- * most of the time, if the 2 components are different we should print a new line, (e.g. course system->rss client)
- * but when we are in grade, all reports/import/export capabilites should be together
- * @param string a - component string a
- * @param string b - component string b
- * @return bool - whether 2 component are in different "sections"
+ * when we read in a new capability.
+ * Most of the time, if the 2 components are different we should print a new line, (e.g. course system->rss client)
+ * but when we are in grade, all reports/import/export capabilities should be together
+ *
+ * @param string $cap component string a
+ * @param string $comp component string b
+ * @param mixed $contextlevel
+ * @return bool whether 2 component are in different "sections"
  */
 function component_level_changed($cap, $comp, $contextlevel) {
 
-    if ($cap->component == 'enrol/authorize' && $comp =='enrol/authorize') {
-        return false;
-    }
-
     if (strstr($cap->component, '/') && strstr($comp, '/')) {
         $compsa = explode('/', $cap->component);
         $compsb = explode('/', $comp);
@@ -5412,195 +6339,51 @@ function component_level_changed($cap, $comp, $contextlevel) {
 }
 
 /**
- * Populate context.path and context.depth where missing.
- * @param bool $force force a complete rebuild of the path and depth fields.
- * @param bool $feedback display feedback (during upgrade usually)
- * @return void
+ * Rebuild all related context depth and path caches
+ *
+ * @param array $fixcontexts array of contexts, strongtyped
  */
-function build_context_path($force=false, $feedback=false) {
-    global $CFG;
-    require_once($CFG->libdir.'/ddllib.php');
+function rebuild_contexts(array $fixcontexts) {
+    global $DB;
+
+    foreach ($fixcontexts as $context) {
+        if ($context->path) {
+            mark_context_dirty($context->path);
+        }
+        $DB->set_field_select('context', 'depth', 0, "path LIKE '%/$context->id/%'");
+        $DB->set_field('context', 'depth', 0, array('id'=>$context->id));
+    }
+    build_context_path(false);
+}
 
+/**
+ * Populate context.path and context.depth where missing.
+ *
+ * @param bool $force force a complete rebuild of the path and depth fields, defaults to false
+ */
+function build_context_path($force = false) {
+    global $ACCESSLIB_PRIVATE;
     // System context
     $sitectx = get_system_context(!$force);
     $base    = '/'.$sitectx->id;
 
-    // Sitecourse
-    $sitecoursectx = get_record('context',
-                                'contextlevel', CONTEXT_COURSE,
-                                'instanceid', SITEID);
-    if ($force || $sitecoursectx->path !== "$base/{$sitecoursectx->id}") {
-        set_field('context', 'path',  "$base/{$sitecoursectx->id}",
-                  'id', $sitecoursectx->id);
-        set_field('context', 'depth', 2,
-                  'id', $sitecoursectx->id);
-        $sitecoursectx = get_record('context',
-                                    'contextlevel', CONTEXT_COURSE,
-                                    'instanceid', SITEID);
-    }
-
-    $ctxemptyclause = " AND (ctx.path IS NULL
-                              OR ctx.depth=0) ";
-    $emptyclause    = " AND ({$CFG->prefix}context.path IS NULL
-                              OR {$CFG->prefix}context.depth=0) ";
     if ($force) {
         $ctxemptyclause = $emptyclause = '';
-    }
-
-    /* MDL-11347:
-     *  - mysql does not allow to use FROM in UPDATE statements
-     *  - using two tables after UPDATE works in mysql, but might give unexpected
-     *    results in pg 8 (depends on configuration)
-     *  - using table alias in UPDATE does not work in pg < 8.2
-     */
-    if ($CFG->dbfamily == 'mysql') {
-        $updatesql = "UPDATE {$CFG->prefix}context ct, {$CFG->prefix}context_temp temp
-                         SET ct.path  = temp.path,
-                             ct.depth = temp.depth
-                       WHERE ct.id = temp.id";
-    } else if ($CFG->dbfamily == 'oracle') {
-        $updatesql = "UPDATE {$CFG->prefix}context ct
-                         SET (ct.path, ct.depth) =
-                             (SELECT temp.path, temp.depth
-                                FROM {$CFG->prefix}context_temp temp
-                               WHERE temp.id=ct.id)
-                       WHERE EXISTS (SELECT 'x'
-                                       FROM {$CFG->prefix}context_temp temp
-                                       WHERE temp.id = ct.id)";
     } else {
-        $updatesql = "UPDATE {$CFG->prefix}context
-                         SET path  = temp.path,
-                             depth = temp.depth
-                        FROM {$CFG->prefix}context_temp temp
-                       WHERE temp.id={$CFG->prefix}context.id";
+        $emptyclause    = ' AND ({$a}.path IS NULL OR {$a}.depth=0) ';
     }
 
-    $udelsql = "TRUNCATE TABLE {$CFG->prefix}context_temp";
-
-    // Top level categories
-    $sql = "UPDATE {$CFG->prefix}context
-               SET depth=2, path=" . sql_concat("'$base/'", 'id') . "
-             WHERE contextlevel=".CONTEXT_COURSECAT."
-                   AND EXISTS (SELECT 'x'
-                                 FROM {$CFG->prefix}course_categories cc
-                                WHERE cc.id = {$CFG->prefix}context.instanceid
-                                      AND cc.depth=1)
-                   $emptyclause";
-
-    execute_sql($sql, $feedback);
-
-    execute_sql($udelsql, $feedback);
-
-    // Deeper categories - one query per depthlevel
-    $maxdepth = get_field_sql("SELECT MAX(depth)
-                               FROM {$CFG->prefix}course_categories");
-    for ($n=2;$n<=$maxdepth;$n++) {
-        $sql = "INSERT INTO {$CFG->prefix}context_temp (id, path, depth)
-                SELECT ctx.id, ".sql_concat('pctx.path', "'/'", 'ctx.id').", $n+1
-                  FROM {$CFG->prefix}context ctx
-                  JOIN {$CFG->prefix}course_categories c ON ctx.instanceid=c.id
-                  JOIN {$CFG->prefix}context pctx ON c.parent=pctx.instanceid
-                 WHERE ctx.contextlevel=".CONTEXT_COURSECAT."
-                       AND pctx.contextlevel=".CONTEXT_COURSECAT."
-                       AND c.depth=$n
-                       AND NOT EXISTS (SELECT 'x'
-                                       FROM {$CFG->prefix}context_temp temp
-                                       WHERE temp.id = ctx.id)
-                       $ctxemptyclause";
-        execute_sql($sql, $feedback);
-        
-        // this is needed after every loop
-        // MDL-11532
-        execute_sql($updatesql, $feedback);
-        execute_sql($udelsql, $feedback);
+    foreach(context_level_base::get_all_context_levels() as $cl) {
+        $cl->build_context_path($base, $emptyclause);
     }
 
-    // Courses -- except sitecourse
-    $sql = "INSERT INTO {$CFG->prefix}context_temp (id, path, depth)
-            SELECT ctx.id, ".sql_concat('pctx.path', "'/'", 'ctx.id').", pctx.depth+1
-              FROM {$CFG->prefix}context ctx
-              JOIN {$CFG->prefix}course c ON ctx.instanceid=c.id
-              JOIN {$CFG->prefix}context pctx ON c.category=pctx.instanceid
-             WHERE ctx.contextlevel=".CONTEXT_COURSE."
-                   AND c.id!=".SITEID."
-                   AND pctx.contextlevel=".CONTEXT_COURSECAT."
-                       AND NOT EXISTS (SELECT 'x'
-                                       FROM {$CFG->prefix}context_temp temp
-                                       WHERE temp.id = ctx.id)
-                   $ctxemptyclause";
-    execute_sql($sql, $feedback);
-
-    execute_sql($updatesql, $feedback);
-    execute_sql($udelsql, $feedback);
-
-    // Module instances
-    $sql = "INSERT INTO {$CFG->prefix}context_temp (id, path, depth)
-            SELECT ctx.id, ".sql_concat('pctx.path', "'/'", 'ctx.id').", pctx.depth+1
-              FROM {$CFG->prefix}context ctx
-              JOIN {$CFG->prefix}course_modules cm ON ctx.instanceid=cm.id
-              JOIN {$CFG->prefix}context pctx ON cm.course=pctx.instanceid
-             WHERE ctx.contextlevel=".CONTEXT_MODULE."
-                   AND pctx.contextlevel=".CONTEXT_COURSE."
-                       AND NOT EXISTS (SELECT 'x'
-                                       FROM {$CFG->prefix}context_temp temp
-                                       WHERE temp.id = ctx.id)
-                   $ctxemptyclause";
-    execute_sql($sql, $feedback);
-
-    execute_sql($updatesql, $feedback);
-    execute_sql($udelsql, $feedback);
-
-    // Blocks - non-pinned course-view only
-    $sql = "INSERT INTO {$CFG->prefix}context_temp (id, path, depth)
-            SELECT ctx.id, ".sql_concat('pctx.path', "'/'", 'ctx.id').", pctx.depth+1
-              FROM {$CFG->prefix}context ctx
-              JOIN {$CFG->prefix}block_instance bi ON ctx.instanceid = bi.id
-              JOIN {$CFG->prefix}context pctx ON bi.pageid=pctx.instanceid
-             WHERE ctx.contextlevel=".CONTEXT_BLOCK."
-                   AND pctx.contextlevel=".CONTEXT_COURSE."
-                   AND bi.pagetype='course-view'
-                       AND NOT EXISTS (SELECT 'x'
-                                       FROM {$CFG->prefix}context_temp temp
-                                       WHERE temp.id = ctx.id)
-                   $ctxemptyclause";
-    execute_sql($sql, $feedback);
-
-    execute_sql($updatesql, $feedback);
-    execute_sql($udelsql, $feedback);
-
-    // Blocks - others
-    $sql = "UPDATE {$CFG->prefix}context
-               SET depth=2, path=".sql_concat("'$base/'", 'id')."
-             WHERE contextlevel=".CONTEXT_BLOCK."
-                   AND EXISTS (SELECT 'x'
-                                 FROM {$CFG->prefix}block_instance bi
-                                WHERE bi.id = {$CFG->prefix}context.instanceid
-                                      AND bi.pagetype!='course-view')
-                   $emptyclause ";
-    execute_sql($sql, $feedback);
-
-    // User
-    $sql = "UPDATE {$CFG->prefix}context
-               SET depth=2, path=".sql_concat("'$base/'", 'id')."
-             WHERE contextlevel=".CONTEXT_USER."
-                   AND EXISTS (SELECT 'x'
-                                 FROM {$CFG->prefix}user u
-                                WHERE u.id = {$CFG->prefix}context.instanceid)
-                   $emptyclause ";
-    execute_sql($sql, $feedback);
-
-    // Personal TODO
-
-    //TODO: fix group contexts
-
     // reset static course cache - it might have incorrect cached data
-    global $context_cache, $context_cache_id;
-    $context_cache    = array();
-    $context_cache_id = array();
-
+    $ACCESSLIB_PRIVATE->contexcache->reset();
 }
 
 /**
+ * Update the path field of the context and all dep. subcontexts that follow
+ *
  * Update the path field of the context and
  * all the dependent subcontexts that follow
  * the move. 
@@ -5609,91 +6392,78 @@ function build_context_path($force=false, $feedback=false) {
  * DB efficient as possible. This op can have a
  * massive impact in the DB.
  *
- * @param obj current   context obj
- * @param obj newparent new parent obj
+ * @param stdClass $current context obj
+ * @param stdClass $newparent new parent obj
  *
  */
 function context_moved($context, $newparent) {
-    global $CFG;
+    global $DB;
 
     $frompath = $context->path;
     $newpath  = $newparent->path . '/' . $context->id;
 
     $setdepth = '';
     if (($newparent->depth +1) != $context->depth) {
-        $setdepth = ", depth= depth + ({$newparent->depth} - {$context->depth}) + 1";
+        $diff = $newparent->depth - $context->depth + 1;
+        $setdepth = ", depth = depth + $diff";
     }
-    $sql = "UPDATE {$CFG->prefix}context 
-            SET path='$newpath'
+    $sql = "UPDATE {context}
+               SET path = ?
                 $setdepth
-            WHERE path='$frompath'";
-    execute_sql($sql,false);
+             WHERE path = ?";
+    $params = array($newpath, $frompath);
+    $DB->execute($sql, $params);
 
-    $len = strlen($frompath);
-    /// MDL-16655 - Substring MSSQL function *requires* 3rd parameter
-    $substr3rdparam = '';
-    if ($CFG->dbfamily == 'mssql') {
-        $substr3rdparam = ', len(path)';
-    }
-    $sql = "UPDATE {$CFG->prefix}context
-            SET path = ".sql_concat("'$newpath'", sql_substr() .'(path, '.$len.' +1'.$substr3rdparam.')')."
+    $sql = "UPDATE {context}
+               SET path = ".$DB->sql_concat("?", $DB->sql_substr("path", strlen($frompath)+1))."
                 $setdepth
-            WHERE path LIKE '{$frompath}/%'";
-    execute_sql($sql,false);
+             WHERE path LIKE ?";
+    $params = array($newpath, "{$frompath}/%");
+    $DB->execute($sql, $params);
 
     mark_context_dirty($frompath);
     mark_context_dirty($newpath);
 }
 
-
-/**
- * Turn the ctx* fields in an objectlike record
- * into a context subobject. This allows
- * us to SELECT from major tables JOINing with 
- * context at no cost, saving a ton of context
- * lookups...
- */
-function make_context_subobj($rec) {
-    $ctx = new StdClass;
-    $ctx->id           = $rec->ctxid;    unset($rec->ctxid);
-    $ctx->path         = $rec->ctxpath;  unset($rec->ctxpath);
-    $ctx->depth        = $rec->ctxdepth; unset($rec->ctxdepth);
-    $ctx->contextlevel = $rec->ctxlevel; unset($rec->ctxlevel);
-    $ctx->instanceid   = $rec->id;
-
-    $rec->context = $ctx;
-    return $rec;
-}
-
 /**
- * Do some basic, quick checks to see whether $rec->context looks like a
- * valid context object.
- *
- * @param object $rec a think that has a context, for example a course, 
- *      course category, course modules, etc.
- * @param integer $contextlevel the type of thing $rec is, one of the CONTEXT_... constants.
- * @return boolean whether $rec->context looks like the correct context object
- *      for this thing.
+ * Preloads context information together with instances.
+ * NOTE: in future this function may return empty strings
+ *       if we implement different caching.
+ *
+ * @param string $joinon for example 'u.id'
+ * @param string $contextlevel context level of instance in $joinon
+ * @param string $tablealias context table alias
+ * @return array with two values - select and join part
  */
-function is_context_subobj_valid($rec, $contextlevel) {
-    return isset($rec->context) && isset($rec->context->id) &&
-            isset($rec->context->path) && isset($rec->context->depth) &&
-            isset($rec->context->contextlevel) && isset($rec->context->instanceid) &&
-            $rec->context->contextlevel == $contextlevel && $rec->context->instanceid == $rec->id;
+function context_instance_preload_sql($joinon, $contextlevel, $tablealias) {
+    $select = ", $tablealias.id AS ctxid, $tablealias.path AS ctxpath, $tablealias.depth AS ctxdepth, $tablealias.contextlevel AS ctxlevel, $tablealias.instanceid AS ctxinstance";
+    $join = "LEFT JOIN {context} $tablealias ON ($tablealias.instanceid = $joinon AND $tablealias.contextlevel = $contextlevel)";
+    return array($select, $join);
 }
 
 /**
- * When you have a record (for example a $category, $course, $user or $cm that may,
- * or may not, have come from a place that does make_context_subobj, you can use
- * this method to ensure that $rec->context is present and correct before you continue.
+ * Preloads context information from db record and strips the cached info.
+ * The db request has to ontain both the $join and $select from context_instance_preload_sql()
  *
- * @param object $rec a thing that has an associated context.
- * @param integer $contextlevel the type of thing $rec is, one of the CONTEXT_... constants.
+ * @param object $rec
+ * @return void (modifies $rec)
  */
-function ensure_context_subobj_present(&$rec, $contextlevel) {
-    if (!is_context_subobj_valid($rec, $contextlevel)) {
-        $rec->context = get_context_instance($contextlevel, $rec->id);
+function context_instance_preload(stdClass $rec) {
+    global $ACCESSLIB_PRIVATE;
+    if (empty($rec->ctxid)) {
+        // $rec does not have enough data, passed here repeatedly or context does not exist yet
+        return;
     }
+
+    // note: in PHP5 the objects are passed by reference, no need to return $rec
+    $context = new stdClass();
+    $context->id           = $rec->ctxid;       unset($rec->ctxid);
+    $context->path         = $rec->ctxpath;     unset($rec->ctxpath);
+    $context->depth        = $rec->ctxdepth;    unset($rec->ctxdepth);
+    $context->contextlevel = $rec->ctxlevel;    unset($rec->ctxlevel);
+    $context->instanceid   = $rec->ctxinstance; unset($rec->ctxinstance);
+
+    $ACCESSLIB_PRIVATE->contexcache->add($context);
 }
 
 /**
@@ -5702,7 +6472,7 @@ function ensure_context_subobj_present(&$rec, $contextlevel) {
  *
  * Uses cache_flags
  * @param int $time
- * @return array of dirty contexts
+ * @return array Array of dirty contexts
  */
 function get_dirty_contexts($time) {
     return get_cache_flags('accesslib/dirtycontexts', $time-2);
@@ -5711,15 +6481,21 @@ function get_dirty_contexts($time) {
 /**
  * Mark a context as dirty (with timestamp)
  * so as to force reloading of the context.
+ *
  * @param string $path context path
  */
 function mark_context_dirty($path) {
-    global $CFG, $DIRTYCONTEXTS;
+    global $CFG, $ACCESSLIB_PRIVATE;
+
+    if (during_initial_install()) {
+        return;
+    }
+
     // only if it is a non-empty string
     if (is_string($path) && $path !== '') {
         set_cache_flag('accesslib/dirtycontexts', $path, 1, time()+$CFG->sessiontimeout);
-        if (isset($DIRTYCONTEXTS)) {
-            $DIRTYCONTEXTS[$path] = 1;
+        if (isset($ACCESSLIB_PRIVATE->dirtycontexts)) {
+            $ACCESSLIB_PRIVATE->dirtycontexts[$path] = 1;
         }
     }
 }
@@ -5729,7 +6505,7 @@ function mark_context_dirty($path) {
  * the contextpath is dirty
  *
  * @param array $contexts array of strings
- * @param obj/array dirty contexts from get_dirty_contexts()
+ * @param obj|array $dirty Dirty contexts from get_dirty_contexts()
  * @return bool
  */
 function is_contextpath_dirty($pathcontexts, $dirty) {
@@ -5744,66 +6520,290 @@ function is_contextpath_dirty($pathcontexts, $dirty) {
 }
 
 /**
+ * Fix the roles.sortorder field in the database, so it contains sequential integers,
+ * and return an array of roleids in order.
  * 
- * switch role order (used in admin/roles/manage.php)
- *
- * @param int $first id of role to move down
- * @param int $second id of role to move up
+ * @param array $allroles array of roles, as returned by get_all_roles();
+ * @return array $role->sortorder =-> $role->id with the keys in ascending order.
+ */
+function fix_role_sortorder($allroles) {
+    global $DB;
+
+    $rolesort = array();
+    $i = 0;
+    foreach ($allroles as $role) {
+        $rolesort[$i] = $role->id;
+        if ($role->sortorder != $i) {
+            $r = new stdClass();
+            $r->id = $role->id;
+            $r->sortorder = $i;
+            $DB->update_record('role', $r);
+            $allroles[$role->id]->sortorder = $i;
+        }
+        $i++;
+    }
+    return $rolesort;
+}
+
+/**
+ * Switch the sort order of two roles (used in admin/roles/manage.php).
  *
- * @return bool success or failure
+ * @param object $first The first role. Actually, only ->sortorder is used.
+ * @param object $second The second role. Actually, only ->sortorder is used.
+ * @return boolean success or failure
  */
 function switch_roles($first, $second) {
-    $status = true;
-    //first find temorary sortorder number
-    $tempsort = count_records('role') + 3;
-    while (get_record('role','sortorder', $tempsort)) {
-        $tempsort += 3;
+    global $DB;
+    $temp = $DB->get_field('role', 'MAX(sortorder) + 1', array());
+    $result = $DB->set_field('role', 'sortorder', $temp, array('sortorder' => $first->sortorder));
+    $result = $result && $DB->set_field('role', 'sortorder', $first->sortorder, array('sortorder' => $second->sortorder));
+    $result = $result && $DB->set_field('role', 'sortorder', $second->sortorder, array('sortorder' => $temp));
+    return $result;
+}
+
+/**
+ * duplicates all the base definitions of a role
+ *
+ * @param object $sourcerole role to copy from
+ * @param int $targetrole id of role to copy to
+ */
+function role_cap_duplicate($sourcerole, $targetrole) {
+    global $DB;
+
+    $systemcontext = get_context_instance(CONTEXT_SYSTEM);
+    $caps = $DB->get_records_sql("SELECT *
+                                    FROM {role_capabilities}
+                                   WHERE roleid = ? AND contextid = ?",
+                                 array($sourcerole->id, $systemcontext->id));
+    // adding capabilities
+    foreach ($caps as $cap) {
+        unset($cap->id);
+        $cap->roleid = $targetrole;
+        $DB->insert_record('role_capabilities', $cap);
     }
+}
+
+
+/**
+ * Returns two lists, this can be used to find out if user has capability.
+ * Having any needed role and no forbidden role in this context means
+ * user has this capability in this context.
+ * Use get_role_names_with_cap_in_context() if you need role names to display in the UI
+ *
+ * @param object $context
+ * @param string $capability
+ * @return array($neededroles, $forbiddenroles)
+ */
+function get_roles_with_cap_in_context($context, $capability) {
+    global $DB;
+
+    $ctxids = trim($context->path, '/'); // kill leading slash
+    $ctxids = str_replace('/', ',', $ctxids);
 
-    $r1 = new object();
-    $r1->id = $first->id;
-    $r1->sortorder = $tempsort;
-    $r2 = new object();
-    $r2->id = $second->id;
-    $r2->sortorder = $first->sortorder;
+    $sql = "SELECT rc.id, rc.roleid, rc.permission, ctx.depth
+              FROM {role_capabilities} rc
+              JOIN {context} ctx ON ctx.id = rc.contextid
+             WHERE rc.capability = :cap AND ctx.id IN ($ctxids)
+          ORDER BY rc.roleid ASC, ctx.depth DESC";
+    $params = array('cap'=>$capability);
 
-    if (!update_record('role', $r1)) {
-        debugging("Can not update role with ID $r1->id!");
-        $status = false;
+    if (!$capdefs = $DB->get_records_sql($sql, $params)) {
+        // no cap definitions --> no capability
+        return array(array(), array());
     }
 
-    if (!update_record('role', $r2)) {
-        debugging("Can not update role with ID $r2->id!");
-        $status = false;
+    $forbidden = array();
+    $needed    = array();
+    foreach($capdefs as $def) {
+        if (isset($forbidden[$def->roleid])) {
+            continue;
+        }
+        if ($def->permission == CAP_PROHIBIT) {
+            $forbidden[$def->roleid] = $def->roleid;
+            unset($needed[$def->roleid]);
+            continue;
     }
+        if (!isset($needed[$def->roleid])) {
+            if ($def->permission == CAP_ALLOW) {
+                $needed[$def->roleid] = true;
+            } else if ($def->permission == CAP_PREVENT) {
+                $needed[$def->roleid] = false;
+            }
+        }
+    }
+    unset($capdefs);
 
-    $r1->sortorder = $second->sortorder;
-    if (!update_record('role', $r1)) {
-        debugging("Can not update role with ID $r1->id!");
-        $status = false;
+    // remove all those roles not allowing
+    foreach($needed as $key=>$value) {
+        if (!$value) {
+            unset($needed[$key]);
+        } else {
+            $needed[$key] = $key;
+        }
     }
 
-    return $status;
+    return array($needed, $forbidden);
 }
 
 /**
- * duplicates all the base definitions of a role
+ * Returns an array of role IDs that have ALL of the the supplied capabilities
+ * Uses get_roles_with_cap_in_context(). Returns $allowed minus $forbidden
  *
- * @param object $sourcerole role to copy from
- * @param int $targetrole id of role to copy to
+ * @param object $context
+ * @param array $capabilities An array of capabilities
+ * @return array of roles with all of the required capabilities
+ */
+function get_roles_with_caps_in_context($context, $capabilities) {
+    $neededarr = array();
+    $forbiddenarr = array();
+    foreach($capabilities as $caprequired) {
+        list($neededarr[], $forbiddenarr[]) = get_roles_with_cap_in_context($context, $caprequired);
+    }
+
+    $rolesthatcanrate = array();
+    if (!empty($neededarr)) {
+        foreach ($neededarr as $needed) {
+            if (empty($rolesthatcanrate)) {
+                $rolesthatcanrate = $needed;
+            } else {
+                //only want roles that have all caps
+                $rolesthatcanrate = array_intersect_key($rolesthatcanrate,$needed);
+            }
+        }
+    }
+    if (!empty($forbiddenarr) && !empty($rolesthatcanrate)) {
+        foreach ($forbiddenarr as $forbidden) {
+           //remove any roles that are forbidden any of the caps
+           $rolesthatcanrate = array_diff($rolesthatcanrate, $forbidden);
+        }
+    }
+    return $rolesthatcanrate;
+}
+
+/**
+ * Returns an array of role names that have ALL of the the supplied capabilities
+ * Uses get_roles_with_caps_in_context(). Returns $allowed minus $forbidden
  *
+ * @param object $context
+ * @param array $capabilities An array of capabilities
+ * @return array of roles with all of the required capabilities
+ */
+function get_role_names_with_caps_in_context($context, $capabilities) {
+    global $DB;
+
+    $rolesthatcanrate = get_roles_with_caps_in_context($context, $capabilities);
+
+    $allroles = array();
+    $roles = $DB->get_records('role', null, 'sortorder DESC');
+    foreach ($roles as $roleid=>$role) {
+        $allroles[$roleid] = $role->name;
+    }
+
+    $rolenames = array();
+    foreach ($rolesthatcanrate as $r) {
+        $rolenames[$r] = $allroles[$r];
+    }
+    $rolenames = role_fix_names($rolenames, $context);
+    return $rolenames;
+}
+
+/**
+ * This function verifies the prohibit comes from this context
+ * and there are no more prohibits in parent contexts.
+ * @param object $context
+ * @param string $capability name
+ * @return bool
+ */
+function prohibit_is_removable($roleid, $context, $capability) {
+    global $DB;
+
+    $ctxids = trim($context->path, '/'); // kill leading slash
+    $ctxids = str_replace('/', ',', $ctxids);
+
+    $params = array('roleid'=>$roleid, 'cap'=>$capability, 'prohibit'=>CAP_PROHIBIT);
+
+    $sql = "SELECT ctx.id
+              FROM {role_capabilities} rc
+              JOIN {context} ctx ON ctx.id = rc.contextid
+             WHERE rc.roleid = :roleid AND rc.permission = :prohibit AND rc.capability = :cap AND ctx.id IN ($ctxids)
+          ORDER BY ctx.depth DESC";
+
+    if (!$prohibits = $DB->get_records_sql($sql, $params)) {
+        // no prohibits == nothing to remove
+        return true;
+    }
+
+    if (count($prohibits) > 1) {
+        // more prohibints can not be removed
+        return false;
+    }
+
+    return !empty($prohibits[$context->id]);
+}
+
+/**
+ * More user friendly role permission changing,
+ * it should produce as few overrides as possible.
+ * @param int $roleid
+ * @param object $context
+ * @param string $capname capability name
+ * @param int $permission
  * @return void
  */
-function role_cap_duplicate($sourcerole, $targetrole) {
-    global $CFG;
-    $systemcontext = get_context_instance(CONTEXT_SYSTEM);
-    $caps = get_records_sql("SELECT * FROM {$CFG->prefix}role_capabilities
-                             WHERE roleid = $sourcerole->id
-                             AND contextid = $systemcontext->id");
-    // adding capabilities
-    foreach ($caps as $cap) {
-        unset($cap->id);
-        $cap->roleid = $targetrole;
-        insert_record('role_capabilities', $cap);
+function role_change_permission($roleid, $context, $capname, $permission) {
+    global $DB;
+
+    if ($permission == CAP_INHERIT) {
+        unassign_capability($capname, $roleid, $context->id);
+        mark_context_dirty($context->path);
+        return;
+    }
+
+    $ctxids = trim($context->path, '/'); // kill leading slash
+    $ctxids = str_replace('/', ',', $ctxids);
+
+    $params = array('roleid'=>$roleid, 'cap'=>$capname);
+
+    $sql = "SELECT ctx.id, rc.permission, ctx.depth
+              FROM {role_capabilities} rc
+              JOIN {context} ctx ON ctx.id = rc.contextid
+             WHERE rc.roleid = :roleid AND rc.capability = :cap AND ctx.id IN ($ctxids)
+          ORDER BY ctx.depth DESC";
+
+    if ($existing = $DB->get_records_sql($sql, $params)) {
+        foreach($existing as $e) {
+            if ($e->permission == CAP_PROHIBIT) {
+                // prohibit can not be overridden, no point in changing anything
+                return;
+            }
+        }
+        $lowest = array_shift($existing);
+        if ($lowest->permission == $permission) {
+            // permission already set in this context or parent - nothing to do
+            return;
+        }
+        if ($existing) {
+            $parent = array_shift($existing);
+            if ($parent->permission == $permission) {
+                // permission already set in parent context or parent - just unset in this context
+                // we do this because we want as few overrides as possible for performance reasons
+                unassign_capability($capname, $roleid, $context->id);
+                mark_context_dirty($context->path);
+                return;
+            }
+        }
+
+    } else {
+        if ($permission == CAP_PREVENT) {
+            // nothing means role does not have permission
+            return;
     }
-}?>
+    }
+
+    // assign the needed capability
+    assign_capability($capname, $permission, $roleid, $context->id, true);
+
+    // force cap reloading
+    mark_context_dirty($context->path);
+}
+
