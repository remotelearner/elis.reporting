diff --git a/lib/profilerlib.php b/lib/profilerlib.php
old mode 100755
new mode 100644
index c212940..dcded90
--- a/lib/profilerlib.php
+++ b/lib/profilerlib.php
@@ -1,273 +1,40 @@
 <?php
-ini_set('display_errors', "On");
-
-require_once 'PEAR.php';
-
-if(!function_exists('scandir'))
-{
-    function scandir($dir, $sortorder = 0)
-    {
-        if(is_dir($dir))
-        {
-            $dirlist = opendir($dir);
-
-            while( ($file = readdir($dirlist)) !== false)
-            {
-                if(!is_dir($file))
-                {
-                    $files[] = $file;
-                }
-            }
-
-            ($sortorder == 0) ? asort($files) : arsort($files);
-
-            return $files;
-        }
-        else
-        {
-            return FALSE;
-            break;
-        }
-    }
-}
 
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
 
 /**
- * Command-line options parsing class.
- *
- * @author Andrei Zmievski <andrei@php.net>
- *
+ * @package   moodlecore
+ * @copyright 1999 onwards Martin Dougiamas  {@link http://moodle.com}
+ * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
  */
-class Console_Getopt {
-    /**
-     * Parses the command-line options.
-     *
-     * The first parameter to this function should be the list of command-line
-     * arguments without the leading reference to the running program.
-     *
-     * The second parameter is a string of allowed short options. Each of the
-     * option letters can be followed by a colon ':' to specify that the option
-     * requires an argument, or a double colon '::' to specify that the option
-     * takes an optional argument.
-     *
-     * The third argument is an optional array of allowed long options. The
-     * leading '--' should not be included in the option name. Options that
-     * require an argument should be followed by '=', and options that take an
-     * option argument should be followed by '=='.
-     *
-     * The return value is an array of two elements: the list of parsed
-     * options and the list of non-option command-line arguments. Each entry in
-     * the list of parsed options is a pair of elements - the first one
-     * specifies the option, and the second one specifies the option argument,
-     * if there was one.
-     *
-     * Long and short options can be mixed.
-     *
-     * Most of the semantics of this function are based on GNU getopt_long().
-     *
-     * @param array  $args           an array of command-line arguments
-     * @param string $short_options  specifies the list of allowed short options
-     * @param array  $long_options   specifies the list of allowed long options
-     *
-     * @return array two-element array containing the list of parsed options and
-     * the non-option arguments
-     *
-     * @access public
-     *
-     */
-    function getopt2($args, $short_options, $long_options = null)
-    {
-        return Console_Getopt::doGetopt(2, $args, $short_options, $long_options);
-    }
-
-    /**
-     * This function expects $args to start with the script name (POSIX-style).
-     * Preserved for backwards compatibility.
-     * @see getopt2()
-     */
-    function getopt($args, $short_options, $long_options = null)
-    {
-        return Console_Getopt::doGetopt(1, $args, $short_options, $long_options);
-    }
-
-    /**
-     * The actual implementation of the argument parsing code.
-     */
-    function doGetopt($version, $args, $short_options, $long_options = null)
-    {
-        // in case you pass directly readPHPArgv() as the first arg
-        if (PEAR::isError($args)) {
-            return $args;
-        }
-        if (empty($args)) {
-            return array(array(), array());
-        }
-        $opts     = array();
-        $non_opts = array();
-
-        settype($args, 'array');
-
-        if ($long_options) {
-            sort($long_options);
-        }
-
-        /*
-         * Preserve backwards compatibility with callers that relied on
-         * erroneous POSIX fix.
-         */
-        if ($version < 2) {
-            if (isset($args[0]{0}) && $args[0]{0} != '-') {
-                array_shift($args);
-            }
-        }
 
-        reset($args);
-        while (list($i, $arg) = each($args)) {
+/** Includes */
+require_once('Console/Getopt.php');
 
-            /* The special element '--' means explicit end of
-               options. Treat the rest of the arguments as non-options
-               and end the loop. */
-            if ($arg == '--') {
-                $non_opts = array_merge($non_opts, array_slice($args, $i + 1));
-                break;
-            }
-
-            if ($arg{0} != '-' || (strlen($arg) > 1 && $arg{1} == '-' && !$long_options)) {
-                $non_opts = array_merge($non_opts, array_slice($args, $i));
-                break;
-            } elseif (strlen($arg) > 1 && $arg{1} == '-') {
-                $error = Console_Getopt::_parseLongOption(substr($arg, 2), $long_options, $opts, $args);
-                if (PEAR::isError($error))
-                    return $error;
-            } else {
-                $error = Console_Getopt::_parseShortOption(substr($arg, 1), $short_options, $opts, $args);
-                if (PEAR::isError($error))
-                    return $error;
-            }
-        }
-
-        return array($opts, $non_opts);
-    }
-
-    /**
-     * @access private
-     *
-     */
-    function _parseShortOption($arg, $short_options, &$opts, &$args)
-    {
-        for ($i = 0; $i < strlen($arg); $i++) {
-            $opt = $arg{$i};
-            $opt_arg = null;
-
-            /* Try to find the short option in the specifier string. */
-            if (($spec = strstr($short_options, $opt)) === false || $arg{$i} == ':')
-            {
-                return PEAR::raiseError("Console_Getopt: unrecognized option -- $opt");
-            }
-
-            if (strlen($spec) > 1 && $spec{1} == ':') {
-                if (strlen($spec) > 2 && $spec{2} == ':') {
-                    if ($i + 1 < strlen($arg)) {
-                        /* Option takes an optional argument. Use the remainder of
-                           the arg string if there is anything left. */
-                        $opts[] = array($opt, substr($arg, $i + 1));
-                        break;
-                    }
-                } else {
-                    /* Option requires an argument. Use the remainder of the arg
-                       string if there is anything left. */
-                    if ($i + 1 < strlen($arg)) {
-                        $opts[] = array($opt,  substr($arg, $i + 1));
-                        break;
-                    } else if (list(, $opt_arg) = each($args))
-                        /* Else use the next argument. */;
-                    else
-                        return PEAR::raiseError("Console_Getopt: option requires an argument -- $opt");
-                }
-            }
-
-            $opts[] = array($opt, $opt_arg);
-        }
-    }
-
-    /**
-     * @access private
-     *
-     */
-    function _parseLongOption($arg, $long_options, &$opts, &$args)
-    {
-        @list($opt, $opt_arg) = explode('=', $arg);
-        $opt_len = strlen($opt);
-
-        for ($i = 0; $i < count($long_options); $i++) {
-            $long_opt  = $long_options[$i];
-            $opt_start = substr($long_opt, 0, $opt_len);
-
-            /* Option doesn't match. Go on to the next one. */
-            if ($opt_start != $opt)
-                continue;
-
-            $opt_rest  = substr($long_opt, $opt_len);
-
-            /* Check that the options uniquely matches one of the allowed
-               options. */
-            if ($opt_rest != '' && $opt{0} != '=' &&
-                $i + 1 < count($long_options) &&
-                $opt == substr($long_options[$i+1], 0, $opt_len)) {
-                return PEAR::raiseError("Console_Getopt: option --$opt is ambiguous");
-            }
-
-            if (substr($long_opt, -1) == '=') {
-                if (substr($long_opt, -2) != '==') {
-                    /* Long option requires an argument.
-                       Take the next argument if one wasn't specified. */;
-                    if (!strlen($opt_arg) && !(list(, $opt_arg) = each($args))) {
-                        return PEAR::raiseError("Console_Getopt: option --$opt requires an argument");
-                    }
-                }
-            } else if ($opt_arg) {
-                return PEAR::raiseError("Console_Getopt: option --$opt doesn't allow an argument");
-            }
-
-            $opts[] = array('--' . $opt, $opt_arg);
-            return;
-        }
-
-        return PEAR::raiseError("Console_Getopt: unrecognized option --$opt");
-    }
-
-    /**
-    * Safely read the $argv PHP array across different PHP configurations.
-    * Will take care on register_globals and register_argc_argv ini directives
+/**
+ * Profiler adapted from Pear::APD's pprofp script. Not quite there yet, I need
+ * to get this to accept a similar list of arguments as the script does,
+ * and process them the same way. Also make sure that the file being loaded
+ * is the right one. Also support multiple pids used in one page load (up to 4 so far).
+ * Then output all this in a nicely formatted table.
     *
-    * @access public
-    * @return mixed the $argv PHP array or PEAR error if not registered
+ * @package   moodlecore
+ * @copyright 1999 onwards Martin Dougiamas  {@link http://moodle.com}
+ * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
     */
-    function readPHPArgv()
-    {
-        global $argv;
-        if (!is_array($argv)) {
-            if (!@is_array($_SERVER['argv'])) {
-                if (!@is_array($GLOBALS['HTTP_SERVER_VARS']['argv'])) {
-                    return PEAR::raiseError("Console_Getopt: Could not read cmd args (register_argc_argv=Off?)");
-                }
-                return $GLOBALS['HTTP_SERVER_VARS']['argv'];
-            }
-            return $_SERVER['argv'];
-        }
-        return $argv;
-    }
-
-}
-
-
-/**
-* Profiler adapted from Pear::APD's pprofp script. Not quite there yet, I need
-* to get this to accept a similar list of arguments as the script does,
-* and process them the same way. Also make sure that the file being loaded
-* is the right one. Also support multiple pids used in one page load (up to 4 so far).
-* Then output all this in a nicely formatted table.
-*/
 class Profiler
 {
     var $stimes;
@@ -288,6 +55,8 @@ class Profiler
      * WARNING: If you switch cleanup off, profiling data will
      * accumulate from one pageload to the next.
      *
+     * @global object
+     * @global object
      * @param boolean $cleanup Whether to delete pprof files or not.
      * @return String Profiling raw data
      */
@@ -319,7 +88,7 @@ class Profiler
      * Returns profiling information gathered using APD functions.
      * Accepts a numerical array of command-line arguments.
      * 
-     * @usage Profiler::get_profiling($args)
+     * Profiler::get_profiling($args)
      *  Sort options
      *  -a          Sort by alphabetic names of subroutines.
      *  -l          Sort by number of calls to subroutines
@@ -492,7 +261,7 @@ class Profiler
         if(array_key_exists('U', $opt)) { $sort = 'by_c_utime'; }
         if(array_key_exists('Z', $opt)) { $sort = 'by_c_time'; }
         if( !count($symbol_hash)) {
-            continue;
+            return NULL;
         }
 
         $retstring .= sprintf("
@@ -706,4 +475,3 @@ EOD;
         return $this->num_cmp($this->mem[$b], $this->mem[$a]); 
     } 
 }
-?>
