diff --git a/lib/questionlib.php b/lib/questionlib.php
index f67370d..a14843a 100644
--- a/lib/questionlib.php
+++ b/lib/questionlib.php
@@ -1,4 +1,19 @@
-<?php  // $Id$
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
 /**
  * Code for handling and processing questions
  *
@@ -10,56 +25,27 @@
  * TODO: separate those functions which form part of the API
  *       from the helper functions.
  *
- * @author Martin Dougiamas and many others. This has recently been completely
- *         rewritten by Alex Smith, Julian Sedding and Gustav Delius as part of
- *         the Serving Mathematics project
- *         {@link http://maths.york.ac.uk/serving_maths}
- * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
- * @package question
+ * @package moodlecore
+ * @subpackage questionbank
+ * @copyright 1999 onwards Martin Dougiamas and others {@link http://moodle.com}
+ * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
  */
 
-/// CONSTANTS ///////////////////////////////////
 
-/**#@+
- * The different types of events that can create question states
- */
-define('QUESTION_EVENTOPEN', '0');      // The state was created by Moodle
-define('QUESTION_EVENTNAVIGATE', '1');  // The responses were saved because the student navigated to another page (this is not currently used)
-define('QUESTION_EVENTSAVE', '2');      // The student has requested that the responses should be saved but not submitted or validated
-define('QUESTION_EVENTGRADE', '3');     // Moodle has graded the responses. A SUBMIT event can be changed to a GRADE event by Moodle.
-define('QUESTION_EVENTDUPLICATE', '4'); // The responses submitted were the same as previously
-define('QUESTION_EVENTVALIDATE', '5');  // The student has requested a validation. This causes the responses to be saved as well, but not graded.
-define('QUESTION_EVENTCLOSEANDGRADE', '6'); // Moodle has graded the responses. A CLOSE event can be changed to a CLOSEANDGRADE event by Moodle.
-define('QUESTION_EVENTSUBMIT', '7');    // The student response has been submitted but it has not yet been marked
-define('QUESTION_EVENTCLOSE', '8');     // The response has been submitted and the session has been closed, either because the student requested it or because Moodle did it (e.g. because of a timelimit). The responses have not been graded.
-define('QUESTION_EVENTMANUALGRADE', '9');   // Grade was entered by teacher
-
-define('QUESTION_EVENTS_GRADED', QUESTION_EVENTGRADE.','.
-                    QUESTION_EVENTCLOSEANDGRADE.','.
-                    QUESTION_EVENTMANUALGRADE);
-/**#@-*/
-
-/**#@+
- * The core question types.
- */
-define("SHORTANSWER",   "shortanswer");
-define("TRUEFALSE",     "truefalse");
-define("MULTICHOICE",   "multichoice");
-define("RANDOM",        "random");
-define("MATCH",         "match");
-define("RANDOMSAMATCH", "randomsamatch");
-define("DESCRIPTION",   "description");
-define("NUMERICAL",     "numerical");
-define("MULTIANSWER",   "multianswer");
-define("CALCULATED",    "calculated");
-define("ESSAY",         "essay");
-/**#@-*/
+defined('MOODLE_INTERNAL') || die();
+
+require_once($CFG->dirroot . '/question/engine/lib.php');
+require_once($CFG->dirroot . '/question/type/questiontypebase.php');
+
+
+
+/// CONSTANTS ///////////////////////////////////
 
 /**
  * Constant determines the number of answer boxes supplied in the editing
  * form for multiple choice and similar question types.
  */
-define("QUESTION_NUMANS", "10");
+define("QUESTION_NUMANS", 10);
 
 /**
  * Constant determines the number of answer boxes supplied in the editing
@@ -76,197 +62,109 @@ define("QUESTION_NUMANS_START", 3);
 define("QUESTION_NUMANS_ADD", 3);
 
 /**
- * The options used when popping up a question preview window in Javascript.
- */
-define('QUESTION_PREVIEW_POPUP_OPTIONS', 'scrollbars=yes,resizable=yes,width=700,height=540');
-
-/**#@+
- * Option flags for ->optionflags
- * The options are read out via bitwise operation using these constants
- */
-/**
- * Whether the questions is to be run in adaptive mode. If this is not set then
- * a question closes immediately after the first submission of responses. This
- * is how question is Moodle always worked before version 1.5
- */
-define('QUESTION_ADAPTIVE', 1);
-
-/**
- * options used in forms that move files.
+ * Move one question type in a list of question types. If you try to move one element
+ * off of the end, nothing will change.
  *
+ * @param array $sortedqtypes An array $qtype => anything.
+ * @param string $tomove one of the keys from $sortedqtypes
+ * @param integer $direction +1 or -1
+ * @return array an array $index => $qtype, with $index from 0 to n in order, and
+ *      the $qtypes in the same order as $sortedqtypes, except that $tomove will
+ *      have been moved one place.
  */
-define('QUESTION_FILENOTHINGSELECTED', 0);
-define('QUESTION_FILEDONOTHING', 1);
-define('QUESTION_FILECOPY', 2);
-define('QUESTION_FILEMOVE', 3);
-define('QUESTION_FILEMOVELINKSONLY', 4);
-
-/**#@-*/
-
-/// QTYPES INITIATION //////////////////
-// These variables get initialised via calls to question_register_questiontype
-// as the question type classes are included.
-global $QTYPES, $QTYPE_MANUAL, $QTYPE_EXCLUDE_FROM_RANDOM;
-/**
- * Array holding question type objects
- */
-$QTYPES = array();
-/**
- * String in the format "'type1','type2'" that can be used in SQL clauses like
- * "WHERE q.type IN ($QTYPE_MANUAL)".
- */
-$QTYPE_MANUAL = '';
-/**
- * String in the format "'type1','type2'" that can be used in SQL clauses like
- * "WHERE q.type NOT IN ($QTYPE_EXCLUDE_FROM_RANDOM)".
- */
-$QTYPE_EXCLUDE_FROM_RANDOM = '';
-
-/**
- * Add a new question type to the various global arrays above.
- *
- * @param object $qtype An instance of the new question type class.
+function question_reorder_qtypes($sortedqtypes, $tomove, $direction) {
+    $neworder = array_keys($sortedqtypes);
+    // Find the element to move.
+    $key = array_search($tomove, $neworder);
+    if ($key === false) {
+        return $neworder;
+    }
+    // Work out the other index.
+    $otherkey = $key + $direction;
+    if (!isset($neworder[$otherkey])) {
+        return $neworder;
+    }
+    // Do the swap.
+    $swap = $neworder[$otherkey];
+    $neworder[$otherkey] = $neworder[$key];
+    $neworder[$key] = $swap;
+    return $neworder;
+}
+
+/**
+ * Save a new question type order to the config_plugins table.
+ * @global object
+ * @param $neworder An arra $index => $qtype. Indices should start at 0 and be in order.
+ * @param $config get_config('question'), if you happen to have it around, to save one DB query.
  */
-function question_register_questiontype($qtype) {
-    global $QTYPES, $QTYPE_MANUAL, $QTYPE_EXCLUDE_FROM_RANDOM;
+function question_save_qtype_order($neworder, $config = null) {
+    global $DB;
 
-    $name = $qtype->name();
-    $QTYPES[$name] = $qtype;
-    if ($qtype->is_manual_graded()) {
-        if ($QTYPE_MANUAL) {
-            $QTYPE_MANUAL .= ',';
-        }
-        $QTYPE_MANUAL .= "'$name'";
+    if (is_null($config)) {
+        $config = get_config('question');
     }
-    if (!$qtype->is_usable_by_random()) {
-        if ($QTYPE_EXCLUDE_FROM_RANDOM) {
-            $QTYPE_EXCLUDE_FROM_RANDOM .= ',';
+
+    foreach ($neworder as $index => $qtype) {
+        $sortvar = $qtype . '_sortorder';
+        if (!isset($config->$sortvar) || $config->$sortvar != $index + 1) {
+            set_config($sortvar, $index + 1, 'question');
         }
-        $QTYPE_EXCLUDE_FROM_RANDOM .= "'$name'";
     }
 }
 
-require_once("$CFG->dirroot/question/type/questiontype.php");
-
-// Load the questiontype.php file for each question type
-// These files in turn call question_register_questiontype()
-// with a new instance of each qtype class.
-$qtypenames= get_list_of_plugins('question/type');
-foreach($qtypenames as $qtypename) {
-    // Instanciates all plug-in question types
-    $qtypefilepath= "$CFG->dirroot/question/type/$qtypename/questiontype.php";
-
-    // echo "Loading $qtypename<br/>"; // Uncomment for debugging
-    if (is_readable($qtypefilepath)) {
-        require_once($qtypefilepath);
-    }
-}
+/// FUNCTIONS //////////////////////////////////////////////////////
 
 /**
- * An array of question type names translated to the user's language, suitable for use when
- * creating a drop-down menu of options.
+ * Returns an array of names of activity modules that use this question
  *
- * Long-time Moodle programmers will realise that this replaces the old $QTYPE_MENU array.
- * The array returned will only hold the names of all the question types that the user should
- * be able to create directly. Some internal question types like random questions are excluded.
+ * @deprecated since Moodle 2.1. Use {@link questions_in_use} instead.
  *
- * @return array an array of question type names translated to the user's language.
+ * @param object $questionid
+ * @return array of strings
  */
-function question_type_menu() {
-    global $QTYPES;
-    static $menu_options = null;
-    if (is_null($menu_options)) {
-        $menu_options = array();
-        foreach ($QTYPES as $name => $qtype) {
-            $menuname = $qtype->menu_name();
-            if ($menuname) {
-                $menu_options[$name] = $menuname;
-            }
-        }
-    }
-    return $menu_options;
+function question_list_instances($questionid) {
+    throw new coding_exception('question_list_instances has been deprectated. ' .
+            'Please use questions_in_use instead.');
 }
 
-/// OTHER CLASSES /////////////////////////////////////////////////////////
-
 /**
- * This holds the options that are set by the course module
- */
-class cmoptions {
-    /**
-    * Whether a new attempt should be based on the previous one. If true
-    * then a new attempt will start in a state where all responses are set
-    * to the last responses from the previous attempt.
-    */
-    var $attemptonlast = false;
-
-    /**
-    * Various option flags. The flags are accessed via bitwise operations
-    * using the constants defined in the CONSTANTS section above.
-    */
-    var $optionflags = QUESTION_ADAPTIVE;
-
-    /**
-    * Determines whether in the calculation of the score for a question
-    * penalties for earlier wrong responses within the same attempt will
-    * be subtracted.
+ * @param array $questionids of question ids.
+ * @return boolean whether any of these questions are being used by any part of Moodle.
     */
-    var $penaltyscheme = true;
-
-    /**
-    * The maximum time the user is allowed to answer the questions withing
-    * an attempt. This is measured in minutes so needs to be multiplied by
-    * 60 before compared to timestamps. If set to 0 no timelimit will be applied
-    */
-    var $timelimit = 0;
-
-    /**
-    * Timestamp for the closing time. Responses submitted after this time will
-    * be saved but no credit will be given for them.
-    */
-    var $timeclose = 9999999999;
-
-    /**
-    * The id of the course from withing which the question is currently being used
-    */
-    var $course = SITEID;
-
-    /**
-    * Whether the answers in a multiple choice question should be randomly
-    * shuffled when a new attempt is started.
-    */
-    var $shuffleanswers = true;
+function questions_in_use($questionids) {
+    global $CFG;
 
-    /**
-    * The number of decimals to be shown when scores are printed
-    */
-    var $decimalpoints = 2;
-}
+    if (question_engine::questions_in_use($questionids)) {
+        return true;
+    }
 
+    foreach (get_plugin_list('mod') as $module => $path) {
+        $lib = $path . '/lib.php';
+        if (is_readable($lib)) {
+            include_once($lib);
 
-/// FUNCTIONS //////////////////////////////////////////////////////
+            $fn = $module . '_questions_in_use';
+            if (function_exists($fn)) {
+                if ($fn($questionids)) {
+                    return true;
+                }
+            } else {
 
-/**
- * Returns an array of names of activity modules that use this question
- *
- * @param object $questionid
- * @return array of strings
- */
-function question_list_instances($questionid) {
-    global $CFG;
-    $instances = array();
-    $modules = get_records('modules');
-    foreach ($modules as $module) {
-        $fullmod = $CFG->dirroot . '/mod/' . $module->name;
-        if (file_exists($fullmod . '/lib.php')) {
-            include_once($fullmod . '/lib.php');
-            $fn = $module->name.'_question_list_instances';
+                // Fallback for legacy modules.
+                $fn = $module . '_question_list_instances';
             if (function_exists($fn)) {
-                $instances = $instances + $fn($questionid);
+                    foreach ($questionids as $questionid) {
+                        $instances = $fn($questionid);
+                        if (!empty($instances)) {
+                            return true;
             }
         }
     }
-    return $instances;
+            }
+        }
+    }
+
+    return false;
 }
 
 /**
@@ -279,7 +177,7 @@ function question_list_instances($questionid) {
  *         any questions in them.
  */
 function question_context_has_any_questions($context) {
-    global $CFG;
+    global $DB;
     if (is_object($context)) {
         $contextid = $context->id;
     } else if (is_numeric($context)) {
@@ -287,61 +185,25 @@ function question_context_has_any_questions($context) {
     } else {
         print_error('invalidcontextinhasanyquestions', 'question');
     }
-    return record_exists_sql('SELECT * FROM ' . $CFG->prefix . 'question q ' .
-            'JOIN ' . $CFG->prefix . 'question_categories qc ON qc.id = q.category ' .
-            "WHERE qc.contextid = $contextid AND q.parent = 0");
+    return $DB->record_exists_sql("SELECT *
+                                     FROM {question} q
+                                     JOIN {question_categories} qc ON qc.id = q.category
+                                    WHERE qc.contextid = ? AND q.parent = 0", array($contextid));
 }
 
 /**
  * Returns list of 'allowed' grades for grade selection
  * formatted suitably for dropdown box function
+ *
+ * @deprecated since 2.1. Use {@link question_bank::fraction_options()} or
+ * {@link question_bank::fraction_options_full()} instead.
+ *
  * @return object ->gradeoptionsfull full array ->gradeoptions +ve only
  */
 function get_grade_options() {
-    // define basic array of grades
-    $grades = array(
-        1.00,
-        0.90,
-        0.83333,
-        0.80,
-        0.75,
-        0.70,
-        0.66666,
-        0.60,
-        0.50,
-        0.40,
-        0.33333,
-        0.30,
-        0.25,
-        0.20,
-        0.16666,
-        0.142857,
-        0.125,
-        0.11111,
-        0.10,
-        0.05,
-        0);
-
-    // iterate through grades generating full range of options
-    $gradeoptionsfull = array();
-    $gradeoptions = array();
-    foreach ($grades as $grade) {
-        $percentage = 100 * $grade;
-        $neggrade = -$grade;
-        $gradeoptions["$grade"] = "$percentage %";
-        $gradeoptionsfull["$grade"] = "$percentage %";
-        $gradeoptionsfull["$neggrade"] = -$percentage." %";
-    }
-    $gradeoptionsfull["0"] = $gradeoptions["0"] = get_string("none");
-
-    // sort lists
-    arsort($gradeoptions, SORT_NUMERIC);
-    arsort($gradeoptionsfull, SORT_NUMERIC);
-
-    // construct return object
-    $grades = new stdClass;
-    $grades->gradeoptions = $gradeoptions;
-    $grades->gradeoptionsfull = $gradeoptionsfull;
+    $grades = new stdClass();
+    $grades->gradeoptions = question_bank::fraction_options();
+    $grades->gradeoptionsfull = question_bank::fraction_options_full();
 
     return $grades;
 }
@@ -355,21 +217,20 @@ function get_grade_options() {
  * @return mixed either 'fixed' value or false if erro
  */
 function match_grade_options($gradeoptionsfull, $grade, $matchgrades='error') {
+    if ($matchgrades == 'error') {
     // if we just need an error...
-    if ($matchgrades=='error') {
-        foreach($gradeoptionsfull as $value => $option) {
+        foreach ($gradeoptionsfull as $value => $option) {
             // slightly fuzzy test, never check floats for equality :-)
-            if (abs($grade-$value)<0.00001) {
+            if (abs($grade - $value) < 0.00001) {
                 return $grade;
             }
         }
         // didn't find a match so that's an error
         return false;
-    }
+    } else if ($matchgrades == 'nearest') {
     // work out nearest value
-    else if ($matchgrades=='nearest') {
         $hownear = array();
-        foreach($gradeoptionsfull as $value => $option) {
+        foreach ($gradeoptionsfull as $value => $option) {
             if ($grade==$value) {
                 return $grade;
             }
@@ -379,79 +240,71 @@ function match_grade_options($gradeoptionsfull, $grade, $matchgrades='error') {
         asort( $hownear, SORT_NUMERIC );
         reset( $hownear );
         return key( $hownear );
-    }
-    else {
+    } else {
         return false;
     }
 }
 
 /**
- * Tests whether a category is in use by any activity module
- *
- * @return boolean
- * @param integer $categoryid
- * @param boolean $recursive Whether to examine category children recursively
+ * @deprecated Since Moodle 2.1. Use {@link question_category_in_use} instead.
+ * @param integer $categoryid a question category id.
+ * @param boolean $recursive whether to check child categories too.
+ * @return boolean whether any question in this category is in use.
  */
 function question_category_isused($categoryid, $recursive = false) {
+    throw new coding_exception('question_category_isused has been deprectated. ' .
+            'Please use question_category_in_use instead.');
+}
+
+/**
+ * Tests whether any question in a category is used by any part of Moodle.
+ *
+ * @param integer $categoryid a question category id.
+ * @param boolean $recursive whether to check child categories too.
+ * @return boolean whether any question in this category is in use.
+ */
+function question_category_in_use($categoryid, $recursive = false) {
+    global $DB;
 
     //Look at each question in the category
-    if ($questions = get_records('question', 'category', $categoryid)) {
-        foreach ($questions as $question) {
-            if (count(question_list_instances($question->id))) {
+    if ($questions = $DB->get_records_menu('question',
+            array('category' => $categoryid), '', 'id, 1')) {
+        if (questions_in_use(array_keys($questions))) {
                 return true;
             }
         }
+    if (!$recursive) {
+        return false;
     }
 
     //Look under child categories recursively
-    if ($recursive) {
-        if ($children = get_records('question_categories', 'parent', $categoryid)) {
+    if ($children = $DB->get_records('question_categories',
+            array('parent' => $categoryid), '', 'id, 1')) {
             foreach ($children as $child) {
-                if (question_category_isused($child->id, $recursive)) {
+            if (question_category_in_use($child->id, $recursive)) {
                     return true;
                 }
             }
         }
-    }
 
     return false;
 }
 
 /**
- * Deletes all data associated to an attempt from the database
- *
- * @param integer $attemptid The id of the attempt being deleted
- */
-function delete_attempt($attemptid) {
-    global $QTYPES;
-
-    $states = get_records('question_states', 'attempt', $attemptid);
-    if ($states) {
-        $stateslist = implode(',', array_keys($states));
-
-        // delete question-type specific data
-        foreach ($QTYPES as $qtype) {
-            $qtype->delete_states($stateslist);
-        }
-    }
-
-    // delete entries from all other question tables
-    // It is important that this is done only after calling the questiontype functions
-    delete_records("question_states", "attempt", $attemptid);
-    delete_records("question_sessions", "attemptid", $attemptid);
-    delete_records("question_attempts", "id", $attemptid);
-}
-
-/**
  * Deletes question and all associated data from the database
  *
  * It will not delete a question if it is used by an activity module
  * @param object $question  The question being deleted
  */
-function delete_question($questionid) {
-    global $QTYPES;
-
-    if (!$question = get_record('question', 'id', $questionid)) {
+function question_delete_question($questionid) {
+    global $DB;
+
+    $question = $DB->get_record_sql('
+            SELECT q.*, qc.contextid
+            FROM {question} q
+            JOIN {question_categories} qc ON qc.id = q.category
+            WHERE q.id = ?', array($questionid));
+    if (!$question) {
         // In some situations, for example if this was a child of a
         // Cloze question that was previously deleted, the question may already
         // have gone. In this case, just do nothing.
@@ -459,48 +312,32 @@ function delete_question($questionid) {
     }
 
     // Do not delete a question if it is used by an activity module
-    if (count(question_list_instances($questionid))) {
+    if (questions_in_use(array($questionid))) {
         return;
     }
 
-    // delete questiontype-specific data
+    // Check permissions.
     question_require_capability_on($question, 'edit');
-    if ($question) {
-        if (isset($QTYPES[$question->qtype])) {
-            $QTYPES[$question->qtype]->delete_question($questionid);
-        }
-    } else {
-        echo "Question with id $questionid does not exist.<br />";
-    }
 
-    if ($states = get_records('question_states', 'question', $questionid)) {
-        $stateslist = implode(',', array_keys($states));
+    $dm = new question_engine_data_mapper();
+    $dm->delete_previews($questionid);
 
         // delete questiontype-specific data
-        foreach ($QTYPES as $qtype) {
-            $qtype->delete_states($stateslist);
-        }
-    }
-
-    // delete entries from all other question tables
-    // It is important that this is done only after calling the questiontype functions
-    delete_records("question_answers", "question", $questionid);
-    delete_records("question_states", "question", $questionid);
-    delete_records("question_sessions", "questionid", $questionid);
+    question_bank::get_qtype($question->qtype, false)->delete_question(
+            $questionid, $question->contextid);
 
     // Now recursively delete all child questions
-    if ($children = get_records('question', 'parent', $questionid)) {
+    if ($children = $DB->get_records('question',
+            array('parent' => $questionid), '', 'id, qtype')) {
         foreach ($children as $child) {
             if ($child->id != $questionid) {
-                delete_question($child->id);
+                question_delete_question($child->id);
             }
         }
     }
 
     // Finally delete the question record itself
-    delete_records('question', 'id', $questionid);
-
-    return;
+    $DB->delete_records('question', array('id' => $questionid));
 }
 
 /**
@@ -511,13 +348,16 @@ function delete_question($questionid) {
  * @return boolean
  */
 function question_delete_course($course, $feedback=true) {
+    global $DB, $OUTPUT;
+
     //To store feedback to be showed at the end of the process
     $feedbackdata   = array();
 
     //Cache some strings
     $strcatdeleted = get_string('unusedcategorydeleted', 'quiz');
     $coursecontext = get_context_instance(CONTEXT_COURSE, $course->id);
-    $categoriescourse = get_records('question_categories', 'contextid', $coursecontext->id, 'parent', 'id, parent, name, contextid');
+    $categoriescourse = $DB->get_records('question_categories',
+            array('contextid' => $coursecontext->id), 'parent', 'id, parent, name, contextid');
 
     if ($categoriescourse) {
 
@@ -529,24 +369,25 @@ function question_delete_course($course, $feedback=true) {
 
             //Delete it completely (questions and category itself)
             //deleting questions
-            if ($questions = get_records("question", "category", $category->id)) {
+            if ($questions = $DB->get_records('question',
+                    array('category' => $category->id), '', 'id,qtype')) {
                 foreach ($questions as $question) {
-                    delete_question($question->id);
+                    question_delete_question($question->id);
                 }
-                delete_records("question", "category", $category->id);
+                $DB->delete_records("question", array("category" => $category->id));
             }
             //delete the category
-            delete_records('question_categories', 'id', $category->id);
+            $DB->delete_records('question_categories', array('id' => $category->id));
 
             //Fill feedback
             $feedbackdata[] = array($category->name, $strcatdeleted);
         }
         //Inform about changes performed if feedback is enabled
         if ($feedback) {
-            $table = new stdClass;
-            $table->head = array(get_string('category','quiz'), get_string('action'));
+            $table = new html_table();
+            $table->head = array(get_string('category', 'quiz'), get_string('action'));
             $table->data = $feedbackdata;
-            print_table($table);
+            echo html_writer::table($table);
         }
     }
     return true;
@@ -558,11 +399,14 @@ function question_delete_course($course, $feedback=true) {
  * 2/ All questions are moved to new category
  *
  * @param object $category course category object
- * @param object $newcategory empty means everything deleted, otherwise id of category where content moved
+ * @param object $newcategory empty means everything deleted, otherwise id of
+ *      category where content moved
  * @param boolean $feedback to specify if the process must output a summary of its work
  * @return boolean
  */
 function question_delete_course_category($category, $newcategory, $feedback=true) {
+    global $DB, $OUTPUT;
+
     $context = get_context_instance(CONTEXT_COURSECAT, $category->id);
     if (empty($newcategory)) {
         $feedbackdata   = array(); // To store feedback to be showed at the end of the process
@@ -570,33 +414,39 @@ function question_delete_course_category($category, $newcategory, $feedback=true
         $strcatdeleted = get_string('unusedcategorydeleted', 'quiz');
 
         // Loop over question categories.
-        if ($categories = get_records('question_categories', 'contextid', $context->id, 'parent', 'id, parent, name')) {
+        if ($categories = $DB->get_records('question_categories',
+                array('contextid'=>$context->id), 'parent', 'id, parent, name')) {
             foreach ($categories as $category) {
 
                 // Deal with any questions in the category.
-                if ($questions = get_records('question', 'category', $category->id)) {
+                if ($questions = $DB->get_records('question',
+                        array('category' => $category->id), '', 'id,qtype')) {
 
                     // Try to delete each question.
                     foreach ($questions as $question) {
-                        delete_question($question->id);
+                        question_delete_question($question->id);
                     }
 
-                    // Check to see if there were any questions that were kept because they are
-                    // still in use somehow, even though quizzes in courses in this category will
-                    // already have been deteted. This could happen, for example, if questions are
-                    // added to a course, and then that course is moved to another category (MDL-14802).
-                    $questionids = get_records_select_menu('question', 'category = ' . $category->id, '', 'id,1');
+                    // Check to see if there were any questions that were kept because
+                    // they are still in use somehow, even though quizzes in courses
+                    // in this category will already have been deteted. This could
+                    // happen, for example, if questions are added to a course,
+                    // and then that course is moved to another category (MDL-14802).
+                    $questionids = $DB->get_records_menu('question',
+                            array('category'=>$category->id), '', 'id, 1');
                     if (!empty($questionids)) {
-                        if (!$rescueqcategory = question_save_from_deletion(implode(',', array_keys($questionids)),
-                                get_parent_contextid($context), print_context_name($context), $rescueqcategory)) {
+                        if (!$rescueqcategory = question_save_from_deletion(
+                                array_keys($questionids), get_parent_contextid($context),
+                                print_context_name($context), $rescueqcategory)) {
                             return false;
                        }
-                       $feedbackdata[] = array($category->name, get_string('questionsmovedto', 'question', $rescueqcategory->name));
+                        $feedbackdata[] = array($category->name,
+                            get_string('questionsmovedto', 'question', $rescueqcategory->name));
                     }
                 }
 
                 // Now delete the category.
-                if (!delete_records('question_categories', 'id', $category->id)) {
+                if (!$DB->delete_records('question_categories', array('id'=>$category->id))) {
                     return false;
                 }
                 $feedbackdata[] = array($category->name, $strcatdeleted);
@@ -606,10 +456,10 @@ function question_delete_course_category($category, $newcategory, $feedback=true
 
         // Output feedback if requested.
         if ($feedback and $feedbackdata) {
-            $table = new stdClass;
-            $table->head = array(get_string('questioncategory','question'), get_string('action'));
+            $table = new html_table();
+            $table->head = array(get_string('questioncategory', 'question'), get_string('action'));
             $table->data = $feedbackdata;
-            print_table($table);
+            echo html_writer::table($table);
         }
 
     } else {
@@ -617,14 +467,14 @@ function question_delete_course_category($category, $newcategory, $feedback=true
         if (!$newcontext = get_context_instance(CONTEXT_COURSECAT, $newcategory->id)) {
             return false;
         }
-        if (!set_field('question_categories', 'contextid', $newcontext->id, 'contextid', $context->id)) {
-            return false;
-        }
+        $DB->set_field('question_categories', 'contextid', $newcontext->id,
+                array('contextid'=>$context->id));
         if ($feedback) {
-            $a = new stdClass;
+            $a = new stdClass();
             $a->oldplace = print_context_name($context);
             $a->newplace = print_context_name($newcontext);
-            notify(get_string('movedquestionsandcategories', 'question', $a), 'notifysuccess');
+            echo $OUTPUT->notification(
+                    get_string('movedquestionsandcategories', 'question', $a), 'notifysuccess');
         }
     }
 
@@ -636,23 +486,25 @@ function question_delete_course_category($category, $newcategory, $feedback=true
  *
  * @param string $questionids list of questionids
  * @param object $newcontext the context to create the saved category in.
- * @param string $oldplace a textual description of the think being deleted, e.g. from get_context_name
+ * @param string $oldplace a textual description of the think being deleted,
+ *      e.g. from get_context_name
  * @param object $newcategory
  * @return mixed false on
  */
-function question_save_from_deletion($questionids, $newcontextid, $oldplace, $newcategory = null) {
+function question_save_from_deletion($questionids, $newcontextid, $oldplace,
+        $newcategory = null) {
+    global $DB;
+
     // Make a category in the parent context to move the questions to.
     if (is_null($newcategory)) {
-        $newcategory = new object();
+        $newcategory = new stdClass();
         $newcategory->parent = 0;
         $newcategory->contextid = $newcontextid;
-        $newcategory->name = addslashes(get_string('questionsrescuedfrom', 'question', $oldplace));
-        $newcategory->info = addslashes(get_string('questionsrescuedfrominfo', 'question', $oldplace));
+        $newcategory->name = get_string('questionsrescuedfrom', 'question', $oldplace);
+        $newcategory->info = get_string('questionsrescuedfrominfo', 'question', $oldplace);
         $newcategory->sortorder = 999;
         $newcategory->stamp = make_unique_id_code();
-        if (!$newcategory->id = insert_record('question_categories', $newcategory)) {
-            return false;
-        }
+        $newcategory->id = $DB->insert_record('question_categories', $newcategory);
     }
 
     // Move any remaining questions to the 'saved' category.
@@ -670,13 +522,16 @@ function question_save_from_deletion($questionids, $newcontextid, $oldplace, $ne
  * @return boolean
  */
 function question_delete_activity($cm, $feedback=true) {
+    global $DB, $OUTPUT;
+
     //To store feedback to be showed at the end of the process
     $feedbackdata   = array();
 
     //Cache some strings
     $strcatdeleted = get_string('unusedcategorydeleted', 'quiz');
     $modcontext = get_context_instance(CONTEXT_MODULE, $cm->id);
-    if ($categoriesmods = get_records('question_categories', 'contextid', $modcontext->id, 'parent', 'id, parent, name, contextid')){
+    if ($categoriesmods = $DB->get_records('question_categories',
+            array('contextid' => $modcontext->id), 'parent', 'id, parent, name, contextid')) {
         //Sort categories following their tree (parent-child) relationships
         //this will make the feedback more readable
         $categoriesmods = sort_categories_by_tree($categoriesmods);
@@ -685,24 +540,25 @@ function question_delete_activity($cm, $feedback=true) {
 
             //Delete it completely (questions and category itself)
             //deleting questions
-            if ($questions = get_records("question", "category", $category->id)) {
+            if ($questions = $DB->get_records('question',
+                    array('category' => $category->id), '', 'id,qtype')) {
                 foreach ($questions as $question) {
-                    delete_question($question->id);
+                    question_delete_question($question->id);
                 }
-                delete_records("question", "category", $category->id);
+                $DB->delete_records("question", array("category"=>$category->id));
             }
             //delete the category
-            delete_records('question_categories', 'id', $category->id);
+            $DB->delete_records('question_categories', array('id'=>$category->id));
 
             //Fill feedback
             $feedbackdata[] = array($category->name, $strcatdeleted);
         }
         //Inform about changes performed if feedback is enabled
         if ($feedback) {
-            $table = new stdClass;
-            $table->head = array(get_string('category','quiz'), get_string('action'));
+            $table = new html_table();
+            $table->head = array(get_string('category', 'quiz'), get_string('action'));
             $table->data = $feedbackdata;
-            print_table($table);
+            echo html_writer::table($table);
         }
     }
     return true;
@@ -710,1070 +566,303 @@ function question_delete_activity($cm, $feedback=true) {
 
 /**
  * This function should be considered private to the question bank, it is called from
- * question/editlib.php question/contextmoveq.php and a few similar places to to the work of
- * acutally moving questions and associated data. However, callers of this function also have to
- * do other work, which is why you should not call this method directly from outside the questionbank.
+ * question/editlib.php question/contextmoveq.php and a few similar places to to the
+ * work of acutally moving questions and associated data. However, callers of this
+ * function also have to do other work, which is why you should not call this method
+ * directly from outside the questionbank.
  *
  * @param string $questionids a comma-separated list of question ids.
- * @param integer $newcategory the id of the category to move to.
+ * @param integer $newcategoryid the id of the category to move to.
  */
-function question_move_questions_to_category($questionids, $newcategory) {
-    $result = true;
+function question_move_questions_to_category($questionids, $newcategoryid) {
+    global $DB;
+
+    $newcontextid = $DB->get_field('question_categories', 'contextid',
+            array('id' => $newcategoryid));
+    list($questionidcondition, $params) = $DB->get_in_or_equal($questionids);
+    $questions = $DB->get_records_sql("
+            SELECT q.id, q.qtype, qc.contextid
+              FROM {question} q
+              JOIN {question_categories} qc ON q.category = qc.id
+             WHERE  q.id $questionidcondition", $params);
+    foreach ($questions as $question) {
+        if ($newcontextid != $question->contextid) {
+            question_bank::get_qtype($question->qtype)->move_files(
+                    $question->id, $question->contextid, $newcontextid);
+        }
+    }
 
     // Move the questions themselves.
-    $result = $result && set_field_select('question', 'category', $newcategory, "id IN ($questionids)");
+    $DB->set_field_select('question', 'category', $newcategoryid,
+            "id $questionidcondition", $params);
 
     // Move any subquestions belonging to them.
-    $result = $result && set_field_select('question', 'category', $newcategory, "parent IN ($questionids)");
+    $DB->set_field_select('question', 'category', $newcategoryid,
+            "parent $questionidcondition", $params);
 
     // TODO Deal with datasets.
 
-    return $result;
+    return true;
 }
 
 /**
- * @param array $row tab objects
- * @param question_edit_contexts $contexts object representing contexts available from this context
- * @param string $querystring to append to urls
- * */
-function questionbank_navigation_tabs(&$row, $contexts, $querystring) {
-    global $CFG, $QUESTION_EDITTABCAPS;
-    $tabs = array(
-            'questions' =>array("$CFG->wwwroot/question/edit.php?$querystring", get_string('questions', 'quiz'), get_string('editquestions', 'quiz')),
-            'categories' =>array("$CFG->wwwroot/question/category.php?$querystring", get_string('categories', 'quiz'), get_string('editqcats', 'quiz')),
-            'import' =>array("$CFG->wwwroot/question/import.php?$querystring", get_string('import', 'quiz'), get_string('importquestions', 'quiz')),
-            'export' =>array("$CFG->wwwroot/question/export.php?$querystring", get_string('export', 'quiz'), get_string('exportquestions', 'quiz')));
-    foreach ($tabs as $tabname => $tabparams){
-        if ($contexts->have_one_edit_tab_cap($tabname)) {
-            $row[] = new tabobject($tabname, $tabparams[0], $tabparams[1], $tabparams[2]);
-        }
+ * This function helps move a question cateogry to a new context by moving all
+ * the files belonging to all the questions to the new context.
+ * Also moves subcategories.
+ * @param integer $categoryid the id of the category being moved.
+ * @param integer $oldcontextid the old context id.
+ * @param integer $newcontextid the new context id.
+ */
+function question_move_category_to_context($categoryid, $oldcontextid, $newcontextid) {
+    global $DB;
+
+    $questionids = $DB->get_records_menu('question',
+            array('category' => $categoryid), '', 'id,qtype');
+    foreach ($questionids as $questionid => $qtype) {
+        question_bank::get_qtype($qtype)->move_files(
+                $questionid, $oldcontextid, $newcontextid);
     }
-}
 
-/**
- * Private function to factor common code out of get_question_options().
- *
- * @param object $question the question to tidy.
- * @return boolean true if successful, else false.
- */
-function _tidy_question(&$question) {
-    global $QTYPES;
-    if (!array_key_exists($question->qtype, $QTYPES)) {
-        $question->qtype = 'missingtype';
-        $question->questiontext = '<p>' . get_string('warningmissingtype', 'quiz') . '</p>' . $question->questiontext;
+    $subcatids = $DB->get_records_menu('question_categories',
+            array('parent' => $categoryid), '', 'id,1');
+    foreach ($subcatids as $subcatid => $notused) {
+        $DB->set_field('question_categories', 'contextid', $newcontextid,
+                array('id' => $subcatid));
+        question_move_category_to_context($subcatid, $oldcontextid, $newcontextid);
     }
-    $question->name_prefix = question_make_name_prefix($question->id);
-    return $QTYPES[$question->qtype]->get_question_options($question);
 }
 
 /**
- * Updates the question objects with question type specific
- * information by calling {@link get_question_options()}
- *
- * Can be called either with an array of question objects or with a single
- * question object.
- *
- * @param mixed $questions Either an array of question objects to be updated
- *         or just a single question object
- * @return bool Indicates success or failure.
+ * Generate the URL for starting a new preview of a given question with the given options.
+ * @param integer $questionid the question to preview.
+ * @param string $preferredbehaviour the behaviour to use for the preview.
+ * @param float $maxmark the maximum to mark the question out of.
+ * @param question_display_options $displayoptions the display options to use.
+ * @param int $variant the variant of the question to preview. If null, one will
+ *      be picked randomly.
+ * @param object $context context to run the preview in (affects things like
+ *      filter settings, theme, lang, etc.) Defaults to $PAGE->context.
+ * @return string the URL.
  */
-function get_question_options(&$questions) {
-    if (is_array($questions)) { // deal with an array of questions
-        foreach ($questions as $i => $notused) {
-            if (!_tidy_question($questions[$i])) {
-                return false;
-            }
-        }
-        return true;
-    } else { // deal with single question
-        return _tidy_question($questions);
-    }
-}
+function question_preview_url($questionid, $preferredbehaviour = null,
+        $maxmark = null, $displayoptions = null, $variant = null, $context = null) {
 
-/**
-* Loads the most recent state of each question session from the database
-* or create new one.
-*
-* For each question the most recent session state for the current attempt
-* is loaded from the question_states table and the question type specific data and
-* responses are added by calling {@link restore_question_state()} which in turn
-* calls {@link restore_session_and_responses()} for each question.
-* If no states exist for the question instance an empty state object is
-* created representing the start of a session and empty question
-* type specific information and responses are created by calling
-* {@link create_session_and_responses()}.
-*
-* @return array           An array of state objects representing the most recent
-*                         states of the question sessions.
-* @param array $questions The questions for which sessions are to be restored or
-*                         created.
-* @param object $cmoptions
-* @param object $attempt  The attempt for which the question sessions are
-*                         to be restored or created.
-* @param mixed either the id of a previous attempt, if this attmpt is
-*                         building on a previous one, or false for a clean attempt.
-*/
-function get_question_states(&$questions, $cmoptions, $attempt, $lastattemptid = false) {
-    global $CFG, $QTYPES;
-
-    // get the question ids
-    $ids = array_keys($questions);
-    $questionlist = implode(',', $ids);
-
-    // The question field must be listed first so that it is used as the
-    // array index in the array returned by get_records_sql
-    $statefields = 'n.questionid as question, s.id, s.attempt, s.originalquestion, ' .
-            's.seq_number, s.answer, s.timestamp, s.event, s.grade, s.raw_grade, ' .
-            's.penalty, n.sumpenalty, n.manualcomment';
-    // Load the newest states for the questions
-    $sql = "SELECT $statefields".
-           "  FROM {$CFG->prefix}question_states s,".
-           "       {$CFG->prefix}question_sessions n".
-           " WHERE s.id = n.newest".
-           "   AND n.attemptid = '$attempt->uniqueid'".
-           "   AND n.questionid IN ($questionlist)";
-    $states = get_records_sql($sql);
-
-    // Load the newest graded states for the questions
-    $sql = "SELECT $statefields".
-           "  FROM {$CFG->prefix}question_states s,".
-           "       {$CFG->prefix}question_sessions n".
-           " WHERE s.id = n.newgraded".
-           "   AND n.attemptid = '$attempt->uniqueid'".
-           "   AND n.questionid IN ($questionlist)";
-    $gradedstates = get_records_sql($sql);
-
-    // loop through all questions and set the last_graded states
-    foreach ($ids as $i) {
-        if (isset($states[$i])) {
-            restore_question_state($questions[$i], $states[$i]);
-            if (isset($gradedstates[$i])) {
-                restore_question_state($questions[$i], $gradedstates[$i]);
-                $states[$i]->last_graded = $gradedstates[$i];
-            } else {
-                $states[$i]->last_graded = clone($states[$i]);
-            }
-        } else {
-            if ($lastattemptid) {
-                // If the new attempt is to be based on this previous attempt.
-                // Find the responses from the previous attempt and save them to the new session
-
-                // Load the last graded state for the question. Note, $statefields is
-                // the same as above, except that we don't want n.manualcomment.
-                $statefields = 'n.questionid as question, s.id, s.attempt, s.originalquestion, ' .
-                        's.seq_number, s.answer, s.timestamp, s.event, s.grade, s.raw_grade, ' .
-                        's.penalty, n.sumpenalty';
-                $sql = "SELECT $statefields".
-                       "  FROM {$CFG->prefix}question_states s,".
-                       "       {$CFG->prefix}question_sessions n".
-                       " WHERE s.id = n.newest".
-                       "   AND n.attemptid = '$lastattemptid'".
-                       "   AND n.questionid = '$i'";
-                if (!$laststate = get_record_sql($sql)) {
-                    // Only restore previous responses that have been graded
-                    continue;
+    $params = array('id' => $questionid);
+
+    if (is_null($context)) {
+        global $PAGE;
+        $context = $PAGE->context;
                 }
-                // Restore the state so that the responses will be restored
-                restore_question_state($questions[$i], $laststate);
-                $states[$i] = clone($laststate);
-                unset($states[$i]->id);
-            } else {
-                // create a new empty state
-                $states[$i] = new object;
-                $states[$i]->question = $i;
-                $states[$i]->responses = array('' => '');
-                $states[$i]->raw_grade = 0;
-            }
-
-            // now fill/overide initial values
-            $states[$i]->attempt = $attempt->uniqueid;
-            $states[$i]->seq_number = 0;
-            $states[$i]->timestamp = $attempt->timestart;
-            $states[$i]->event = ($attempt->timefinish) ? QUESTION_EVENTCLOSE : QUESTION_EVENTOPEN;
-            $states[$i]->grade = 0;
-            $states[$i]->penalty = 0;
-            $states[$i]->sumpenalty = 0;
-            $states[$i]->manualcomment = '';
-
-            // Prevent further changes to the session from incrementing the
-            // sequence number
-            $states[$i]->changed = true;
-
-            if ($lastattemptid) {
-                // prepare the previous responses for new processing
-                $action = new stdClass;
-                $action->responses = $laststate->responses;
-                $action->timestamp = $laststate->timestamp;
-                $action->event = QUESTION_EVENTSAVE; //emulate save of questions from all pages MDL-7631
-
-                // Process these responses ...
-                question_process_responses($questions[$i], $states[$i], $action, $cmoptions, $attempt);
-
-                // Fix for Bug #5506: When each attempt is built on the last one,
-                // preserve the options from any previous attempt.
-                if ( isset($laststate->options) ) {
-                    $states[$i]->options = $laststate->options;
+    if ($context->contextlevel == CONTEXT_MODULE) {
+        $params['cmid'] = $context->instanceid;
+    } else if ($context->contextlevel == CONTEXT_COURSE) {
+        $params['courseid'] = $context->instanceid;
                 }
-            } else {
-                // Create the empty question type specific information
-                if (!$QTYPES[$questions[$i]->qtype]->create_session_and_responses(
-                        $questions[$i], $states[$i], $cmoptions, $attempt)) {
-                    return false;
+
+    if (!is_null($preferredbehaviour)) {
+        $params['behaviour'] = $preferredbehaviour;
                 }
+
+    if (!is_null($maxmark)) {
+        $params['maxmark'] = $maxmark;
             }
-            $states[$i]->last_graded = clone($states[$i]);
+
+    if (!is_null($displayoptions)) {
+        $params['correctness']     = $displayoptions->correctness;
+        $params['marks']           = $displayoptions->marks;
+        $params['markdp']          = $displayoptions->markdp;
+        $params['feedback']        = (bool) $displayoptions->feedback;
+        $params['generalfeedback'] = (bool) $displayoptions->generalfeedback;
+        $params['rightanswer']     = (bool) $displayoptions->rightanswer;
+        $params['history']         = (bool) $displayoptions->history;
         }
+
+    if ($variant) {
+        $params['variant'] = $variant;
     }
-    return $states;
-}
 
+    return new moodle_url('/question/preview.php', $params);
+}
 
 /**
-* Creates the run-time fields for the states
-*
-* Extends the state objects for a question by calling
-* {@link restore_session_and_responses()}
-* @param object $question The question for which the state is needed
-* @param object $state The state as loaded from the database
-* @return boolean Represents success or failure
-*/
-function restore_question_state(&$question, &$state) {
-    global $QTYPES;
-
-    // initialise response to the value in the answer field
-    $state->responses = array('' => addslashes($state->answer));
-    unset($state->answer);
-    $state->manualcomment = isset($state->manualcomment) ? addslashes($state->manualcomment) : '';
-
-    // Set the changed field to false; any code which changes the
-    // question session must set this to true and must increment
-    // ->seq_number. The save_question_session
-    // function will save the new state object to the database if the field is
-    // set to true.
-    $state->changed = false;
-
-    // Load the question type specific data
-    return $QTYPES[$question->qtype]
-            ->restore_session_and_responses($question, $state);
-
+ * @return array that can be passed as $params to the {@link popup_action} constructor.
+ */
+function question_preview_popup_params() {
+    return array(
+        'height' => 600,
+        'width' => 800,
+    );
 }
 
 /**
-* Saves the current state of the question session to the database
-*
-* The state object representing the current state of the session for the
-* question is saved to the question_states table with ->responses[''] saved
-* to the answer field of the database table. The information in the
-* question_sessions table is updated.
-* The question type specific data is then saved.
-* @return mixed           The id of the saved or updated state or false
-* @param object $question The question for which session is to be saved.
-* @param object $state    The state information to be saved. In particular the
-*                         most recent responses are in ->responses. The object
-*                         is updated to hold the new ->id.
-*/
-function save_question_session(&$question, &$state) {
-    global $QTYPES;
-    // Check if the state has changed
-    if (!$state->changed && isset($state->id)) {
-        return $state->id;
-    }
-    // Set the legacy answer field
-    $state->answer = isset($state->responses['']) ? $state->responses[''] : '';
-
-    // Save the state
-    if (!empty($state->update)) { // this forces the old state record to be overwritten
-        update_record('question_states', $state);
-    } else {
-        if (!$state->id = insert_record('question_states', $state)) {
-            unset($state->id);
-            unset($state->answer);
-            return false;
-        }
-    }
-
-    // create or update the session
-    if (!$session = get_record('question_sessions', 'attemptid',
-            $state->attempt, 'questionid', $question->id)) {
-        $session->attemptid = $state->attempt;
-        $session->questionid = $question->id;
-        $session->newest = $state->id;
-        // The following may seem weird, but the newgraded field needs to be set
-        // already even if there is no graded state yet.
-        $session->newgraded = $state->id;
-        $session->sumpenalty = $state->sumpenalty;
-        $session->manualcomment = $state->manualcomment;
-        if (!insert_record('question_sessions', $session)) {
-            error('Could not insert entry in question_sessions');
+ * Given a list of ids, load the basic information about a set of questions from
+ * the questions table. The $join and $extrafields arguments can be used together
+ * to pull in extra data. See, for example, the usage in mod/quiz/attemptlib.php, and
+ * read the code below to see how the SQL is assembled. Throws exceptions on error.
+ *
+ * @global object
+ * @global object
+ * @param array $questionids array of question ids.
+ * @param string $extrafields extra SQL code to be added to the query.
+ * @param string $join extra SQL code to be added to the query.
+ * @param array $extraparams values for any placeholders in $join.
+ * You are strongly recommended to use named placeholder.
+ *
+ * @return array partially complete question objects. You need to call get_question_options
+ * on them before they can be properly used.
+ */
+function question_preload_questions($questionids, $extrafields = '', $join = '',
+        $extraparams = array()) {
+    global $DB;
+    if (empty($questionids)) {
+        return array();
         }
-    } else {
-        $session->newest = $state->id;
-        if (question_state_is_graded($state) or $state->event == QUESTION_EVENTOPEN) {
-            // this state is graded or newly opened, so it goes into the lastgraded field as well
-            $session->newgraded = $state->id;
-            $session->sumpenalty = $state->sumpenalty;
-            $session->manualcomment = $state->manualcomment;
-        } else {
-            $session->manualcomment = addslashes($session->manualcomment);
+    if ($join) {
+        $join = ' JOIN '.$join;
         }
-        update_record('question_sessions', $session);
+    if ($extrafields) {
+        $extrafields = ', ' . $extrafields;
     }
+    list($questionidcondition, $params) = $DB->get_in_or_equal(
+            $questionids, SQL_PARAMS_NAMED, 'qid0000');
+    $sql = 'SELECT q.*, qc.contextid' . $extrafields . ' FROM {question} q
+            JOIN {question_categories} qc ON q.category = qc.id' .
+            $join .
+          ' WHERE q.id ' . $questionidcondition;
 
-    unset($state->answer);
+    // Load the questions
+    if (!$questions = $DB->get_records_sql($sql, $extraparams + $params)) {
+        return array();
+    }
 
-    // Save the question type specific state information and responses
-    if (!$QTYPES[$question->qtype]->save_session_and_responses(
-     $question, $state)) {
-        return false;
+    foreach ($questions as $question) {
+        $question->_partiallyloaded = true;
     }
-    // Reset the changed flag
-    $state->changed = false;
-    return $state->id;
-}
 
-/**
-* Determines whether a state has been graded by looking at the event field
-*
-* @return boolean         true if the state has been graded
-* @param object $state
-*/
-function question_state_is_graded($state) {
-    $gradedevents = explode(',', QUESTION_EVENTS_GRADED);
-    return (in_array($state->event, $gradedevents));
-}
+    // Note, a possible optimisation here would be to not load the TEXT fields
+    // (that is, questiontext and generalfeedback) here, and instead load them in
+    // question_load_questions. That would add one DB query, but reduce the amount
+    // of data transferred most of the time. I am not going to do this optimisation
+    // until it is shown to be worthwhile.
 
-/**
-* Determines whether a state has been closed by looking at the event field
-*
-* @return boolean         true if the state has been closed
-* @param object $state
-*/
-function question_state_is_closed($state) {
-    return ($state->event == QUESTION_EVENTCLOSE
-        or $state->event == QUESTION_EVENTCLOSEANDGRADE
-        or $state->event == QUESTION_EVENTMANUALGRADE);
+    return $questions;
 }
 
-
 /**
- * Extracts responses from submitted form
+ * Load a set of questions, given a list of ids. The $join and $extrafields arguments can be used
+ * together to pull in extra data. See, for example, the usage in mod/quiz/attempt.php, and
+ * read the code below to see how the SQL is assembled. Throws exceptions on error.
  *
- * This can extract the responses given to one or several questions present on a page
- * It returns an array with one entry for each question, indexed by question id
- * Each entry is an object with the properties
- *  ->event     The event that has triggered the submission. This is determined by which button
- *               the user has pressed.
- *  ->responses An array holding the responses to an individual question, indexed by the
- *               name of the corresponding form element.
- *  ->timestamp A unix timestamp
- * @return array            array of action objects, indexed by question ids.
- * @param array $questions  an array containing at least all questions that are used on the form
- * @param array $formdata   the data submitted by the form on the question page
- * @param integer $defaultevent  the event type used if no 'mark' or 'validate' is submitted
- */
-function question_extract_responses($questions, $formdata, $defaultevent=QUESTION_EVENTSAVE) {
-
-    $time = time();
-    $actions = array();
-    foreach ($formdata as $key => $response) {
-        // Get the question id from the response name
-        if (false !== ($quid = question_get_id_from_name_prefix($key))) {
-            // check if this is a valid id
-            if (!isset($questions[$quid])) {
-                error('Form contained question that is not in questionids');
-            }
-
-            // Remove the name prefix from the name
-            //decrypt trying
-            $key = substr($key, strlen($questions[$quid]->name_prefix));
-            if (false === $key) {
-                $key = '';
-            }
-            // Check for question validate and mark buttons & set events
-            if ($key === 'validate') {
-                $actions[$quid]->event = QUESTION_EVENTVALIDATE;
-            } else if ($key === 'submit') {
-                $actions[$quid]->event = QUESTION_EVENTSUBMIT;
-            } else {
-                $actions[$quid]->event = $defaultevent;
-            }
-
-            // Update the state with the new response
-            $actions[$quid]->responses[$key] = $response;
+ * @param array $questionids array of question ids.
+ * @param string $extrafields extra SQL code to be added to the query.
+ * @param string $join extra SQL code to be added to the query.
+ * @param array $extraparams values for any placeholders in $join.
+ * You are strongly recommended to use named placeholder.
+ *
+ * @return array question objects.
+ */
+function question_load_questions($questionids, $extrafields = '', $join = '') {
+    $questions = question_preload_questions($questionids, $extrafields, $join);
 
-            // Set the timestamp
-            $actions[$quid]->timestamp = $time;
-        }
+    // Load the question type specific information
+    if (!get_question_options($questions)) {
+        return 'Could not load the question options';
     }
-    foreach ($actions as $quid => $notused) {
-        ksort($actions[$quid]->responses);
-    }
-    return $actions;
-}
 
+    return $questions;
+}
 
 /**
- * Returns the html for question feedback image.
- * @param float   $fraction  value representing the correctness of the user's
- *                           response to a question.
- * @param boolean $selected  whether or not the answer is the one that the
- *                           user picked.
- * @return string
+ * Private function to factor common code out of get_question_options().
+ *
+ * @param object $question the question to tidy.
+ * @param boolean $loadtags load the question tags from the tags table. Optional, default false.
  */
-function question_get_feedback_image($fraction, $selected=true) {
-
+function _tidy_question($question, $loadtags = false) {
     global $CFG;
-
-    if ($fraction >= 1.0) {
-        if ($selected) {
-            $feedbackimg = '<img src="'.$CFG->pixpath.'/i/tick_green_big.gif" '.
-                            'alt="'.get_string('correct', 'quiz').'" class="icon" />';
-        } else {
-            $feedbackimg = '<img src="'.$CFG->pixpath.'/i/tick_green_small.gif" '.
-                            'alt="'.get_string('correct', 'quiz').'" class="icon" />';
-        }
-    } else if ($fraction > 0.0 && $fraction < 1.0) {
-        if ($selected) {
-            $feedbackimg = '<img src="'.$CFG->pixpath.'/i/tick_amber_big.gif" '.
-                            'alt="'.get_string('partiallycorrect', 'quiz').'" class="icon" />';
-        } else {
-            $feedbackimg = '<img src="'.$CFG->pixpath.'/i/tick_amber_small.gif" '.
-                            'alt="'.get_string('partiallycorrect', 'quiz').'" class="icon" />';
+    if (!question_bank::is_qtype_installed($question->qtype)) {
+        $question->questiontext = html_writer::tag('p', get_string('warningmissingtype',
+                'qtype_missingtype')) . $question->questiontext;
         }
-    } else {
-        if ($selected) {
-            $feedbackimg = '<img src="'.$CFG->pixpath.'/i/cross_red_big.gif" '.
-                            'alt="'.get_string('incorrect', 'quiz').'" class="icon" />';
-        } else {
-            $feedbackimg = '<img src="'.$CFG->pixpath.'/i/cross_red_small.gif" '.
-                            'alt="'.get_string('incorrect', 'quiz').'" class="icon" />';
+    question_bank::get_qtype($question->qtype)->get_question_options($question);
+    if (isset($question->_partiallyloaded)) {
+        unset($question->_partiallyloaded);
         }
+    if ($loadtags && !empty($CFG->usetags)) {
+        require_once($CFG->dirroot . '/tag/lib.php');
+        $question->tags = tag_get_tags_array('question', $question->id);
     }
-    return $feedbackimg;
 }
 
-
 /**
- * Returns the class name for question feedback.
- * @param float  $fraction  value representing the correctness of the user's
- *                          response to a question.
- * @return string
+ * Updates the question objects with question type specific
+ * information by calling {@link get_question_options()}
+ *
+ * Can be called either with an array of question objects or with a single
+ * question object.
+ *
+ * @param mixed $questions Either an array of question objects to be updated
+ *         or just a single question object
+ * @param boolean $loadtags load the question tags from the tags table. Optional, default false.
+ * @return bool Indicates success or failure.
  */
-function question_get_feedback_class($fraction) {
-
-    global $CFG;
-
-    if ($fraction >= 1.0) {
-        $class = 'correct';
-    } else if ($fraction > 0.0 && $fraction < 1.0) {
-        $class = 'partiallycorrect';
-    } else {
-        $class = 'incorrect';
+function get_question_options(&$questions, $loadtags = false) {
+    if (is_array($questions)) { // deal with an array of questions
+        foreach ($questions as $i => $notused) {
+            _tidy_question($questions[$i], $loadtags);
     }
-    return $class;
+    } else { // deal with single question
+        _tidy_question($questions, $loadtags);
+    }
+    return true;
 }
 
+/**
+ * Print the icon for the question type
+ *
+ * @param object $question The question object for which the icon is required.
+ *       Only $question->qtype is used.
+ * @return string the HTML for the img tag.
+ */
+function print_question_icon($question) {
+    global $PAGE;
+    return $PAGE->get_renderer('question', 'bank')->qtype_icon($question->qtype);
+}
 
 /**
-* For a given question in an attempt we walk the complete history of states
-* and recalculate the grades as we go along.
-*
-* This is used when a question is changed and old student
-* responses need to be marked with the new version of a question.
-*
-* TODO: Make sure this is not quiz-specific
-*
-* @return boolean            Indicates whether the grade has changed
-* @param object  $question   A question object
-* @param object  $attempt    The attempt, in which the question needs to be regraded.
-* @param object  $cmoptions
-* @param boolean $verbose    Optional. Whether to print progress information or not.
-*/
-function regrade_question_in_attempt($question, $attempt, $cmoptions, $verbose=false) {
-
-    // load all states for this question in this attempt, ordered in sequence
-    if ($states = get_records_select('question_states',
-            "attempt = '{$attempt->uniqueid}' AND question = '{$question->id}'",
-            'seq_number ASC')) {
-        $states = array_values($states);
-
-        // Subtract the grade for the latest state from $attempt->sumgrades to get the
-        // sumgrades for the attempt without this question.
-        $attempt->sumgrades -= $states[count($states)-1]->grade;
-
-        // Initialise the replaystate
-        $state = clone($states[0]);
-        $state->manualcomment = get_field('question_sessions', 'manualcomment', 'attemptid',
-                $attempt->uniqueid, 'questionid', $question->id);
-        restore_question_state($question, $state);
-        $state->sumpenalty = 0.0;
-        $replaystate = clone($state);
-        $replaystate->last_graded = $state;
-
-        $changed = false;
-        for($j = 1; $j < count($states); $j++) {
-            restore_question_state($question, $states[$j]);
-            $action = new stdClass;
-            $action->responses = $states[$j]->responses;
-            $action->timestamp = $states[$j]->timestamp;
-
-            // Change event to submit so that it will be reprocessed
-            if (QUESTION_EVENTCLOSE == $states[$j]->event
-                    or QUESTION_EVENTGRADE == $states[$j]->event
-                    or QUESTION_EVENTCLOSEANDGRADE == $states[$j]->event) {
-                $action->event = QUESTION_EVENTSUBMIT;
-
-            // By default take the event that was saved in the database
-            } else {
-                $action->event = $states[$j]->event;
-            }
-
-            if ($action->event == QUESTION_EVENTMANUALGRADE) {
-                // Ensure that the grade is in range - in the past this was not checked,
-                // but now it is (MDL-14835) - so we need to ensure the data is valid before
-                // proceeding.
-                if ($states[$j]->grade < 0) {
-                    $states[$j]->grade = 0;
-                } else if ($states[$j]->grade > $question->maxgrade) {
-                    $states[$j]->grade = $question->maxgrade;
-                }
-                $error = question_process_comment($question, $replaystate, $attempt,
-                        $replaystate->manualcomment, $states[$j]->grade);
-                if (is_string($error)) {
-                     notify($error);
-                }
-            } else {
-
-                // Reprocess (regrade) responses
-                if (!question_process_responses($question, $replaystate,
-                        $action, $cmoptions, $attempt)) {
-                    $verbose && notify("Couldn't regrade state #{$state->id}!");
-                }
-            }
-
-            // We need rounding here because grades in the DB get truncated
-            // e.g. 0.33333 != 0.3333333, but we want them to be equal here
-            if ((round((float)$replaystate->raw_grade, 5) != round((float)$states[$j]->raw_grade, 5))
-                    or (round((float)$replaystate->penalty, 5) != round((float)$states[$j]->penalty, 5))
-                    or (round((float)$replaystate->grade, 5) != round((float)$states[$j]->grade, 5))) {
-                $changed = true;
-            }
-
-            $replaystate->id = $states[$j]->id;
-            $replaystate->changed = true;
-            $replaystate->update = true; // This will ensure that the existing database entry is updated rather than a new one created
-            save_question_session($question, $replaystate);
-        }
-        if ($changed) {
-            // TODO, call a method in quiz to do this, where 'quiz' comes from
-            // the question_attempts table.
-            update_record('quiz_attempts', $attempt);
-        }
-
-        return $changed;
-    }
-    return false;
-}
-
-/**
-* Processes an array of student responses, grading and saving them as appropriate
-*
-* @param object $question Full question object, passed by reference
-* @param object $state    Full state object, passed by reference
-* @param object $action   object with the fields ->responses which
-*                         is an array holding the student responses,
-*                         ->action which specifies the action, e.g., QUESTION_EVENTGRADE,
-*                         and ->timestamp which is a timestamp from when the responses
-*                         were submitted by the student.
-* @param object $cmoptions
-* @param object $attempt  The attempt is passed by reference so that
-*                         during grading its ->sumgrades field can be updated
-* @return boolean         Indicates success/failure
-*/
-function question_process_responses(&$question, &$state, $action, $cmoptions, &$attempt) {
-    global $QTYPES;
-
-    // if no responses are set initialise to empty response
-    if (!isset($action->responses)) {
-        $action->responses = array('' => '');
-    }
-
-    // make sure these are gone!
-    unset($action->responses['submit'], $action->responses['validate']);
-
-    // Check the question session is still open
-    if (question_state_is_closed($state)) {
-        return true;
-    }
-
-    // If $action->event is not set that implies saving
-    if (! isset($action->event)) {
-        debugging('Ambiguous action in question_process_responses.' , DEBUG_DEVELOPER);
-        $action->event = QUESTION_EVENTSAVE;
-    }
-    // If submitted then compare against last graded
-    // responses, not last given responses in this case
-    if (question_isgradingevent($action->event)) {
-        $state->responses = $state->last_graded->responses;
-    }
-
-    // Check for unchanged responses (exactly unchanged, not equivalent).
-    // We also have to catch questions that the student has not yet attempted
-    $sameresponses = $QTYPES[$question->qtype]->compare_responses($question, $action, $state);
-    if (!empty($state->last_graded) && $state->last_graded->event == QUESTION_EVENTOPEN &&
-            question_isgradingevent($action->event)) {
-        $sameresponses = false;
-    }
-
-    // If the response has not been changed then we do not have to process it again
-    // unless the attempt is closing or validation is requested
-    if ($sameresponses and QUESTION_EVENTCLOSE != $action->event
-            and QUESTION_EVENTVALIDATE != $action->event) {
-        return true;
-    }
-
-    // Roll back grading information to last graded state and set the new
-    // responses
-    $newstate = clone($state->last_graded);
-    $newstate->responses = $action->responses;
-    $newstate->seq_number = $state->seq_number + 1;
-    $newstate->changed = true; // will assure that it gets saved to the database
-    $newstate->last_graded = clone($state->last_graded);
-    $newstate->timestamp = $action->timestamp;
-    $state = $newstate;
-
-    // Set the event to the action we will perform. The question type specific
-    // grading code may override this by setting it to QUESTION_EVENTCLOSE if the
-    // attempt at the question causes the session to close
-    $state->event = $action->event;
-
-    if (!question_isgradingevent($action->event)) {
-        // Grade the response but don't update the overall grade
-        if (!$QTYPES[$question->qtype]->grade_responses($question, $state, $cmoptions)) {
-            return false;
-        }
-
-        // Temporary hack because question types are not given enough control over what is going
-        // on. Used by Opaque questions.
-        // TODO fix this code properly.
-        if (!empty($state->believeevent)) {
-            // If the state was graded we need to ...
-            if (question_state_is_graded($state)) {
-                question_apply_penalty_and_timelimit($question, $state, $attempt, $cmoptions);
-
-                // update the attempt grade
-                $attempt->sumgrades -= (float)$state->last_graded->grade;
-                $attempt->sumgrades += (float)$state->grade;
-
-                // and update the last_graded field.
-                unset($state->last_graded);
-                $state->last_graded = clone($state);
-                unset($state->last_graded->changed);
-            }
-        } else {
-            // Don't allow the processing to change the event type
-            $state->event = $action->event;
-        }
-
-    } else { // grading event
-
-        // Unless the attempt is closing, we want to work out if the current responses
-        // (or equivalent responses) were already given in the last graded attempt.
-        if(QUESTION_EVENTCLOSE != $action->event && QUESTION_EVENTOPEN != $state->last_graded->event &&
-                $QTYPES[$question->qtype]->compare_responses($question, $state, $state->last_graded)) {
-            $state->event = QUESTION_EVENTDUPLICATE;
-        }
-
-        // If we did not find a duplicate or if the attempt is closing, perform grading
-        if ((!$sameresponses and QUESTION_EVENTDUPLICATE != $state->event) or
-                QUESTION_EVENTCLOSE == $action->event) {
-            if (!$QTYPES[$question->qtype]->grade_responses($question, $state, $cmoptions)) {
-                return false;
-            }
-
-            // Calculate overall grade using correct penalty method
-            question_apply_penalty_and_timelimit($question, $state, $attempt, $cmoptions);
-        }
-
-        // If the state was graded we need to ...
-        if (question_state_is_graded($state)) {
-            // update the attempt grade
-            $attempt->sumgrades -= (float)$state->last_graded->grade;
-            $attempt->sumgrades += (float)$state->grade;
-
-            // and update the last_graded field.
-            unset($state->last_graded);
-            $state->last_graded = clone($state);
-            unset($state->last_graded->changed);
-        }
-    }
-    $attempt->timemodified = $action->timestamp;
-
-    return true;
-}
-
-/**
-* Determine if event requires grading
-*/
-function question_isgradingevent($event) {
-    return (QUESTION_EVENTSUBMIT == $event || QUESTION_EVENTCLOSE == $event);
-}
-
-/**
-* Applies the penalty from the previous graded responses to the raw grade
-* for the current responses
-*
-* The grade for the question in the current state is computed by subtracting the
-* penalty accumulated over the previous graded responses at the question from the
-* raw grade. If the timestamp is more than 1 minute beyond the end of the attempt
-* the grade is set to zero. The ->grade field of the state object is modified to
-* reflect the new grade but is never allowed to decrease.
-* @param object $question The question for which the penalty is to be applied.
-* @param object $state    The state for which the grade is to be set from the
-*                         raw grade and the cumulative penalty from the last
-*                         graded state. The ->grade field is updated by applying
-*                         the penalty scheme determined in $cmoptions to the ->raw_grade and
-*                         ->last_graded->penalty fields.
-* @param object $cmoptions  The options set by the course module.
-*                           The ->penaltyscheme field determines whether penalties
-*                           for incorrect earlier responses are subtracted.
-*/
-function question_apply_penalty_and_timelimit(&$question, &$state, $attempt, $cmoptions) {
-    // TODO. Quiz dependancy. The fact that the attempt that is passed in here
-    // is from quiz_attempts, and we use things like $cmoptions->timelimit.
-
-    // deal with penalty
-    if ($cmoptions->penaltyscheme) {
-        $state->grade = $state->raw_grade - $state->sumpenalty;
-        $state->sumpenalty += (float) $state->penalty;
-    } else {
-        $state->grade = $state->raw_grade;
-    }
-
-    // deal with timelimit
-    if ($cmoptions->timelimit) {
-        // We allow for 5% uncertainty in the following test
-        if ($state->timestamp - $attempt->timestart > $cmoptions->timelimit * 63) {
-            $cm = get_coursemodule_from_instance('quiz', $cmoptions->id);
-            if (!has_capability('mod/quiz:ignoretimelimits', get_context_instance(CONTEXT_MODULE, $cm->id),
-                    $attempt->userid, false)) {
-                $state->grade = 0;
-            }
-        }
-    }
-
-    // deal with closing time
-    if ($cmoptions->timeclose and $state->timestamp > ($cmoptions->timeclose + 60) // allowing 1 minute lateness
-             and !$attempt->preview) { // ignore closing time for previews
-        $state->grade = 0;
-    }
-
-    // Ensure that the grade does not go down
-    $state->grade = max($state->grade, $state->last_graded->grade);
-}
-
-/**
-* Print the icon for the question type
-*
-* @param object $question  The question object for which the icon is required
-* @param boolean $return   If true the functions returns the link as a string
-*/
-function print_question_icon($question, $return = false) {
-    global $QTYPES, $CFG;
-
-    if (array_key_exists($question->qtype, $QTYPES)) {
-        $namestr = $QTYPES[$question->qtype]->menu_name();
-    } else {
-        $namestr = 'missingtype';
-    }
-    $html = '<img src="' . $CFG->wwwroot . '/question/type/' .
-            $question->qtype . '/icon.gif" alt="' .
-            $namestr . '" title="' . $namestr . '" />';
-    if ($return) {
-        return $html;
-    } else {
-        echo $html;
-    }
-}
-
-/**
-* Returns a html link to the question image if there is one
-*
-* @return string The html image tag or the empy string if there is no image.
-* @param object $question The question object
-*/
-function get_question_image($question) {
-
-    global $CFG;
-    $img = '';
-
-    if (!$category = get_record('question_categories', 'id', $question->category)){
-        error('invalid category id '.$question->category);
-    }
-    $coursefilesdir = get_filesdir_from_context(get_context_instance_by_id($category->contextid));
-
-    if ($question->image) {
-
-        if (substr(strtolower($question->image), 0, 7) == 'http://') {
-            $img .= $question->image;
-
-        } else {
-            require_once($CFG->libdir .'/filelib.php');
-            $img = get_file_url("$coursefilesdir/{$question->image}");
-        }      
-    }
-    return $img;
-}
-
-function question_print_comment_box($question, $state, $attempt, $url) {
-    global $CFG, $QTYPES;
-
-    $prefix = 'response';
-    $usehtmleditor = can_use_richtext_editor();
-    if (!question_state_is_graded($state) && $QTYPES[$question->qtype]->is_question_manual_graded($question, $attempt->layout)) {
-        $grade = '';
-    } else {
-        $grade = round($state->last_graded->grade, 3);
-    }
-    echo '<form method="post" action="'.$url.'">';
-    include($CFG->dirroot.'/question/comment.html');
-    echo '<input type="hidden" name="attempt" value="'.$attempt->uniqueid.'" />';
-    echo '<input type="hidden" name="question" value="'.$question->id.'" />';
-    echo '<input type="hidden" name="sesskey" value="'.sesskey().'" />';
-    echo '<input type="submit" name="submit" value="'.get_string('save', 'quiz').'" />';
-    echo '</form>';
-
-    if ($usehtmleditor) {
-        use_html_editor();
-    }
-}
-
-/**
- * Process a manual grading action. That is, use $comment and $grade to update
- * $state and $attempt. The attempt and the comment text are stored in the
- * database. $state is only updated in memory, it is up to the call to store
- * that, if appropriate.
- *
- * @param object $question the question
- * @param object $state the state to be updated.
- * @param object $attempt the attempt the state belongs to, to be updated.
- * @param string $comment the new comment from the teacher.
- * @param mixed $grade the grade the teacher assigned, or '' to not change the grade.
- * @return mixed true on success, a string error message if a problem is detected
- *         (for example score out of range).
- */
-function question_process_comment($question, &$state, &$attempt, $comment, $grade) {
-    $grade = trim($grade);
-    if ($grade < 0 || $grade > $question->maxgrade) {
-        $a = new stdClass;
-        $a->grade = $grade;
-        $a->maxgrade = $question->maxgrade;
-        $a->name = $question->name;
-        return get_string('errormanualgradeoutofrange', 'question', $a);
-    }
-
-    // Update the comment and save it in the database
-    $comment = trim($comment);
-    $state->manualcomment = $comment;
-    if (!set_field('question_sessions', 'manualcomment', $comment, 'attemptid', $attempt->uniqueid, 'questionid', $question->id)) {
-        return get_string('errorsavingcomment', 'question', $question);
-    }
-
-    // Update the attempt if the score has changed.
-    if ($grade !== '' && (abs($state->last_graded->grade - $grade) > 0.002 || $state->last_graded->event != QUESTION_EVENTMANUALGRADE)) {
-        $attempt->sumgrades = $attempt->sumgrades - $state->last_graded->grade + $grade;
-        $attempt->timemodified = time();
-        if (!update_record('quiz_attempts', $attempt)) {
-            return get_string('errorupdatingattempt', 'question', $attempt);
-        }
-
-        // We want to update existing state (rather than creating new one) if it
-        // was itself created by a manual grading event.
-        $state->update = $state->event == QUESTION_EVENTMANUALGRADE;
-
-        // Update the other parts of the state object.
-        $state->raw_grade = $grade;
-        $state->grade = $grade;
-        $state->penalty = 0;
-        $state->timestamp = time();
-        $state->seq_number++;
-        $state->event = QUESTION_EVENTMANUALGRADE;
-
-        // Update the last graded state (don't simplify!)
-        unset($state->last_graded);
-        $state->last_graded = clone($state);
-
-        // We need to indicate that the state has changed in order for it to be saved.
-        $state->changed = 1;
-    }
-
-    return true;
-}
-
-/**
-* Construct name prefixes for question form element names
-*
-* Construct the name prefix that should be used for example in the
-* names of form elements created by questions.
-* This is called by {@link get_question_options()}
-* to set $question->name_prefix.
-* This name prefix includes the question id which can be
-* extracted from it with {@link question_get_id_from_name_prefix()}.
-*
-* @return string
-* @param integer $id  The question id
-*/
-function question_make_name_prefix($id) {
-    return 'resp' . $id . '_';
-}
-
-/**
-* Extract question id from the prefix of form element names
-*
-* @return integer      The question id
-* @param string $name  The name that contains a prefix that was
-*                      constructed with {@link question_make_name_prefix()}
-*/
-function question_get_id_from_name_prefix($name) {
-    if (!preg_match('/^resp([0-9]+)_/', $name, $matches))
-        return false;
-    return (integer) $matches[1];
-}
-
-/**
- * Returns the unique id for a new attempt
- *
- * Every module can keep their own attempts table with their own sequential ids but
- * the question code needs to also have a unique id by which to identify all these
- * attempts. Hence a module, when creating a new attempt, calls this function and
- * stores the return value in the 'uniqueid' field of its attempts table.
- */
-function question_new_attempt_uniqueid($modulename='quiz') {
-    global $CFG;
-    $attempt = new stdClass;
-    $attempt->modulename = $modulename;
-    if (!$id = insert_record('question_attempts', $attempt)) {
-        error('Could not create new entry in question_attempts table');
-    }
-    return $id;
-}
-
-/**
- * Creates a stamp that uniquely identifies this version of the question
- *
- * In future we want this to use a hash of the question data to guarantee that
- * identical versions have the same version stamp.
- *
- * @param object $question
- * @return string A unique version stamp
- */
-function question_hash($question) {
-    return make_unique_id_code();
-}
-
+ * Creates a stamp that uniquely identifies this version of the question
+ *
+ * In future we want this to use a hash of the question data to guarantee that
+ * identical versions have the same version stamp.
+ *
+ * @param object $question
+ * @return string A unique version stamp
+ */
+function question_hash($question) {
+    return make_unique_id_code();
+}
 
 /// FUNCTIONS THAT SIMPLY WRAP QUESTIONTYPE METHODS //////////////////////////////////
 /**
- * Get the HTML that needs to be included in the head tag when the
- * questions in $questionlist are printed in the gives states.
- *
- * @param array $questionlist a list of questionids of the questions what will appear on this page.
- * @param array $questions an array of question objects, whose keys are question ids.
- *      Must contain all the questions in $questionlist
- * @param array $states an array of question state objects, whose keys are question ids.
- *      Must contain the state of all the questions in $questionlist
- *
- * @return string some HTML code that can go inside the head tag.
- */
-function get_html_head_contributions(&$questionlist, &$questions, &$states) {
-    global $QTYPES;
-
-    $contributions = array();
-    foreach ($questionlist as $questionid) {
-        $question = $questions[$questionid];
-        $contributions = array_merge($contributions,
-                $QTYPES[$question->qtype]->get_html_head_contributions(
-                $question, $states[$questionid]));
-    }
-    return implode("\n", array_unique($contributions));
-}
-
-/**
- * Like @see{get_html_head_contributions} but for the editing page
- * question/question.php.
+ * Get anything that needs to be included in the head of the question editing page
+ * for a particular question type. This function is called by question/question.php.
  *
  * @param $question A question object. Only $question->qtype is used.
- * @return string some HTML code that can go inside the head tag.
+ * @return string Deprecated. Some HTML code that can go inside the head tag.
  */
-function get_editing_head_contributions($question) {
-    global $QTYPES;
-    $contributions = $QTYPES[$question->qtype]->get_editing_head_contributions();
-    return implode("\n", array_unique($contributions));
+function question_get_editing_head_contributions($question) {
+    question_bank::get_qtype($question->qtype, false)->get_editing_head_contributions();
 }
 
 /**
- * Prints a question
- *
- * Simply calls the question type specific print_question() method.
- * @param object $question The question to be rendered.
- * @param object $state    The state to render the question in.
- * @param integer $number  The number for this question.
- * @param object $cmoptions  The options specified by the course module
- * @param object $options  An object specifying the rendering options.
- */
-function print_question(&$question, &$state, $number, $cmoptions, $options=null) {
-    global $QTYPES;
-    $QTYPES[$question->qtype]->print_question($question, $state, $number, $cmoptions, $options);
-}
-/**
  * Saves question options
  *
  * Simply calls the question type specific save_question_options() method.
  */
 function save_question_options($question) {
-    global $QTYPES;
-
-    $QTYPES[$question->qtype]->save_question_options($question);
-}
-
-/**
-* Gets all teacher stored answers for a given question
-*
-* Simply calls the question type specific get_all_responses() method.
-*/
-// ULPGC ecastro
-function get_question_responses($question, $state) {
-    global $QTYPES;
-    $r = $QTYPES[$question->qtype]->get_all_responses($question, $state);
-    return $r;
-}
-
-
-/**
-* Gets the response given by the user in a particular state
-*
-* Simply calls the question type specific get_actual_response() method.
-*/
-// ULPGC ecastro
-function get_question_actual_response($question, $state) {
-    global $QTYPES;
-
-    $r = $QTYPES[$question->qtype]->get_actual_response($question, $state);
-    return $r;
+    question_bank::get_qtype($question->qtype)->save_question_options($question);
 }
 
-/**
-* TODO: document this
-*/
-// ULPGc ecastro
-function get_question_fraction_grade($question, $state) {
-    global $QTYPES;
-
-    $r = $QTYPES[$question->qtype]->get_fractional_grade($question, $state);
-    return $r;
-}
-
-
 /// CATEGORY FUNCTIONS /////////////////////////////////////////////////////////////////
 
 /**
@@ -1782,6 +871,8 @@ function get_question_fraction_grade($question, $state) {
  * incorrect) to avoid missing any category from original array.
  */
 function sort_categories_by_tree(&$categories, $id = 0, $level = 1) {
+    global $DB;
+
     $children = array();
     $keys = array_keys($categories);
 
@@ -1789,17 +880,23 @@ function sort_categories_by_tree(&$categories, $id = 0, $level = 1) {
         if (!isset($categories[$key]->processed) && $categories[$key]->parent == $id) {
             $children[$key] = $categories[$key];
             $categories[$key]->processed = true;
-            $children = $children + sort_categories_by_tree($categories, $children[$key]->id, $level+1);
+            $children = $children + sort_categories_by_tree(
+                    $categories, $children[$key]->id, $level+1);
         }
     }
-    //If level = 1, we have finished, try to look for non processed categories (bad parent) and sort them too
+    //If level = 1, we have finished, try to look for non processed categories
+    // (bad parent) and sort them too
     if ($level == 1) {
         foreach ($keys as $key) {
-            //If not processed and it's a good candidate to start (because its parent doesn't exist in the course)
-            if (!isset($categories[$key]->processed) && !record_exists('question_categories', 'contextid', $categories[$key]->contextid, 'id', $categories[$key]->parent)) {
+            // If not processed and it's a good candidate to start (because its
+            // parent doesn't exist in the course)
+            if (!isset($categories[$key]->processed) && !$DB->record_exists('question_categories',
+                    array('contextid' => $categories[$key]->contextid,
+                            'id' => $categories[$key]->parent))) {
                 $children[$key] = $categories[$key];
                 $categories[$key]->processed = true;
-                $children = $children + sort_categories_by_tree($categories, $children[$key]->id, $level+1);
+                $children = $children + sort_categories_by_tree(
+                        $categories, $children[$key]->id, $level + 1);
             }
         }
     }
@@ -1825,12 +922,14 @@ function flatten_category_tree(&$categories, $id, $depth = 0, $nochildrenof = -1
     // Indent the name of this category.
     $newcategories = array();
     $newcategories[$id] = $categories[$id];
-    $newcategories[$id]->indentedname = str_repeat('&nbsp;&nbsp;&nbsp;', $depth) . $categories[$id]->name;
+    $newcategories[$id]->indentedname = str_repeat('&nbsp;&nbsp;&nbsp;', $depth) .
+            $categories[$id]->name;
 
     // Recursively indent the children.
     foreach ($categories[$id]->childids as $childid) {
-        if ($childid != $nochildrenof){
-            $newcategories = $newcategories + flatten_category_tree($categories, $childid, $depth + 1, $nochildrenof);
+        if ($childid != $nochildrenof) {
+            $newcategories = $newcategories + flatten_category_tree(
+                    $categories, $childid, $depth + 1, $nochildrenof);
         }
     }
 
@@ -1848,8 +947,9 @@ function flatten_category_tree(&$categories, $id, $depth = 0, $nochildrenof = -1
  */
 function add_indented_names($categories, $nochildrenof = -1) {
 
-    // Add an array to each category to hold the child category ids. This array will be removed
-    // again by flatten_category_tree(). It should not be used outside these two functions.
+    // Add an array to each category to hold the child category ids. This array
+    // will be removed again by flatten_category_tree(). It should not be used
+    // outside these two functions.
     foreach (array_keys($categories) as $id) {
         $categories[$id]->childids = array();
     }
@@ -1859,7 +959,8 @@ function add_indented_names($categories, $nochildrenof = -1) {
     // categories from other courses, but not their parents.
     $toplevelcategoryids = array();
     foreach (array_keys($categories) as $id) {
-        if (!empty($categories[$id]->parent) && array_key_exists($categories[$id]->parent, $categories)) {
+        if (!empty($categories[$id]->parent) &&
+                array_key_exists($categories[$id]->parent, $categories)) {
             $categories[$categories[$id]->parent]->childids[] = $id;
         } else {
             $toplevelcategoryids[] = $id;
@@ -1869,7 +970,8 @@ function add_indented_names($categories, $nochildrenof = -1) {
     // Flatten the tree to and add the indents.
     $newcategories = array();
     foreach ($toplevelcategoryids as $id) {
-        $newcategories = $newcategories + flatten_category_tree($categories, $id, 0, $nochildrenof);
+        $newcategories = $newcategories + flatten_category_tree(
+                $categories, $id, 0, $nochildrenof);
     }
 
     return $newcategories;
@@ -1884,56 +986,80 @@ function add_indented_names($categories, $nochildrenof = -1) {
  * @param integer $courseid the id of the course to get the categories for.
  * @param integer $published if true, include publised categories from other courses.
  * @param integer $only_editable if true, exclude categories this user is not allowed to edit.
- * @param integer $selected optionally, the id of a category to be selected by default in the dropdown.
+ * @param integer $selected optionally, the id of a category to be selected by
+ *      default in the dropdown.
  */
-function question_category_select_menu($contexts, $top = false, $currentcat = 0, $selected = "", $nochildrenof = -1) {
-    $categoriesarray = question_category_options($contexts, $top, $currentcat, false, $nochildrenof);
+function question_category_select_menu($contexts, $top = false, $currentcat = 0,
+        $selected = "", $nochildrenof = -1) {
+    global $OUTPUT;
+    $categoriesarray = question_category_options($contexts, $top, $currentcat,
+            false, $nochildrenof);
     if ($selected) {
-        $nothing = '';
+        $choose = '';
+    } else {
+        $choose = 'choosedots';
+    }
+    $options = array();
+    foreach ($categoriesarray as $group => $opts) {
+        $options[] = array($group => $opts);
+    }
+
+    echo html_writer::select($options, 'category', $selected, $choose);
+}
+
+/**
+ * @param integer $contextid a context id.
+ * @return object the default question category for that context, or false if none.
+ */
+function question_get_default_category($contextid) {
+    global $DB;
+    $category = $DB->get_records('question_categories',
+            array('contextid' => $contextid), 'id', '*', 0, 1);
+    if (!empty($category)) {
+        return reset($category);
     } else {
-        $nothing = 'choose';
+        return false;
     }
-    choose_from_menu_nested($categoriesarray, 'category', $selected, $nothing);
 }
 
 /**
-* Gets the default category in the most specific context.
-* If no categories exist yet then default ones are created in all contexts.
-*
-* @param array $contexts  The context objects for this context and all parent contexts.
-* @return object The default category - the category in the course context
-*/
+ * Gets the default category in the most specific context.
+ * If no categories exist yet then default ones are created in all contexts.
+ *
+ * @param array $contexts  The context objects for this context and all parent contexts.
+ * @return object The default category - the category in the course context
+ */
 function question_make_default_categories($contexts) {
+    global $DB;
     static $preferredlevels = array(
         CONTEXT_COURSE => 4,
         CONTEXT_MODULE => 3,
         CONTEXT_COURSECAT => 2,
         CONTEXT_SYSTEM => 1,
     );
+
     $toreturn = null;
     $preferredness = 0;
     // If it already exists, just return it.
     foreach ($contexts as $key => $context) {
-        if (!$categoryrs = get_recordset_select("question_categories", "contextid = '{$context->id}'", 'sortorder, name', '*', '', 1)) {
-            error('error getting category record');
-        } else {
-            if (!$category = rs_fetch_record($categoryrs)){
+        if (!$exists = $DB->record_exists("question_categories",
+                array('contextid' => $context->id))) {
                 // Otherwise, we need to make one
-                $category = new stdClass;
+            $category = new stdClass();
                 $contextname = print_context_name($context, false, true);
-                $category->name = addslashes(get_string('defaultfor', 'question', $contextname));
-                $category->info = addslashes(get_string('defaultinfofor', 'question', $contextname));
+            $category->name = get_string('defaultfor', 'question', $contextname);
+            $category->info = get_string('defaultinfofor', 'question', $contextname);
                 $category->contextid = $context->id;
                 $category->parent = 0;
-                $category->sortorder = 999; // By default, all categories get this number, and are sorted alphabetically.
+            // By default, all categories get this number, and are sorted alphabetically.
+            $category->sortorder = 999;
                 $category->stamp = make_unique_id_code();
-                if (!$category->id = insert_record('question_categories', $category)) {
-                    error('Error creating a default category for context '.print_context_name($context));
-                }
-            }
+            $category->id = $DB->insert_record('question_categories', $category);
+        } else {
+            $category = question_get_default_category($context->id);
         }
-        if ($preferredlevels[$context->contextlevel] > $preferredness &&
-                has_any_capability(array('moodle/question:usemine', 'moodle/question:useall'), $context)) {
+        if ($preferredlevels[$context->contextlevel] > $preferredness && has_any_capability(
+                array('moodle/question:usemine', 'moodle/question:useall'), $context)) {
             $toreturn = $category;
             $preferredness = $preferredlevels[$context->contextlevel];
         }
@@ -1954,11 +1080,11 @@ function question_make_default_categories($contexts) {
  * @return array of category objects.
  */
 function get_categories_for_contexts($contexts, $sortorder = 'parent, sortorder, name ASC') {
-    global $CFG;
-    return get_records_sql("
-            SELECT c.*, (SELECT count(1) FROM {$CFG->prefix}question q
-                    WHERE c.id = q.category AND q.hidden='0' AND q.parent='0') as questioncount
-            FROM {$CFG->prefix}question_categories c
+    global $DB;
+    return $DB->get_records_sql("
+            SELECT c.*, (SELECT count(1) FROM {question} q
+                        WHERE c.id = q.category AND q.hidden='0' AND q.parent='0') AS questioncount
+              FROM {question_categories} c
             WHERE c.contextid IN ($contexts)
             ORDER BY $sortorder");
 }
@@ -1966,10 +1092,11 @@ function get_categories_for_contexts($contexts, $sortorder = 'parent, sortorder,
 /**
  * Output an array of question categories.
  */
-function question_category_options($contexts, $top = false, $currentcat = 0, $popupform = false, $nochildrenof = -1) {
+function question_category_options($contexts, $top = false, $currentcat = 0,
+        $popupform = false, $nochildrenof = -1) {
     global $CFG;
     $pcontexts = array();
-    foreach($contexts as $context){
+    foreach ($contexts as $context) {
         $pcontexts[] = $context->id;
     }
     $contextslist = join($pcontexts, ', ');
@@ -1978,31 +1105,36 @@ function question_category_options($contexts, $top = false, $currentcat = 0, $po
 
     $categories = question_add_context_in_key($categories);
 
-    if ($top){
+    if ($top) {
         $categories = question_add_tops($categories, $pcontexts);
     }
     $categories = add_indented_names($categories, $nochildrenof);
 
-    //sort cats out into different contexts
+    // sort cats out into different contexts
     $categoriesarray = array();
-    foreach ($pcontexts as $pcontext){
-        $contextstring = print_context_name(get_context_instance_by_id($pcontext), true, true);
+    foreach ($pcontexts as $pcontext) {
+        $contextstring = print_context_name(
+                get_context_instance_by_id($pcontext), true, true);
         foreach ($categories as $category) {
-            if ($category->contextid == $pcontext){
+            if ($category->contextid == $pcontext) {
                 $cid = $category->id;
-                if ($currentcat!= $cid || $currentcat==0) {
-                    $countstring = (!empty($category->questioncount))?" ($category->questioncount)":'';
+                if ($currentcat != $cid || $currentcat == 0) {
+                    $countstring = !empty($category->questioncount) ?
+                            " ($category->questioncount)" : '';
                     $categoriesarray[$contextstring][$cid] = $category->indentedname.$countstring;
                 }
             }
         }
     }
-    if ($popupform){
+    if ($popupform) {
         $popupcats = array();
-        foreach ($categoriesarray as $contextstring => $optgroup){
-            $popupcats[] = '--'.$contextstring;
-            $popupcats = array_merge($popupcats, $optgroup);
-            $popupcats[] = '--';
+        foreach ($categoriesarray as $contextstring => $optgroup) {
+            $group = array();
+            foreach ($optgroup as $key => $value) {
+                $key = str_replace($CFG->wwwroot, '', $key);
+                $group[$key] = $value;
+            }
+            $popupcats[] = array($contextstring => $group);
         }
         return $popupcats;
     } else {
@@ -2010,7 +1142,7 @@ function question_category_options($contexts, $top = false, $currentcat = 0, $po
     }
 }
 
-function question_add_context_in_key($categories){
+function question_add_context_in_key($categories) {
     $newcatarray = array();
     foreach ($categories as $id => $category) {
         $category->parent = "$category->parent,$category->contextid";
@@ -2019,10 +1151,11 @@ function question_add_context_in_key($categories){
     }
     return $newcatarray;
 }
-function question_add_tops($categories, $pcontexts){
+
+function question_add_tops($categories, $pcontexts) {
     $topcats = array();
-    foreach ($pcontexts as $context){
-        $newcat = new object();
+    foreach ($pcontexts as $context) {
+        $newcat = new stdClass();
         $newcat->id = "0,$context";
         $newcat->name = get_string('top');
         $newcat->parent = -1;
@@ -2034,22 +1167,22 @@ function question_add_tops($categories, $pcontexts){
 }
 
 /**
- * Returns a comma separated list of ids of the category and all subcategories
+ * @return array of question category ids of the category and all subcategories.
  */
 function question_categorylist($categoryid) {
-    // returns a comma separated list of ids of the category and all subcategories
-    $categorylist = $categoryid;
-    if ($subcategories = get_records('question_categories', 'parent', $categoryid, 'sortorder ASC', 'id, 1 AS notused')) {
+    global $DB;
+
+    $subcategories = $DB->get_records('question_categories',
+            array('parent' => $categoryid), 'sortorder ASC', 'id, 1');
+
+    $categorylist = array($categoryid);
         foreach ($subcategories as $subcategory) {
-            $categorylist .= ','. question_categorylist($subcategory->id);
-        }
+        $categorylist = array_merge($categorylist, question_categorylist($subcategory->id));
     }
+
     return $categorylist;
 }
 
-
-
-
 //===========================
 // Import/Export Functions
 //===========================
@@ -2058,116 +1191,99 @@ function question_categorylist($categoryid) {
  * Get list of available import or export formats
  * @param string $type 'import' if import list, otherwise export list assumed
  * @return array sorted list of import/export formats available
-**/
-function get_import_export_formats( $type ) {
-
+ */
+function get_import_export_formats($type) {
     global $CFG;
-    $fileformats = get_list_of_plugins("question/format");
 
-    $fileformatname=array();
-    require_once( "{$CFG->dirroot}/question/format.php" );
-    foreach ($fileformats as $key => $fileformat) {
-        $format_file = $CFG->dirroot . "/question/format/$fileformat/format.php";
-        if (file_exists( $format_file ) ) {
-            require_once( $format_file );
-        }
-        else {
+    $fileformats = get_plugin_list('qformat');
+
+    $fileformatname = array();
+    require_once($CFG->dirroot . '/question/format.php');
+    foreach ($fileformats as $fileformat => $fdir) {
+        $formatfile = $fdir . '/format.php';
+        if (is_readable($formatfile)) {
+            include_once($formatfile);
+        } else {
             continue;
         }
-        $classname = "qformat_$fileformat";
-        $format_class = new $classname();
-        if ($type=='import') {
-            $provided = $format_class->provide_import();
-        }
-        else {
-            $provided = $format_class->provide_export();
+
+        $classname = 'qformat_' . $fileformat;
+        $formatclass = new $classname();
+        if ($type == 'import') {
+            $provided = $formatclass->provide_import();
+        } else {
+            $provided = $formatclass->provide_export();
         }
+
         if ($provided) {
-            $formatname = get_string($fileformat, 'quiz');
-            if ($formatname == "[[$fileformat]]") {
-                $formatname = get_string($fileformat, 'qformat_'.$fileformat);
-                if ($formatname == "[[$fileformat]]") {
-                    $formatname = $fileformat;  // Just use the raw folder name
-                }
+            $fileformatnames[$fileformat] = get_string($fileformat, 'qformat_' . $fileformat);
             }
-            $fileformatnames[$fileformat] = $formatname;
         }
-    }
-    natcasesort($fileformatnames);
 
+    textlib_get_instance()->asort($fileformatnames);
     return $fileformatnames;
 }
 
 
 /**
-* Create default export filename
-*
-* @return string   default export filename
-* @param object $course
-* @param object $category
-*/
-function default_export_filename($course,$category) {
-    //Take off some characters in the filename !!
-    $takeoff = array(" ", ":", "/", "\\", "|");
-    $export_word = str_replace($takeoff,"_",moodle_strtolower(get_string("exportfilename","quiz")));
-    //If non-translated, use "export"
-    if (substr($export_word,0,1) == "[") {
-        $export_word= "export";
-    }
-
-    //Calculate the date format string
-    $export_date_format = str_replace(" ","_",get_string("exportnameformat","quiz"));
-    //If non-translated, use "%Y%m%d-%H%M"
-    if (substr($export_date_format,0,1) == "[") {
-        $export_date_format = "%%Y%%m%%d-%%H%%M";
-    }
-
-    //Calculate the shortname
-    $export_shortname = clean_filename($course->shortname);
-    if (empty($export_shortname) or $export_shortname == '_' ) {
-        $export_shortname = $course->id;
-    }
-
-    //Calculate the category name
-    $export_categoryname = clean_filename($category->name);
-
-    //Calculate the final export filename
-    //The export word
-    $export_name = $export_word."-";
-    //The shortname
-    $export_name .= moodle_strtolower($export_shortname)."-";
-    //The category name
-    $export_name .= moodle_strtolower($export_categoryname)."-";
-    //The date format
-    $export_name .= userdate(time(),$export_date_format,99,false);
-    //Extension is supplied by format later.
+ * Create a reasonable default file name for exporting questions from a particular
+ * category.
+ * @param object $course the course the questions are in.
+ * @param object $category the question category.
+ * @return string the filename.
+ */
+function question_default_export_filename($course, $category) {
+    // We build a string that is an appropriate name (questions) from the lang pack,
+    // then the corse shortname, then the question category name, then a timestamp.
+
+    $base = clean_filename(get_string('exportfilename', 'question'));
+
+    $dateformat = str_replace(' ', '_', get_string('exportnameformat', 'question'));
+    $timestamp = clean_filename(userdate(time(), $dateformat, 99, false));
+
+    $shortname = clean_filename($course->shortname);
+    if ($shortname == '' || $shortname == '_' ) {
+        $shortname = $course->id;
+    }
+
+    $categoryname = clean_filename(format_string($category->name));
+
+    return "{$base}-{$shortname}-{$categoryname}-{$timestamp}";
 
     return $export_name;
 }
+
+/**
+ * Converts contextlevels to strings and back to help with reading/writing contexts
+ * to/from import/export files.
+ *
+ * @copyright 1999 onwards Martin Dougiamas  {@link http://moodle.com}
+ * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
 class context_to_string_translator{
     /**
      * @var array used to translate between contextids and strings for this context.
      */
-    var $contexttostringarray = array();
+    protected $contexttostringarray = array();
 
-    function context_to_string_translator($contexts){
+    public function __construct($contexts) {
         $this->generate_context_to_string_array($contexts);
     }
 
-    function context_to_string($contextid){
+    public function context_to_string($contextid) {
         return $this->contexttostringarray[$contextid];
     }
 
-    function string_to_context($contextname){
+    public function string_to_context($contextname) {
         $contextid = array_search($contextname, $this->contexttostringarray);
         return $contextid;
     }
 
-    function generate_context_to_string_array($contexts){
-        if (!$this->contexttostringarray){
+    protected function generate_context_to_string_array($contexts) {
+        if (!$this->contexttostringarray) {
             $catno = 1;
-            foreach ($contexts as $context){
-                switch  ($context->contextlevel){
+            foreach ($contexts as $context) {
+                switch ($context->contextlevel) {
                     case CONTEXT_MODULE :
                         $contextstring = 'module';
                         break;
@@ -2191,17 +1307,14 @@ class context_to_string_translator{
 
 /**
  * Check capability on category
+ *
  * @param mixed $question object or id
  * @param string $cap 'add', 'edit', 'view', 'use', 'move'
  * @param integer $cachecat useful to cache all question records in a category
  * @return boolean this user has the capability $cap for this question $question?
  */
-function question_has_capability_on($question, $cap, $cachecat = -1){
-    global $USER;
-    // nicolasconnault@gmail.com In some cases I get $question === false. Since no such object exists, it can't be deleted, we can safely return true
-    if ($question === false) {
-        return true;
-    }
+function question_has_capability_on($question, $cap, $cachecat = -1) {
+    global $USER, $DB;
 
     // these are capabilities on existing questions capabilties are
     //set per category. Each of these has a mine and all version. Append 'mine' and 'all'
@@ -2209,29 +1322,37 @@ function question_has_capability_on($question, $cap, $cachecat = -1){
     static $questions = array();
     static $categories = array();
     static $cachedcat = array();
-    if ($cachecat != -1 && (array_search($cachecat, $cachedcat)===FALSE)){
-        $questions += get_records('question', 'category', $cachecat);
+    if ($cachecat != -1 && array_search($cachecat, $cachedcat) === false) {
+        $questions += $DB->get_records('question', array('category' => $cachecat));
         $cachedcat[] = $cachecat;
     }
-    if (!is_object($question)){
-        if (!isset($questions[$question])){
-            if (!$questions[$question] = get_record('question', 'id', $question)){
+    if (!is_object($question)) {
+        if (!isset($questions[$question])) {
+            if (!$questions[$question] = $DB->get_record('question',
+                    array('id' => $question), 'id,category,createdby')) {
                 print_error('questiondoesnotexist', 'question');
             }
         }
         $question = $questions[$question];
     }
-    if (!isset($categories[$question->category])){
-        if (!$categories[$question->category] = get_record('question_categories', 'id', $question->category)){
+    if (empty($question->category)) {
+        // This can happen when we have created a fake 'missingtype' question to
+        // take the place of a deleted question.
+        return false;
+    }
+    if (!isset($categories[$question->category])) {
+        if (!$categories[$question->category] = $DB->get_record('question_categories',
+                array('id'=>$question->category))) {
             print_error('invalidcategory', 'quiz');
         }
     }
     $category = $categories[$question->category];
+    $context = get_context_instance_by_id($category->contextid);
 
-    if (array_search($cap, $question_questioncaps)!== FALSE){
-        if (!has_capability('moodle/question:'.$cap.'all', get_context_instance_by_id($category->contextid))){
-            if ($question->createdby == $USER->id){
-                return has_capability('moodle/question:'.$cap.'mine', get_context_instance_by_id($category->contextid));
+    if (array_search($cap, $question_questioncaps)!== false) {
+        if (!has_capability('moodle/question:' . $cap . 'all', $context)) {
+            if ($question->createdby == $USER->id) {
+                return has_capability('moodle/question:' . $cap . 'mine', $context);
             } else {
                 return false;
             }
@@ -2239,7 +1360,7 @@ function question_has_capability_on($question, $cap, $cachecat = -1){
             return true;
         }
     } else {
-        return has_capability('moodle/question:'.$cap, get_context_instance_by_id($category->contextid));
+        return has_capability('moodle/question:' . $cap, $context);
     }
 
 }
@@ -2247,109 +1368,486 @@ function question_has_capability_on($question, $cap, $cachecat = -1){
 /**
  * Require capability on question.
  */
-function question_require_capability_on($question, $cap){
-    if (!question_has_capability_on($question, $cap)){
+function question_require_capability_on($question, $cap) {
+    if (!question_has_capability_on($question, $cap)) {
         print_error('nopermissions', '', '', $cap);
     }
     return true;
 }
 
-function question_file_links_base_url($courseid){
-    global $CFG;
-    $baseurl = preg_quote("$CFG->wwwroot/file.php", '!');
-    $baseurl .= '('.preg_quote('?file=', '!').')?';//may or may not
-                                     //be using slasharguments, accept either
-    $baseurl .= "/$courseid/";//course directory
-    return $baseurl;
-}
-
-/*
- * Find all course / site files linked to in a piece of html.
- * @param string html the html to search
- * @param int course search for files for courseid course or set to siteid for
- *              finding site files.
- * @return array files with keys being files.
+/**
+ * Get the real state - the correct question id and answer - for a random
+ * question.
+ * @param object $state with property answer.
+ * @return mixed return integer real question id or false if there was an
+ * error..
  */
-function question_find_file_links_from_html($html, $courseid){
-    global $CFG;
-    $baseurl = question_file_links_base_url($courseid);
-    $searchfor = '!'.
-                   '(<\s*(a|img)\s[^>]*(href|src)\s*=\s*")'.$baseurl.'([^"]*)"'.
-                   '|'.
-                   '(<\s*(a|img)\s[^>]*(href|src)\s*=\s*\')'.$baseurl.'([^\']*)\''.
-                  '!i';
+function question_get_real_state($state) {
+    global $OUTPUT;
+    $realstate = clone($state);
     $matches = array();
-    $no = preg_match_all($searchfor, $html, $matches);
-    if ($no){
-        $rawurls = array_filter(array_merge($matches[5], $matches[10]));//array_filter removes empty elements
-        //remove any links that point somewhere they shouldn't
-        foreach (array_keys($rawurls) as $rawurlkey){
-            if (!$cleanedurl = question_url_check($rawurls[$rawurlkey])){
-                unset($rawurls[$rawurlkey]);
+    if (!preg_match('|^random([0-9]+)-(.*)|', $state->answer, $matches)) {
+        echo $OUTPUT->notification(get_string('errorrandom', 'quiz_statistics'));
+        return false;
             } else {
-                $rawurls[$rawurlkey] = $cleanedurl;
+        $realstate->question = $matches[1];
+        $realstate->answer = $matches[2];
+        return $realstate;
             }
+}
 
+/**
+ * @param object $context a context
+ * @return string A URL for editing questions in this context.
+ */
+function question_edit_url($context) {
+    global $CFG, $SITE;
+    if (!has_any_capability(question_get_question_capabilities(), $context)) {
+        return false;
         }
-        $urls = array_flip($rawurls);// array_flip removes duplicate files
-                                            // and when we merge arrays will continue to automatically remove duplicates
+    $baseurl = $CFG->wwwroot . '/question/edit.php?';
+    $defaultcategory = question_get_default_category($context->id);
+    if ($defaultcategory) {
+        $baseurl .= 'cat=' . $defaultcategory->id . ',' . $context->id . '&amp;';
+    }
+    switch ($context->contextlevel) {
+        case CONTEXT_SYSTEM:
+            return $baseurl . 'courseid=' . $SITE->id;
+        case CONTEXT_COURSECAT:
+            // This is nasty, becuase we can only edit questions in a course
+            // context at the moment, so for now we just return false.
+            return false;
+        case CONTEXT_COURSE:
+            return $baseurl . 'courseid=' . $context->instanceid;
+        case CONTEXT_MODULE:
+            return $baseurl . 'cmid=' . $context->instanceid;
+    }
+
+}
+
+/**
+ * Adds question bank setting links to the given navigation node if caps are met.
+ *
+ * @param navigation_node $navigationnode The navigation node to add the question branch to
+ * @param object $context
+ * @return navigation_node Returns the question branch that was added
+ */
+function question_extend_settings_navigation(navigation_node $navigationnode, $context) {
+    global $PAGE;
+
+    if ($context->contextlevel == CONTEXT_COURSE) {
+        $params = array('courseid'=>$context->instanceid);
+    } else if ($context->contextlevel == CONTEXT_MODULE) {
+        $params = array('cmid'=>$context->instanceid);
     } else {
-        $urls = array();
+        return;
+    }
+
+    if (($cat = $PAGE->url->param('cat')) && preg_match('~\d+,\d+~', $cat)) {
+        $params['cat'] = $cat;
+    }
+
+    $questionnode = $navigationnode->add(get_string('questionbank', 'question'),
+            new moodle_url('/question/edit.php', $params), navigation_node::TYPE_CONTAINER);
+
+    $contexts = new question_edit_contexts($context);
+    if ($contexts->have_one_edit_tab_cap('questions')) {
+        $questionnode->add(get_string('questions', 'quiz'), new moodle_url(
+                '/question/edit.php', $params), navigation_node::TYPE_SETTING);
     }
-    return $urls;
+    if ($contexts->have_one_edit_tab_cap('categories')) {
+        $questionnode->add(get_string('categories', 'quiz'), new moodle_url(
+                '/question/category.php', $params), navigation_node::TYPE_SETTING);
+    }
+    if ($contexts->have_one_edit_tab_cap('import')) {
+        $questionnode->add(get_string('import', 'quiz'), new moodle_url(
+                '/question/import.php', $params), navigation_node::TYPE_SETTING);
+    }
+    if ($contexts->have_one_edit_tab_cap('export')) {
+        $questionnode->add(get_string('export', 'quiz'), new moodle_url(
+                '/question/export.php', $params), navigation_node::TYPE_SETTING);
+    }
+
+    return $questionnode;
+}
+
+/**
+ * @return array all the capabilities that relate to accessing particular questions.
+ */
+function question_get_question_capabilities() {
+    return array(
+        'moodle/question:add',
+        'moodle/question:editmine',
+        'moodle/question:editall',
+        'moodle/question:viewmine',
+        'moodle/question:viewall',
+        'moodle/question:usemine',
+        'moodle/question:useall',
+        'moodle/question:movemine',
+        'moodle/question:moveall',
+    );
 }
-/*
- * Check that url doesn't point anywhere it shouldn't
+
+/**
+ * @return array all the question bank capabilities.
+ */
+function question_get_all_capabilities() {
+    $caps = question_get_question_capabilities();
+    $caps[] = 'moodle/question:managecategory';
+    $caps[] = 'moodle/question:flag';
+    return $caps;
+}
+
+class question_edit_contexts {
+
+    public static $caps = array(
+        'editq' => array('moodle/question:add',
+            'moodle/question:editmine',
+            'moodle/question:editall',
+            'moodle/question:viewmine',
+            'moodle/question:viewall',
+            'moodle/question:usemine',
+            'moodle/question:useall',
+            'moodle/question:movemine',
+            'moodle/question:moveall'),
+        'questions'=>array('moodle/question:add',
+            'moodle/question:editmine',
+            'moodle/question:editall',
+            'moodle/question:viewmine',
+            'moodle/question:viewall',
+            'moodle/question:movemine',
+            'moodle/question:moveall'),
+        'categories'=>array('moodle/question:managecategory'),
+        'import'=>array('moodle/question:add'),
+        'export'=>array('moodle/question:viewall', 'moodle/question:viewmine'));
+
+    protected $allcontexts;
+
+    /**
+     * @param current context
+     */
+    public function __construct($thiscontext) {
+        $pcontextids = get_parent_contexts($thiscontext);
+        $contexts = array($thiscontext);
+        foreach ($pcontextids as $pcontextid) {
+            $contexts[] = get_context_instance_by_id($pcontextid);
+        }
+        $this->allcontexts = $contexts;
+    }
+    /**
+     * @return array all parent contexts
+     */
+    public function all() {
+        return $this->allcontexts;
+    }
+    /**
+     * @return object lowest context which must be either the module or course context
+     */
+    public function lowest() {
+        return $this->allcontexts[0];
+    }
+    /**
+     * @param string $cap capability
+     * @return array parent contexts having capability, zero based index
+     */
+    public function having_cap($cap) {
+        $contextswithcap = array();
+        foreach ($this->allcontexts as $context) {
+            if (has_capability($cap, $context)) {
+                $contextswithcap[] = $context;
+            }
+        }
+        return $contextswithcap;
+    }
+    /**
+     * @param array $caps capabilities
+     * @return array parent contexts having at least one of $caps, zero based index
+     */
+    public function having_one_cap($caps) {
+        $contextswithacap = array();
+        foreach ($this->allcontexts as $context) {
+            foreach ($caps as $cap) {
+                if (has_capability($cap, $context)) {
+                    $contextswithacap[] = $context;
+                    break; //done with caps loop
+                }
+            }
+        }
+        return $contextswithacap;
+    }
+    /**
+     * @param string $tabname edit tab name
+     * @return array parent contexts having at least one of $caps, zero based index
+     */
+    public function having_one_edit_tab_cap($tabname) {
+        return $this->having_one_cap(self::$caps[$tabname]);
+    }
+    /**
+     * Has at least one parent context got the cap $cap?
  *
- * @param $url string relative url within course files directory
- * @return mixed boolean false if not OK or cleaned URL as string if OK
+     * @param string $cap capability
+     * @return boolean
  */
-function question_url_check($url){
-    global $CFG;
-    if ((substr(strtolower($url), 0, strlen($CFG->moddata)) == strtolower($CFG->moddata)) ||
-            (substr(strtolower($url), 0, 10) == 'backupdata')){
+    public function have_cap($cap) {
+        return (count($this->having_cap($cap)));
+    }
+
+    /**
+     * Has at least one parent context got one of the caps $caps?
+     *
+     * @param array $caps capability
+     * @return boolean
+     */
+    public function have_one_cap($caps) {
+        foreach ($caps as $cap) {
+            if ($this->have_cap($cap)) {
+                return true;
+            }
+        }
         return false;
+    }
+
+    /**
+     * Has at least one parent context got one of the caps for actions on $tabname
+     *
+     * @param string $tabname edit tab name
+     * @return boolean
+     */
+    public function have_one_edit_tab_cap($tabname) {
+        return $this->have_one_cap(self::$caps[$tabname]);
+    }
+
+    /**
+     * Throw error if at least one parent context hasn't got the cap $cap
+     *
+     * @param string $cap capability
+     */
+    public function require_cap($cap) {
+        if (!$this->have_cap($cap)) {
+            print_error('nopermissions', '', '', $cap);
+        }
+    }
+
+    /**
+     * Throw error if at least one parent context hasn't got one of the caps $caps
+     *
+     * @param array $cap capabilities
+     */
+    public function require_one_cap($caps) {
+        if (!$this->have_one_cap($caps)) {
+            $capsstring = join($caps, ', ');
+            print_error('nopermissions', '', '', $capsstring);
+        }
+    }
+
+    /**
+     * Throw error if at least one parent context hasn't got one of the caps $caps
+     *
+     * @param string $tabname edit tab name
+     */
+    public function require_one_edit_tab_cap($tabname) {
+        if (!$this->have_one_edit_tab_cap($tabname)) {
+            print_error('nopermissions', '', '', 'access question edit tab '.$tabname);
+        }
+    }
+}
+
+/**
+ * Rewrite question url, file_rewrite_pluginfile_urls always build url by
+ * $file/$contextid/$component/$filearea/$itemid/$pathname_in_text, so we cannot add
+ * extra questionid and attempted in url by it, so we create quiz_rewrite_question_urls
+ * to build url here
+ *
+ * @param string $text text being processed
+ * @param string $file the php script used to serve files
+ * @param int $contextid
+ * @param string $component component
+ * @param string $filearea filearea
+ * @param array $ids other IDs will be used to check file permission
+ * @param int $itemid
+ * @param array $options
+ * @return string
+ */
+function question_rewrite_question_urls($text, $file, $contextid, $component,
+        $filearea, array $ids, $itemid, array $options=null) {
+    global $CFG;
+
+    $options = (array)$options;
+    if (!isset($options['forcehttps'])) {
+        $options['forcehttps'] = false;
+    }
+
+    if (!$CFG->slasharguments) {
+        $file = $file . '?file=';
+    }
+
+    $baseurl = "$CFG->wwwroot/$file/$contextid/$component/$filearea/";
+
+    if (!empty($ids)) {
+        $baseurl .= (implode('/', $ids) . '/');
+    }
+
+    if ($itemid !== null) {
+        $baseurl .= "$itemid/";
+    }
+
+    if ($options['forcehttps']) {
+        $baseurl = str_replace('http://', 'https://', $baseurl);
+    }
+
+    return str_replace('@@PLUGINFILE@@/', $baseurl, $text);
+}
+
+/**
+ * Called by pluginfile.php to serve files related to the 'question' core
+ * component and for files belonging to qtypes.
+ *
+ * For files that relate to questions in a question_attempt, then we delegate to
+ * a function in the component that owns the attempt (for example in the quiz,
+ * or in core question preview) to get necessary inforation.
+ *
+ * (Note that, at the moment, all question file areas relate to questions in
+ * attempts, so the If at the start of the last paragraph is always true.)
+ *
+ * Does not return, either calls send_file_not_found(); or serves the file.
+ *
+ * @param object $course course settings object
+ * @param object $context context object
+ * @param string $component the name of the component we are serving files for.
+ * @param string $filearea the name of the file area.
+ * @param array $args the remaining bits of the file path.
+ * @param bool $forcedownload whether the user must be forced to download the file.
+ */
+function question_pluginfile($course, $context, $component, $filearea, $args, $forcedownload) {
+    global $DB, $CFG;
+
+    list($context, $course, $cm) = get_context_info_array($context->id);
+    require_login($course, false, $cm);
+
+    if ($filearea === 'export') {
+        require_once($CFG->dirroot . '/question/editlib.php');
+        $contexts = new question_edit_contexts($context);
+        // check export capability
+        $contexts->require_one_edit_tab_cap('export');
+        $category_id = (int)array_shift($args);
+        $format      = array_shift($args);
+        $cattofile   = array_shift($args);
+        $contexttofile = array_shift($args);
+        $filename    = array_shift($args);
+
+        // load parent class for import/export
+        require_once($CFG->dirroot . '/question/format.php');
+        require_once($CFG->dirroot . '/question/editlib.php');
+        require_once($CFG->dirroot . '/question/format/' . $format . '/format.php');
+
+        $classname = 'qformat_' . $format;
+        if (!class_exists($classname)) {
+            send_file_not_found();
+        }
+
+        $qformat = new $classname();
+
+        if (!$category = $DB->get_record('question_categories', array('id' => $category_id))) {
+            send_file_not_found();
+        }
+
+        $qformat->setCategory($category);
+        $qformat->setContexts($contexts->having_one_edit_tab_cap('export'));
+        $qformat->setCourse($course);
+
+        if ($cattofile == 'withcategories') {
+            $qformat->setCattofile(true);
+        } else {
+            $qformat->setCattofile(false);
+        }
+
+        if ($contexttofile == 'withcontexts') {
+            $qformat->setContexttofile(true);
     } else {
-        return clean_param($url, PARAM_PATH);
+            $qformat->setContexttofile(false);
+        }
+
+        if (!$qformat->exportpreprocess()) {
+            send_file_not_found();
+            print_error('exporterror', 'question', $thispageurl->out());
+        }
+
+        // export data to moodle file pool
+        if (!$content = $qformat->exportprocess(true)) {
+            send_file_not_found();
+        }
+
+        send_file($content, $filename, 0, 0, true, true, $qformat->mime_type());
+    }
+
+    $qubaid = (int)array_shift($args);
+    $slot = (int)array_shift($args);
+
+    $module = $DB->get_field('question_usages', 'component',
+            array('id' => $qubaid));
+
+    if ($module === 'core_question_preview') {
+        require_once($CFG->dirroot . '/question/previewlib.php');
+        return question_preview_question_pluginfile($course, $context,
+                $component, $filearea, $qubaid, $slot, $args, $forcedownload);
+
+    } else {
+        $dir = get_component_directory($module);
+        if (!file_exists("$dir/lib.php")) {
+            send_file_not_found();
+        }
+        include_once("$dir/lib.php");
+
+        $filefunction = $module . '_question_pluginfile';
+        if (!function_exists($filefunction)) {
+            send_file_not_found();
+        }
+
+        $filefunction($course, $context, $component, $filearea, $qubaid, $slot,
+                $args, $forcedownload);
+
+        send_file_not_found();
     }
 }
 
-/*
- * Find all course / site files linked to in a piece of html.
- * @param string html the html to search
- * @param int course search for files for courseid course or set to siteid for
- *              finding site files.
- * @return array files with keys being files.
+/**
+ * Create url for question export
+ *
+ * @param int $contextid, current context
+ * @param int $categoryid, categoryid
+ * @param string $format
+ * @param string $withcategories
+ * @param string $ithcontexts
+ * @param moodle_url export file url
  */
-function question_replace_file_links_in_html($html, $fromcourseid, $tocourseid, $url, $destination, &$changed){
+function question_make_export_url($contextid, $categoryid, $format, $withcategories,
+        $withcontexts, $filename) {
     global $CFG;
-    require_once($CFG->libdir .'/filelib.php');
-    $tourl = get_file_url("$tocourseid/$destination");
-    $fromurl = question_file_links_base_url($fromcourseid).preg_quote($url, '!');
-    $searchfor = array('!(<\s*(a|img)\s[^>]*(href|src)\s*=\s*")'.$fromurl.'(")!i',
-                   '!(<\s*(a|img)\s[^>]*(href|src)\s*=\s*\')'.$fromurl.'(\')!i');
-    $newhtml = preg_replace($searchfor, '\\1'.$tourl.'\\5', $html);
-    if ($newhtml != $html){
-        $changed = true;
-    }
-    return $newhtml;
+    $urlbase = "$CFG->httpswwwroot/pluginfile.php";
+    return moodle_url::make_file_url($urlbase,
+            "/$contextid/question/export/{$categoryid}/{$format}/{$withcategories}" .
+            "/{$withcontexts}/{$filename}", true);
 }
 
-function get_filesdir_from_context($context){
-    switch ($context->contextlevel){
-        case CONTEXT_COURSE :
-            $courseid = $context->instanceid;
-            break;
-        case CONTEXT_MODULE :
-            $courseid = get_field('course_modules', 'course', 'id', $context->instanceid);
-            break;
-        case CONTEXT_COURSECAT :
-        case CONTEXT_SYSTEM :
-            $courseid = SITEID;
-            break;
-        default :
-            error('Unsupported contextlevel in category record!');
+/**
+ * Return a list of page types
+ * @param string $pagetype current page type
+ * @param stdClass $parentcontext Block's parent context
+ * @param stdClass $currentcontext Current context of block
+ */
+function question_page_type_list($pagetype, $parentcontext, $currentcontext) {
+    global $CFG;
+    $types = array(
+        'question-*'=>get_string('page-question-x', 'question'),
+        'question-edit'=>get_string('page-question-edit', 'question'),
+        'question-category'=>get_string('page-question-category', 'question'),
+        'question-export'=>get_string('page-question-export', 'question'),
+        'question-import'=>get_string('page-question-import', 'question')
+    );
+    if ($currentcontext->contextlevel == CONTEXT_COURSE) {
+        require_once($CFG->dirroot . '/course/lib.php');
+        return array_merge(course_page_type_list($pagetype, $parentcontext, $currentcontext), $types);
+    } else {
+        return $types;
     }
-    return $courseid;
 }
-?>
