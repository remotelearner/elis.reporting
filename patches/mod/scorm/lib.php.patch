diff --git a/mod/scorm/lib.php b/mod/scorm/lib.php
old mode 100755
new mode 100644
index 18059a2..77fb34c
--- a/mod/scorm/lib.php
+++ b/mod/scorm/lib.php
@@ -1,233 +1,307 @@
-<?php  // $Id$
+<?php
+
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
 
 /**
-* Given an object containing all the necessary data,
-* (defined by the form in mod.html) this function
-* will create a new instance and return the id number
-* of the new instance.
-*
-* @param mixed $scorm Form data
-* @return int
-*/
-//require_once('locallib.php');
-function scorm_add_instance($scorm) {
-    global $CFG;
+ * @package   mod-scorm
+ * @copyright 1999 onwards Martin Dougiamas  {@link http://moodle.com}
+ * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
 
-    require_once($CFG->dirroot.'/mod/scorm/locallib.php');
+/** SCORM_TYPE_LOCAL = local */
+define('SCORM_TYPE_LOCAL', 'local');
+/** SCORM_TYPE_LOCALSYNC = localsync */
+define('SCORM_TYPE_LOCALSYNC', 'localsync');
+/** SCORM_TYPE_EXTERNAL = external */
+define('SCORM_TYPE_EXTERNAL', 'external');
+/** SCORM_TYPE_IMSREPOSITORY = imsrepository */
+define('SCORM_TYPE_IMSREPOSITORY', 'imsrepository');
 
-    if (($packagedata = scorm_check_package($scorm)) != null) {
-        $scorm->pkgtype = $packagedata->pkgtype;
-        $scorm->datadir = $packagedata->datadir;
-        $scorm->launch = $packagedata->launch;
-        $scorm->parse = 1;
+define('SCORM_TOC_SIDE', 0);
+define('SCORM_TOC_HIDDEN', 1);
+define('SCORM_TOC_POPUP', 2);
+define('SCORM_TOC_DISABLED', 3);
 
-        $scorm->timemodified = time();
-        if (!scorm_external_link($scorm->reference)) {
-            $scorm->md5hash = md5_file($CFG->dataroot.'/'.$scorm->course.'/'.$scorm->reference);
-        } else {
-            $scorm->dir = $CFG->dataroot.'/'.$scorm->course.'/moddata/scorm';
-            $scorm->md5hash = md5_file($scorm->dir.$scorm->datadir.'/'.basename($scorm->reference));
+/**
+ * Given an object containing all the necessary data,
+ * (defined by the form in mod_form.php) this function
+ * will create a new instance and return the id number
+ * of the new instance.
+ *
+ * @global stdClass
+ * @global object
+ * @uses CONTEXT_MODULE
+ * @uses SCORM_TYPE_LOCAL
+ * @uses SCORM_TYPE_LOCALSYNC
+ * @uses SCORM_TYPE_EXTERNAL
+ * @uses SCORM_TYPE_IMSREPOSITORY
+ * @param object $scorm Form data
+ * @param object $mform
+ * @return int new instance id
+ */
+function scorm_add_instance($scorm, $mform=null) {
+    global $CFG, $DB;
+
+    require_once($CFG->dirroot.'/mod/scorm/locallib.php');
+
+    if (empty($scorm->timeopen)) {
+        $scorm->timeopen = 0;
+    }
+    if (empty($scorm->timeclose)) {
+        $scorm->timeclose = 0;
         }
+    $cmid       = $scorm->coursemodule;
+    $cmidnumber = $scorm->cmidnumber;
+    $courseid   = $scorm->course;
 
-        $scorm = scorm_option2text($scorm);
-        $scorm->width = str_replace('%','',$scorm->width);
-        $scorm->height = str_replace('%','',$scorm->height);
+    $context = get_context_instance(CONTEXT_MODULE, $cmid);
 
-        //sanitize submitted values a bit
-        $scorm->width = clean_param($scorm->width, PARAM_INT);
-        $scorm->height = clean_param($scorm->height, PARAM_INT);
+    $scorm = scorm_option2text($scorm);
+    $scorm->width  = (int)str_replace('%', '', $scorm->width);
+    $scorm->height = (int)str_replace('%', '', $scorm->height);
 
         if (!isset($scorm->whatgrade)) {
             $scorm->whatgrade = 0;
         }
 
-        $id = insert_record('scorm', $scorm);
+    $id = $DB->insert_record('scorm', $scorm);
+
+/// update course module record - from now on this instance properly exists and all function may be used
+    $DB->set_field('course_modules', 'instance', $id, array('id'=>$cmid));
 
-        if (scorm_external_link($scorm->reference) || ((basename($scorm->reference) != 'imsmanifest.xml') && ($scorm->reference[0] != '#'))) {
-            // Rename temp scorm dir to scorm id
-            $scorm->dir = $CFG->dataroot.'/'.$scorm->course.'/moddata/scorm';
-            if (file_exists($scorm->dir.'/'.$id)) {
-                //delete directory as it shouldn't exist! - most likely there from an old moodle install with old files in dataroot
-                scorm_delete_files($scorm->dir.'/'.$id);
+/// reload scorm instance
+    $record = $DB->get_record('scorm', array('id'=>$id));
+
+/// store the package and verify
+    if ($record->scormtype === SCORM_TYPE_LOCAL) {
+        if ($mform) {
+            $filename = $mform->get_new_filename('packagefile');
+            if ($filename !== false) {
+                $fs = get_file_storage();
+                $fs->delete_area_files($context->id, 'mod_scorm', 'package');
+                $mform->save_stored_file('packagefile', $context->id, 'mod_scorm', 'package', 0, '/', $filename);
+                $record->reference = $filename;
             }
-            rename($scorm->dir.$scorm->datadir,$scorm->dir.'/'.$id);
         }
 
-        // Parse scorm manifest
-        if ($scorm->parse == 1) {
-            $scorm->id = $id;
-            $scorm->launch = scorm_parse($scorm);
-            set_field('scorm','launch',$scorm->launch,'id',$scorm->id);
-        }
+    } else if ($record->scormtype === SCORM_TYPE_LOCALSYNC) {
+        $record->reference = $scorm->packageurl;
 
-        scorm_grade_item_update(stripslashes_recursive($scorm));
+    } else if ($record->scormtype === SCORM_TYPE_EXTERNAL) {
+        $record->reference = $scorm->packageurl;
+
+    } else if ($record->scormtype === SCORM_TYPE_IMSREPOSITORY) {
+        $record->reference = $scorm->packageurl;
 
-        return $id;
     } else {
-        print_error('badpackage','scorm');
+        return false;
     }
+
+    // save reference
+    $DB->update_record('scorm', $record);
+
+
+/// extra fields required in grade related functions
+    $record->course     = $courseid;
+    $record->cmidnumber = $cmidnumber;
+    $record->cmid       = $cmid;
+
+    scorm_parse($record, true);
+
+    scorm_grade_item_update($record);
+
+    return $record->id;
 }
 
 /**
-* Given an object containing all the necessary data,
-* (defined by the form in mod.html) this function
-* will update an existing instance with new data.
-*
-* @param mixed $scorm Form data
-* @return int
-*/
-function scorm_update_instance($scorm) {
-    global $CFG;
+ * Given an object containing all the necessary data,
+ * (defined by the form in mod_form.php) this function
+ * will update an existing instance with new data.
+ *
+ * @global stdClass
+ * @global object
+ * @uses CONTEXT_MODULE
+ * @uses SCORM_TYPE_LOCAL
+ * @uses SCORM_TYPE_LOCALSYNC
+ * @uses SCORM_TYPE_EXTERNAL
+ * @uses SCORM_TYPE_IMSREPOSITORY
+ * @param object $scorm Form data
+ * @param object $mform
+ * @return bool
+ */
+function scorm_update_instance($scorm, $mform=null) {
+    global $CFG, $DB;
 
     require_once($CFG->dirroot.'/mod/scorm/locallib.php');
 
-    $scorm->parse = 0;
-    if (($packagedata = scorm_check_package($scorm)) != null) {
-        $scorm->pkgtype = $packagedata->pkgtype;
-        if ($packagedata->launch == 0) {
-            $scorm->launch = $packagedata->launch;
-            $scorm->datadir = $packagedata->datadir;
-            $scorm->parse = 1;
-            if (!scorm_external_link($scorm->reference) && $scorm->reference[0] != '#') { //dont set md5hash if this is from a repo.
-                $scorm->md5hash = md5_file($CFG->dataroot.'/'.$scorm->course.'/'.$scorm->reference);
-            } elseif($scorm->reference[0] != '#') { //dont set md5hash if this is from a repo.
-                $scorm->dir = $CFG->dataroot.'/'.$scorm->course.'/moddata/scorm';
-                $scorm->md5hash = md5_file($scorm->dir.$scorm->datadir.'/'.basename($scorm->reference));
-            }
+    if (empty($scorm->timeopen)) {
+        $scorm->timeopen = 0;
         }
+    if (empty($scorm->timeclose)) {
+        $scorm->timeclose = 0;
     }
 
-    $scorm->timemodified = time();
-    $scorm->id = $scorm->instance;
+    $cmid       = $scorm->coursemodule;
+    $cmidnumber = $scorm->cmidnumber;
+    $courseid   = $scorm->course;
 
-    if (empty($scorm->options)) {
-        $scorm = scorm_option2text($scorm);
-    }
-    $scorm->width = str_replace('%','',$scorm->width);
-    $scorm->height = str_replace('%','',$scorm->height);
+    $scorm->id = $scorm->instance;
 
-    if (!isset($scorm->whatgrade)) {
-        $scorm->whatgrade = 0;
-    }
+    $context = get_context_instance(CONTEXT_MODULE, $cmid);
 
-    // Check if scorm manifest needs to be reparsed
-    if ($scorm->parse == 1) {
-        $scorm->dir = $CFG->dataroot.'/'.$scorm->course.'/moddata/scorm';
-        if (is_dir($scorm->dir.'/'.$scorm->id)) {
-            scorm_delete_files($scorm->dir.'/'.$scorm->id);
+    if ($scorm->scormtype === SCORM_TYPE_LOCAL) {
+        if ($mform) {
+            $filename = $mform->get_new_filename('packagefile');
+            if ($filename !== false) {
+                $scorm->reference = $filename;
+                $fs = get_file_storage();
+                $fs->delete_area_files($context->id, 'mod_scorm', 'package');
+                $mform->save_stored_file('packagefile', $context->id, 'mod_scorm', 'package', 0, '/', $filename);
         }
-        if (isset($scorm->datadir) && ($scorm->datadir != $scorm->id) && 
-           (scorm_external_link($scorm->reference) || ((basename($scorm->reference) != 'imsmanifest.xml') && ($scorm->reference[0] != '#')))) {
-            rename($scorm->dir.$scorm->datadir,$scorm->dir.'/'.$scorm->id);
         }
 
-        $scorm->launch = scorm_parse($scorm);
+    } else if ($scorm->scormtype === SCORM_TYPE_LOCALSYNC) {
+        $scorm->reference = $scorm->packageurl;
+
+    } else if ($scorm->scormtype === SCORM_TYPE_EXTERNAL) {
+        $scorm->reference = $scorm->packageurl;
+
+    } else if ($scorm->scormtype === SCORM_TYPE_IMSREPOSITORY) {
+        $scorm->reference = $scorm->packageurl;
+
     } else {
-        $oldscorm = get_record('scorm','id',$scorm->id);
-        $scorm->reference = $oldscorm->reference; // This fix a problem with Firefox when the teacher choose Cancel on overwrite question
+        return false;
     }
     
-    if ($result = update_record('scorm', $scorm)) {
-        scorm_grade_item_update(stripslashes_recursive($scorm));
-        //scorm_grade_item_update($scorm);  // John Macklins fix - dont think this is needed
+    $scorm = scorm_option2text($scorm);
+    $scorm->width        = (int)str_replace('%','',$scorm->width);
+    $scorm->height       = (int)str_replace('%','',$scorm->height);
+    $scorm->timemodified = time();
+
+    if (!isset($scorm->whatgrade)) {
+        $scorm->whatgrade = 0;
     }
 
-    return $result;
+    $DB->update_record('scorm', $scorm);
+
+    $scorm = $DB->get_record('scorm', array('id'=>$scorm->id));
+
+/// extra fields required in grade related functions
+    $scorm->course   = $courseid;
+    $scorm->idnumber = $cmidnumber;
+    $scorm->cmid     = $cmid;
+
+    scorm_parse($scorm, (bool)$scorm->updatefreq);
+
+    scorm_grade_item_update($scorm);
+    scorm_update_grades($scorm);
+
+    return true;
 }
 
 /**
-* Given an ID of an instance of this module,
-* this function will permanently delete the instance
-* and any data that depends on it.
-*
-* @param int $id Scorm instance id
-* @return boolean
-*/
+ * Given an ID of an instance of this module,
+ * this function will permanently delete the instance
+ * and any data that depends on it.
+ *
+ * @global stdClass
+ * @global object
+ * @param int $id Scorm instance id
+ * @return boolean
+ */
 function scorm_delete_instance($id) {
+    global $CFG, $DB;
 
-    global $CFG;
-
-    if (! $scorm = get_record('scorm', 'id', $id)) {
+    if (! $scorm = $DB->get_record('scorm', array('id'=>$id))) {
         return false;
     }
 
     $result = true;
 
-    $scorm->dir = $CFG->dataroot.'/'.$scorm->course.'/moddata/scorm';
-    if (is_dir($scorm->dir.'/'.$scorm->id)) {
-        // Delete any dependent files
-        require_once($CFG->dirroot.'/mod/scorm/locallib.php');
-        scorm_delete_files($scorm->dir.'/'.$scorm->id);
-    }
-
     // Delete any dependent records
-    if (! delete_records('scorm_scoes_track', 'scormid', $scorm->id)) {
+    if (! $DB->delete_records('scorm_scoes_track', array('scormid'=>$scorm->id))) {
         $result = false;
     }
-    if ($scoes = get_records('scorm_scoes','scorm',$scorm->id)) {
+    if ($scoes = $DB->get_records('scorm_scoes', array('scorm'=>$scorm->id))) {
         foreach ($scoes as $sco) {
-            if (! delete_records('scorm_scoes_data', 'scoid', $sco->id)) {
+            if (! $DB->delete_records('scorm_scoes_data', array('scoid'=>$sco->id))) {
                 $result = false;
             }
         } 
-        delete_records('scorm_scoes', 'scorm', $scorm->id);
+        $DB->delete_records('scorm_scoes', array('scorm'=>$scorm->id));
     } else {
         $result = false;
     }
-    if (! delete_records('scorm', 'id', $scorm->id)) {
+    if (! $DB->delete_records('scorm', array('id'=>$scorm->id))) {
         $result = false;
     }
 
-    /*if (! delete_records('scorm_sequencing_controlmode', 'scormid', $scorm->id)) {
+    /*if (! $DB->delete_records('scorm_sequencing_controlmode', array('scormid'=>$scorm->id))) {
         $result = false;
     }
-    if (! delete_records('scorm_sequencing_rolluprules', 'scormid', $scorm->id)) {
+    if (! $DB->delete_records('scorm_sequencing_rolluprules', array('scormid'=>$scorm->id))) {
         $result = false;
     }
-    if (! delete_records('scorm_sequencing_rolluprule', 'scormid', $scorm->id)) {
+    if (! $DB->delete_records('scorm_sequencing_rolluprule', array('scormid'=>$scorm->id))) {
         $result = false;
     }
-    if (! delete_records('scorm_sequencing_rollupruleconditions', 'scormid', $scorm->id)) {
+    if (! $DB->delete_records('scorm_sequencing_rollupruleconditions', array('scormid'=>$scorm->id))) {
         $result = false;
     }
-    if (! delete_records('scorm_sequencing_rolluprulecondition', 'scormid', $scorm->id)) {
+    if (! $DB->delete_records('scorm_sequencing_rolluprulecondition', array('scormid'=>$scorm->id))) {
         $result = false;
     }
-    if (! delete_records('scorm_sequencing_rulecondition', 'scormid', $scorm->id)) {
+    if (! $DB->delete_records('scorm_sequencing_rulecondition', array('scormid'=>$scorm->id))) {
         $result = false;
     }
-    if (! delete_records('scorm_sequencing_ruleconditions', 'scormid', $scorm->id)) {
+    if (! $DB->delete_records('scorm_sequencing_ruleconditions', array('scormid'=>$scorm->id))) {
         $result = false;
     }*/     
 
-    scorm_grade_item_delete(stripslashes_recursive($scorm));
+    scorm_grade_item_delete($scorm);
   
     return $result;
 }
 
 /**
-* Return a small object with summary information about what a
-* user has done with a given particular instance of this module
-* Used for user activity reports.
-*
-* @param int $course Course id
-* @param int $user User id
-* @param int $mod  
-* @param int $scorm The scorm id
-* @return mixed
-*/
+ * Return a small object with summary information about what a
+ * user has done with a given particular instance of this module
+ * Used for user activity reports.
+ *
+ * @global stdClass
+ * @param int $course Course id
+ * @param int $user User id
+ * @param int $mod
+ * @param int $scorm The scorm id
+ * @return mixed
+ */
 function scorm_user_outline($course, $user, $mod, $scorm) { 
     global $CFG;
     require_once($CFG->dirroot.'/mod/scorm/locallib.php');
+
     require_once("$CFG->libdir/gradelib.php");
     $grades = grade_get_grades($course->id, 'mod', 'scorm', $scorm->id, $user->id);
     if (!empty($grades->items[0]->grades)) {
         $grade = reset($grades->items[0]->grades);
-        $result = new object();
+        $result = new stdClass();
         $result->info = get_string('grade') . ': '. $grade->str_long_grade;
 
         //datesubmitted == time created. dategraded == time modified or time overridden
         //if grade was last modified by the user themselves use date graded. Otherwise use date submitted
+        //TODO: move this copied & pasted code somewhere in the grades API. See MDL-26704
         if ($grade->usermodified == $user->id || empty($grade->datesubmitted)) {
             $result->time = $grade->dategraded;
         } else {
@@ -240,22 +314,22 @@ function scorm_user_outline($course, $user, $mod, $scorm) {
 }
 
 /**
-* Print a detailed representation of what a user has done with
-* a given particular instance of this module, for user activity reports.
-*
-* @param int $course Course id
-* @param int $user User id
-* @param int $mod  
-* @param int $scorm The scorm id
-* @return boolean
-*/
+ * Print a detailed representation of what a user has done with
+ * a given particular instance of this module, for user activity reports.
+ *
+ * @global stdClass
+ * @global object
+ * @param object $course
+ * @param object $user
+ * @param object $mod
+ * @param object $scorm
+ * @return boolean
+ */
 function scorm_user_complete($course, $user, $mod, $scorm) {
-    global $CFG;
+    global $CFG, $DB, $OUTPUT;
     require_once("$CFG->libdir/gradelib.php");
-    require_once($CFG->dirroot.'/mod/scorm/locallib.php');
 
     $liststyle = 'structlist';
-    $scormpixdir = $CFG->modpixpath.'/scorm/pix';
     $now = time();
     $firstmodify = $now;
     $lastmodify = 0;
@@ -263,6 +337,7 @@ function scorm_user_complete($course, $user, $mod, $scorm) {
     $report = '';
 
     // First Access and Last Access dates for SCOs
+    require_once($CFG->dirroot.'/mod/scorm/locallib.php');
     $timetracks = scorm_get_sco_runtime($scorm->id, false, $user->id);
     $firstmodify = $timetracks->start;
     $lastmodify = $timetracks->finish;
@@ -270,28 +345,32 @@ function scorm_user_complete($course, $user, $mod, $scorm) {
     $grades = grade_get_grades($course->id, 'mod', 'scorm', $scorm->id, $user->id);
     if (!empty($grades->items[0]->grades)) {
         $grade = reset($grades->items[0]->grades);
-        echo '<p>'.get_string('grade').': '.$grade->str_long_grade.'</p>';
+        echo $OUTPUT->container(get_string('grade').': '.$grade->str_long_grade);
         if ($grade->str_feedback) {
-            echo '<p>'.get_string('feedback').': '.$grade->str_feedback.'</p>';
+            echo $OUTPUT->container(get_string('feedback').': '.$grade->str_feedback);
         }
     }
 
-    if ($orgs = get_records_select('scorm_scoes',"scorm='$scorm->id' AND organization='' AND launch=''",'id','id,identifier,title')) {
+    if ($orgs = $DB->get_records_select('scorm_scoes', 'scorm = ? AND '.
+                                         $DB->sql_isempty('scorm_scoes', 'launch', false, true).' AND '.
+                                         $DB->sql_isempty('scorm_scoes', 'organization', false, false),
+                                         array($scorm->id),'id','id,identifier,title')) {
         if (count($orgs) <= 1) {
             unset($orgs);
             $orgs[]->identifier = '';
         }
         $report .= '<div class="mod-scorm">'."\n";
         foreach ($orgs as $org) {
-            $organizationsql = '';
+            $conditions = array();
             $currentorg = '';
             if (!empty($org->identifier)) {
                 $report .= '<div class="orgtitle">'.$org->title.'</div>';
                 $currentorg = $org->identifier;
-                $organizationsql = "AND organization='$currentorg'";
+                $conditions['organization'] = $currentorg;
             }
             $report .= "<ul id='0' class='$liststyle'>";
-            if ($scoes = get_records_select('scorm_scoes',"scorm='$scorm->id' $organizationsql order by id ASC")){
+                $conditions['scorm'] = $scorm->id;
+            if ($scoes = $DB->get_records('scorm_scoes', $conditions, "id ASC")){
                 // drop keys so that we can access array sequentially
                 $scoes = array_values($scoes); 
                 $level=0;
@@ -328,7 +407,7 @@ function scorm_user_complete($course, $user, $mod, $scorm) {
                     if (($nextsco !== false) && ($sco->parent != $nextsco->parent) && (($level==0) || (($level>0) && ($nextsco->parent == $sco->identifier)))) {
                         $sublist++;
                     } else {
-                        $report .= '<img src="'.$scormpixdir.'/spacer.gif" alt="" />';
+                        $report .= '<img src="'.$OUTPUT->pix_url('spacer', 'scorm').'" alt="" />';
                     }
 
                     if ($sco->launch) {
@@ -339,12 +418,12 @@ function scorm_user_complete($course, $user, $mod, $scorm) {
                                 $usertrack->status = 'notattempted';
                             }
                             $strstatus = get_string($usertrack->status,'scorm');
-                            $report .= "<img src='".$scormpixdir.'/'.$usertrack->status.".gif' alt='$strstatus' title='$strstatus' />";
+                            $report .= "<img src='".$OUTPUT->pix_url($usertrack->status, 'scorm')."' alt='$strstatus' title='$strstatus' />";
                         } else {
                             if ($sco->scormtype == 'sco') {
-                                $report .= '<img src="'.$scormpixdir.'/'.'notattempted.gif" alt="'.get_string('notattempted','scorm').'" title="'.get_string('notattempted','scorm').'" />';
+                                $report .= '<img src="'.$OUTPUT->pix_url('notattempted', 'scorm').'" alt="'.get_string('notattempted','scorm').'" title="'.get_string('notattempted','scorm').'" />';
                             } else {
-                                $report .= '<img src="'.$scormpixdir.'/'.'asset.gif" alt="'.get_string('asset','scorm').'" title="'.get_string('asset','scorm').'" />';
+                                $report .= '<img src="'.$OUTPUT->pix_url('asset', 'scorm').'" alt="'.get_string('asset','scorm').'" title="'.get_string('asset','scorm').'" />';
                             }
                         }
                         $report .= "&nbsp;$sco->title $score$totaltime</li>\n";
@@ -389,20 +468,22 @@ function scorm_user_complete($course, $user, $mod, $scorm) {
 }
 
 /**
-* Function to be run periodically according to the moodle cron
-* This function searches for things that need to be done, such
-* as sending out mail, toggling flags etc ...
-*
-* @return boolean
-*/
+ * Function to be run periodically according to the moodle cron
+ * This function searches for things that need to be done, such
+ * as sending out mail, toggling flags etc ...
+ *
+ * @global stdClass
+ * @global object
+ * @return boolean
+ */
 function scorm_cron () {
-
-    global $CFG;
+    global $CFG, $DB;
 
     require_once($CFG->dirroot.'/mod/scorm/locallib.php');
 
     $sitetimezone = $CFG->timezone;
-    /// Now see if there are any digest mails waiting to be sent, and if we should send them
+    /// Now see if there are any scorm updates to be done
+
     if (!isset($CFG->scorm_updatetimelast)) {    // To catch the first time
         set_config('scorm_updatetimelast', 0);
     }
@@ -416,12 +497,9 @@ function scorm_cron () {
 
         mtrace('Updating scorm packages which require daily update');//We are updating
 
-        $scormsupdate = get_records('scorm','updatefreq',UPDATE_EVERYDAY);
-        if (!empty($scormsupdate)) {
+        $scormsupdate = $DB->get_records('scorm', array('updatefreq'=>UPDATE_EVERYDAY));
             foreach($scormsupdate as $scormupdate) {
-                $scormupdate->instance = $scormupdate->id;
-                $id = scorm_update_instance($scormupdate);
-            }
+            scorm_parse($scormupdate, true);
         }
     }
 
@@ -431,19 +509,21 @@ function scorm_cron () {
 /**
  * Return grade for given user or all users.
  *
+ * @global stdClass
+ * @global object
  * @param int $scormid id of scorm
  * @param int $userid optional user id, 0 means all users
  * @return array array of grades, false if none
  */
 function scorm_get_user_grades($scorm, $userid=0) {
-    global $CFG;
+    global $CFG, $DB;
     require_once($CFG->dirroot.'/mod/scorm/locallib.php');
 
     $grades = array();
     if (empty($userid)) {
-        if ($scousers = get_records_select('scorm_scoes_track', "scormid='$scorm->id' GROUP BY userid", "", "userid,null")) {
+        if ($scousers = $DB->get_records_select('scorm_scoes_track', "scormid=? GROUP BY userid", array($scorm->id), "", "userid,null")) {
             foreach ($scousers as $scouser) {
-                $grades[$scouser->userid] = new object();
+                $grades[$scouser->userid] = new stdClass();
                 $grades[$scouser->userid]->id         = $scouser->userid;
                 $grades[$scouser->userid]->userid     = $scouser->userid;
                 $grades[$scouser->userid]->rawgrade = scorm_grade_user($scorm, $scouser->userid);
@@ -453,10 +533,10 @@ function scorm_get_user_grades($scorm, $userid=0) {
         }
 
     } else {
-        if (!get_records_select('scorm_scoes_track', "scormid='$scorm->id' AND userid='$userid' GROUP BY userid", "", "userid,null")) {
+        if (!$DB->get_records_select('scorm_scoes_track', "scormid=? AND userid=? GROUP BY userid", array($scorm->id, $userid), "", "userid,null")) {
             return false; //no attempt yet
         }
-        $grades[$userid] = new object();
+        $grades[$userid] = new stdClass();
         $grades[$userid]->id         = $userid;
         $grades[$userid]->userid     = $userid;
         $grades[$userid]->rawgrade = scorm_grade_user($scorm, $userid);
@@ -468,21 +548,21 @@ function scorm_get_user_grades($scorm, $userid=0) {
 /**
  * Update grades in central gradebook
  *
- * @param object $scorm null means all scormbases
+ * @global stdClass
+ * @global object
+ * @param object $scorm
  * @param int $userid specific user only, 0 mean all
+ * @param bool $nullifnone
  */
-function scorm_update_grades($scorm=null, $userid=0, $nullifnone=true) {
-    global $CFG;
-    if (!function_exists('grade_update')) { //workaround for buggy PHP versions
+function scorm_update_grades($scorm, $userid=0, $nullifnone=true) {
+    global $CFG, $DB;
         require_once($CFG->libdir.'/gradelib.php');
-    }
 
-    if ($scorm != null) {
         if ($grades = scorm_get_user_grades($scorm, $userid)) {
             scorm_grade_item_update($scorm, $grades);
 
         } else if ($userid and $nullifnone) {
-            $grade = new object();
+        $grade = new stdClass();
             $grade->userid   = $userid;
             $grade->rawgrade = NULL;
             scorm_grade_item_update($scorm, $grade);
@@ -490,29 +570,52 @@ function scorm_update_grades($scorm=null, $userid=0, $nullifnone=true) {
         } else {
             scorm_grade_item_update($scorm);
         }
+}
 
-    } else {
-        $sql = "SELECT s.*, cm.idnumber as cmidnumber
-                  FROM {$CFG->prefix}scorm s, {$CFG->prefix}course_modules cm, {$CFG->prefix}modules m
+/**
+ * Update all grades in gradebook.
+ *
+ * @global object
+ */
+function scorm_upgrade_grades() {
+    global $DB;
+
+    $sql = "SELECT COUNT('x')
+              FROM {scorm} s, {course_modules} cm, {modules} m
                  WHERE m.name='scorm' AND m.id=cm.module AND cm.instance=s.id";
-        if ($rs = get_recordset_sql($sql)) {
-            while ($scorm = rs_fetch_next_record($rs)) {
+    $count = $DB->count_records_sql($sql);
+
+    $sql = "SELECT s.*, cm.idnumber AS cmidnumber, s.course AS courseid
+              FROM {scorm} s, {course_modules} cm, {modules} m
+             WHERE m.name='scorm' AND m.id=cm.module AND cm.instance=s.id";
+    $rs = $DB->get_recordset_sql($sql);
+    if ($rs->valid()) {
+        $pbar = new progress_bar('scormupgradegrades', 500, true);
+        $i=0;
+        foreach ($rs as $scorm) {
+            $i++;
+            upgrade_set_timeout(60*5); // set up timeout, may also abort execution
                 scorm_update_grades($scorm, 0, false);
-            }
-            rs_close($rs);
+            $pbar->update($i, $count, "Updating Scorm grades ($i/$count).");
         }
     }
+    $rs->close();
 }
 
 /**
  * Update/create grade item for given scorm
  *
+ * @global stdClass
+ * @global object
+ * @uses GRADE_TYPE_VALUE
+ * @uses GRADE_TYPE_NONE
  * @param object $scorm object with extra cmidnumber
- * @param mixed optional array/object of grade(s); 'reset' means reset grades in gradebook
+ * @param mixed $grades optional array/object of grade(s); 'reset' means reset grades in gradebook
  * @return object grade_item
  */
 function scorm_grade_item_update($scorm, $grades=NULL) {
-    global $CFG;
+    global $CFG, $DB;
+    require_once($CFG->dirroot.'/mod/scorm/locallib.php');
     if (!function_exists('grade_update')) { //workaround for buggy PHP versions
         require_once($CFG->libdir.'/gradelib.php');
     }
@@ -522,8 +625,8 @@ function scorm_grade_item_update($scorm, $grades=NULL) {
         $params['idnumber'] = $scorm->cmidnumber;
     }
 
-    if (($scorm->grademethod % 10) == 0) { // GRADESCOES
-        if ($maxgrade = count_records_select('scorm_scoes',"scorm='$scorm->id' AND launch<>'".sql_empty()."'")) {
+    if ($scorm->grademethod == GRADESCOES) {
+        if ($maxgrade = $DB->count_records_select('scorm_scoes', 'scorm = ? AND '.$DB->sql_isnotempty('scorm_scoes', 'launch', false, true), array($scorm->id))) {
             $params['gradetype'] = GRADE_TYPE_VALUE;
             $params['grademax']  = $maxgrade;
             $params['grademin']  = 0;
@@ -547,6 +650,7 @@ function scorm_grade_item_update($scorm, $grades=NULL) {
 /**
  * Delete grade item for given scorm
  *
+ * @global stdClass
  * @param object $scorm object
  * @return object grade_item
  */
@@ -557,14 +661,24 @@ function scorm_grade_item_delete($scorm) {
     return grade_update('mod/scorm', $scorm->course, 'mod', 'scorm', $scorm->id, 0, NULL, array('deleted'=>1));
 }
 
+/**
+ * @return array
+ */
 function scorm_get_view_actions() {
     return array('pre-view','view','view all','report');
 }
 
+/**
+ * @return array
+ */
 function scorm_get_post_actions() {
     return array();
 }
 
+/**
+ * @param object $scorm
+ * @return object $scorm
+ */
 function scorm_option2text($scorm) {
     $scorm_popoup_options = scorm_get_popup_options_array();
 
@@ -592,7 +706,8 @@ function scorm_option2text($scorm) {
 /**
  * Implementation of the function for printing the form elements that control
  * whether the course reset functionality affects the scorm.
- * @param $mform form passed by reference
+ *
+ * @param object $mform form passed by reference
  */
 function scorm_reset_course_form_definition(&$mform) {
     $mform->addElement('header', 'scormheader', get_string('modulenameplural', 'scorm'));
@@ -601,6 +716,8 @@ function scorm_reset_course_form_definition(&$mform) {
 
 /**
  * Course reset form defaults.
+ *
+ * @return array
  */
 function scorm_reset_course_form_defaults($course) {
     return array('reset_scorm'=>1);
@@ -608,17 +725,20 @@ function scorm_reset_course_form_defaults($course) {
 
 /**
  * Removes all grades from gradebook
+ *
+ * @global stdClass
+ * @global object
  * @param int $courseid
  * @param string optional type
  */
 function scorm_reset_gradebook($courseid, $type='') {
-    global $CFG;
+    global $CFG, $DB;
 
     $sql = "SELECT s.*, cm.idnumber as cmidnumber, s.course as courseid
-              FROM {$CFG->prefix}scorm s, {$CFG->prefix}course_modules cm, {$CFG->prefix}modules m
-             WHERE m.name='scorm' AND m.id=cm.module AND cm.instance=s.id AND s.course=$courseid";
+              FROM {scorm} s, {course_modules} cm, {modules} m
+             WHERE m.name='scorm' AND m.id=cm.module AND cm.instance=s.id AND s.course=?";
 
-    if ($scorms = get_records_sql($sql)) {
+    if ($scorms = $DB->get_records_sql($sql, array($courseid))) {
         foreach ($scorms as $scorm) {
             scorm_grade_item_update($scorm, 'reset');
         }
@@ -626,23 +746,26 @@ function scorm_reset_gradebook($courseid, $type='') {
 }
 
 /**
- * Actual implementation of the rest coures functionality, delete all the
+ * Actual implementation of the reset course functionality, delete all the
  * scorm attempts for course $data->courseid.
- * @param $data the data submitted from the reset course.
+ *
+ * @global stdClass
+ * @global object
+ * @param object $data the data submitted from the reset course.
  * @return array status array
  */
 function scorm_reset_userdata($data) {
-    global $CFG;
+    global $CFG, $DB;
 
     $componentstr = get_string('modulenameplural', 'scorm');
     $status = array();
 
     if (!empty($data->reset_scorm)) {
         $scormssql = "SELECT s.id
-                         FROM {$CFG->prefix}scorm s
-                        WHERE s.course={$data->courseid}";
+                         FROM {scorm} s
+                        WHERE s.course=?";
 
-        delete_records_select('scorm_scoes_track', "scormid IN ($scormssql)");
+        $DB->delete_records_select('scorm_scoes_track', "scormid IN ($scormssql)", array($data->courseid));
 
         // remove all grades from gradebook
         if (empty($data->reset_gradebook_grades)) {
@@ -659,17 +782,307 @@ function scorm_reset_userdata($data) {
 
 /**
  * Returns all other caps used in module
+ *
+ * @return array
  */
 function scorm_get_extra_capabilities() {
     return array('moodle/site:accessallgroups');
 }
 
 /**
- * Tells if files in moddata are trusted and can be served without XSS protection.
- * @return bool true if file can be submitted by teacher only (trusted), false otherwise
+ * Lists all file areas current user may browse
+ *
+ * @param object $course
+ * @param object $cm
+ * @param object $context
+ * @return array
  */
-function scorm_is_moddata_trusted() {
+function scorm_get_file_areas($course, $cm, $context) {
+    $areas = array();
+    $areas['content'] = get_string('areacontent', 'scorm');
+    $areas['package'] = get_string('areapackage', 'scorm');
+    return $areas;
+}
+
+/**
+ * File browsing support for SCORM file areas
+ *
+ * @param stdclass $browser
+ * @param stdclass $areas
+ * @param stdclass $course
+ * @param stdclass $cm
+ * @param stdclass $context
+ * @param string $filearea
+ * @param int $itemid
+ * @param string $filepath
+ * @param string $filename
+ * @return stdclass file_info instance or null if not found
+ */
+function scorm_get_file_info($browser, $areas, $course, $cm, $context, $filearea, $itemid, $filepath, $filename) {
+    global $CFG;
+
+    if (!has_capability('moodle/course:managefiles', $context)) {
+        return null;
+    }
+
+    // no writing for now!
+
+    $fs = get_file_storage();
+
+    if ($filearea === 'content') {
+
+        $filepath = is_null($filepath) ? '/' : $filepath;
+        $filename = is_null($filename) ? '.' : $filename;
+
+        $urlbase = $CFG->wwwroot.'/pluginfile.php';
+        if (!$storedfile = $fs->get_file($context->id, 'mod_scorm', 'content', 0, $filepath, $filename)) {
+            if ($filepath === '/' and $filename === '.') {
+                $storedfile = new virtual_root_file($context->id, 'mod_scorm', 'content', 0);
+            } else {
+                // not found
+                return null;
+            }
+        }
+        require_once("$CFG->dirroot/mod/scorm/locallib.php");
+        return new scorm_package_file_info($browser, $context, $storedfile, $urlbase, $areas[$filearea], true, true, false, false);
+
+    } else if ($filearea === 'package') {
+        $filepath = is_null($filepath) ? '/' : $filepath;
+        $filename = is_null($filename) ? '.' : $filename;
+
+        $urlbase = $CFG->wwwroot.'/pluginfile.php';
+        if (!$storedfile = $fs->get_file($context->id, 'mod_scorm', 'package', 0, $filepath, $filename)) {
+            if ($filepath === '/' and $filename === '.') {
+                $storedfile = new virtual_root_file($context->id, 'mod_scorm', 'package', 0);
+            } else {
+                // not found
+                return null;
+            }
+        }
+        return new file_info_stored($browser, $context, $storedfile, $urlbase, $areas[$filearea], false, true, false, false);
+    }
+
+    // scorm_intro handled in file_browser
+
+    return false;
+}
+
+/**
+ * Serves scorm content, introduction images and packages. Implements needed access control ;-)
+ *
+ * @param object $course
+ * @param object $cm
+ * @param object $context
+ * @param string $filearea
+ * @param array $args
+ * @param bool $forcedownload
+ * @return bool false if file not found, does not return if found - just send the file
+ */
+function scorm_pluginfile($course, $cm, $context, $filearea, $args, $forcedownload) {
+    global $CFG;
+
+    if ($context->contextlevel != CONTEXT_MODULE) {
+        return false;
+    }
+
+    require_login($course, true, $cm);
+
+    $lifetime = isset($CFG->filelifetime) ? $CFG->filelifetime : 86400;
+
+    if ($filearea === 'content') {
+        $revision = (int)array_shift($args); // prevents caching problems - ignored here
+        $relativepath = implode('/', $args);
+        $fullpath = "/$context->id/mod_scorm/content/0/$relativepath";
+        // TODO: add any other access restrictions here if needed!
+
+    } else if ($filearea === 'package') {
+        if (!has_capability('moodle/course:manageactivities', $context)) {
+            return false;
+        }
+        $relativepath = implode('/', $args);
+        $fullpath = "/$context->id/mod_scorm/package/0/$relativepath";
+        $lifetime = 0; // no caching here
+
+    } else {
+        return false;
+    }
+
+    $fs = get_file_storage();
+    if (!$file = $fs->get_file_by_hash(sha1($fullpath)) or $file->is_directory()) {
+        return false;
+    }
+
+    // finally send the file
+    send_stored_file($file, $lifetime, 0, false);
+}
+
+/**
+ * @uses FEATURE_GROUPS
+ * @uses FEATURE_GROUPINGS
+ * @uses FEATURE_GROUPMEMBERSONLY
+ * @uses FEATURE_MOD_INTRO
+ * @uses FEATURE_COMPLETION_TRACKS_VIEWS
+ * @uses FEATURE_GRADE_HAS_GRADE
+ * @uses FEATURE_GRADE_OUTCOMES
+ * @param string $feature FEATURE_xx constant for requested feature
+ * @return mixed True if module supports feature, false if not, null if doesn't know
+ */
+function scorm_supports($feature) {
+    switch($feature) {
+        case FEATURE_GROUPS:                  return false;
+        case FEATURE_GROUPINGS:               return false;
+        case FEATURE_GROUPMEMBERSONLY:        return true;
+        case FEATURE_MOD_INTRO:               return true;
+        case FEATURE_COMPLETION_TRACKS_VIEWS: return true;
+        case FEATURE_GRADE_HAS_GRADE:         return true;
+        case FEATURE_GRADE_OUTCOMES:          return true;
+        case FEATURE_BACKUP_MOODLE2:          return true;
+
+        default: return null;
+    }
+}
+
+/**
+ * This function extends the global navigation for the site.
+ * It is important to note that you should not rely on PAGE objects within this
+ * body of code as there is no guarantee that during an AJAX request they are
+ * available
+ *
+ * @param navigation_node $navigation The scorm node within the global navigation
+ * @param stdClass $course The course object returned from the DB
+ * @param stdClass $module The module object returned from the DB
+ * @param stdClass $cm The course module instance returned from the DB
+ */
+function scorm_extend_navigation($navigation, $course, $module, $cm) {
+    /**
+     * This is currently just a stub so that it can be easily expanded upon.
+     * When expanding just remove this comment and the line below and then add
+     * you content.
+     */
+    $navigation->nodetype = navigation_node::NODETYPE_LEAF;
+}
+
+/**
+ * Get the filename for a temp log file
+ *
+ * @param string $type - type of log(aicc,scorm12,scorm13) used as prefix for filename
+ * @param integer $scoid - scoid of object this log entry is for
+ * @return string The filename as an absolute path
+*/
+function scorm_debug_log_filename($type, $scoid) {
+    global $CFG, $USER;
+
+    $logpath = $CFG->dataroot.'/temp/scormlogs';
+    $logfile = $logpath.'/'.$type.'debug_'.$USER->id.'_'.$scoid.'.log';
+    return $logfile;
+}
+
+/**
+ * writes log output to a temp log file
+ *
+ * @param string $type - type of log(aicc,scorm12,scorm13) used as prefix for filename
+ * @param string $text - text to be written to file.
+ * @param integer $scoid - scoid of object this log entry is for.
+ */
+function scorm_debug_log_write($type, $text, $scoid) {
+
+    $debugenablelog = get_config('scorm', 'allowapidebug');
+    if (!$debugenablelog || empty($text)) {
+        return ;
+    }
+    if (make_upload_directory('temp/scormlogs/')) {
+        $logfile = scorm_debug_log_filename($type, $scoid);
+        @file_put_contents($logfile, date('Y/m/d H:i:s O')." DEBUG $text\r\n", FILE_APPEND);
+    }
+}
+
+ /**
+ * Remove debug log file
+ *
+ * @param string $type - type of log(aicc,scorm12,scorm13) used as prefix for filename
+ * @param integer $scoid - scoid of object this log entry is for
+ * @return boolean True if the file is successfully deleted, false otherwise
+ */
+function scorm_debug_log_remove($type, $scoid) {
+
+    $debugenablelog = get_config('scorm', 'allowapidebug');
+    $logfile = scorm_debug_log_filename($type, $scoid);
+    if (!$debugenablelog || !file_exists($logfile)) {
+        return false;
+    }
+
+    return @unlink($logfile);
+}
+
+/**
+ * writes overview info for course_overview block - displays upcoming scorm objects that have a due date
+ *
+ * @param object $type - type of log(aicc,scorm12,scorm13) used as prefix for filename
+ * @param array $htmlarray
+ * @return mixed
+ */
+function scorm_print_overview($courses, &$htmlarray) {
+    global $USER, $CFG, $DB;
+
+    if (empty($courses) || !is_array($courses) || count($courses) == 0) {
+        return array();
+    }
+
+    if (!$scorms = get_all_instances_in_courses('scorm',$courses)) {
+        return;
+    }
+
+    $scormids = array();
+
+    // Do scorm::isopen() here without loading the whole thing for speed
+    foreach ($scorms as $key => $scorm) {
+        $time = time();
+        if ($scorm->timeopen) {
+            $isopen = ($scorm->timeopen <= $time && $time <= $scorm->timeclose);
+        }
+        if (empty($scorm->displayattemptstatus) && (empty($isopen) || empty($scorm->timeclose))) {
+            unset($scorms[$key]);
+        }else{
+            $scormids[] = $scorm->id;
+        }
+    }
+
+    if(empty($scormids)){
+        // no scorms to look at - we're done
     return true;
+    }
+    $strscorm   = get_string('modulename', 'scorm');
+    $strduedate = get_string('duedate', 'scorm');
+
+    foreach ($scorms as $scorm) {
+        $str = '<div class="scorm overview"><div class="name">'.$strscorm. ': '.
+               '<a '.($scorm->visible ? '':' class="dimmed"').
+               'title="'.$strscorm.'" href="'.$CFG->wwwroot.
+               '/mod/scorm/view.php?id='.$scorm->coursemodule.'">'.
+               $scorm->name.'</a></div>';
+        if ($scorm->timeclose) {
+            $str .= '<div class="info">'.$strduedate.': '.userdate($scorm->timeclose).'</div>';
+        }
+        if ($scorm->displayattemptstatus == 1) {
+            require_once($CFG->dirroot.'/mod/scorm/locallib.php');
+            $str .= '<div class="details">'.scorm_get_attempt_status($USER, $scorm).'</div>';
+        }
+        $str .= '</div>';
+        if (empty($htmlarray[$scorm->course]['scorm'])) {
+            $htmlarray[$scorm->course]['scorm'] = $str;
+        } else {
+            $htmlarray[$scorm->course]['scorm'] .= $str;
+        }
+    }
 }
 
-?>
+/**
+ * Return a list of page types
+ * @param string $pagetype current page type
+ * @param stdClass $parentcontext Block's parent context
+ * @param stdClass $currentcontext Current context of block
+ */
+function scorm_page_type_list($pagetype, $parentcontext, $currentcontext) {
+    $module_pagetype = array('mod-scorm-*'=>get_string('page-mod-scorm-x', 'scorm'));
+    return $module_pagetype;
+}
