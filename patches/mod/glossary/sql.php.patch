diff --git a/mod/glossary/sql.php b/mod/glossary/sql.php
index 7527980..43b7904 100644
--- a/mod/glossary/sql.php
+++ b/mod/glossary/sql.php
@@ -3,7 +3,6 @@
 /**
  * SQL.PHP
  *    This file is include from view.php and print.php
- * @version $Id$
  * @copyright 2003 
  **/
 
@@ -14,6 +13,10 @@
     $sqlsortkey = NULL;
     $textlib = textlib_get_instance();
 
+    // For cases needing inner view
+    $sqlwrapheader = '';
+    $sqlwrapfooter = '';
+
 /// Calculate the SQL sortkey to be used by the SQL statements later
     switch ( $sortkey ) {    
         case "CREATION": 
@@ -37,22 +40,23 @@
 /// printpivot indicate if the pivot should be printed or not
 
     $fullpivot = 1;
+    $params = array('gid1'=>$glossary->id, 'gid2'=>$glossary->id, 'myid'=>$USER->id, 'hook'=>$hook);
 
     $userid = '';
-    if ( !empty($USER->id) ) {
-        $userid = "OR ge.userid = $USER->id";
+    if ( isloggedin() ) {
+        $userid = "OR ge.userid = :myid";
     }
     switch ($tab) {
     case GLOSSARY_CATEGORY_VIEW:
         if ($hook == GLOSSARY_SHOW_ALL_CATEGORIES  ) { 
 
             $sqlselect = "SELECT gec.id AS cid, ge.*, gec.entryid, gc.name AS glossarypivot";
-            $sqlfrom   = "FROM {$CFG->prefix}glossary_entries ge,
-                         {$CFG->prefix}glossary_entries_categories gec,
-                         {$CFG->prefix}glossary_categories gc";
-            $sqlwhere  = "WHERE (ge.glossaryid = '$glossary->id' OR ge.sourceglossaryid = '$glossary->id') AND
+            $sqlfrom   = "FROM {glossary_entries} ge,
+                               {glossary_entries_categories} gec,
+                               {glossary_categories} gc";
+            $sqlwhere  = "WHERE (ge.glossaryid = :gid1 OR ge.sourceglossaryid = :gid2) AND
                           ge.id = gec.entryid AND gc.id = gec.categoryid AND
-                          (ge.approved != 0 $userid)";
+                          (ge.approved <> 0 $userid)";
 
             $sqlorderby = ' ORDER BY gc.name, ge.concept';
 
@@ -60,10 +64,10 @@
 
             $printpivot = 0;
             $sqlselect = "SELECT ge.*, concept AS glossarypivot";
-            $sqlfrom   = "FROM {$CFG->prefix}glossary_entries ge LEFT JOIN {$CFG->prefix}glossary_entries_categories gec
+            $sqlfrom   = "FROM {glossary_entries} ge LEFT JOIN {glossary_entries_categories} gec
                           ON ge.id = gec.entryid";
-            $sqlwhere  = "WHERE (glossaryid = '$glossary->id' OR sourceglossaryid = '$glossary->id') AND
-                          (ge.approved != 0 $userid) AND gec.entryid IS NULL";
+            $sqlwhere  = "WHERE (glossaryid = :gid1 OR sourceglossaryid = :gid2) AND
+                          (ge.approved <> 0 $userid) AND gec.entryid IS NULL";
 
 
             $sqlorderby = ' ORDER BY concept';
@@ -72,11 +76,11 @@
 
             $printpivot = 0;
             $sqlselect  = "SELECT ge.*, ce.entryid, c.name AS glossarypivot";
-            $sqlfrom    = "FROM {$CFG->prefix}glossary_entries ge, {$CFG->prefix}glossary_entries_categories ce, {$CFG->prefix}glossary_categories c";
-            $sqlwhere   = "WHERE ge.id = ce.entryid AND ce.categoryid = '$hook' AND
+            $sqlfrom    = "FROM {glossary_entries} ge, {glossary_entries_categories} ce, {glossary_categories} c";
+            $sqlwhere   = "WHERE ge.id = ce.entryid AND ce.categoryid = :hook AND
                                  ce.categoryid = c.id AND ge.approved != 0 AND
-                                 (ge.glossaryid = '$glossary->id' OR ge.sourceglossaryid = '$glossary->id') AND
-                          (ge.approved != 0 $userid)";
+                                 (ge.glossaryid = :gid1 OR ge.sourceglossaryid = :gid2) AND
+                          (ge.approved <> 0 $userid)";
 
             $sqlorderby = ' ORDER BY c.name, ge.concept';
 
@@ -85,24 +89,25 @@
     case GLOSSARY_AUTHOR_VIEW:
 
         $where = '';
+        $params['hookup'] = $textlib->strtoupper($hook);
 
         if ( $sqlsortkey == 'firstname' ) {
-            $usernamefield = sql_fullname('u.firstname' , 'u.lastname');
+            $usernamefield = $DB->sql_fullname('u.firstname' , 'u.lastname');
         } else {
-            $usernamefield = sql_fullname('u.lastname' , 'u.firstname');
+            $usernamefield = $DB->sql_fullname('u.lastname' , 'u.firstname');
         }
-        $where = "AND " . sql_substr() . "(upper($usernamefield),1," .  $textlib->strlen($hook) . ") = '" . $textlib->strtoupper($hook) . "'";
+        $where = "AND " . $DB->sql_substr("upper($usernamefield)", 1, $textlib->strlen($hook)) . " = :hookup";
 
         if ( $hook == 'ALL' ) {
             $where = '';
         }
 
         $sqlselect  = "SELECT ge.*, $usernamefield AS glossarypivot, 1 AS userispivot ";
-        $sqlfrom    = "FROM {$CFG->prefix}glossary_entries ge, {$CFG->prefix}user u";
+        $sqlfrom    = "FROM {glossary_entries} ge, {user} u";
         $sqlwhere   = "WHERE ge.userid = u.id  AND
-                             (ge.approved != 0 $userid)
+                             (ge.approved <> 0 $userid)
                              $where AND 
-                             (ge.glossaryid = '$glossary->id' OR ge.sourceglossaryid = '$glossary->id')";
+                             (ge.glossaryid = :gid1 OR ge.sourceglossaryid = :gid2)";
         $sqlorderby = "ORDER BY $usernamefield $sqlsortorder, ge.concept";
     break;
     case GLOSSARY_APPROVAL_VIEW:
@@ -110,13 +115,15 @@
         $printpivot = 0;
 
         $where = '';
+        $params['hookup'] = $textlib->strtoupper($hook);
+
         if ($hook != 'ALL' and $hook != 'SPECIAL') {
-            $where = 'AND ' . sql_substr() . '(upper(concept),1,' .  $textlib->strlen($hook) . ') = \'' . $textlib->strtoupper($hook) . '\'';
+            $where = "AND " . $DB->sql_substr("upper(concept)", 1, $textlib->strlen($hook)) . " = :hookup";
         }
 
         $sqlselect  = "SELECT ge.*, ge.concept AS glossarypivot";
-        $sqlfrom    = "FROM {$CFG->prefix}glossary_entries ge";
-        $sqlwhere   = "WHERE (ge.glossaryid = '$glossary->id' OR ge.sourceglossaryid = '$glossary->id') AND
+        $sqlfrom    = "FROM {glossary_entries} ge";
+        $sqlwhere   = "WHERE (ge.glossaryid = :gid1 OR ge.sourceglossaryid = :gid2) AND
                              ge.approved = 0 $where";
                              
         if ( $sqlsortkey ) {
@@ -130,136 +137,119 @@
     case GLOSSARY_STANDARD_VIEW:
     default:
         $sqlselect  = "SELECT ge.*, ge.concept AS glossarypivot";
-        $sqlfrom    = "FROM {$CFG->prefix}glossary_entries ge";
+        $sqlfrom    = "FROM {glossary_entries} ge";
 
         $where = '';
         $fullpivot = 0;
-        $LIKE = sql_ilike();
-        $NOTLIKE = 'NOT ' . $LIKE;
 
         switch ( $mode ) {
         case 'search': 
 
-            /// Some differences in syntax for PostgreSQL
-            if ($CFG->dbfamily == "postgres") {
-                $REGEXP = "~*";
-                $NOTREGEXP = "!~*";
-            } else {
-                $REGEXP = "REGEXP";
-                $NOTREGEXP = "NOT REGEXP";
+            if ($DB->sql_regex_supported()) {
+                $REGEXP    = $DB->sql_regex(true);
+                $NOTREGEXP = $DB->sql_regex(false);
             }
 
-            $conceptsearch = "";
-            $aliassearch = "";
-            $definitionsearch = "";
+            $searchcond = array();
+            $alcond     = array();
+            //$params     = array();
+            $i = 0;
+
+            $concat = $DB->sql_concat('ge.concept', "' '", 'ge.definition',"' '", "COALESCE(al.alias, '')");
 
             $searchterms = explode(" ",$hook);
 
             foreach ($searchterms as $searchterm) {
+                $i++;
 
-                if ($conceptsearch) {
-                    $conceptsearch .= " AND ";
-                }
-                if ($aliassearch) {
-                    $aliassearch .= " AND ";
+                $NOT = false; /// Initially we aren't going to perform NOT LIKE searches, only MSSQL and Oracle
+                           /// will use it to simulate the "-" operator with LIKE clause
+
+            /// Under Oracle and MSSQL, trim the + and - operators and perform
+            /// simpler LIKE (or NOT LIKE) queries
+                if (!$DB->sql_regex_supported()) {
+                    if (substr($searchterm, 0, 1) == '-') {
+                        $NOT = true;
                 }
-                if ($definitionsearch) {
-                    $definitionsearch .= " AND ";
+                    $searchterm = trim($searchterm, '+-');
                 }
 
-            /// Under Oracle and MSSQL, trim the + and - operators and perform
-            /// simpler LIKE search
-                if ($CFG->dbfamily == 'oracle' || $CFG->dbfamily == 'mssql') {
+                if (substr($searchterm,0,1) == '+') {
                     $searchterm = trim($searchterm, '+-');
+                    if ($textlib->strlen($searchterm) < 2) {
+                        continue;
                 }
+                    $searchterm = preg_quote($searchterm, '|');
+                    $searchcond[] = "$concat $REGEXP :ss$i";
+                    $params['ss'.$i] = "(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)";
 
-                if (substr($searchterm,0,1) == "+") {
-                    $searchterm = substr($searchterm,1);
-                    $conceptsearch .= " ge.concept $REGEXP '(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)' ";
-                    $aliassearch .= " al.alias $REGEXP '(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)' ";
-                    $definitionsearch .= " ge.definition $REGEXP '(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)' ";
                 } else if (substr($searchterm,0,1) == "-") {
-                    $searchterm = substr($searchterm,1);
-                    $conceptsearch .= " ge.concept $NOTREGEXP '(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)' ";
-                    $aliassearch .= " al.alias $NOTREGEXP '(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)' ";
-                    $definitionsearch .= " ge.definition $NOTREGEXP '(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)' ";
-                } else {
-                    $conceptsearch .= " ge.concept $LIKE '%$searchterm%' ";
-                    $aliassearch .= " al.alias $LIKE '%$searchterm%' ";
-                    $definitionsearch .= " ge.definition $LIKE '%$searchterm%' ";
-                }
+                    $searchterm = trim($searchterm, '+-');
+                    if ($textlib->strlen($searchterm) < 2) {
+                        continue;
             }
+                    $searchterm = preg_quote($searchterm, '|');
+                    $searchcond[] = "$concat $NOTREGEXP :ss$i";
+                    $params['ss'.$i] = "(^|[^a-zA-Z0-9])$searchterm([^a-zA-Z0-9]|$)";
      
-            //Search in aliases first
-            $idaliases = '';
-            $listaliases = array();
-            $recaliases = get_records_sql ("SELECT al.id, al.entryid
-                                              FROM {$CFG->prefix}glossary_alias al,
-                                                   {$CFG->prefix}glossary_entries ge
-                                              WHERE (ge.glossaryid = '$glossary->id' OR
-                                                     ge.sourceglossaryid = '$glossary->id') AND
-                                                    (ge.approved != 0 $userid) AND
-                                                    ge.id = al.entryid AND
-                                                    $aliassearch");
-            //Process aliases id
-            if ($recaliases) {
-                foreach ($recaliases as $recalias) {
-                    $listaliases[] = $recalias->entryid;
+                } else {
+                    if ($textlib->strlen($searchterm) < 2) {
+                        continue;
                 }
-                $idaliases = implode (',',$listaliases);
+                    $searchcond[] = $DB->sql_like($concat, ":ss$i", false, true, $NOT);
+                    $params['ss'.$i] = "%$searchterm%";
             }
-           
-            //Add seach conditions in concepts and, if needed, in definitions
-            $printpivot = 0;
-            $where = "AND (( $conceptsearch) ";
-
-            //Include aliases id if found
-            if (!empty($idaliases)) {
-                $where .= " OR ge.id IN ($idaliases) ";
             }
 
-            //Include search in definitions if requested
-            if ( $fullsearch ) {
-                $where .= " OR ($definitionsearch) )";
+            if (empty($searchcond)) {
+                $where = "AND 1=2 "; // no search result
+
             } else {
-                $where .= ")";
+                $searchcond = implode(" AND ", $searchcond);
+
+                // Need one inner view here to avoid distinct + text
+                $sqlwrapheader = 'SELECT ge.*, ge.concept AS glossarypivot
+                                    FROM {glossary_entries} ge
+                                    JOIN ( ';
+                $sqlwrapfooter = ' ) gei ON (ge.id = gei.id)';
+
+                $sqlselect  = "SELECT DISTINCT ge.id";
+                $sqlfrom    = "FROM {glossary_entries} ge
+                               LEFT JOIN {glossary_alias} al ON al.entryid = ge.id";
+                $where      = "AND ($searchcond)";
             }
 
         break;
         
         case 'term': 
+            $params['hook2'] = $hook;
             $printpivot = 0;
-            $sqlfrom .= " left join {$CFG->prefix}glossary_alias ga on ge.id = ga.entryid ";
-            $where = "AND (ge.concept = '$hook' OR ga.alias = '$hook' )
-                     ";
+            $sqlfrom .= " LEFT JOIN {glossary_alias} ga on ge.id = ga.entryid";
+            $where = "AND (ge.concept = :hook OR ga.alias = :hook2) ";
         break;
 
         case 'entry': 
             $printpivot = 0;
-            $where = "AND ge.id = '$hook'";
+            $where = "AND ge.id = :hook";
         break;
 
         case 'letter': 
             if ($hook != 'ALL' and $hook != 'SPECIAL') {
-                $where = 'AND ' . sql_substr() . '(upper(concept),1,' .  $textlib->strlen($hook) . ') = \'' . $textlib->strtoupper($hook) . '\'';
+                $params['hookup'] = $textlib->strtoupper($hook);
+                $where = "AND " . $DB->sql_substr("upper(concept)", 1, $textlib->strlen($hook)) . " = :hookup";
             }
             if ($hook == 'SPECIAL') {
                 //Create appropiate IN contents
-                $alphabet = explode(",", get_string("alphabet"));
-                $sqlalphabet = '';
-                for ($i = 0; $i < count($alphabet); $i++) {
-                    if ($i != 0) {
-                        $sqlalphabet .= ',';
-                    }
-                    $sqlalphabet .= '\''.$alphabet[$i].'\'';
-                }
-                $where = 'AND ' . sql_substr() . '(upper(concept),1,1) NOT IN (' . $textlib->strtoupper($sqlalphabet) . ')';
+                $alphabet = explode(",", get_string('alphabet', 'langconfig'));
+                list($nia, $aparams) = $DB->get_in_or_equal($alphabet, SQL_PARAMS_NAMED, $start='a', false);
+                $params = array_merge($params, $aparams);
+                $where = "AND " . $DB->sql_substr("upper(concept)", 1, 1) . " $nia";
             }
         break;
         }
         
-        $sqlwhere   = "WHERE (ge.glossaryid = '$glossary->id' or ge.sourceglossaryid = '$glossary->id') AND
-                             (ge.approved != 0 $userid)
+        $sqlwhere   = "WHERE (ge.glossaryid = :gid1 or ge.sourceglossaryid = :gid2) AND
+                             (ge.approved <> 0 $userid)
                               $where";
         switch ( $tab ) {
         case GLOSSARY_DATE_VIEW: 
@@ -273,7 +263,7 @@
         }
     break;
     } 
-    $count = count_records_sql("select count(*) $sqlfrom $sqlwhere");
+    $count = $DB->count_records_sql("SELECT COUNT(DISTINCT(ge.id)) $sqlfrom $sqlwhere", $params);
 
     $limitfrom = $offset;
     $limitnum = 0;
@@ -282,5 +272,6 @@
         $limitnum = $entriesbypage;
     }
 
-    $allentries = get_records_sql("$sqlselect $sqlfrom $sqlwhere $sqlorderby", $limitfrom, $limitnum);
-?>
+    $query = "$sqlwrapheader $sqlselect $sqlfrom $sqlwhere $sqlwrapfooter $sqlorderby";
+    $allentries = $DB->get_records_sql($query, $params, $limitfrom, $limitnum);
+
