diff --git a/mod/quiz/report/grading/report.php b/mod/quiz/report/grading/report.php
index f75c9a8..81628dd 100644
--- a/mod/quiz/report/grading/report.php
+++ b/mod/quiz/report/grading/report.php
@@ -1,482 +1,554 @@
-<?php  // $Id$
+<?php
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
 /**
- * Quiz report to help teachers manually grade quiz questions that need it.
+ * This file defines the quiz manual grading report class.
  *
  * @package quiz
- * @subpackage reports
+ * @subpackage grading
+ * @copyright  2006 Gustav Delius
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
  */
 
-// Flow of the file:
-//     Get variables, run essential queries
-//     Check for post data submitted.  If exists, then process data (the data is the grades and comments for essay questions)
-//     Check for userid, attemptid, or gradeall and for questionid.  If found, print out the appropriate essay question attempts
-//     Switch:
-//         first case: print out all essay questions in quiz and the number of ungraded attempts
-//         second case: print out all users and their attempts for a specific essay question
 
-require_once($CFG->dirroot . "/mod/quiz/editlib.php");
-require_once($CFG->libdir . '/tablelib.php');
+defined('MOODLE_INTERNAL') || die();
+
+require_once($CFG->dirroot . '/mod/quiz/report/grading/gradingsettings_form.php');
+
 
 /**
- * Quiz report to help teachers manually grade quiz questions that need it.
+ * Quiz report to help teachers manually grade questions that need it.
  *
- * @package quiz
- * @subpackage reports
- */
-class quiz_report extends quiz_default_report {
-    /**
-     * Displays the report.
+ * This report basically provides two screens:
+ * - List question that might need manual grading (or optionally all questions).
+ * - Provide an efficient UI to grade all attempts at a particular question.
+ *
+ * @copyright  2006 Gustav Delius
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
      */
-    function display($quiz, $cm, $course) {
-        global $CFG, $QTYPES;
+class quiz_grading_report extends quiz_default_report {
+    const DEFAULT_PAGE_SIZE = 5;
+    const DEFAULT_ORDER = 'random';
+
+    protected $viewoptions = array();
+    protected $questions;
+    protected $currentgroup;
+    protected $users;
+    protected $cm;
+    protected $quiz;
+    protected $context;
+
+    public function display($quiz, $cm, $course) {
+        global $CFG, $DB, $PAGE;
+
+        $this->quiz = $quiz;
+        $this->cm = $cm;
+        $this->course = $course;
 
-        $viewoptions = array('mode'=>'grading', 'q'=>$quiz->id);
+        // Get the URL options.
+        $slot = optional_param('slot', null, PARAM_INT);
+        $questionid = optional_param('qid', null, PARAM_INT);
+        $grade = optional_param('grade', null, PARAM_ALPHA);
 
-        if ($questionid = optional_param('questionid', 0, PARAM_INT)){
-            $viewoptions += array('questionid'=>$questionid);
+        $includeauto = optional_param('includeauto', false, PARAM_BOOL);
+        if (!in_array($grade, array('all', 'needsgrading', 'autograded', 'manuallygraded'))) {
+            $grade = null;
         }
+        $pagesize = optional_param('pagesize', self::DEFAULT_PAGE_SIZE, PARAM_INT);
+        $page = optional_param('page', 0, PARAM_INT);
+        $order = optional_param('order', self::DEFAULT_ORDER, PARAM_ALPHA);
 
-        // grade question specific parameters
-        $gradeungraded  = optional_param('gradeungraded', 0, PARAM_INT);
-
-        if ($userid    = optional_param('userid', 0, PARAM_INT)){
-            $viewoptions += array('userid'=>$userid);
-        }
-        if ($attemptid = optional_param('attemptid', 0, PARAM_INT)){
-            $viewoptions += array('attemptid'=>$attemptid);
+        // Assemble the options requried to reload this page.
+        $optparams = array('includeauto', 'page');
+        foreach ($optparams as $param) {
+            if ($$param) {
+                $this->viewoptions[$param] = $$param;
         }
-        if ($gradeall  = optional_param('gradeall', 0, PARAM_INT)){
-            $viewoptions += array('gradeall'=> $gradeall);
         }
-        if ($gradeungraded  = optional_param('gradeungraded', 0, PARAM_INT)){
-            $viewoptions += array('gradeungraded'=> $gradeungraded);
+        if ($pagesize != self::DEFAULT_PAGE_SIZE) {
+            $this->viewoptions['pagesize'] = $pagesize;
         }
-        if ($gradenextungraded  = optional_param('gradenextungraded', 0, PARAM_INT)){
-            $viewoptions += array('gradenextungraded'=> $gradenextungraded);
+        if ($order != self::DEFAULT_ORDER) {
+            $this->viewoptions['order'] = $order;
         }
 
-
-        $this->cm = $cm;
-
-        $this->print_header_and_tabs($cm, $course, $quiz, $reportmode="grading");
-
         // Check permissions
         $this->context = get_context_instance(CONTEXT_MODULE, $cm->id);
-        if (!has_capability('mod/quiz:grade', $this->context)) {
-            notify(get_string('gradingnotallowed', 'quiz_grading'));
-            return true;
-        }
+        require_capability('mod/quiz:grade', $this->context);
+        $shownames = has_capability('quiz/grading:viewstudentnames', $this->context);
+        $showidnumbers = has_capability('quiz/grading:viewidnumber', $this->context);
 
-        $gradeableqs = quiz_report_load_questions($quiz);
-        $questionsinuse = implode(',', array_keys($gradeableqs));
-        foreach ($gradeableqs as $qid => $question){
-            if (!$QTYPES[$question->qtype]->is_question_manual_graded($question, $questionsinuse)){
-                unset($gradeableqs[$qid]);
+        // Validate order.
+        if (!in_array($order, array('random', 'date', 'student', 'idnumber'))) {
+            $order = self::DEFAULT_ORDER;
+        } else if (!$shownames && $order == 'student') {
+            $order = self::DEFAULT_ORDER;
+        } else if (!$showidnumbers && $order == 'idnumber') {
+            $order = self::DEFAULT_ORDER;
             }
+        if ($order == 'random') {
+            $page = 0;
         }
 
-        if (empty($gradeableqs)) {
-            print_heading(get_string('noessayquestionsfound', 'quiz'));
-            return true;
-        } else if (count($gradeableqs)==1){
-            $questionid = array_shift(array_keys($gradeableqs));
+        // Get the list of questions in this quiz.
+        $this->questions = quiz_report_get_significant_questions($quiz);
+        if ($slot && !array_key_exists($slot, $this->questions)) {
+            throw new moodle_exception('unknownquestion', 'quiz_grading');
         }
 
-        $currentgroup = groups_get_activity_group($this->cm, true);
-        $this->users = get_users_by_capability($this->context, array('mod/quiz:reviewmyattempts', 'mod/quiz:attempt'),'','','','',$currentgroup,'',false);
-        if ($this->users) {
-            $this->userids = implode(',', array_keys($this->users));
-        } else {
-            $this->userids = 0;
-        }
+        // Process any submitted data.
+        if ($data = data_submitted() && confirm_sesskey() && $this->validate_submitted_marks()) {
+            $this->process_submitted_data();
 
-        if (!empty($questionid)) {
-            if (!isset($gradeableqs[$questionid])){
-                error("Gradeable question with id $questionid not found");
-            } else {
-                $question =& $gradeableqs[$questionid];
+            redirect($this->grade_question_url($slot, $questionid, $grade, $page + 1));
             }
-            $question->maxgrade = get_field('quiz_question_instances', 'grade', 'quiz', $quiz->id, 'question', $question->id);
 
-            // Some of the questions code is optimised to work with several questions
-            // at once so it wants the question to be in an array. The array key
-            // must be the question id.
-            $key = $question->id;
-            $questions[$key] = &$question;
+        // Get the group, and the list of significant users.
+        $this->currentgroup = groups_get_activity_group($this->cm, true);
+        $this->users = get_users_by_capability($this->context,
+                array('mod/quiz:reviewmyattempts', 'mod/quiz:attempt'), '', '', '', '',
+                $this->currentgroup, '', false);
 
-            // We need to add additional questiontype specific information to
-            // the question objects.
-            if (!get_question_options($questions)) {
-                error("Unable to load questiontype specific question information");
+        // Start output.
+        $this->print_header_and_tabs($cm, $course, $quiz, 'grading');
+
+        // What sort of page to display?
+        if (!quiz_questions_in_quiz($quiz->questions)) {
+            echo quiz_no_questions_message($quiz, $cm, $this->context);
+
+        } else if (!$slot) {
+            $this->display_index($includeauto);
+
+        } else {
+            $this->display_grading_interface($slot, $questionid, $grade,
+                    $pagesize, $page, $shownames, $showidnumbers, $order);
             }
-            // This will have extended the question object so that it now holds
-            // all the information about the questions that may be needed later.
+        return true;
         }
 
-        add_to_log($course->id, "quiz", "manualgrading", "report.php?mode=grading&amp;q=$quiz->id", "$quiz->id", "$cm->id");
+    protected function get_qubaids_condition() {
+        global $DB;
 
-        echo '<div id="overDiv" style="position:absolute; visibility:hidden; z-index:1000;"></div>'; // for overlib
+        $where = "quiza.quiz = :mangrquizid AND
+                quiza.preview = 0 AND
+                quiza.timefinish <> 0";
+        $params = array('mangrquizid' => $this->cm->instance);
 
-        if ($data = data_submitted()) {  // post data submitted, process it
-            require_sesskey();
+        if ($this->currentgroup) {
+            list($usql, $uparam) = $DB->get_in_or_equal(array_keys($this->users),
+                    SQL_PARAMS_NAMED, 'mangru');
+            $where .= ' AND quiza.userid ' . $usql;
+            $params += $uparam;
+        }
 
-            // now go through all of the responses and save them.
-            $allok = true;
-            foreach($data->manualgrades as $uniqueid => $response) {
-                // get our attempt
-                $uniqueid = clean_param($uniqueid, PARAM_INT);
-                if (!$attempt = get_record_sql("SELECT * FROM {$CFG->prefix}quiz_attempts " .
-                                "WHERE uniqueid = $uniqueid AND " .
-                                "quiz = " . $quiz->id)){
-                    error('No such attempt ID exists');
+        return new qubaid_join('{quiz_attempts} quiza', 'quiza.uniqueid', $where, $params);
                 }
 
-                // Load the state for this attempt (The questions array was created earlier)
-                $states = get_question_states($questions, $quiz, $attempt);
-                // The $states array is indexed by question id but because we are dealing
-                // with only one question there is only one entry in this array
-                $state = &$states[$question->id];
+    protected function load_attempts_by_usage_ids($qubaids) {
+        global $DB;
 
-                // the following will update the state and attempt
-                $error = question_process_comment($question, $state, $attempt, $response['comment'], $response['grade']);
-                if (is_string($error)) {
-                    notify($error);
-                    $allok = false;
-                } else if ($state->changed) {
-                    // If the state has changed save it and update the quiz grade
-                    save_question_session($question, $state);
-                    quiz_save_best_grade($quiz, $attempt->userid);
-                }
-            }
+        list($asql, $params) = $DB->get_in_or_equal($qubaids);
+        $params[] = $this->quiz->id;
 
-            if ($allok) {
-                notify(get_string('changessaved', 'quiz'), 'notifysuccess');
-            } else {
-                notify(get_string('changessavedwitherrors', 'quiz'), 'notifysuccess');
+        $attemptsbyid = $DB->get_records_sql("
+                SELECT quiza.*, u.firstname, u.lastname, u.idnumber
+                FROM {quiz_attempts} quiza
+                JOIN {user} u ON u.id = quiza.userid
+                WHERE quiza.uniqueid $asql AND quiza.timefinish <> 0 AND quiza.quiz = ?",
+                $params);
+
+        $attempts = array();
+        foreach ($attemptsbyid as $attempt) {
+            $attempts[$attempt->uniqueid] = $attempt;
             }
+        return $attempts;
         }
-        $this->viewurl = new moodle_url($CFG->wwwroot.'/mod/quiz/report.php', $viewoptions); 
-        /// find out current groups mode
 
-        if ($groupmode = groups_get_activity_groupmode($this->cm)) {   // Groups are being used
-            groups_print_activity_menu($this->cm, $this->viewurl->out(false, array('userid'=>0, 'attemptid'=>0)));
+    /**
+     * Get the URL of the front page of the report that lists all the questions.
+     * @param $includeauto if not given, use the current setting, otherwise,
+     *      force a paricular value of includeauto in the URL.
+     * @return string the URL.
+     */
+    protected function base_url() {
+        return new moodle_url('/mod/quiz/report.php',
+                array('id' => $this->cm->id, 'mode' => 'grading'));
         }
 
-        echo '<div class="quizattemptcounts">' . quiz_num_attempt_summary($quiz, $cm, true, $currentgroup) . '</div>';
+    /**
+     * Get the URL of the front page of the report that lists all the questions.
+     * @param $includeauto if not given, use the current setting, otherwise,
+     *      force a paricular value of includeauto in the URL.
+     * @return string the URL.
+     */
+    protected function list_questions_url($includeauto = null) {
+        $url = $this->base_url();
 
-        if (empty($this->users)) {
-            if ($currentgroup){
-                notify(get_string('nostudentsingroup'));
-                return true;
-            } else {
-                notify(get_string('nostudentsyet'));
-            }
-        }
-        $gradeablequestionids = implode(',',array_keys($gradeableqs));
-        $qattempts = quiz_get_total_qas_graded_and_ungraded($quiz, $gradeablequestionids, $this->userids);
-        if(empty($qattempts)) {
-            notify(get_string('noattemptstoshow', 'quiz'));
-            return true;
+        $url->params($this->viewoptions);
+
+        if (!is_null($includeauto)) {
+            $url->param('includeauto', $includeauto);
         }
-        $qmenu = array();
-        foreach ($gradeableqs as $qid => $questionformenu){
-            $a= new object();
-            $a->number = $gradeableqs[$qid]->number;
-            $a->name = $gradeableqs[$qid]->name;
-            $a->gradedattempts =$qattempts[$qid]->gradedattempts;
-            $a->totalattempts =$qattempts[$qid]->totalattempts;
-            $a->openspan ='';
-            $a->closespan ='';
-            $qmenu[$qid]= get_string('questiontitle', 'quiz_grading', $a);
-        }
-        if (count($gradeableqs)!=1){
-            $qurl = fullclone($this->viewurl);
-            $qurl->remove_params('questionid', 'attemptid', 'gradeall', 'gradeungraded', 'gradenextungraded');
-            $menu = popup_form(($qurl->out()).'&amp;questionid=',$qmenu, 'questionid', $questionid, 'choose', '', '', true);
-            echo '<div class="mdl-align">'.$menu.'</div>';
-        }
-        if (!$questionid){
-            return true;
+
+        return $url;
         }
-        $a = new object();
-        $a->number = $question->number;
-        $a->name = $question->name;
-        $a->gradedattempts =$qattempts[$question->id]->gradedattempts;
-        $a->totalattempts =$qattempts[$question->id]->totalattempts;
-        $a->openspan ='<span class="highlightgraded">';
-        $a->closespan ='</span>';
-        print_heading(get_string('questiontitle', 'quiz_grading', $a));
 
-        // our 3 different views
-        // the first one displays all of the manually graded questions in the quiz
-        // with the number of ungraded attempts for each question
+    /**
+     * @param int $slot
+     * @param int $questionid
+     * @param string $grade
+     * @param mixed $page = true, link to current page. false = omit page.
+     *      number = link to specific page.
+     */
+    protected function grade_question_url($slot, $questionid, $grade, $page = true) {
+        $url = $this->base_url();
+        $url->params(array('slot' => $slot, 'qid' => $questionid, 'grade' => $grade));
+        $url->params($this->viewoptions);
 
-        // the second view displays the users who have answered the essay question
-        // and all of their attempts at answering the question
+        $options = $this->viewoptions;
+        if (!$page) {
+            $url->remove_params('page');
+        } else if (is_integer($page)) {
+            $url->param('page', $page);
+        }
 
-        // the third prints the question with a comment
-        // and grade form underneath it
+        return $url;
+    }
 
-        $ungraded = $qattempts[$questionid]->totalattempts- $qattempts[$questionid]->gradedattempts;
-        if ($gradenextungraded ||$gradeungraded || $gradeall || $userid || $attemptid){
-            $this->print_questions_and_form($quiz, $question, $userid, $attemptid, $gradeungraded, $gradenextungraded, $ungraded);
-        } else {
-            $this->view_question($quiz, $question, $qattempts[$questionid]->totalattempts, $ungraded);
+    protected function format_count_for_table($counts, $type, $gradestring) {
+        $result = $counts->$type;
+        if ($counts->$type > 0) {
+            $result .= ' ' . html_writer::link($this->grade_question_url(
+                    $counts->slot, $counts->questionid, $type),
+                    get_string($gradestring, 'quiz_grading'),
+                    array('class' => 'gradetheselink'));
         }
-        return true;
+        return $result;
     }
 
-    /**
-     * Prints a table with users and their attempts
-     *
-     * @return void
-     * @todo Add current grade to the table
-     *       Finnish documenting
-     **/
-    function view_question($quiz, $question, $totalattempts, $ungraded) {
-        global $CFG;
+    protected function display_index($includeauto) {
+        global $OUTPUT;
 
+        if ($groupmode = groups_get_activity_groupmode($this->cm)) {
+            // Groups are being used
+            groups_print_activity_menu($this->cm, $this->list_questions_url());
+        }
 
-        $usercount = count($this->users);
+        echo $OUTPUT->heading(get_string('questionsthatneedgrading', 'quiz_grading'));
+        if ($includeauto) {
+            $linktext = get_string('hideautomaticallygraded', 'quiz_grading');
+        } else {
+            $linktext = get_string('alsoshowautomaticallygraded', 'quiz_grading');
+        }
+        echo html_writer::tag('p', html_writer::link($this->list_questions_url(!$includeauto),
+                $linktext), array('class' => 'toggleincludeauto'));
 
-        // set up table
-        $tablecolumns = array('picture', 'fullname', 'timefinish', 'grade');
-        $tableheaders = array('', get_string('name'), get_string("completedon", "quiz"), '');
+        $statecounts = $this->get_question_state_summary(array_keys($this->questions));
 
-        $table = new flexible_table('mod-quiz-report-grading');
+        $data = array();
+        foreach ($statecounts as $counts) {
+            if ($counts->all == 0) {
+                continue;
+            }
+            if (!$includeauto && $counts->needsgrading == 0 && $counts->manuallygraded == 0) {
+                continue;
+            }
 
-        $table->define_columns($tablecolumns);
-        $table->define_headers($tableheaders);
-        $table->define_baseurl($this->viewurl->out());
+            $row = array();
 
-        $table->sortable(true);
-        $table->initialbars($usercount>20);  // will show initialbars if there are more than 20 users
-        $table->pageable(true);
-        $table->collapsible(true);
+            $row[] = $this->questions[$counts->slot]->number;
 
-        $table->column_suppress('fullname');
-        $table->column_suppress('picture');
-        $table->column_suppress('grade');
+            $row[] = format_string($counts->name);
 
-        $table->column_class('picture', 'picture');
+            $row[] = $this->format_count_for_table($counts, 'needsgrading', 'grade');
 
-        // attributes in the table tag
-        $table->set_attribute('cellspacing', '0');
-        $table->set_attribute('id', 'attempts');
-        $table->set_attribute('class', 'generaltable generalbox');
-        $table->set_attribute('align', 'center');
-        //$table->set_attribute('width', '50%');
+            $row[] = $this->format_count_for_table($counts, 'manuallygraded', 'updategrade');
 
-        // get it ready!
-        $table->setup();
+            if ($includeauto) {
+                $row[] = $this->format_count_for_table($counts, 'autograded', 'updategrade');
+            }
 
-        list($select, $from, $where) = $this->attempts_sql($quiz->id, true, $question->id);
+            $row[] = $this->format_count_for_table($counts, 'all', 'gradeall');
 
-        if($table->get_sql_where()) { // forgot what this does
-            $where .= 'AND '.$table->get_sql_where();
+            $data[] = $row;
         }
 
-        // sorting of the table
-        if($sort = $table->get_sql_sort()) {
-            $sort = 'ORDER BY '.$sort;  // seems like I would need to have u. or qa. infront of the ORDER BY attribues... but seems to work..
-        } else {
-            // my default sort rule
-            $sort = 'ORDER BY u.firstname, u.lastname, qa.timefinish ASC';
+        if (empty($data)) {
+            echo $OUTPUT->heading(get_string('noquestionsfound', 'quiz_grading'));
+            return;
         }
 
-        // set up the pagesize
-        $table->pagesize(QUIZ_REPORT_DEFAULT_PAGE_SIZE, $totalattempts);
+        $table = new html_table();
+        $table->class = 'generaltable';
+        $table->id = 'questionstograde';
 
-        // get the attempts and process them
-        if ($attempts = get_records_sql($select.$from.$where.$sort,$table->get_page_start(), $table->get_page_size())) {
-            // grade all link
-            $links = "<strong><a href=\"report.php?mode=grading&amp;gradeall=1&amp;q=$quiz->id&amp;questionid=$question->id\">".get_string('gradeall', 'quiz_grading', $totalattempts).'</a></strong>';
-            if ($ungraded>0){
-                $links .="<br /><strong><a href=\"report.php?mode=grading&amp;gradeungraded=1&amp;q=$quiz->id&amp;questionid=$question->id\">".get_string('gradeungraded', 'quiz_grading', $ungraded).'</a></strong>';
-                if ($ungraded>QUIZ_REPORT_DEFAULT_GRADING_PAGE_SIZE){
-                    $links .="<br /><strong><a href=\"report.php?mode=grading&amp;gradenextungraded=1&amp;q=$quiz->id&amp;questionid=$question->id\">".get_string('gradenextungraded', 'quiz_grading', QUIZ_REPORT_DEFAULT_GRADING_PAGE_SIZE).'</a></strong>';
-                }
+        $table->head[] = get_string('qno', 'quiz_grading');
+        $table->head[] = get_string('questionname', 'quiz_grading');
+        $table->head[] = get_string('tograde', 'quiz_grading');
+        $table->head[] = get_string('alreadygraded', 'quiz_grading');
+        if ($includeauto) {
+            $table->head[] = get_string('automaticallygraded', 'quiz_grading');
             }
-            $table->add_data_keyed(array('grade'=> $links));
-            $table->add_separator();
-            foreach($attempts as $attempt) {
+        $table->head[] = get_string('total', 'quiz_grading');
 
-                $picture = print_user_picture($attempt->userid, $quiz->course, $attempt->picture, false, true);
-
-                // link to student profile
-                $userlink = "<a href=\"$CFG->wwwroot/user/view.php?id=$attempt->userid&amp;course=$quiz->course\">".
-                            fullname($attempt, true).'</a>';
-
-                $gradedclass = question_state_is_graded($attempt)?' class="highlightgraded" ':'';
-                $gradedstring = question_state_is_graded($attempt)?(' '.get_string('graded','quiz_grading')):'';
+        $table->data = $data;
+        echo html_writer::table($table);
+    }
 
-                // link for the attempt
-                $attemptlink = "<a {$gradedclass}href=\"report.php?mode=grading&amp;q=$quiz->id&amp;questionid=$question->id&amp;attemptid=$attempt->attemptid\">".
-                        userdate($attempt->timefinish, get_string('strftimedatetime')).
-                        $gradedstring.'</a>';
+    protected function display_grading_interface($slot, $questionid, $grade,
+            $pagesize, $page, $shownames, $showidnumbers, $order) {
+        global $OUTPUT;
 
-                // grade all attempts for this user
-                $gradelink = "<a href=\"report.php?mode=grading&amp;q=$quiz->id&amp;questionid=$question->id&amp;userid=$attempt->userid\">".
-                        get_string('grade').'</a>';
+        // Make sure there is something to do.
+        $statecounts = $this->get_question_state_summary(array($slot));
 
-                $table->add_data( array($picture, $userlink, $attemptlink, $gradelink) );
+        $counts = null;
+        foreach ($statecounts as $record) {
+            if ($record->questionid == $questionid) {
+                $counts = $record;
+                break;
             }
-            $table->add_separator();
-            $table->add_data_keyed(array('grade'=> $links));
         }
-        // print everything here
-        echo '<div id="tablecontainer">';
-        $table->print_html();
-        echo '</div>';
+
+        // If not, redirect back to the list.
+        if (!$counts || $counts->$grade == 0) {
+            redirect($this->list_questions_url(), get_string('alldoneredirecting', 'quiz_grading'));
     }
 
+        if ($pagesize * $page >= $counts->$grade) {
+            $page = 0;
+        }
 
-    /**
-     * Prints questions with comment and grade form underneath each question
-     *
-     * @return void
-     * @todo Finish documenting this function
-     **/
-    function print_questions_and_form($quiz, $question, $userid, $attemptid, $gradeungraded, $gradenextungraded, $ungraded) {
-        global $CFG;
+        list($qubaids, $count) = $this->get_usage_ids_where_question_in_state(
+                $grade, $slot, $questionid, $order, $page, $pagesize);
+        $attempts = $this->load_attempts_by_usage_ids($qubaids);
 
-        // TODO get the context, and put in proper roles an permissions checks.
-        $context = NULL;
+        // Prepare the form.
+        $hidden = array(
+            'id' => $this->cm->id,
+            'mode' => 'grading',
+            'slot' => $slot,
+            'qid' => $questionid,
+            'page' => $page,
+        );
+        if (array_key_exists('includeauto', $this->viewoptions)) {
+            $hidden['includeauto'] = $this->viewoptions['includeauto'];
+        }
+        $mform = new quiz_grading_settings($hidden, $counts, $shownames, $showidnumbers);
 
-        $questions[$question->id] = &$question;
-        $usehtmleditor = can_use_richtext_editor();
+        // Tell the form the current settings.
+        $settings = new stdClass();
+        $settings->grade = $grade;
+        $settings->pagesize = $pagesize;
+        $settings->order = $order;
+        $mform->set_data($settings);
 
-        list($select, $from, $where) = $this->attempts_sql($quiz->id, false, $question->id, $userid, $attemptid, $gradeungraded, $gradenextungraded);
+        // Print the heading and form.
+        echo question_engine::initialise_js();
 
-        $sort = 'ORDER BY u.firstname, u.lastname, qa.attempt ASC';
+        $a = new stdClass();
+        $a->number = $this->questions[$slot]->number;
+        $a->questionname = format_string($counts->name);
+        echo $OUTPUT->heading(get_string('gradingquestionx', 'quiz_grading', $a));
+        echo html_writer::tag('p', html_writer::link($this->list_questions_url(),
+                get_string('backtothelistofquestions', 'quiz_grading')),
+                array('class' => 'mdl-align'));
 
-        if ($gradenextungraded){
-            $attempts = get_records_sql($select.$from.$where.$sort, 0, QUIZ_REPORT_DEFAULT_GRADING_PAGE_SIZE);
-        } else {
-            $attempts = get_records_sql($select.$from.$where.$sort);
-        }
-        if ($attempts){
-            $firstattempt = current($attempts);
-            $fullname = fullname($firstattempt);
-            if ($gradeungraded) { // getting all ungraded attempts
-                print_heading(get_string('gradingungraded','quiz_grading', $ungraded), '', 3);
-            } else if ($gradenextungraded) { // getting next ungraded attempts
-                print_heading(get_string('gradingnextungraded','quiz_grading', QUIZ_REPORT_DEFAULT_GRADING_PAGE_SIZE), '', 3);
-            } else if ($userid){
-                print_heading(get_string('gradinguser','quiz_grading', $fullname), '', 3);
-            } else if ($attemptid){
-                $a = new object();
-                $a->fullname = $fullname;
-                $a->attempt = $firstattempt->attempt;
-                print_heading(get_string('gradingattempt','quiz_grading', $a), '', 3);
-            } else {
-                print_heading(get_string('gradingall','quiz_grading', count($attempts)), '', 3);
-            }
+        $mform->display();
 
-            // Display the form with one part for each selected attempt
+        // Paging info.
+        $a = new stdClass();
+        $a->from = $page * $pagesize + 1;
+        $a->to = min(($page + 1) * $pagesize, $count);
+        $a->of = $count;
+        echo $OUTPUT->heading(get_string('gradingattemptsxtoyofz', 'quiz_grading', $a), 3);
 
-            echo '<form method="post" action="report.php">'.
-                '<input type="hidden" name="mode" value="grading" />'.
-                '<input type="hidden" name="q" value="'.$quiz->id.'" />'.
-                '<input type="hidden" name="sesskey" value="'.sesskey().'" />'.
-                '<input type="hidden" name="questionid" value="'.$question->id.'" />';
+        if ($count > $pagesize && $order != 'random') {
+            echo $OUTPUT->paging_bar($count, $page, $pagesize,
+                    $this->grade_question_url($slot, $questionid, $grade, false));
+        }
 
-            foreach ($attempts as $attempt) {
+        // Display the form with one section for each attempt.
+        $usehtmleditor = can_use_html_editor();
+        $sesskey = sesskey();
+        $qubaidlist = implode(',', $qubaids);
+        echo html_writer::start_tag('form', array('method' => 'post',
+                'action' => $this->grade_question_url($slot, $questionid, $grade, $page),
+                'class' => 'mform', 'id' => 'manualgradingform')) .
+                html_writer::start_tag('div') .
+                html_writer::input_hidden_params(new moodle_url('', array(
+                'qubaids' => $qubaidlist, 'slots' => $slot, 'sesskey' => $sesskey)));
 
-                // Load the state for this attempt (The questions array was created earlier)
-                $states = get_question_states($questions, $quiz, $attempt);
-                // The $states array is indexed by question id but because we are dealing
-                // with only one question there is only one entry in this array
-                $state = &$states[$question->id];
+        foreach ($qubaids as $qubaid) {
+            $attempt = $attempts[$qubaid];
+            $quba = question_engine::load_questions_usage_by_activity($qubaid);
+            $displayoptions = quiz_get_review_options($this->quiz, $attempt, $this->context);
+            $displayoptions->hide_all_feedback();
+            $displayoptions->history = question_display_options::HIDDEN;
+            $displayoptions->manualcomment = question_display_options::EDITABLE;
 
-                $options = quiz_get_reviewoptions($quiz, $attempt, $context);
-                unset($options->questioncommentlink);
-                $options->noeditlink = true;
-                $copy = $state->manualcomment;
-                $state->manualcomment = '';
+            $heading = $this->get_question_heading($attempt, $shownames, $showidnumbers);
+            if ($heading) {
+                echo $OUTPUT->heading($heading, 4);
+            }
+            echo $quba->render_question($slot, $displayoptions, $this->questions[$slot]->number);
+        }
 
-                $options->readonly = 1;
+        echo html_writer::tag('div', html_writer::empty_tag('input', array(
+                'type' => 'submit', 'value' => get_string('saveandnext', 'quiz_grading'))),
+                array('class' => 'mdl-align')) .
+                html_writer::end_tag('div') . html_writer::end_tag('form');
+    }
 
-                $gradedclass = question_state_is_graded($state)?' class="highlightgraded" ':'';
-                $gradedstring = question_state_is_graded($state)?(' '.get_string('graded','quiz_grading')):'';
-                $a = new object();
-                $a->fullname = fullname($attempt, true);
+    protected function get_question_heading($attempt, $shownames, $showidnumbers) {
+        $a = new stdClass();
                 $a->attempt = $attempt->attempt;
+        $a->fullname = fullname($attempt);
+        $a->idnumber = $attempt->idnumber;
+
+        $showidnumbers &= !empty($attempt->idnumber);
+
+        if ($shownames && $showidnumbers) {
+            return get_string('gradingattemptwithidnumber', 'quiz_grading', $a);
+        } else if ($shownames) {
+            return get_string('gradingattempt', 'quiz_grading', $a);
+        } else if ($showidnumbers) {
+            $a->fullname = $attempt->idnumber;
+            return get_string('gradingattempt', 'quiz_grading', $a);
+        } else {
+            return '';
+        }
+    }
 
-                // print the user name, attempt count, the question, and some more hidden fields
-                echo '<div class="boxaligncenter" width="80%" style="clear:left;padding:15px;">';
-                echo "<span$gradedclass>".get_string('gradingattempt','quiz_grading', $a);
-                echo $gradedstring."</span>";
+    protected function validate_submitted_marks() {
 
-                print_question($question, $state, '', $quiz, $options);
+        $qubaids = optional_param('qubaids', null, PARAM_SEQUENCE);
+        if (!$qubaids) {
+            return false;
+        }
+        $qubaids = clean_param(explode(',', $qubaids), PARAM_INT);
 
-                $prefix = "manualgrades[$attempt->uniqueid]";
-                if (!question_state_is_graded($state)) {
-                    $grade = '';
+        $slots = optional_param('slots', '', PARAM_SEQUENCE);
+        if (!$slots) {
+            $slots = array();
                 } else {
-                    $grade = round($state->last_graded->grade, 3);
+            $slots = explode(',', $slots);
                 }
-                $state->manualcomment = $copy;
 
-                include($CFG->dirroot . '/question/comment.html');
-
-                echo '</div>';
+        foreach ($qubaids as $qubaid) {
+            foreach ($slots as $slot) {
+                $prefix = 'q' . $qubaid . ':' . $slot . '_';
+                $mark = optional_param($prefix . '-mark', null, PARAM_NUMBER);
+                $maxmark = optional_param($prefix . '-maxmark', null, PARAM_NUMBER);
+                $minfraction = optional_param($prefix . ':minfraction', null, PARAM_NUMBER);
+                if (!is_null($mark) && ($mark < $minfraction * $maxmark || $mark > $maxmark)) {
+                    return false;
             }
-            echo '<div class="boxaligncenter"><input type="submit" value="'.get_string('savechanges').'" /></div>'.
-                '</form>';
-
-            if ($usehtmleditor) {
-                use_html_editor();
             }
-        } else {
-            notify(get_string('noattemptstoshow', 'quiz'));
         }
+
+        return true;
     }
 
-    function attempts_sql($quizid, $wantstateevent=false, $questionid=0, $userid=0, $attemptid=0, $gradeungraded=0, $gradenextungraded=0){
-        global $CFG;
-        // this sql joins the attempts table and the user table
-        $select = 'SELECT qa.id AS attemptid, qa.uniqueid, qa.attempt, qa.timefinish, qa.preview,
-                    u.id AS userid, u.firstname, u.lastname, u.picture ';
-        if ($wantstateevent && $questionid){
-            $select .= ', qs.event ';
+    protected function process_submitted_data() {
+        global $DB;
+
+        $qubaids = optional_param('qubaids', null, PARAM_SEQUENCE);
+        if (!$qubaids) {
+            return;
         }
-        $from   = 'FROM '.$CFG->prefix.'user u, ' .
-                $CFG->prefix.'quiz_attempts qa ';
-        if (($wantstateevent|| $gradenextungraded || $gradeungraded) && $questionid){
-            $from .= "LEFT JOIN {$CFG->prefix}question_sessions qns " .
-                    "ON (qns.attemptid = qa.uniqueid AND qns.questionid = $questionid) ";
-            $from .=  "LEFT JOIN  {$CFG->prefix}question_states qs " .
-                    "ON (qs.id = qns.newgraded AND qs.question = $questionid) ";
+
+        $qubaids = clean_param(explode(',', $qubaids), PARAM_INT);
+        $attempts = $this->load_attempts_by_usage_ids($qubaids);
+
+        $transaction = $DB->start_delegated_transaction();
+        foreach ($qubaids as $qubaid) {
+            $attempt = $attempts[$qubaid];
+            $quba = question_engine::load_questions_usage_by_activity($qubaid);
+            $attemptobj = new quiz_attempt($attempt, $this->quiz, $this->cm, $this->course);
+            $attemptobj->process_all_actions(time());
         }
-        if ($gradenextungraded || $gradeungraded) { // get ungraded attempts
-            if ($this->userids) {
-                $where = 'WHERE u.id IN ('.$this->userids.')';
-            } else {
-                $where = 'WHERE u.id = u.id';
-            }
-            $where .= ' AND qs.event NOT IN ('.QUESTION_EVENTS_GRADED.') ';
-        } else if ($userid) { // get all the attempts for a specific user
-            $where = 'WHERE u.id='.$userid.' ';
-        } else if ($attemptid) { // get a specific attempt
-            $where = 'WHERE qa.id='.$attemptid.' ';
-        } else { // get all user attempts
-            if ($this->userids) {
-                $where = 'WHERE u.id IN ('.$this->userids.')';
-            } else {
-                $where = 'WHERE u.id = u.id';
+        $transaction->allow_commit();
             }
+
+    /**
+     * Load information about the number of attempts at various questions in each
+     * summarystate.
+     *
+     * The results are returned as an two dimensional array $qubaid => $slot => $dataobject
+     *
+     * @param array $slots A list of slots for the questions you want to konw about.
+     * @return array The array keys are slot,qestionid. The values are objects with
+     * fields $slot, $questionid, $inprogress, $name, $needsgrading, $autograded,
+     * $manuallygraded and $all.
+     */
+    protected function get_question_state_summary($slots) {
+        $dm = new question_engine_data_mapper();
+        return $dm->load_questions_usages_question_state_summary(
+                $this->get_qubaids_condition(), $slots);
         }
 
-        $where .= ' AND u.id = qa.userid AND qa.quiz = '.$quizid;
-        // ignore previews
-        $where .= ' AND preview = 0 ';
+    /**
+     * Get a list of usage ids where the question with slot $slot, and optionally
+     * also with question id $questionid, is in summary state $summarystate. Also
+     * return the total count of such states.
+     *
+     * Only a subset of the ids can be returned by using $orderby, $limitfrom and
+     * $limitnum. A special value 'random' can be passed as $orderby, in which case
+     * $limitfrom is ignored.
+     *
+     * @param int $slot The slot for the questions you want to konw about.
+     * @param int $questionid (optional) Only return attempts that were of this specific question.
+     * @param string $summarystate 'all', 'needsgrading', 'autograded' or 'manuallygraded'.
+     * @param string $orderby 'random', 'date', 'student' or 'idnumber'.
+     * @param int $page implements paging of the results.
+     *      Ignored if $orderby = random or $pagesize is null.
+     * @param int $pagesize implements paging of the results. null = all.
+     */
+    protected function get_usage_ids_where_question_in_state($summarystate, $slot,
+            $questionid = null, $orderby = 'random', $page = 0, $pagesize = null) {
+        global $CFG, $DB;
+        $dm = new question_engine_data_mapper();
+
+        if ($pagesize && $orderby != 'random') {
+            $limitfrom = $page * $pagesize;
+        } else {
+            $limitfrom = 0;
+        }
 
-        $where .= ' AND qa.timefinish != 0 ';
+        $qubaids = $this->get_qubaids_condition();
 
-        return array($select, $from, $where);
+        $params = array();
+        if ($orderby == 'date') {
+            list($statetest, $params) = $dm->in_summary_state_test(
+                    'manuallygraded', false, 'mangrstate');
+            $orderby = "(
+                    SELECT MAX(sortqas.timecreated)
+                    FROM {question_attempt_steps} sortqas
+                    WHERE sortqas.questionattemptid = qa.id
+                        AND sortqas.state $statetest
+                    )";
+        } else if ($orderby == 'student' || $orderby == 'idnumber') {
+            $qubaids->from .= " JOIN {user} u ON quiza.userid = u.id ";
+            if ($orderby == 'student') {
+                $orderby = $DB->sql_fullname('u.firstname', 'u.lastname');
+            }
     }
 
+        return $dm->load_questions_usages_where_question_in_state($qubaids, $summarystate,
+                $slot, $questionid, $orderby, $params, $limitfrom, $pagesize);
+    }
 }
-
-?>
