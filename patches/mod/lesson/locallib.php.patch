diff --git a/mod/lesson/locallib.php b/mod/lesson/locallib.php
index 76b51d4..0925fa0 100644
--- a/mod/lesson/locallib.php
+++ b/mod/lesson/locallib.php
@@ -1,1835 +1,2763 @@
-<?php // $Id$
+<?php
+
+// This file is part of Moodle - http://moodle.org/
+//
+// Moodle is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// Moodle is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
+
 /**
  * Local library file for Lesson.  These are non-standard functions that are used
  * only by Lesson.
  *
- * @version $Id$
- * @license http://www.gnu.org/copyleft/gpl.html GNU Public License
- * @package lesson
+ * @package    mod
+ * @subpackage lesson
+ * @copyright 1999 onwards Martin Dougiamas  {@link http://moodle.com}
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or late
  **/
 
-/**
-* Next page -> any page not seen before
-*/    
-if (!defined("LESSON_UNSEENPAGE")) {
-    define("LESSON_UNSEENPAGE", 1); // Next page -> any page not seen before
-}
-/**
-* Next page -> any page not answered correctly
-*/
-if (!defined("LESSON_UNANSWEREDPAGE")) {
-    define("LESSON_UNANSWEREDPAGE", 2); // Next page -> any page not answered correctly
-}
-
-/**
-* Define different lesson flows for next page
-*/
-$LESSON_NEXTPAGE_ACTION = array (0 => get_string("normal", "lesson"),
-                          LESSON_UNSEENPAGE => get_string("showanunseenpage", "lesson"),
-                          LESSON_UNANSWEREDPAGE => get_string("showanunansweredpage", "lesson") );
-
-// Lesson jump types defined
-//  TODO: instead of using define statements, create an array with all the jump values
+/** Make sure this isn't being directly accessed */
+defined('MOODLE_INTERNAL') || die();
+
+/** Include the files that are required by this module */
+require_once($CFG->dirroot.'/course/moodleform_mod.php');
+require_once($CFG->dirroot . '/mod/lesson/lib.php');
+require_once($CFG->libdir . '/filelib.php');
+
+/** This page */
+define('LESSON_THISPAGE', 0);
+/** Next page -> any page not seen before */
+define("LESSON_UNSEENPAGE", 1);
+/** Next page -> any page not answered correctly */
+define("LESSON_UNANSWEREDPAGE", 2);
+/** Jump to Next Page */
+define("LESSON_NEXTPAGE", -1);
+/** End of Lesson */
+define("LESSON_EOL", -9);
+/** Jump to an unseen page within a branch and end of branch or end of lesson */
+define("LESSON_UNSEENBRANCHPAGE", -50);
+/** Jump to Previous Page */
+define("LESSON_PREVIOUSPAGE", -40);
+/** Jump to a random page within a branch and end of branch or end of lesson */
+define("LESSON_RANDOMPAGE", -60);
+/** Jump to a random Branch */
+define("LESSON_RANDOMBRANCH", -70);
+/** Cluster Jump */
+define("LESSON_CLUSTERJUMP", -80);
+/** Undefined */
+define("LESSON_UNDEFINED", -99);
+
+/** LESSON_MAX_EVENT_LENGTH = 432000 ; 5 days maximum */
+define("LESSON_MAX_EVENT_LENGTH", "432000");
 
-/**
- * Jump to Next Page
- */
-if (!defined("LESSON_NEXTPAGE")) {
-    define("LESSON_NEXTPAGE", -1);
-}
-/**
- * End of Lesson
- */
-if (!defined("LESSON_EOL")) {
-    define("LESSON_EOL", -9);
-}
-/**
- * Jump to an unseen page within a branch and end of branch or end of lesson
- */
-if (!defined("LESSON_UNSEENBRANCHPAGE")) {
-    define("LESSON_UNSEENBRANCHPAGE", -50);
-}
-/**
- * Jump to Previous Page
- */
-if (!defined("LESSON_PREVIOUSPAGE")) {
-    define("LESSON_PREVIOUSPAGE", -40);
-}
-/**
- * Jump to a random page within a branch and end of branch or end of lesson
- */
-if (!defined("LESSON_RANDOMPAGE")) {
-    define("LESSON_RANDOMPAGE", -60);
-}
-/**
- * Jump to a random Branch
- */
-if (!defined("LESSON_RANDOMBRANCH")) {
-    define("LESSON_RANDOMBRANCH", -70);
-}
-/**
- * Cluster Jump
- */
-if (!defined("LESSON_CLUSTERJUMP")) {
-    define("LESSON_CLUSTERJUMP", -80);
-}
-/**
- * Undefined
- */    
-if (!defined("LESSON_UNDEFINED")) {
-    define("LESSON_UNDEFINED", -99);
-}
 
-// Lesson question types defined
+//////////////////////////////////////////////////////////////////////////////////////
+/// Any other lesson functions go here.  Each of them must have a name that
+/// starts with lesson_
 
 /**
- * Short answer question type
- */
-if (!defined("LESSON_SHORTANSWER")) {
-    define("LESSON_SHORTANSWER",   "1");
-}        
-/**
- * True/False question type
- */
-if (!defined("LESSON_TRUEFALSE")) {
-    define("LESSON_TRUEFALSE",     "2");
-}
-/**
- * Multichoice question type
+ * Checks to see if a LESSON_CLUSTERJUMP or
+ * a LESSON_UNSEENBRANCHPAGE is used in a lesson.
  *
- * If you change the value of this then you need 
- * to change it in restorelib.php as well.
- */
-if (!defined("LESSON_MULTICHOICE")) {
-    define("LESSON_MULTICHOICE",   "3");
-}
-/**
- * Random question type - not used
- */
-if (!defined("LESSON_RANDOM")) {
-    define("LESSON_RANDOM",        "4");
-}
-/**
- * Matching question type
+ * This function is only executed when a teacher is
+ * checking the navigation for a lesson.
  *
- * If you change the value of this then you need
- * to change it in restorelib.php, in mysql.php 
- * and postgres7.php as well.
- */
-if (!defined("LESSON_MATCHING")) {
-    define("LESSON_MATCHING",      "5");
-}
-/**
- * Not sure - not used
- */
-if (!defined("LESSON_RANDOMSAMATCH")) {
-    define("LESSON_RANDOMSAMATCH", "6");
-}
-/**
- * Not sure - not used
- */
-if (!defined("LESSON_DESCRIPTION")) {
-    define("LESSON_DESCRIPTION",   "7");
-}
-/**
- * Numerical question type
- */
-if (!defined("LESSON_NUMERICAL")) {
-    define("LESSON_NUMERICAL",     "8");
-}
-/**
- * Multichoice with multianswer question type
- */
-if (!defined("LESSON_MULTIANSWER")) {
-    define("LESSON_MULTIANSWER",   "9");
-}
-/**
- * Essay question type
- */
-if (!defined("LESSON_ESSAY")) {
-    define("LESSON_ESSAY", "10");
-}
-
-/**
- * Lesson question type array.
- * Contains all question types used
- */
-$LESSON_QUESTION_TYPE = array ( LESSON_MULTICHOICE => get_string("multichoice", "quiz"),
-                              LESSON_TRUEFALSE     => get_string("truefalse", "quiz"),
-                              LESSON_SHORTANSWER   => get_string("shortanswer", "quiz"),
-                              LESSON_NUMERICAL     => get_string("numerical", "quiz"),
-                              LESSON_MATCHING      => get_string("match", "quiz"),
-                              LESSON_ESSAY           => get_string("essay", "lesson")
-//                            LESSON_DESCRIPTION   => get_string("description", "quiz"),
-//                            LESSON_RANDOM        => get_string("random", "quiz"),
-//                            LESSON_RANDOMSAMATCH => get_string("randomsamatch", "quiz"),
-//                            LESSON_MULTIANSWER   => get_string("multianswer", "quiz"),
-                              );
-
-// Non-question page types
-
-/**
- * Branch Table page
- */
-if (!defined("LESSON_BRANCHTABLE")) {
-    define("LESSON_BRANCHTABLE",   "20");
-}
-/**
- * End of Branch page
- */
-if (!defined("LESSON_ENDOFBRANCH")) {
-    define("LESSON_ENDOFBRANCH",   "21");
-}
-/**
- * Start of Cluster page
- */
-if (!defined("LESSON_CLUSTER")) {
-    define("LESSON_CLUSTER",   "30");
-}
-/**
- * End of Cluster page
- */
-if (!defined("LESSON_ENDOFCLUSTER")) {
-    define("LESSON_ENDOFCLUSTER",   "31");
-}
+ * @param stdClass $lesson Id of the lesson that is to be checked.
+ * @return boolean True or false.
+ **/
+function lesson_display_teacher_warning($lesson) {
+    global $DB;
 
-// other variables...
+    // get all of the lesson answers
+    $params = array ("lessonid" => $lesson->id);
+    if (!$lessonanswers = $DB->get_records_select("lesson_answers", "lessonid = :lessonid", $params)) {
+        // no answers, then not using cluster or unseen
+        return false;
+    }
+    // just check for the first one that fulfills the requirements
+    foreach ($lessonanswers as $lessonanswer) {
+        if ($lessonanswer->jumpto == LESSON_CLUSTERJUMP || $lessonanswer->jumpto == LESSON_UNSEENBRANCHPAGE) {
+            return true;
+        }
+    }
 
-/**
- * Flag for the editor for the answer textarea.
- */
-if (!defined("LESSON_ANSWER_EDITOR")) {
-    define("LESSON_ANSWER_EDITOR",   "1");
-}
-/**
- * Flag for the editor for the response textarea.
- */
-if (!defined("LESSON_RESPONSE_EDITOR")) {
-    define("LESSON_RESPONSE_EDITOR",   "2");
+    // if no answers use either of the two jumps
+    return false;
 }
 
-//////////////////////////////////////////////////////////////////////////////////////
-/// Any other lesson functions go here.  Each of them must have a name that 
-/// starts with lesson_
-
 /**
- * Print the standard header for lesson module
- *
- * @uses $CFG
- * @uses $USER
- * @param object $cm Course module record object
- * @param object $course Couse record object
- * @param object $lesson Lesson module record object
- * @param string $currenttab Current tab for the lesson tabs
- * @return boolean
+ * Interprets the LESSON_UNSEENBRANCHPAGE jump.
+ *
+ * will return the pageid of a random unseen page that is within a branch
+ *
+ * @param lesson $lesson
+ * @param int $userid Id of the user.
+ * @param int $pageid Id of the page from which we are jumping.
+ * @return int Id of the next page.
  **/
-function lesson_print_header($cm, $course, $lesson, $currenttab = '') {
-    global $CFG, $USER;
-
-    $strlesson = get_string('modulename', 'lesson');
-    $strname   = format_string($lesson->name, true, $course->id);
-
-    $context = get_context_instance(CONTEXT_MODULE, $cm->id);
+function lesson_unseen_question_jump($lesson, $user, $pageid) {
+    global $DB;
 
-    if (has_capability('mod/lesson:edit', $context)) {
-        $button = update_module_button($cm->id, $course->id, $strlesson);
-    } else {
-        $button = '';
+    // get the number of retakes
+    if (!$retakes = $DB->count_records("lesson_grades", array("lessonid"=>$lesson->id, "userid"=>$user))) {
+        $retakes = 0;
     }
 
-/// Header setup
-    $navigation = build_navigation('', $cm);
-    
-/// Print header, heading, tabs and messages
-    print_header("$course->shortname: $strname", $course->fullname, $navigation,
-                  '', '', true, $button, navmenu($course, $cm));
-
-    if (has_capability('mod/lesson:manage', $context)) {
-        print_heading_with_help($strname, "overview", "lesson");
-
-        if (!empty($currenttab)) {
-            include($CFG->dirroot.'/mod/lesson/tabs.php');
+    // get all the lesson_attempts aka what the user has seen
+    if ($viewedpages = $DB->get_records("lesson_attempts", array("lessonid"=>$lesson->id, "userid"=>$user, "retry"=>$retakes), "timeseen DESC")) {
+        foreach($viewedpages as $viewed) {
+            $seenpages[] = $viewed->pageid;
         }
     } else {
-        print_heading($strname);
+        $seenpages = array();
     }
 
-    lesson_print_messages();
-
-    return true;
-}
+    // get the lesson pages
+    $lessonpages = $lesson->load_all_pages();
 
-/**
- * Returns course module, course and module instance given 
- * either the course module ID or a lesson module ID.
- *
- * @param int $cmid Course Module ID
- * @param int $lessonid Lesson module instance ID
- * @return array array($cm, $course, $lesson)
- **/
-function lesson_get_basics($cmid = 0, $lessonid = 0) {
-    if ($cmid) {
-        if (!$cm = get_coursemodule_from_id('lesson', $cmid)) {
-            error('Course Module ID was incorrect');
+    if ($pageid == LESSON_UNSEENBRANCHPAGE) {  // this only happens when a student leaves in the middle of an unseen question within a branch series
+        $pageid = $seenpages[0];  // just change the pageid to the last page viewed inside the branch table
         }
-        if (!$course = get_record('course', 'id', $cm->course)) {
-            error('Course is misconfigured');
+
+    // go up the pages till branch table
+    while ($pageid != 0) { // this condition should never be satisfied... only happens if there are no branch tables above this page
+        if ($lessonpages[$pageid]->qtype == LESSON_PAGE_BRANCHTABLE) {
+            break;
         }
-        if (!$lesson = get_record('lesson', 'id', $cm->instance)) {
-            error('Course module is incorrect');
+        $pageid = $lessonpages[$pageid]->prevpageid;
         }
-    } else if ($lessonid) {
-        if (!$lesson = get_record('lesson', 'id', $lessonid)) {
-            error('Course module is incorrect');
+
+    $pagesinbranch = $lesson->get_sub_pages_of($pageid, array(LESSON_PAGE_BRANCHTABLE, LESSON_PAGE_ENDOFBRANCH));
+
+    // this foreach loop stores all the pages that are within the branch table but are not in the $seenpages array
+    $unseen = array();
+    foreach($pagesinbranch as $page) {
+        if (!in_array($page->id, $seenpages)) {
+            $unseen[] = $page->id;
         }
-        if (!$course = get_record('course', 'id', $lesson->course)) {
-            error('Course is misconfigured');
         }
-        if (!$cm = get_coursemodule_from_instance('lesson', $lesson->id, $course->id)) {
-            error('Course Module ID was incorrect');
+
+    if(count($unseen) == 0) {
+        if(isset($pagesinbranch)) {
+            $temp = end($pagesinbranch);
+            $nextpage = $temp->nextpageid; // they have seen all the pages in the branch, so go to EOB/next branch table/EOL
+        } else {
+            // there are no pages inside the branch, so return the next page
+            $nextpage = $lessonpages[$pageid]->nextpageid;
         }
+        if ($nextpage == 0) {
+            return LESSON_EOL;
     } else {
-        error('No course module ID or lesson ID were passed');
+            return $nextpage;
     }
-    
-    return array($cm, $course, $lesson);
-}
-
-/**
- * Sets a message to be printed.  Messages are printed
- * by calling {@link lesson_print_messages()}.
- *
- * @uses $SESSION
- * @param string $message The message to be printed
- * @param string $class Class to be passed to {@link notify()}.  Usually notifyproblem or notifysuccess.
- * @param string $align Alignment of the message
- * @return boolean
- **/
-function lesson_set_message($message, $class="notifyproblem", $align='center') {
-    global $SESSION;
-    
-    if (empty($SESSION->lesson_messages) or !is_array($SESSION->lesson_messages)) {
-        $SESSION->lesson_messages = array();
+    } else {
+        return $unseen[rand(0, count($unseen)-1)];  // returns a random page id for the next page
     }
-    
-    $SESSION->lesson_messages[] = array($message, $class, $align);
-    
-    return true;
 }
 
 /**
- * Print all set messages.
- *
- * See {@link lesson_set_message()} for setting messages.
- *
- * Uses {@link notify()} to print the messages.
+ * Handles the unseen branch table jump.
  *
- * @uses $SESSION
- * @return boolean
+ * @param lesson $lesson
+ * @param int $userid User id.
+ * @return int Will return the page id of a branch table or end of lesson
  **/
-function lesson_print_messages() {
-    global $SESSION;
+function lesson_unseen_branch_jump($lesson, $userid) {
+    global $DB;
     
-    if (empty($SESSION->lesson_messages)) {
-        // No messages to print
-        return true;
+    if (!$retakes = $DB->count_records("lesson_grades", array("lessonid"=>$lesson->id, "userid"=>$userid))) {
+        $retakes = 0;
     }
     
-    foreach($SESSION->lesson_messages as $message) {
-        notify($message[0], $message[1], $message[2]);
+    $params = array ("lessonid" => $lesson->id, "userid" => $userid, "retry" => $retakes);
+    if (!$seenbranches = $DB->get_records_select("lesson_branch", "lessonid = :lessonid AND userid = :userid AND retry = :retry", $params,
+                "timeseen DESC")) {
+        print_error('cannotfindrecords', 'lesson');
     }
     
-    // Reset
-    unset($SESSION->lesson_messages);
-    
-    return true;
-}
+    // get the lesson pages
+    $lessonpages = $lesson->load_all_pages();
 
-/**
- * Prints a lesson link that submits a form.
- *
- * If Javascript is disabled, then a regular submit button is printed
- *
- * @param string $name Name of the link or button
- * @param string $form The name of the form to be submitted
- * @param string $align Alignment of the button
- * @param string $class Class names to add to the div wrapper
- * @param string $title Title for the link (Not used if javascript is disabled)
- * @param string $id ID tag
- * @param boolean $return Return flag
- * @return mixed boolean/html
- **/
-function lesson_print_submit_link($name, $form, $align = 'center', $class='standardbutton', $title = '', $id = '', $return = false) {
-    if (!empty($align)) {
-        $align = " style=\"text-align:$align\"";
+    // this loads all the viewed branch tables into $seen until it finds the branch table with the flag
+    // which is the branch table that starts the unseenbranch function
+    $seen = array();
+    foreach ($seenbranches as $seenbranch) {
+        if (!$seenbranch->flag) {
+            $seen[$seenbranch->pageid] = $seenbranch->pageid;
+        } else {
+            $start = $seenbranch->pageid;
+            break;
     }
-    if (!empty($id)) {
-        $id = " id=\"$id\"";
     }
-    if (empty($title)) {
-        $title = $name;
+    // this function searches through the lesson pages to find all the branch tables
+    // that follow the flagged branch table
+    $pageid = $lessonpages[$start]->nextpageid; // move down from the flagged branch table
+    while ($pageid != 0) {  // grab all of the branch table till eol
+        if ($lessonpages[$pageid]->qtype == LESSON_PAGE_BRANCHTABLE) {
+            $branchtables[] = $lessonpages[$pageid]->id;
     }
-
-    $output = "<div class=\"lessonbutton $class\" $align>\n";
-    $output .= "<input type=\"submit\" value=\"$name\" $align $id />";
-    $output .= "</div>\n";
-    
-    if ($return) {
-        return $output;
-    } else {
-        echo $output;
-        return true;
+        $pageid = $lessonpages[$pageid]->nextpageid;
     }
-}
-
-/**
- * Prints a time remaining in the following format: H:MM:SS
- *
- * @param int $starttime Time when the lesson started
- * @param int $maxtime Length of the lesson
- * @param boolean $return Return output switch
- * @return mixed boolean/string
- **/
-function lesson_print_time_remaining($starttime, $maxtime, $return = false) {
-    // Calculate hours, minutes and seconds
-    $timeleft = $starttime + $maxtime * 60 - time();
-    $hours = floor($timeleft/3600);
-    $timeleft = $timeleft - ($hours * 3600);
-    $minutes = floor($timeleft/60);
-    $secs = $timeleft - ($minutes * 60);
-    
-    if ($minutes < 10) {
-        $minutes = "0$minutes";
+    $unseen = array();
+    foreach ($branchtables as $branchtable) {
+        // load all of the unseen branch tables into unseen
+        if (!array_key_exists($branchtable, $seen)) {
+            $unseen[] = $branchtable;
     }
-    if ($secs < 10) {
-        $secs = "0$secs";
     }
-    $output   = array();
-    $output[] = $hours;
-    $output[] = $minutes;
-    $output[] = $secs;
-    
-    $output = implode(':', $output);
-    
-    if ($return) {
-        return $output;
+    if (count($unseen) > 0) {
+        return $unseen[rand(0, count($unseen)-1)];  // returns a random page id for the next page
     } else {
-        echo $output;
-        return true;
+        return LESSON_EOL;  // has viewed all of the branch tables
     }
 }
 
 /**
- * Prints the page action buttons
- *
- * Move/Edit/Preview/Delete
+ * Handles the random jump between a branch table and end of branch or end of lesson (LESSON_RANDOMPAGE).
  *
- * @uses $CFG
- * @param int $cmid Course Module ID
- * @param object $page Page record
- * @param boolean $printmove Flag to print the move button or not
- * @param boolean $printaddpage Flag to print the add page drop-down or not
- * @param boolean $return Return flag
- * @return mixed boolean/string
+ * @param lesson $lesson
+ * @param int $pageid The id of the page that we are jumping from (?)
+ * @return int The pageid of a random page that is within a branch table
  **/
-function lesson_print_page_actions($cmid, $page, $printmove, $printaddpage = false, $return = false) {
-    global $CFG;
-    
-    $context = get_context_instance(CONTEXT_MODULE, $cmid);
-    $actions = array();
+function lesson_random_question_jump($lesson, $pageid) {
+    global $DB;
     
-    if (has_capability('mod/lesson:edit', $context)) {
-        if ($printmove) {
-            $actions[] = "<a title=\"".get_string('move')."\" href=\"$CFG->wwwroot/mod/lesson/lesson.php?id=$cmid&amp;action=move&amp;pageid=$page->id\">
-                          <img src=\"$CFG->pixpath/t/move.gif\" class=\"iconsmall\" alt=\"".get_string('move')."\" /></a>\n";
+    // get the lesson pages
+    $params = array ("lessonid" => $lesson->id);
+    if (!$lessonpages = $DB->get_records_select("lesson_pages", "lessonid = :lessonid", $params)) {
+        print_error('cannotfindpages', 'lesson');
         }
-        $actions[] = "<a title=\"".get_string('update')."\" href=\"$CFG->wwwroot/mod/lesson/lesson.php?id=$cmid&amp;action=editpage&amp;pageid=$page->id\">
-                      <img src=\"$CFG->pixpath/t/edit.gif\" class=\"iconsmall\" alt=\"".get_string('update')."\" /></a>\n";
         
-        $actions[] = "<a title=\"".get_string('preview')."\" href=\"$CFG->wwwroot/mod/lesson/view.php?id=$cmid&amp;pageid=$page->id\">
-                      <img src=\"$CFG->pixpath/t/preview.gif\" class=\"iconsmall\" alt=\"".get_string('preview')."\" /></a>\n";
-        
-        $actions[] = "<a title=\"".get_string('delete')."\" href=\"$CFG->wwwroot/mod/lesson/lesson.php?id=$cmid&amp;sesskey=".sesskey()."&amp;action=confirmdelete&amp;pageid=$page->id\">
-                      <img src=\"$CFG->pixpath/t/delete.gif\" class=\"iconsmall\" alt=\"".get_string('delete')."\" /></a>\n";
-        
-        if ($printaddpage) {
-            // Add page drop-down
-            $options = array();
-            $options['addcluster&amp;sesskey='.sesskey()]      = get_string('clustertitle', 'lesson');
-            $options['addendofcluster&amp;sesskey='.sesskey()] = get_string('endofclustertitle', 'lesson');
-            $options['addbranchtable']                         = get_string('branchtable', 'lesson');
-            $options['addendofbranch&amp;sesskey='.sesskey()]  = get_string('endofbranch', 'lesson');
-            $options['addpage']                                = get_string('question', 'lesson');
-            // Base url
-            $common = "$CFG->wwwroot/mod/lesson/lesson.php?id=$cmid&amp;pageid=$page->id&amp;action=";
+    // go up the pages till branch table
+    while ($pageid != 0) { // this condition should never be satisfied... only happens if there are no branch tables above this page
         
-            $actions[] = popup_form($common, $options, "addpage_$page->id", '', get_string('addpage', 'lesson').'...', '', '', true);
+        if ($lessonpages[$pageid]->qtype == LESSON_PAGE_BRANCHTABLE) {
+            break;
         }
+        $pageid = $lessonpages[$pageid]->prevpageid;
     }
     
-    $actions = implode(' ', $actions);
+    // get the pages within the branch
+    $pagesinbranch = $lesson->get_sub_pages_of($pageid, array(LESSON_PAGE_BRANCHTABLE, LESSON_PAGE_ENDOFBRANCH));
     
-    if ($return) {
-        return $actions;
+    if(count($pagesinbranch) == 0) {
+        // there are no pages inside the branch, so return the next page
+        return $lessonpages[$pageid]->nextpageid;
     } else {
-        echo $actions;
-        return false;
+        return $pagesinbranch[rand(0, count($pagesinbranch)-1)]->id;  // returns a random page id for the next page
     }
 }
 
 /**
- * Prints the add links in expanded view or single view when editing
- *
- * @uses $CFG
- * @param int $cmid Course Module ID
- * @param int $prevpageid Previous page id
- * @param boolean $return Return flag
- * @return mixed boolean/string
- * @todo &amp;pageid does not make sense, it is prevpageid
- **/
-function lesson_print_add_links($cmid, $prevpageid, $return = false) {
-    global $CFG;
-    
-    $context = get_context_instance(CONTEXT_MODULE, $cmid);
+ * Calculates a user's grade for a lesson.
+ *
+ * @param object $lesson The lesson that the user is taking.
+ * @param int $retries The attempt number.
+ * @param int $userid Id of the user (optional, default current user).
+ * @return object { nquestions => number of questions answered
+                    attempts => number of question attempts
+                    total => max points possible
+                    earned => points earned by student
+                    grade => calculated percentage grade
+                    nmanual => number of manually graded questions
+                    manualpoints => point value for manually graded questions }
+ */
+function lesson_grade($lesson, $ntries, $userid = 0) {
+    global $USER, $DB;
     
-    $links = '';
-    if (has_capability('mod/lesson:edit', $context)) {
-        $links = array();
-        $links[] = "<a href=\"$CFG->wwwroot/mod/lesson/import.php?id=$cmid&amp;pageid=$prevpageid\">".
-                    get_string('importquestions', 'lesson').'</a>';
+    if (empty($userid)) {
+        $userid = $USER->id;
+    }
         
-        $links[] = "<a href=\"$CFG->wwwroot/mod/lesson/lesson.php?id=$cmid&amp;sesskey=".sesskey()."&amp;action=addcluster&amp;pageid=$prevpageid\">".
-                    get_string('addcluster', 'lesson').'</a>';
+    // Zero out everything
+    $ncorrect     = 0;
+    $nviewed      = 0;
+    $score        = 0;
+    $nmanual      = 0;
+    $manualpoints = 0;
+    $thegrade     = 0;
+    $nquestions   = 0;
+    $total        = 0;
+    $earned       = 0;
         
-        if ($prevpageid != 0) {
-            $links[] = "<a href=\"$CFG->wwwroot/mod/lesson/lesson.php?id=$cmid&amp;sesskey=".sesskey()."&amp;action=addendofcluster&amp;pageid=$prevpageid\">".
-                        get_string('addendofcluster', 'lesson').'</a>';
+    $params = array ("lessonid" => $lesson->id, "userid" => $userid, "retry" => $ntries);
+    if ($useranswers = $DB->get_records_select("lesson_attempts",  "lessonid = :lessonid AND
+            userid = :userid AND retry = :retry", $params, "timeseen")) {
+        // group each try with its page
+        $attemptset = array();
+        foreach ($useranswers as $useranswer) {
+            $attemptset[$useranswer->pageid][] = $useranswer;
         }
-        $links[] = "<a href=\"$CFG->wwwroot/mod/lesson/lesson.php?id=$cmid&amp;action=addbranchtable&amp;pageid=$prevpageid\">".
-                    get_string('addabranchtable', 'lesson').'</a>';
         
-        if ($prevpageid != 0) {
-            $links[] = "<a href=\"$CFG->wwwroot/mod/lesson/lesson.php?id=$cmid&amp;sesskey=".sesskey()."&amp;action=addendofbranch&amp;pageid=$prevpageid\">".
-                        get_string('addanendofbranch', 'lesson').'</a>';
+        // Drop all attempts that go beyond max attempts for the lesson
+        foreach ($attemptset as $key => $set) {
+            $attemptset[$key] = array_slice($set, 0, $lesson->maxattempts);
         }
         
-        $links[] = "<a href=\"$CFG->wwwroot/mod/lesson/lesson.php?id=$cmid&amp;action=addpage&amp;pageid=$prevpageid\">".
-                    get_string('addaquestionpagehere', 'lesson').'</a>';
+        // get only the pages and their answers that the user answered
+        list($usql, $parameters) = $DB->get_in_or_equal(array_keys($attemptset));
+        array_unshift($parameters, $lesson->id);
+        $pages = $DB->get_records_select("lesson_pages", "lessonid = ? AND id $usql", $parameters);
+        $answers = $DB->get_records_select("lesson_answers", "lessonid = ? AND pageid $usql", $parameters);
+
+        // Number of pages answered
+        $nquestions = count($pages);
         
-        $links = implode(" | \n", $links);
-        $links = "\n<div class=\"addlinks\">\n$links\n</div>\n";
+        foreach ($attemptset as $attempts) {
+            $page = lesson_page::load($pages[end($attempts)->pageid], $lesson);
+            if ($lesson->custom) {
+                $attempt = end($attempts);
+                // If essay question, handle it, otherwise add to score
+                if ($page->requires_manual_grading()) {
+                    $useranswerobj = unserialize($attempt->useranswer);
+                    if (isset($useranswerobj->score)) {
+                        $earned += $useranswerobj->score;
+                    }
+                    $nmanual++;
+                    $manualpoints += $answers[$attempt->answerid]->score;
+                } else if (!empty($attempt->answerid)) {
+                    $earned += $page->earned_score($answers, $attempt);
+                }
+            } else {
+                foreach ($attempts as $attempt) {
+                    $earned += $attempt->correct;
+                }
+                $attempt = end($attempts); // doesn't matter which one
+                // If essay question, increase numbers
+                if ($page->requires_manual_grading()) {
+                    $nmanual++;
+                    $manualpoints++;
+                }
+            }
+            // Number of times answered
+            $nviewed += count($attempts);
     }
 
-    if ($return) {
-        return $links;
+        if ($lesson->custom) {
+            $bestscores = array();
+            // Find the highest possible score per page to get our total
+            foreach ($answers as $answer) {
+                if(!isset($bestscores[$answer->pageid])) {
+                    $bestscores[$answer->pageid] = $answer->score;
+                } else if ($bestscores[$answer->pageid] < $answer->score) {
+                    $bestscores[$answer->pageid] = $answer->score;
+                }
+            }
+            $total = array_sum($bestscores);
     } else {
-        echo $links;
-        return true;
+            // Check to make sure the student has answered the minimum questions
+            if ($lesson->minquestions and $nquestions < $lesson->minquestions) {
+                // Nope, increase number viewed by the amount of unanswered questions
+                $total =  $nviewed + ($lesson->minquestions - $nquestions);
+            } else {
+                $total = $nviewed;
+            }
+        }
     }
-}
 
-/**
- * Returns the string for a page type
- *
- * @uses $LESSON_QUESTION_TYPE
- * @param int $qtype Page type
- * @return string
- **/
-function lesson_get_qtype_name($qtype) {
-    global $LESSON_QUESTION_TYPE;
-    switch ($qtype) {
-        case LESSON_ESSAY :
-        case LESSON_SHORTANSWER :
-        case LESSON_MULTICHOICE :
-        case LESSON_MATCHING :
-        case LESSON_TRUEFALSE :
-        case LESSON_NUMERICAL :
-            return $LESSON_QUESTION_TYPE[$qtype];
-            break;
-        case LESSON_BRANCHTABLE :    
-            return get_string("branchtable", "lesson");
-            break;
-        case LESSON_ENDOFBRANCH :
-            return get_string("endofbranch", "lesson");
-            break;
-        case LESSON_CLUSTER :
-            return get_string("clustertitle", "lesson");
-            break;
-        case LESSON_ENDOFCLUSTER :
-            return get_string("endofclustertitle", "lesson");
-            break;
-        default:
-            return '';
-            break;
+    if ($total) { // not zero
+        $thegrade = round(100 * $earned / $total, 5);
     }
+
+    // Build the grade information object
+    $gradeinfo               = new stdClass;
+    $gradeinfo->nquestions   = $nquestions;
+    $gradeinfo->attempts     = $nviewed;
+    $gradeinfo->total        = $total;
+    $gradeinfo->earned       = $earned;
+    $gradeinfo->grade        = $thegrade;
+    $gradeinfo->nmanual      = $nmanual;
+    $gradeinfo->manualpoints = $manualpoints;
+
+    return $gradeinfo;
 }
 
 /**
- * Returns the string for a jump name
+ * Determines if a user can view the left menu.  The determining factor
+ * is whether a user has a grade greater than or equal to the lesson setting
+ * of displayleftif
  *
- * @param int $jumpto Jump code or page ID
- * @return string
+ * @param object $lesson Lesson object of the current lesson
+ * @return boolean 0 if the user cannot see, or $lesson->displayleft to keep displayleft unchanged
  **/
-function lesson_get_jump_name($jumpto) {
-    if ($jumpto == 0) {
-        $jumptitle = get_string('thispage', 'lesson');
-    } elseif ($jumpto == LESSON_NEXTPAGE) {
-        $jumptitle = get_string('nextpage', 'lesson');
-    } elseif ($jumpto == LESSON_EOL) {
-        $jumptitle = get_string('endoflesson', 'lesson');
-    } elseif ($jumpto == LESSON_UNSEENBRANCHPAGE) {
-        $jumptitle = get_string('unseenpageinbranch', 'lesson');
-    } elseif ($jumpto == LESSON_PREVIOUSPAGE) {
-        $jumptitle = get_string('previouspage', 'lesson');
-    } elseif ($jumpto == LESSON_RANDOMPAGE) {
-        $jumptitle = get_string('randompageinbranch', 'lesson');
-    } elseif ($jumpto == LESSON_RANDOMBRANCH) {
-        $jumptitle = get_string('randombranch', 'lesson');
-    } elseif ($jumpto == LESSON_CLUSTERJUMP) {
-        $jumptitle = get_string('clusterjump', 'lesson');
+function lesson_displayleftif($lesson) {
+    global $CFG, $USER, $DB;
+
+    if (!empty($lesson->displayleftif)) {
+        // get the current user's max grade for this lesson
+        $params = array ("userid" => $USER->id, "lessonid" => $lesson->id);
+        if ($maxgrade = $DB->get_record_sql('SELECT userid, MAX(grade) AS maxgrade FROM {lesson_grades} WHERE userid = :userid AND lessonid = :lessonid GROUP BY userid', $params)) {
+            if ($maxgrade->maxgrade < $lesson->displayleftif) {
+                return 0;  // turn off the displayleft
+            }
     } else {
-        if (!$jumptitle = get_field('lesson_pages', 'title', 'id', $jumpto)) {
-            $jumptitle = '<strong>'.get_string('notdefined', 'lesson').'</strong>';
+            return 0; // no grades
         }
     }
     
-    return format_string($jumptitle,true);
+    // if we get to here, keep the original state of displayleft lesson setting
+    return $lesson->displayleft;
 }
 
 /**
- * Given some question info and some data about the the answers
- * this function parses, organises and saves the question
- *
- * This is only used when IMPORTING questions and is only called
- * from format.php
- * Lifted from mod/quiz/lib.php - 
- *    1. all reference to oldanswers removed
- *    2. all reference to quiz_multichoice table removed
- *    3. In SHORTANSWER questions usecase is store in the qoption field
- *    4. In NUMERIC questions store the range as two answers
- *    5. TRUEFALSE options are ignored
- *    6. For MULTICHOICE questions with more than one answer the qoption field is true
- * 
- * @param opject $question Contains question data like question, type and answers.
- * @return object Returns $result->error or $result->notice.
- **/
-function lesson_save_question_options($question) {
-    
-    $timenow = time();
-    switch ($question->qtype) {
-        case LESSON_SHORTANSWER:
+ *
+ * @param $cm
+ * @param $lesson
+ * @param $page
+ * @return unknown_type
+ */
+function lesson_add_fake_blocks($page, $cm, $lesson, $timer = null) {
+    $bc = lesson_menu_block_contents($cm->id, $lesson);
+    if (!empty($bc)) {
+        $regions = $page->blocks->get_regions();
+        $firstregion = reset($regions);
+        $page->blocks->add_fake_block($bc, $firstregion);
+    }
 
-            $answers = array();
-            $maxfraction = -1;
-
-            // Insert all the new answers
-            foreach ($question->answer as $key => $dataanswer) {
-                if ($dataanswer != "") {
-                    $answer = new stdClass;
-                    $answer->lessonid   = $question->lessonid;
-                    $answer->pageid   = $question->id;
-                    if ($question->fraction[$key] >=0.5) {
-                        $answer->jumpto = LESSON_NEXTPAGE;
-                    }
-                    $answer->timecreated   = $timenow;
-                    $answer->grade = $question->fraction[$key] * 100;
-                    $answer->answer   = $dataanswer;
-                    $answer->response = $question->feedback[$key];
-                    if (!$answer->id = insert_record("lesson_answers", $answer)) {
-                        $result->error = "Could not insert shortanswer quiz answer!";
-                        return $result;
+    $bc = lesson_mediafile_block_contents($cm->id, $lesson);
+    if (!empty($bc)) {
+        $page->blocks->add_fake_block($bc, $page->blocks->get_default_region());
                     }
-                    $answers[] = $answer->id;
-                    if ($question->fraction[$key] > $maxfraction) {
-                        $maxfraction = $question->fraction[$key];
+
+    if (!empty($timer)) {
+        $bc = lesson_clock_block_contents($cm->id, $lesson, $timer, $page);
+        if (!empty($bc)) {
+            $page->blocks->add_fake_block($bc, $page->blocks->get_default_region());
                     }
                 }
+}
+
+/**
+ * If there is a media file associated with this
+ * lesson, return a block_contents that displays it.
+ *
+ * @param int $cmid Course Module ID for this lesson
+ * @param object $lesson Full lesson record object
+ * @return block_contents
+ **/
+function lesson_mediafile_block_contents($cmid, $lesson) {
+    global $OUTPUT;
+    if (empty($lesson->mediafile)) {
+        return null;
             }
 
+    $options = array();
+    $options['menubar'] = 0;
+    $options['location'] = 0;
+    $options['left'] = 5;
+    $options['top'] = 5;
+    $options['scrollbars'] = 1;
+    $options['resizable'] = 1;
+    $options['width'] = $lesson->mediawidth;
+    $options['height'] = $lesson->mediaheight;
+
+    $link = new moodle_url('/mod/lesson/mediafile.php?id='.$cmid);
+    $action = new popup_action('click', $link, 'lessonmediafile', $options);
+    $content = $OUTPUT->action_link($link, get_string('mediafilepopup', 'lesson'), $action, array('title'=>get_string('mediafilepopup', 'lesson')));
+
+    $bc = new block_contents();
+    $bc->title = get_string('linkedmedia', 'lesson');
+    $bc->attributes['class'] = 'mediafile';
+    $bc->content = $content;
+
+    return $bc;
+}
 
-            /// Perform sanity checks on fractional grades
-            if ($maxfraction != 1) {
-                $maxfraction = $maxfraction * 100;
-                $result->notice = get_string("fractionsnomax", "quiz", $maxfraction);
-                return $result;
+/**
+ * If a timed lesson and not a teacher, then
+ * return a block_contents containing the clock.
+ *
+ * @param int $cmid Course Module ID for this lesson
+ * @param object $lesson Full lesson record object
+ * @param object $timer Full timer record object
+ * @return block_contents
+ **/
+function lesson_clock_block_contents($cmid, $lesson, $timer, $page) {
+    // Display for timed lessons and for students only
+    $context = get_context_instance(CONTEXT_MODULE, $cmid);
+    if(!$lesson->timed || has_capability('mod/lesson:manage', $context)) {
+        return null;
             }
-            break;
 
-        case LESSON_NUMERICAL:   // Note similarities to SHORTANSWER
+    $content = '<div class="jshidewhenenabled">';
+    $content .=  $lesson->time_remaining($timer->starttime);
+    $content .= '</div>';
 
-            $answers = array();
-            $maxfraction = -1;
-
-            
-            // for each answer store the pair of min and max values even if they are the same 
-            foreach ($question->answer as $key => $dataanswer) {
-                if ($dataanswer != "") {
-                    $answer = new stdClass;
-                    $answer->lessonid   = $question->lessonid;
-                    $answer->pageid   = $question->id;
-                    $answer->jumpto = LESSON_NEXTPAGE;
-                    $answer->timecreated   = $timenow;
-                    $answer->grade = $question->fraction[$key] * 100;
-                    $min = $question->answer[$key] - $question->tolerance[$key];
-                    $max = $question->answer[$key] + $question->tolerance[$key];
-                    $answer->answer   = $min.":".$max;
-                    // $answer->answer   = $question->min[$key].":".$question->max[$key]; original line for min/max
-                    $answer->response = $question->feedback[$key];
-                    if (!$answer->id = insert_record("lesson_answers", $answer)) {
-                        $result->error = "Could not insert numerical quiz answer!";
-                        return $result;
-                    }
+    $clocksettings = array('starttime'=>$timer->starttime, 'servertime'=>time(),'testlength'=>($lesson->maxtime * 60));
+    $page->requires->data_for_js('clocksettings', $clocksettings);
+    $page->requires->js('/mod/lesson/timer.js');
+    $page->requires->js_function_call('show_clock');
+
+    $bc = new block_contents();
+    $bc->title = get_string('timeremaining', 'lesson');
+    $bc->attributes['class'] = 'clock block';
+    $bc->content = $content;
+
+    return $bc;
+}
+
+/**
+ * If left menu is turned on, then this will
+ * print the menu in a block
+ *
+ * @param int $cmid Course Module ID for this lesson
+ * @param lesson $lesson Full lesson record object
+ * @return void
+ **/
+function lesson_menu_block_contents($cmid, $lesson) {
+    global $CFG, $DB;
                     
-                    $answers[] = $answer->id;
-                    if ($question->fraction[$key] > $maxfraction) {
-                        $maxfraction = $question->fraction[$key];
+    if (!$lesson->displayleft) {
+        return null;
                     }
+
+    $pages = $lesson->load_all_pages();
+    foreach ($pages as $page) {
+        if ((int)$page->prevpageid === 0) {
+            $pageid = $page->id;
+            break;
                 }
             }
+    $currentpageid = optional_param('pageid', $pageid, PARAM_INT);
 
-            /// Perform sanity checks on fractional grades
-            if ($maxfraction != 1) {
-                $maxfraction = $maxfraction * 100;
-                $result->notice = get_string("fractionsnomax", "quiz", $maxfraction);
-                return $result;
+    if (!$pageid || !$pages) {
+        return null;
             }
-        break;
 
+    $content = '<a href="#maincontent" class="skip">'.get_string('skip', 'lesson')."</a>\n<div class=\"menuwrapper\">\n<ul>\n";
 
-        case LESSON_TRUEFALSE:
+    while ($pageid != 0) {
+        $page = $pages[$pageid];
 
-            // the truth
-            $answer->lessonid   = $question->lessonid;
-            $answer->pageid = $question->id;
-            $answer->timecreated   = $timenow;
-            $answer->answer = get_string("true", "quiz");
-            $answer->grade = $question->answer * 100;
-            if ($answer->grade > 50 ) {
-                $answer->jumpto = LESSON_NEXTPAGE;
+        // Only process branch tables with display turned on
+        if ($page->displayinmenublock && $page->display) {
+            if ($page->id == $currentpageid) {
+                $content .= '<li class="selected">'.format_string($page->title,true)."</li>\n";
+            } else {
+                $content .= "<li class=\"notselected\"><a href=\"$CFG->wwwroot/mod/lesson/view.php?id=$cmid&amp;pageid=$page->id\">".format_string($page->title,true)."</a></li>\n";
             }
-            if (isset($question->feedbacktrue)) {
-                $answer->response = $question->feedbacktrue;
+
             }
-            if (!$true->id = insert_record("lesson_answers", $answer)) {
-                $result->error = "Could not insert quiz answer \"true\")!";
-                return $result;
+        $pageid = $page->nextpageid;
             }
+    $content .= "</ul>\n</div>\n";
+
+    $bc = new block_contents();
+    $bc->title = get_string('lessonmenu', 'lesson');
+    $bc->attributes['class'] = 'menu block';
+    $bc->content = $content;
+
+    return $bc;
+}
 
-            // the lie    
-            $answer = new stdClass;
-            $answer->lessonid   = $question->lessonid;
-            $answer->pageid = $question->id;
-            $answer->timecreated   = $timenow;
-            $answer->answer = get_string("false", "quiz");
-            $answer->grade = (1 - (int)$question->answer) * 100;
-            if ($answer->grade > 50 ) {
-                $answer->jumpto = LESSON_NEXTPAGE;
+/**
+ * Adds header buttons to the page for the lesson
+ *
+ * @param object $cm
+ * @param object $context
+ * @param bool $extraeditbuttons
+ * @param int $lessonpageid
+ */
+function lesson_add_header_buttons($cm, $context, $extraeditbuttons=false, $lessonpageid=null) {
+    global $CFG, $PAGE, $OUTPUT;
+    if (has_capability('mod/lesson:edit', $context) && $extraeditbuttons) {
+        if ($lessonpageid === null) {
+            print_error('invalidpageid', 'lesson');
             }
-            if (isset($question->feedbackfalse)) {
-                $answer->response = $question->feedbackfalse;
+        if (!empty($lessonpageid) && $lessonpageid != LESSON_EOL) {
+            $url = new moodle_url('/mod/lesson/editpage.php', array('id'=>$cm->id, 'pageid'=>$lessonpageid, 'edit'=>1));
+            $PAGE->set_button($OUTPUT->single_button($url, get_string('editpagecontent', 'lesson')));
             }
-            if (!$false->id = insert_record("lesson_answers", $answer)) {
-                $result->error = "Could not insert quiz answer \"false\")!";
-                return $result;
             }
+}
 
-          break;
+/**
+ * This is a function used to detect media types and generate html code.
+ *
+ * @global object $CFG
+ * @global object $PAGE
+ * @param object $lesson
+ * @param object $context
+ * @return string $code the html code of media
+ */
+function lesson_get_media_html($lesson, $context) {
+    global $CFG, $PAGE, $OUTPUT;
+    require_once("$CFG->libdir/resourcelib.php");
 
+    // get the media file link
+    if (strpos($lesson->mediafile, '://') !== false) {
+        $url = new moodle_url($lesson->mediafile);
+    } else {
+        // the timemodified is used to prevent caching problems, instead of '/' we should better read from files table and use sortorder
+        $url = moodle_url::make_pluginfile_url($context->id, 'mod_lesson', 'mediafile', $lesson->timemodified, '/', ltrim($lesson->mediafile, '/'));
+    }
+    $title = $lesson->mediafile;
 
-        case LESSON_MULTICHOICE:
+    $clicktoopen = html_writer::link($url, get_string('download'));
 
-            $totalfraction = 0;
-            $maxfraction = -1;
+    $mimetype = resourcelib_guess_url_mimetype($url);
 
-            $answers = array();
+    $extension = resourcelib_get_extension($url->out(false));
 
-            // Insert all the new answers
-            foreach ($question->answer as $key => $dataanswer) {
-                if ($dataanswer != "") {
-                    $answer = new stdClass;
-                    $answer->lessonid   = $question->lessonid;
-                    $answer->pageid   = $question->id;
-                    $answer->timecreated   = $timenow;
-                    $answer->grade = $question->fraction[$key] * 100;
-                    // changed some defaults
-                    /* Original Code
-                    if ($answer->grade > 50 ) {
-                        $answer->jumpto = LESSON_NEXTPAGE;
-                    }
-                    Replaced with:                    */
-                    if ($answer->grade > 50 ) {
-                        $answer->jumpto = LESSON_NEXTPAGE;
-                        $answer->score = 1;
-                    }
-                    // end Replace
-                    $answer->answer   = $dataanswer;
-                    $answer->response = $question->feedback[$key];
-                    if (!$answer->id = insert_record("lesson_answers", $answer)) {
-                        $result->error = "Could not insert multichoice quiz answer! ";
-                        return $result;
-                    }
-                    // for Sanity checks
-                    if ($question->fraction[$key] > 0) {                 
-                        $totalfraction += $question->fraction[$key];
-                    }
-                    if ($question->fraction[$key] > $maxfraction) {
-                        $maxfraction = $question->fraction[$key];
-                    }
-                }
-            }
+    // find the correct type and print it out
+    if (in_array($mimetype, array('image/gif','image/jpeg','image/png'))) {  // It's an image
+        $code = resourcelib_embed_image($url, $title);
 
-            /// Perform sanity checks on fractional grades
-            if ($question->single) {
-                if ($maxfraction != 1) {
-                    $maxfraction = $maxfraction * 100;
-                    $result->notice = get_string("fractionsnomax", "quiz", $maxfraction);
-                    return $result;
-                }
-            } else {
-                $totalfraction = round($totalfraction,2);
-                if ($totalfraction != 1) {
-                    $totalfraction = $totalfraction * 100;
-                    $result->notice = get_string("fractionsaddwrong", "quiz", $totalfraction);
-                    return $result;
-                }
-            }
-        break;
+    } else if ($mimetype == 'audio/mp3') {
+        // MP3 audio file
+        $code = resourcelib_embed_mp3($url, $title, $clicktoopen);
 
-        case LESSON_MATCHING:
-
-            $subquestions = array();
-
-            $i = 0;
-            // Insert all the new question+answer pairs
-            foreach ($question->subquestions as $key => $questiontext) {
-                $answertext = $question->subanswers[$key];
-                if (!empty($questiontext) and !empty($answertext)) {
-                    $answer = new stdClass;
-                    $answer->lessonid   = $question->lessonid;
-                    $answer->pageid   = $question->id;
-                    $answer->timecreated   = $timenow;
-                    $answer->answer = $questiontext;
-                    $answer->response   = $answertext; 
-                    if ($i == 0) {
-                        // first answer contains the correct answer jump
-                        $answer->jumpto = LESSON_NEXTPAGE;
-                    }
-                    if (!$subquestion->id = insert_record("lesson_answers", $answer)) {
-                        $result->error = "Could not insert quiz match subquestion!";
-                        return $result;
-                    }
-                    $subquestions[] = $subquestion->id;
-                    $i++;
-                }
-            }
+    } else if ($mimetype == 'video/x-flv' or $extension === 'f4v') {
+        // Flash video file
+        $code = resourcelib_embed_flashvideo($url, $title, $clicktoopen);
 
-            if (count($subquestions) < 3) {
-                $result->notice = get_string("notenoughsubquestions", "quiz");
-                return $result;
-            }
+    } else if ($mimetype == 'application/x-shockwave-flash') {
+        // Flash file
+        $code = resourcelib_embed_flash($url, $title, $clicktoopen);
 
-            break;
+    } else if (substr($mimetype, 0, 10) == 'video/x-ms') {
+        // Windows Media Player file
+        $code = resourcelib_embed_mediaplayer($url, $title, $clicktoopen);
 
+    } else if ($mimetype == 'video/quicktime') {
+        // Quicktime file
+        $code = resourcelib_embed_quicktime($url, $title, $clicktoopen);
+
+    } else if ($mimetype == 'video/mpeg') {
+        // Mpeg file
+        $code = resourcelib_embed_mpeg($url, $title, $clicktoopen);
+
+    } else if ($mimetype == 'audio/x-pn-realaudio-plugin') {
+        // RealMedia file
+        $code = resourcelib_embed_real($url, $title, $clicktoopen);
 
-        case LESSON_RANDOMSAMATCH:
-            $options->question = $question->id;
-            $options->choose = $question->choose;
-            if ($existing = get_record("quiz_randomsamatch", "question", $options->question)) {
-                $options->id = $existing->id;
-                if (!update_record("quiz_randomsamatch", $options)) {
-                    $result->error = "Could not update quiz randomsamatch options!";
-                    return $result;
-                }
             } else {
-                if (!insert_record("quiz_randomsamatch", $options)) {
-                    $result->error = "Could not insert quiz randomsamatch options!";
-                    return $result;
+        // anything else - just try object tag enlarged as much as possible
+        $code = resourcelib_embed_general($url, $title, $clicktoopen, $mimetype);
                 }
-            }
-        break;
 
-        case LESSON_MULTIANSWER:
-            if (!$oldmultianswers = get_records("quiz_multianswers", "question", $question->id, "id ASC")) {
-                $oldmultianswers = array();
-            }
+    return $code;
+}
 
-            // Insert all the new multi answers
-            foreach ($question->answers as $dataanswer) {
-                if ($oldmultianswer = array_shift($oldmultianswers)) {  // Existing answer, so reuse it
-                    $multianswer = $oldmultianswer;
-                    $multianswer->positionkey = $dataanswer->positionkey;
-                    $multianswer->norm = $dataanswer->norm;
-                    $multianswer->answertype = $dataanswer->answertype;
 
-                    if (! $multianswer->answers = quiz_save_multianswer_alternatives
-                            ($question->id, $dataanswer->answertype,
-                             $dataanswer->alternatives, $oldmultianswer->answers))
-                    {
-                        $result->error = "Could not update multianswer alternatives! (id=$multianswer->id)";
-                        return $result;
-                    }
-                    if (!update_record("quiz_multianswers", $multianswer)) {
-                        $result->error = "Could not update quiz multianswer! (id=$multianswer->id)";
-                        return $result;
-                    }
-                } else {    // This is a completely new answer
-                    $multianswer = new stdClass;
-                    $multianswer->question = $question->id;
-                    $multianswer->positionkey = $dataanswer->positionkey;
-                    $multianswer->norm = $dataanswer->norm;
-                    $multianswer->answertype = $dataanswer->answertype;
-
-                    if (! $multianswer->answers = quiz_save_multianswer_alternatives
-                            ($question->id, $dataanswer->answertype,
-                             $dataanswer->alternatives))
-                    {
-                        $result->error = "Could not insert multianswer alternatives! (questionid=$question->id)";
-                        return $result;
-                    }
-                    if (!insert_record("quiz_multianswers", $multianswer)) {
-                        $result->error = "Could not insert quiz multianswer!";
-                        return $result;
-                    }
-                }
-            }
-        break;
+/**
+ * Abstract class that page type's MUST inherit from.
+ *
+ * This is the abstract class that ALL add page type forms must extend.
+ * You will notice that all but two of the methods this class contains are final.
+ * Essentially the only thing that extending classes can do is extend custom_definition.
+ * OR if it has a special requirement on creation it can extend construction_override
+ *
+ * @abstract
+ * @copyright  2009 Sam Hemelryk
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+abstract class lesson_add_page_form_base extends moodleform {
 
-        case LESSON_RANDOM:
-        break;
+    /**
+     * This is the classic define that is used to identify this pagetype.
+     * Will be one of LESSON_*
+     * @var int
+     */
+    public $qtype;
 
-        case LESSON_DESCRIPTION:
-        break;
+    /**
+     * The simple string that describes the page type e.g. truefalse, multichoice
+     * @var string
+     */
+    public $qtypestring;
 
-        default:
-            $result->error = "Unsupported question type ($question->qtype)!";
-            return $result;
-        break;
+    /**
+     * An array of options used in the htmleditor
+     * @var array
+     */
+    protected $editoroptions = array();
+
+    /**
+     * True if this is a standard page of false if it does something special.
+     * Questions are standard pages, branch tables are not
+     * @var bool
+     */
+    protected $standard = true;
+
+    /**
+     * Each page type can and should override this to add any custom elements to
+     * the basic form that they want
+     */
+    public function custom_definition() {}
+
+    /**
+     * Used to determine if this is a standard page or a special page
+     * @return bool
+     */
+    public final function is_standard() {
+        return (bool)$this->standard;
     }
-    return true;
-}
 
-/**
- * Determins if a jumpto value is correct or not.
- *
- * returns true if jumpto page is (logically) after the pageid page or
- * if the jumpto value is a special value.  Returns false in all other cases.
+    /**
+     * Add the required basic elements to the form.
  * 
- * @param int $pageid Id of the page from which you are jumping from.
- * @param int $jumpto The jumpto number.
- * @return boolean True or false after a series of tests.
- **/
-function lesson_iscorrect($pageid, $jumpto) {
+     * This method adds the basic elements to the form including title and contents
+     * and then calls custom_definition();
+     */
+    public final function definition() {
+        $mform = $this->_form;
+        $editoroptions = $this->_customdata['editoroptions'];
     
-    // first test the special values
-    if (!$jumpto) {
-        // same page
-        return false;
-    } elseif ($jumpto == LESSON_NEXTPAGE) {
-        return true;
-    } elseif ($jumpto == LESSON_UNSEENBRANCHPAGE) {
-        return true;
-    } elseif ($jumpto == LESSON_RANDOMPAGE) {
-        return true;
-    } elseif ($jumpto == LESSON_CLUSTERJUMP) {
-        return true;
-    } elseif ($jumpto == LESSON_EOL) {
-        return true;
+        $mform->addElement('header', 'qtypeheading', get_string('addaquestionpage', 'lesson', get_string($this->qtypestring, 'lesson')));
+
+        $mform->addElement('hidden', 'id');
+        $mform->setType('id', PARAM_INT);
+
+        $mform->addElement('hidden', 'pageid');
+        $mform->setType('pageid', PARAM_INT);
+
+        if ($this->standard === true) {
+            $mform->addElement('hidden', 'qtype');
+            $mform->setType('qtype', PARAM_INT);
+
+            $mform->addElement('text', 'title', get_string('pagetitle', 'lesson'), array('size'=>70));
+            $mform->setType('title', PARAM_TEXT);
+            $mform->addRule('title', get_string('required'), 'required', null, 'client');
+
+            $this->editoroptions = array('noclean'=>true, 'maxfiles'=>EDITOR_UNLIMITED_FILES, 'maxbytes'=>$this->_customdata['maxbytes']);
+            $mform->addElement('editor', 'contents_editor', get_string('pagecontents', 'lesson'), null, $this->editoroptions);
+            $mform->setType('contents_editor', PARAM_RAW);
+            $mform->addRule('contents_editor', get_string('required'), 'required', null, 'client');
     }
-    // we have to run through the pages from pageid looking for jumpid
-    if ($lessonid = get_field('lesson_pages', 'lessonid', 'id', $pageid)) {
-        if ($pages = get_records('lesson_pages', 'lessonid', $lessonid, '', 'id, nextpageid')) {
-            $apageid = $pages[$pageid]->nextpageid;
-            while ($apageid != 0) {
-                if ($jumpto == $apageid) {
-                    return true;
+
+        $this->custom_definition();
+
+        if ($this->_customdata['edit'] === true) {
+            $mform->addElement('hidden', 'edit', 1);
+            $this->add_action_buttons(get_string('cancel'), get_string('savepage', 'lesson'));
+        } else {
+            $this->add_action_buttons(get_string('cancel'), get_string('addaquestionpage', 'lesson'));
                 }
-                $apageid = $pages[$apageid]->nextpageid;
             }
+
+    /**
+     * Convenience function: Adds a jumpto select element
+     *
+     * @param string $name
+     * @param string|null $label
+     * @param int $selected The page to select by default
+     */
+    protected final function add_jumpto($name, $label=null, $selected=LESSON_NEXTPAGE) {
+        $title = get_string("jump", "lesson");
+        if ($label === null) {
+            $label = $title;
         }
+        if (is_int($name)) {
+            $name = "jumpto[$name]";
+        }
+        $this->_form->addElement('select', $name, $label, $this->_customdata['jumpto']);
+        $this->_form->setDefault($name, $selected);
+        $this->_form->addHelpButton($name, 'jumps', 'lesson');
     }
-    return false;
-}
 
-/**
- * Checks to see if a page is a branch table or is
- * a page that is enclosed by a branch table and an end of branch or end of lesson.
- * May call this function: {@link lesson_is_page_in_branch()}
+    /**
+     * Convenience function: Adds a score input element
  *
- * @param int $lesson Id of the lesson to which the page belongs.
- * @param int $pageid Id of the page.
- * @return boolean True or false.
- **/
-function lesson_display_branch_jumps($lessonid, $pageid) {
-    if($pageid == 0) {
-        // first page
-        return false;
+     * @param string $name
+     * @param string|null $label
+     * @param mixed $value The default value
+     */
+    protected final function add_score($name, $label=null, $value=null) {
+        if ($label === null) {
+            $label = get_string("score", "lesson");
     }
-    // get all of the lesson pages
-    if (!$lessonpages = get_records_select("lesson_pages", "lessonid = $lessonid")) {
-        // adding first page
-        return false;
+        if (is_int($name)) {
+            $name = "score[$name]";
+        }
+        $this->_form->addElement('text', $name, $label, array('size'=>5));
+        if ($value !== null) {
+            $this->_form->setDefault($name, $value);
     }
-
-    if ($lessonpages[$pageid]->qtype == LESSON_BRANCHTABLE) {
-        return true;
     }
     
-    return lesson_is_page_in_branch($lessonpages, $pageid);
-}
-
-/**
- * Checks to see if a page is a cluster page or is
- * a page that is enclosed by a cluster page and an end of cluster or end of lesson 
- * May call this function: {@link lesson_is_page_in_cluster()}
+    /**
+     * Convenience function: Adds an answer editor
  * 
- * @param int $lesson Id of the lesson to which the page belongs.
- * @param int $pageid Id of the page.
- * @return boolean True or false.
- **/
-function lesson_display_cluster_jump($lesson, $pageid) {
-    if($pageid == 0) {
-        // first page
-        return false;
+     * @param int $count The count of the element to add
+     * @param string $label, NULL means default
+     * @param bool $required
+     * @return void
+     */
+    protected final function add_answer($count, $label = NULL, $required = false) {
+        if ($label === NULL) {
+            $label = get_string('answer', 'lesson');
+        }
+        $this->_form->addElement('editor', 'answer_editor['.$count.']', $label, array('rows'=>'4', 'columns'=>'80'), array('noclean'=>true));
+        $this->_form->setDefault('answer_editor['.$count.']', array('text'=>'', 'format'=>FORMAT_MOODLE));
+        if ($required) {
+            $this->_form->addRule('answer_editor['.$count.']', get_string('required'), 'required', null, 'client');
+        }
+    }
+    /**
+     * Convenience function: Adds an response editor
+     *
+     * @param int $count The count of the element to add
+     * @param string $label, NULL means default
+     * @param bool $required
+     * @return void
+     */
+    protected final function add_response($count, $label = NULL, $required = false) {
+        if ($label === NULL) {
+            $label = get_string('response', 'lesson');
+        }
+        $this->_form->addElement('editor', 'response_editor['.$count.']', $label, array('rows'=>'4', 'columns'=>'80'), array('noclean'=>true));
+        $this->_form->setDefault('response_editor['.$count.']', array('text'=>'', 'format'=>FORMAT_MOODLE));
+        if ($required) {
+            $this->_form->addRule('response_editor['.$count.']', get_string('required'), 'required', null, 'client');
     }
-    // get all of the lesson pages
-    if (!$lessonpages = get_records_select("lesson_pages", "lessonid = $lesson")) {
-        // adding first page
-        return false;
     }
 
-    if ($lessonpages[$pageid]->qtype == LESSON_CLUSTER) {
+    /**
+     * A function that gets called upon init of this object by the calling script.
+     *
+     * This can be used to process an immediate action if required. Currently it
+     * is only used in special cases by non-standard page types.
+     *
+     * @return bool
+     */
+    public function construction_override() {
         return true;
     }
+}
     
-    return lesson_is_page_in_cluster($lessonpages, $pageid);
 
-}
 
 /**
- * Checks to see if a LESSON_CLUSTERJUMP or 
- * a LESSON_UNSEENBRANCHPAGE is used in a lesson.
+ * Class representation of a lesson
  *
- * This function is only executed when a teacher is 
- * checking the navigation for a lesson.
+ * This class is used the interact with, and manage a lesson once instantiated.
+ * If you need to fetch a lesson object you can do so by calling
  *
- * @param int $lesson Id of the lesson that is to be checked.
- * @return boolean True or false.
- **/
-function lesson_display_teacher_warning($lesson) {
-    // get all of the lesson answers
-    if (!$lessonanswers = get_records_select("lesson_answers", "lessonid = $lesson")) {
-        // no answers, then not useing cluster or unseen
-        return false;
+ * <code>
+ * lesson::load($lessonid);
+ * // or
+ * $lessonrecord = $DB->get_record('lesson', $lessonid);
+ * $lesson = new lesson($lessonrecord);
+ * </code>
+ *
+ * The class itself extends lesson_base as all classes within the lesson module should
+ *
+ * These properties are from the database
+ * @property int $id The id of this lesson
+ * @property int $course The ID of the course this lesson belongs to
+ * @property string $name The name of this lesson
+ * @property int $practice Flag to toggle this as a practice lesson
+ * @property int $modattempts Toggle to allow the user to go back and review answers
+ * @property int $usepassword Toggle the use of a password for entry
+ * @property string $password The password to require users to enter
+ * @property int $dependency ID of another lesson this lesson is dependent on
+ * @property string $conditions Conditions of the lesson dependency
+ * @property int $grade The maximum grade a user can achieve (%)
+ * @property int $custom Toggle custom scoring on or off
+ * @property int $ongoing Toggle display of an ongoing score
+ * @property int $usemaxgrade How retakes are handled (max=1, mean=0)
+ * @property int $maxanswers The max number of answers or branches
+ * @property int $maxattempts The maximum number of attempts a user can record
+ * @property int $review Toggle use or wrong answer review button
+ * @property int $nextpagedefault Override the default next page
+ * @property int $feedback Toggles display of default feedback
+ * @property int $minquestions Sets a minimum value of pages seen when calculating grades
+ * @property int $maxpages Maximum number of pages this lesson can contain
+ * @property int $retake Flag to allow users to retake a lesson
+ * @property int $activitylink Relate this lesson to another lesson
+ * @property string $mediafile File to pop up to or webpage to display
+ * @property int $mediaheight Sets the height of the media file popup
+ * @property int $mediawidth Sets the width of the media file popup
+ * @property int $mediaclose Toggle display of a media close button
+ * @property int $slideshow Flag for whether branch pages should be shown as slideshows
+ * @property int $width Width of slideshow
+ * @property int $height Height of slideshow
+ * @property string $bgcolor Background colour of slideshow
+ * @property int $displayleft Display a left menu
+ * @property int $displayleftif Sets the condition on which the left menu is displayed
+ * @property int $progressbar Flag to toggle display of a lesson progress bar
+ * @property int $highscores Flag to toggle collection of high scores
+ * @property int $maxhighscores Number of high scores to limit to
+ * @property int $available Timestamp of when this lesson becomes available
+ * @property int $deadline Timestamp of when this lesson is no longer available
+ * @property int $timemodified Timestamp when lesson was last modified
+ *
+ * These properties are calculated
+ * @property int $firstpageid Id of the first page of this lesson (prevpageid=0)
+ * @property int $lastpageid Id of the last page of this lesson (nextpageid=0)
+ *
+ * @copyright  2009 Sam Hemelryk
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class lesson extends lesson_base {
+
+    /**
+     * The id of the first page (where prevpageid = 0) gets set and retrieved by
+     * {@see get_firstpageid()} by directly calling <code>$lesson->firstpageid;</code>
+     * @var int
+     */
+    protected $firstpageid = null;
+    /**
+     * The id of the last page (where nextpageid = 0) gets set and retrieved by
+     * {@see get_lastpageid()} by directly calling <code>$lesson->lastpageid;</code>
+     * @var int
+     */
+    protected $lastpageid = null;
+    /**
+     * An array used to cache the pages associated with this lesson after the first
+     * time they have been loaded.
+     * A note to developers: If you are going to be working with MORE than one or
+     * two pages from a lesson you should probably call {@see $lesson->load_all_pages()}
+     * in order to save excess database queries.
+     * @var array An array of lesson_page objects
+     */
+    protected $pages = array();
+    /**
+     * Flag that gets set to true once all of the pages associated with the lesson
+     * have been loaded.
+     * @var bool
+     */
+    protected $loadedallpages = false;
+
+    /**
+     * Simply generates a lesson object given an array/object of properties
+     * Overrides {@see lesson_base->create()}
+     * @static
+     * @param object|array $properties
+     * @return lesson
+     */
+    public static function create($properties) {
+        return new lesson($properties);
     }
-    // just check for the first one that fulfills the requirements
-    foreach ($lessonanswers as $lessonanswer) {
-        if ($lessonanswer->jumpto == LESSON_CLUSTERJUMP || $lessonanswer->jumpto == LESSON_UNSEENBRANCHPAGE) {
-            return true;
+
+    /**
+     * Generates a lesson object from the database given its id
+     * @static
+     * @param int $lessonid
+     * @return lesson
+     */
+    public static function load($lessonid) {
+        global $DB;
+
+        if (!$lesson = $DB->get_record('lesson', array('id' => $lessonid))) {
+            print_error('invalidcoursemodule');
         }
+        return new lesson($lesson);
     }
     
-    // if no answers use either of the two jumps
-    return false;
-}
-
+    /**
+     * Deletes this lesson from the database
+     */
+    public function delete() {
+        global $CFG, $DB;
+        require_once($CFG->libdir.'/gradelib.php');
+        require_once($CFG->dirroot.'/calendar/lib.php');
+
+        $DB->delete_records("lesson", array("id"=>$this->properties->id));;
+        $DB->delete_records("lesson_pages", array("lessonid"=>$this->properties->id));
+        $DB->delete_records("lesson_answers", array("lessonid"=>$this->properties->id));
+        $DB->delete_records("lesson_attempts", array("lessonid"=>$this->properties->id));
+        $DB->delete_records("lesson_grades", array("lessonid"=>$this->properties->id));
+        $DB->delete_records("lesson_timer", array("lessonid"=>$this->properties->id));
+        $DB->delete_records("lesson_branch", array("lessonid"=>$this->properties->id));
+        $DB->delete_records("lesson_high_scores", array("lessonid"=>$this->properties->id));
+        if ($events = $DB->get_records('event', array("modulename"=>'lesson', "instance"=>$this->properties->id))) {
+            foreach($events as $event) {
+                $event = calendar_event::load($event);
+                $event->delete();
+            }
+        }
+
+        grade_update('mod/lesson', $this->properties->course, 'mod', 'lesson', $this->properties->id, 0, NULL, array('deleted'=>1));
+        return true;
+    }
 
-/**
- * Interprets LESSON_CLUSTERJUMP jumpto value.
+    /**
+     * Fetches messages from the session that may have been set in previous page
+     * actions.
  *
- * This will select a page randomly
- * and the page selected will be inbetween a cluster page and end of cluter or end of lesson
- * and the page selected will be a page that has not been viewed already
- * and if any pages are within a branch table or end of branch then only 1 page within 
- * the branch table or end of branch will be randomly selected (sub clustering).
+     * <code>
+     * // Do not call this method directly instead use
+     * $lesson->messages;
+     * </code>
  * 
- * @param int $lessonid Id of the lesson.
- * @param int $userid Id of the user.
- * @param int $pageid Id of the current page from which we are jumping from.
- * @return int The id of the next page.
- **/
-function lesson_cluster_jump($lessonid, $userid, $pageid) {
-    // get the number of retakes
-    if (!$retakes = count_records("lesson_grades", "lessonid", $lessonid, "userid", $userid)) {
-        $retakes = 0;
-    }
+     * @return array
+     */
+    protected function get_messages() {
+        global $SESSION;
 
-    // get all the lesson_attempts aka what the user has seen
-    if ($seen = get_records_select("lesson_attempts", "lessonid = $lessonid AND userid = $userid AND retry = $retakes", "timeseen DESC")) {
-        foreach ($seen as $value) { // load it into an array that I can more easily use
-            $seenpages[$value->pageid] = $value->pageid;
+        $messages = array();
+        if (!empty($SESSION->lesson_messages) && is_array($SESSION->lesson_messages) && array_key_exists($this->properties->id, $SESSION->lesson_messages)) {
+            $messages = $SESSION->lesson_messages[$this->properties->id];
+            unset($SESSION->lesson_messages[$this->properties->id]);
         }
-    } else {
-        $seenpages = array();
+
+        return $messages;
     }
 
-    // get the lesson pages
-    if (!$lessonpages = get_records_select("lesson_pages", "lessonid = $lessonid")) {
-        error("Error: could not find records in lesson_pages table");
+    /**
+     * Get all of the attempts for the current user.
+     *
+     * @param int $retries
+     * @param bool $correct Optional: only fetch correct attempts
+     * @param int $pageid Optional: only fetch attempts at the given page
+     * @param int $userid Optional: defaults to the current user if not set
+     * @return array|false
+     */
+    public function get_attempts($retries, $correct=false, $pageid=null, $userid=null) {
+        global $USER, $DB;
+        $params = array("lessonid"=>$this->properties->id, "userid"=>$userid, "retry"=>$retries);
+        if ($correct) {
+            $params['correct'] = 1;
     }
-    // find the start of the cluster
-    while ($pageid != 0) { // this condition should not be satisfied... should be a cluster page
-        if ($lessonpages[$pageid]->qtype == LESSON_CLUSTER) {
-            break;
+        if ($pageid !== null) {
+            $params['pageid'] = $pageid;
         }
-        $pageid = $lessonpages[$pageid]->prevpageid;
+        if ($userid === null) {
+            $params['userid'] = $USER->id;
     }
-
-    $pageid = $lessonpages[$pageid]->nextpageid; // move down from the cluster page
-    
-    $clusterpages = array();
-    while (true) {  // now load all the pages into the cluster that are not already inside of a branch table.
-        if ($lessonpages[$pageid]->qtype == LESSON_ENDOFCLUSTER) {
-            // store the endofcluster page's jump
-            $exitjump = get_field("lesson_answers", "jumpto", "pageid", $pageid, "lessonid", $lessonid);
-            if ($exitjump == LESSON_NEXTPAGE) {
-                $exitjump = $lessonpages[$pageid]->nextpageid;
+        return $DB->get_records('lesson_attempts', $params, 'timeseen ASC');
             }
-            if ($exitjump == 0) {
-                $exitjump = LESSON_EOL;
+
+    /**
+     * Returns the first page for the lesson or false if there isn't one.
+     *
+     * This method should be called via the magic method __get();
+     * <code>
+     * $firstpage = $lesson->firstpage;
+     * </code>
+     *
+     * @return lesson_page|bool Returns the lesson_page specialised object or false
+     */
+    protected function get_firstpage() {
+        $pages = $this->load_all_pages();
+        if (count($pages) > 0) {
+            foreach ($pages as $page) {
+                if ((int)$page->prevpageid === 0) {
+                    return $page;
             }
-            break;
-        } elseif (!lesson_is_page_in_branch($lessonpages, $pageid) && $lessonpages[$pageid]->qtype != LESSON_ENDOFBRANCH) {
-            // load page into array when it is not in a branch table and when it is not an endofbranch
-            $clusterpages[] = $lessonpages[$pageid];
         }
-        if ($lessonpages[$pageid]->nextpageid == 0) {
-            // shouldn't ever get here... should be using endofcluster
-            $exitjump = LESSON_EOL;
-            break;
-        } else {
-            $pageid = $lessonpages[$pageid]->nextpageid;
         }
+        return false;
     }
 
-    // filter out the ones we have seen
-    $unseen = array();
-    foreach ($clusterpages as $clusterpage) {
-        if ($clusterpage->qtype == LESSON_BRANCHTABLE) {            // if branchtable, check to see if any pages inside have been viewed
-            $branchpages = lesson_pages_in_branch($lessonpages, $clusterpage->id); // get the pages in the branchtable
-            $flag = true;
-            foreach ($branchpages as $branchpage) {
-                if (array_key_exists($branchpage->id, $seenpages)) {  // check if any of the pages have been viewed
-                    $flag = false;
+    /**
+     * Returns the last page for the lesson or false if there isn't one.
+     *
+     * This method should be called via the magic method __get();
+     * <code>
+     * $lastpage = $lesson->lastpage;
+     * </code>
+     *
+     * @return lesson_page|bool Returns the lesson_page specialised object or false
+     */
+    protected function get_lastpage() {
+        $pages = $this->load_all_pages();
+        if (count($pages) > 0) {
+            foreach ($pages as $page) {
+                if ((int)$page->nextpageid === 0) {
+                    return $page;
+                }
                 }
             }
-            if ($flag && count($branchpages) > 0) {
-                // add branch table
-                $unseen[] = $clusterpage;
+        return false;
             }        
+
+    /**
+     * Returns the id of the first page of this lesson. (prevpageid = 0)
+     * @return int
+     */
+    protected function get_firstpageid() {
+        global $DB;
+        if ($this->firstpageid == null) {
+            if (!$this->loadedallpages) {
+                $firstpageid = $DB->get_field('lesson_pages', 'id', array('lessonid'=>$this->properties->id, 'prevpageid'=>0));
+                if (!$firstpageid) {
+                    print_error('cannotfindfirstpage', 'lesson');
+                }
+                $this->firstpageid = $firstpageid;
         } else {
-            // add any other type of page that has not already been viewed
-            if (!array_key_exists($clusterpage->id, $seenpages)) {
-                $unseen[] = $clusterpage;
+                $firstpage = $this->get_firstpage();
+                $this->firstpageid = $firstpage->id;
             }
         }
+        return $this->firstpageid;
     }
 
-    if (count($unseen) > 0) { // it does not contain elements, then use exitjump, otherwise find out next page/branch
-        $nextpage = $unseen[rand(0, count($unseen)-1)];
+    /**
+     * Returns the id of the last page of this lesson. (nextpageid = 0)
+     * @return int
+     */
+    public function get_lastpageid() {
+        global $DB;
+        if ($this->lastpageid == null) {
+            if (!$this->loadedallpages) {
+                $lastpageid = $DB->get_field('lesson_pages', 'id', array('lessonid'=>$this->properties->id, 'nextpageid'=>0));
+                if (!$lastpageid) {
+                    print_error('cannotfindlastpage', 'lesson');
+                }
+                $this->lastpageid = $lastpageid;
     } else {
-        return $exitjump; // seen all there is to see, leave the cluster
+                $lastpageid = $this->get_lastpage();
+                $this->lastpageid = $lastpageid->id;
     }
-    
-    if ($nextpage->qtype == LESSON_BRANCHTABLE) { // if branch table, then pick a random page inside of it
-        $branchpages = lesson_pages_in_branch($lessonpages, $nextpage->id);
-        return $branchpages[rand(0, count($branchpages)-1)]->id;
-    } else { // otherwise, return the page's id
-        return $nextpage->id;
     }
-}
 
-/**
- * Returns pages that are within a branch table and another branch table, end of branch or end of lesson
- * 
- * @param array $lessonpages An array of lesson page objects.
- * @param int $branchid The id of the branch table that we would like the containing pages for.
- * @return array An array of lesson page objects.
- **/
-function lesson_pages_in_branch($lessonpages, $branchid) {
-    $pageid = $lessonpages[$branchid]->nextpageid;  // move to the first page after the branch table
-    $pagesinbranch = array();
+        return $this->lastpageid;
+    }
     
-    while (true) { 
-        if ($pageid == 0) { // EOL
-            break;
-        } elseif ($lessonpages[$pageid]->qtype == LESSON_BRANCHTABLE) {
+     /**
+     * Gets the next page id to display after the one that is provided.
+     * @param int $nextpageid
+     * @return bool
+     */
+    public function get_next_page($nextpageid) {
+        global $USER, $DB;
+        $allpages = $this->load_all_pages();
+        if ($this->properties->nextpagedefault) {
+            // in Flash Card mode...first get number of retakes
+            $nretakes = $DB->count_records("lesson_grades", array("lessonid" => $this->properties->id, "userid" => $USER->id));
+            shuffle($allpages);
+            $found = false;
+            if ($this->properties->nextpagedefault == LESSON_UNSEENPAGE) {
+                foreach ($allpages as $nextpage) {
+                    if (!$DB->count_records("lesson_attempts", array("pageid" => $nextpage->id, "userid" => $USER->id, "retry" => $nretakes))) {
+                        $found = true;
             break;
-        } elseif ($lessonpages[$pageid]->qtype == LESSON_ENDOFBRANCH) {
+                    }
+                }
+            } elseif ($this->properties->nextpagedefault == LESSON_UNANSWEREDPAGE) {
+                foreach ($allpages as $nextpage) {
+                    if (!$DB->count_records("lesson_attempts", array('pageid' => $nextpage->id, 'userid' => $USER->id, 'correct' => 1, 'retry' => $nretakes))) {
+                        $found = true;
             break;
         }
-        $pagesinbranch[] = $lessonpages[$pageid];
-        $pageid = $lessonpages[$pageid]->nextpageid;
+                }
+            }
+            if ($found) {
+                if ($this->properties->maxpages) {
+                    // check number of pages viewed (in the lesson)
+                    if ($DB->count_records("lesson_attempts", array("lessonid" => $this->properties->id, "userid" => $USER->id, "retry" => $nretakes)) >= $this->properties->maxpages) {
+                        return LESSON_EOL;
+                    }
+                }
+                return $nextpage->id;
+            }
+        }
+        // In a normal lesson mode
+        foreach ($allpages as $nextpage) {
+            if ((int)$nextpage->id === (int)$nextpageid) {
+                return $nextpage->id;
+            }
+        }
+        return LESSON_EOL;
     }
     
-    return $pagesinbranch;
-}
-
-/**
- * Interprets the LESSON_UNSEENBRANCHPAGE jump.
- * 
- * will return the pageid of a random unseen page that is within a branch
+    /**
+     * Sets a message against the session for this lesson that will displayed next
+     * time the lesson processes messages
  *
- * @see lesson_pages_in_branch()
- * @param int $lesson Id of the lesson.
- * @param int $userid Id of the user.
- * @param int $pageid Id of the page from which we are jumping.
- * @return int Id of the next page.
- **/
-function lesson_unseen_question_jump($lesson, $user, $pageid) {
-    // get the number of retakes
-    if (!$retakes = count_records("lesson_grades", "lessonid", $lesson, "userid", $user)) {
-        $retakes = 0;
-    }
+     * @param string $message
+     * @param string $class
+     * @param string $align
+     * @return bool
+     */
+    public function add_message($message, $class="notifyproblem", $align='center') {
+        global $SESSION;
 
-    // get all the lesson_attempts aka what the user has seen
-    if ($viewedpages = get_records_select("lesson_attempts", "lessonid = $lesson AND userid = $user AND retry = $retakes", "timeseen DESC")) {
-        foreach($viewedpages as $viewed) {
-            $seenpages[] = $viewed->pageid;
-        }
-    } else {
-        $seenpages = array();
+        if (empty($SESSION->lesson_messages) || !is_array($SESSION->lesson_messages)) {
+            $SESSION->lesson_messages = array();
+            $SESSION->lesson_messages[$this->properties->id] = array();
+        } else if (!array_key_exists($this->properties->id, $SESSION->lesson_messages)) {
+            $SESSION->lesson_messages[$this->properties->id] = array();
     }
 
-    // get the lesson pages
-    if (!$lessonpages = get_records_select("lesson_pages", "lessonid = $lesson")) {
-        error("Error: could not find records in lesson_pages table");
+        $SESSION->lesson_messages[$this->properties->id][] = array($message, $class, $align);
+
+        return true;
     }
     
-    if ($pageid == LESSON_UNSEENBRANCHPAGE) {  // this only happens when a student leaves in the middle of an unseen question within a branch series
-        $pageid = $seenpages[0];  // just change the pageid to the last page viewed inside the branch table
+    /**
+     * Check if the lesson is accessible at the present time
+     * @return bool True if the lesson is accessible, false otherwise
+     */
+    public function is_accessible() {
+        $available = $this->properties->available;
+        $deadline = $this->properties->deadline;
+        return (($available == 0 || time() >= $available) && ($deadline == 0 || time() < $deadline));
     }
 
-    // go up the pages till branch table
-    while ($pageid != 0) { // this condition should never be satisfied... only happens if there are no branch tables above this page
-        if ($lessonpages[$pageid]->qtype == LESSON_BRANCHTABLE) {
-            break;
+    /**
+     * Starts the lesson time for the current user
+     * @return bool Returns true
+     */
+    public function start_timer() {
+        global $USER, $DB;
+        $USER->startlesson[$this->properties->id] = true;
+        $startlesson = new stdClass;
+        $startlesson->lessonid = $this->properties->id;
+        $startlesson->userid = $USER->id;
+        $startlesson->starttime = time();
+        $startlesson->lessontime = time();
+        $DB->insert_record('lesson_timer', $startlesson);
+        if ($this->properties->timed) {
+            $this->add_message(get_string('maxtimewarning', 'lesson', $this->properties->maxtime), 'center');
         }
-        $pageid = $lessonpages[$pageid]->prevpageid;
+        return true;
     }
     
-    $pagesinbranch = lesson_pages_in_branch($lessonpages, $pageid);
+    /**
+     * Updates the timer to the current time and returns the new timer object
+     * @param bool $restart If set to true the timer is restarted
+     * @param bool $continue If set to true AND $restart=true then the timer
+     *                        will continue from a previous attempt
+     * @return stdClass The new timer
+     */
+    public function update_timer($restart=false, $continue=false) {
+        global $USER, $DB;
+        // clock code
+        // get time information for this user
+        if (!$timer = $DB->get_records('lesson_timer', array ("lessonid" => $this->properties->id, "userid" => $USER->id), 'starttime DESC', '*', 0, 1)) {
+            print_error('cannotfindtimer', 'lesson');
+        } else {
+            $timer = current($timer); // this will get the latest start time record
+        }
     
-    // this foreach loop stores all the pages that are within the branch table but are not in the $seenpages array
-    $unseen = array();
-    foreach($pagesinbranch as $page) {    
-        if (!in_array($page->id, $seenpages)) {
-            $unseen[] = $page->id;
+        if ($restart) {
+            if ($continue) {
+                // continue a previous test, need to update the clock  (think this option is disabled atm)
+                $timer->starttime = time() - ($timer->lessontime - $timer->starttime);
+            } else {
+                // starting over, so reset the clock
+                $timer->starttime = time();
         }
     }
 
-    if(count($unseen) == 0) {
-        if(isset($pagesinbranch)) {
-            $temp = end($pagesinbranch);
-            $nextpage = $temp->nextpageid; // they have seen all the pages in the branch, so go to EOB/next branch table/EOL
-        } else {
-            // there are no pages inside the branch, so return the next page
-            $nextpage = $lessonpages[$pageid]->nextpageid;
+        $timer->lessontime = time();
+        $DB->update_record('lesson_timer', $timer);
+        return $timer;
         }
-        if ($nextpage == 0) {
-            return LESSON_EOL;
-        } else {
-            return $nextpage;
+
+    /**
+     * Updates the timer to the current time then stops it by unsetting the user var
+     * @return bool Returns true
+     */
+    public function stop_timer() {
+        global $USER, $DB;
+        unset($USER->startlesson[$this->properties->id]);
+        return $this->update_timer(false, false);
         }
-    } else {
-        return $unseen[rand(0, count($unseen)-1)];  // returns a random page id for the next page
+
+    /**
+     * Checks to see if the lesson has pages
+     */
+    public function has_pages() {
+        global $DB;
+        $pagecount = $DB->count_records('lesson_pages', array('lessonid'=>$this->properties->id));
+        return ($pagecount>0);
     }
-}
 
-/**
- * Handles the unseen branch table jump.
- *
- * @param int $lessonid Lesson id.
- * @param int $userid User id.
- * @return int Will return the page id of a branch table or end of lesson
- **/
-function lesson_unseen_branch_jump($lessonid, $userid) {
-    if (!$retakes = count_records("lesson_grades", "lessonid", $lessonid, "userid", $userid)) {
-        $retakes = 0;
+    /**
+     * Returns the link for the related activity
+     * @return array|false
+     */
+    public function link_for_activitylink() {
+        global $DB;
+        $module = $DB->get_record('course_modules', array('id' => $this->properties->activitylink));
+        if ($module) {
+            $modname = $DB->get_field('modules', 'name', array('id' => $module->module));
+            if ($modname) {
+                $instancename = $DB->get_field($modname, 'name', array('id' => $module->instance));
+                if ($instancename) {
+                    return html_writer::link(new moodle_url('/mod/'.$modname.'/view.php', array('id'=>$this->properties->activitylink)),
+                        get_string('activitylinkname', 'lesson', $instancename),
+                        array('class'=>'centerpadded lessonbutton standardbutton'));
+                }
+            }
+        }
+        return '';
     }
 
-    if (!$seenbranches = get_records_select("lesson_branch", "lessonid = $lessonid AND userid = $userid AND retry = $retakes",
-                "timeseen DESC")) {
-        error("Error: could not find records in lesson_branch table");
+    /**
+     * Loads the requested page.
+     *
+     * This function will return the requested page id as either a specialised
+     * lesson_page object OR as a generic lesson_page.
+     * If the page has been loaded previously it will be returned from the pages
+     * array, otherwise it will be loaded from the database first
+     *
+     * @param int $pageid
+     * @return lesson_page A lesson_page object or an object that extends it
+     */
+    public function load_page($pageid) {
+        if (!array_key_exists($pageid, $this->pages)) {
+            $manager = lesson_page_type_manager::get($this);
+            $this->pages[$pageid] = $manager->load_page($pageid, $this);
+        }
+        return $this->pages[$pageid];
     }
 
-    // get the lesson pages
-    if (!$lessonpages = get_records_select("lesson_pages", "lessonid = $lessonid")) {
-        error("Error: could not find records in lesson_pages table");
+    /**
+     * Loads ALL of the pages for this lesson
+     *
+     * @return array An array containing all pages from this lesson
+     */
+    public function load_all_pages() {
+        if (!$this->loadedallpages) {
+            $manager = lesson_page_type_manager::get($this);
+            $this->pages = $manager->load_all_pages($this);
+            $this->loadedallpages = true;
+        }
+        return $this->pages;
     }
     
-    // this loads all the viewed branch tables into $seen untill it finds the branch table with the flag
-    // which is the branch table that starts the unseenbranch function
-    $seen = array();    
-    foreach ($seenbranches as $seenbranch) {
-        if (!$seenbranch->flag) {
-            $seen[$seenbranch->pageid] = $seenbranch->pageid;
-        } else {
-            $start = $seenbranch->pageid;
-            break;
+    /**
+     * Determines if a jumpto value is correct or not.
+     *
+     * returns true if jumpto page is (logically) after the pageid page or
+     * if the jumpto value is a special value.  Returns false in all other cases.
+     *
+     * @param int $pageid Id of the page from which you are jumping from.
+     * @param int $jumpto The jumpto number.
+     * @return boolean True or false after a series of tests.
+     **/
+    public function jumpto_is_correct($pageid, $jumpto) {
+        global $DB;
+
+        // first test the special values
+        if (!$jumpto) {
+            // same page
+            return false;
+        } elseif ($jumpto == LESSON_NEXTPAGE) {
+            return true;
+        } elseif ($jumpto == LESSON_UNSEENBRANCHPAGE) {
+            return true;
+        } elseif ($jumpto == LESSON_RANDOMPAGE) {
+            return true;
+        } elseif ($jumpto == LESSON_CLUSTERJUMP) {
+            return true;
+        } elseif ($jumpto == LESSON_EOL) {
+            return true;
         }
+
+        $pages = $this->load_all_pages();
+        $apageid = $pages[$pageid]->nextpageid;
+        while ($apageid != 0) {
+            if ($jumpto == $apageid) {
+                return true;
     }
-    // this function searches through the lesson pages to find all the branch tables
-    // that follow the flagged branch table
-    $pageid = $lessonpages[$start]->nextpageid; // move down from the flagged branch table
-    while ($pageid != 0) {  // grab all of the branch table till eol
-        if ($lessonpages[$pageid]->qtype == LESSON_BRANCHTABLE) {
-            $branchtables[] = $lessonpages[$pageid]->id;
+            $apageid = $pages[$apageid]->nextpageid;
         }
-        $pageid = $lessonpages[$pageid]->nextpageid;
+        return false;
     }
-    $unseen = array();
-    foreach ($branchtables as $branchtable) {
-        // load all of the unseen branch tables into unseen
-        if (!array_key_exists($branchtable, $seen)) {
-            $unseen[] = $branchtable;
+
+    /**
+     * Returns the time a user has remaining on this lesson
+     * @param int $starttime Starttime timestamp
+     * @return string
+     */
+    public function time_remaining($starttime) {
+        $timeleft = $starttime + $this->maxtime * 60 - time();
+        $hours = floor($timeleft/3600);
+        $timeleft = $timeleft - ($hours * 3600);
+        $minutes = floor($timeleft/60);
+        $secs = $timeleft - ($minutes * 60);
+
+        if ($minutes < 10) {
+            $minutes = "0$minutes";
         }
+        if ($secs < 10) {
+            $secs = "0$secs";
     }
-    if (count($unseen) > 0) {
-        return $unseen[rand(0, count($unseen)-1)];  // returns a random page id for the next page
-    } else {
-        return LESSON_EOL;  // has viewed all of the branch tables
+        $output   = array();
+        $output[] = $hours;
+        $output[] = $minutes;
+        $output[] = $secs;
+        $output = implode(':', $output);
+        return $output;
     }
-}
 
-/**
- * Handles the random jump between a branch table and end of branch or end of lesson (LESSON_RANDOMPAGE).
+    /**
+     * Interprets LESSON_CLUSTERJUMP jumpto value.
  * 
- * @param int $lessonid Lesson id.
- * @param int $pageid The id of the page that we are jumping from (?)
- * @return int The pageid of a random page that is within a branch table
+     * This will select a page randomly
+     * and the page selected will be inbetween a cluster page and end of clutter or end of lesson
+     * and the page selected will be a page that has not been viewed already
+     * and if any pages are within a branch table or end of branch then only 1 page within
+     * the branch table or end of branch will be randomly selected (sub clustering).
+     *
+     * @param int $pageid Id of the current page from which we are jumping from.
+     * @param int $userid Id of the user.
+     * @return int The id of the next page.
  **/
-function lesson_random_question_jump($lessonid, $pageid) {
-    // get the lesson pages
-    if (!$lessonpages = get_records_select("lesson_pages", "lessonid = $lessonid")) {
-        error("Error: could not find records in lesson_pages table");
+    public function cluster_jump($pageid, $userid=null) {
+        global $DB, $USER;
+
+        if ($userid===null) {
+            $userid = $USER->id;
+        }
+        // get the number of retakes
+        if (!$retakes = $DB->count_records("lesson_grades", array("lessonid"=>$this->properties->id, "userid"=>$userid))) {
+            $retakes = 0;
+        }
+        // get all the lesson_attempts aka what the user has seen
+        $seenpages = array();
+        if ($attempts = $this->get_attempts($retakes)) {
+            foreach ($attempts as $attempt) {
+                $seenpages[$attempt->pageid] = $attempt->pageid;
     }
 
-    // go up the pages till branch table
-    while ($pageid != 0) { // this condition should never be satisfied... only happens if there are no branch tables above this page
+        }
 
-        if ($lessonpages[$pageid]->qtype == LESSON_BRANCHTABLE) {
+        // get the lesson pages
+        $lessonpages = $this->load_all_pages();
+        // find the start of the cluster
+        while ($pageid != 0) { // this condition should not be satisfied... should be a cluster page
+            if ($lessonpages[$pageid]->qtype == LESSON_PAGE_CLUSTER) {
             break;
         }
         $pageid = $lessonpages[$pageid]->prevpageid;
     }
 
-    // get the pages within the branch    
-    $pagesinbranch = lesson_pages_in_branch($lessonpages, $pageid);
+        $clusterpages = array();
+        $clusterpages = $this->get_sub_pages_of($pageid, array(LESSON_PAGE_ENDOFCLUSTER));
+        $unseen = array();
+        foreach ($clusterpages as $key=>$cluster) {
+            if ($cluster->type !== lesson_page::TYPE_QUESTION) {
+                unset($clusterpages[$key]);
+            } elseif ($cluster->is_unseen($seenpages)) {
+                $unseen[] = $cluster;
+            }
+        }
     
-    if(count($pagesinbranch) == 0) {
-        // there are no pages inside the branch, so return the next page
-        return $lessonpages[$pageid]->nextpageid;
+        if (count($unseen) > 0) {
+            // it does not contain elements, then use exitjump, otherwise find out next page/branch
+            $nextpage = $unseen[rand(0, count($unseen)-1)];
+            if ($nextpage->qtype == LESSON_PAGE_BRANCHTABLE) {
+                // if branch table, then pick a random page inside of it
+                $branchpages = $this->get_sub_pages_of($nextpage->id, array(LESSON_PAGE_BRANCHTABLE, LESSON_PAGE_ENDOFBRANCH));
+                return $branchpages[rand(0, count($branchpages)-1)]->id;
+            } else { // otherwise, return the page's id
+                return $nextpage->id;
+            }
     } else {
-        return $pagesinbranch[rand(0, count($pagesinbranch)-1)]->id;  // returns a random page id for the next page
+            // seen all there is to see, leave the cluster
+            if (end($clusterpages)->nextpageid == 0) {
+                return LESSON_EOL;
+            } else {
+                $clusterendid = $pageid;
+                while ($clusterendid != 0) { // this condition should not be satisfied... should be a cluster page
+                    if ($lessonpages[$clusterendid]->qtype == LESSON_PAGE_CLUSTER) {
+                        break;
+                    }
+                    $clusterendid = $lessonpages[$clusterendid]->prevpageid;
+                }
+                $exitjump = $DB->get_field("lesson_answers", "jumpto", array("pageid" => $clusterendid, "lessonid" => $this->properties->id));
+                if ($exitjump == LESSON_NEXTPAGE) {
+                    $exitjump = $lessonpages[$pageid]->nextpageid;
+                }
+                if ($exitjump == 0) {
+                    return LESSON_EOL;
+                } else if (in_array($exitjump, array(LESSON_EOL, LESSON_PREVIOUSPAGE))) {
+                    return $exitjump;
+                } else {
+                    if (!array_key_exists($exitjump, $lessonpages)) {
+                        $found = false;
+                        foreach ($lessonpages as $page) {
+                            if ($page->id === $clusterendid) {
+                                $found = true;
+                            } else if ($page->qtype == LESSON_PAGE_ENDOFCLUSTER) {
+                                $exitjump = $DB->get_field("lesson_answers", "jumpto", array("pageid" => $page->id, "lessonid" => $this->properties->id));
+                                break;
+                            }
+                        }
+                    }
+                    if (!array_key_exists($exitjump, $lessonpages)) {
+                        return LESSON_EOL;
+                    }
+                    return $exitjump;
+                }
+            }
+        }
     }
-}
 
-/**
- * Check to see if a page is below a branch table (logically).
+    /**
+     * Finds all pages that appear to be a subtype of the provided pageid until
+     * an end point specified within $ends is encountered or no more pages exist
  * 
- * Will return true if a branch table is found logically above the page.
- * Will return false if an end of branch, cluster or the beginning
- * of the lesson is found before a branch table.
+     * @param int $pageid
+     * @param array $ends An array of LESSON_PAGE_* types that signify an end of
+     *               the subtype
+     * @return array An array of specialised lesson_page objects
+     */
+    public function get_sub_pages_of($pageid, array $ends) {
+        $lessonpages = $this->load_all_pages();
+        $pageid = $lessonpages[$pageid]->nextpageid;  // move to the first page after the branch table
+        $pages = array();
+
+        while (true) {
+            if ($pageid == 0 || in_array($lessonpages[$pageid]->qtype, $ends)) {
+                break;
+            }
+            $pages[] = $lessonpages[$pageid];
+            $pageid = $lessonpages[$pageid]->nextpageid;
+        }
+
+        return $pages;
+    }
+
+    /**
+     * Checks to see if the specified page[id] is a subpage of a type specified in
+     * the $types array, until either there are no more pages of we find a type
+     * corresponding to that of a type specified in $ends
  *
- * @param array $pages An array of lesson page objects.
- * @param int $pageid Id of the page for testing.
- * @return boolean
+     * @param int $pageid The id of the page to check
+     * @param array $types An array of types that would signify this page was a subpage
+     * @param array $ends An array of types that mean this is not a subpage
+     * @return bool
  */
-function lesson_is_page_in_branch($pages, $pageid) {
+    public function is_sub_page_of_type($pageid, array $types, array $ends) {
+        $pages = $this->load_all_pages();
     $pageid = $pages[$pageid]->prevpageid; // move up one
 
+        array_unshift($ends, 0);
     // go up the pages till branch table    
     while (true) {
-        if ($pageid == 0) {  // ran into the beginning of the lesson
-            return false;
-        } elseif ($pages[$pageid]->qtype == LESSON_ENDOFBRANCH) { // ran into the end of another branch table
+            if ($pageid==0 || in_array($pages[$pageid]->qtype, $ends)) {
             return false;
-        } elseif ($pages[$pageid]->qtype == LESSON_CLUSTER) { // do not look beyond a cluster
-            return false;
-        } elseif ($pages[$pageid]->qtype == LESSON_BRANCHTABLE) { // hit a branch table
+            } else if (in_array($pages[$pageid]->qtype, $types)) {
             return true;
         }
         $pageid = $pages[$pageid]->prevpageid;
     }
-
+    }
 }
 
+
 /**
- * Check to see if a page is below a cluster page (logically).
+ * Abstract class to provide a core functions to the all lesson classes
+ *
+ * This class should be abstracted by ALL classes with the lesson module to ensure
+ * that all classes within this module can be interacted with in the same way.
  * 
- * Will return true if a cluster is found logically above the page.
- * Will return false if an end of cluster or the beginning
- * of the lesson is found before a cluster page.
+ * This class provides the user with a basic properties array that can be fetched
+ * or set via magic methods, or alternatively by defining methods get_blah() or
+ * set_blah() within the extending object.
  *
- * @param array $pages An array of lesson page objects.
- * @param int $pageid Id of the page for testing.
- * @return boolean
+ * @copyright  2009 Sam Hemelryk
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
  */
-function lesson_is_page_in_cluster($pages, $pageid) {
-    $pageid = $pages[$pageid]->prevpageid; // move up one
+abstract class lesson_base {
 
-    // go up the pages till branch table    
-    while (true) {
-        if ($pageid == 0) {  // ran into the beginning of the lesson
-            return false;
-        } elseif ($pages[$pageid]->qtype == LESSON_ENDOFCLUSTER) { // ran into the end of another branch table
-            return false;
-        } elseif ($pages[$pageid]->qtype == LESSON_CLUSTER) { // hit a branch table
-            return true;
+    /**
+     * An object containing properties
+     * @var stdClass
+     */
+    protected $properties;
+
+    /**
+     * The constructor
+     * @param stdClass $properties
+     */
+    public function __construct($properties) {
+        $this->properties = (object)$properties;
         }
-        $pageid = $pages[$pageid]->prevpageid;
+
+    /**
+     * Magic property method
+     *
+     * Attempts to call a set_$key method if one exists otherwise falls back
+     * to simply set the property
+     *
+     * @param string $key
+     * @param mixed $value
+     */
+    public function __set($key, $value) {
+        if (method_exists($this, 'set_'.$key)) {
+            $this->{'set_'.$key}($value);
+        }
+        $this->properties->{$key} = $value;
+    }
+
+    /**
+     * Magic get method
+     *
+     * Attempts to call a get_$key method to return the property and ralls over
+     * to return the raw property
+     *
+     * @param str $key
+     * @return mixed
+     */
+    public function __get($key) {
+        if (method_exists($this, 'get_'.$key)) {
+            return $this->{'get_'.$key}();
+        }
+        return $this->properties->{$key};
+    }
+
+    /**
+     * Stupid PHP needs an isset magic method if you use the get magic method and
+     * still want empty calls to work.... blah ~!
+     *
+     * @param string $key
+     * @return bool
+     */
+    public function __isset($key) {
+        if (method_exists($this, 'get_'.$key)) {
+            $val = $this->{'get_'.$key}();
+            return !empty($val);
+        }
+        return !empty($this->properties->{$key});
+    }
+
+    /**
+     * If overridden should create a new instance, save it in the DB and return it
+     */
+    public static function create() {}
+    /**
+     * If overridden should load an instance from the DB and return it
+     */
+    public static function load() {}
+    /**
+     * Fetches all of the properties of the object
+     * @return stdClass
+     */
+    public function properties() {
+        return $this->properties;
     }
 }
 
+
 /**
- * Calculates a user's grade for a lesson.
+ * Abstract class representation of a page associated with a lesson.
  *
- * @param object $lesson The lesson that the user is taking.
- * @param int $retries The attempt number.
- * @param int $userid Id of the user (optinal, default current user).
- * @return object { nquestions => number of questions answered
-                    attempts => number of question attempts
-                    total => max points possible
-                    earned => points earned by student
-                    grade => calculated percentage grade
-                    nmanual => number of manually graded questions
-                    manualpoints => point value for manually graded questions }
+ * This class should MUST be extended by all specialised page types defined in
+ * mod/lesson/pagetypes/.
+ * There are a handful of abstract methods that need to be defined as well as
+ * severl methods that can optionally be defined in order to make the page type
+ * operate in the desired way
+ *
+ * Database properties
+ * @property int $id The id of this lesson page
+ * @property int $lessonid The id of the lesson this page belongs to
+ * @property int $prevpageid The id of the page before this one
+ * @property int $nextpageid The id of the next page in the page sequence
+ * @property int $qtype Identifies the page type of this page
+ * @property int $qoption Used to record page type specific options
+ * @property int $layout Used to record page specific layout selections
+ * @property int $display Used to record page specific display selections
+ * @property int $timecreated Timestamp for when the page was created
+ * @property int $timemodified Timestamp for when the page was last modified
+ * @property string $title The title of this page
+ * @property string $contents The rich content shown to describe the page
+ * @property int $contentsformat The format of the contents field
+ *
+ * Calculated properties
+ * @property-read array $answers An array of answers for this page
+ * @property-read bool $displayinmenublock Toggles display in the left menu block
+ * @property-read array $jumps An array containing all the jumps this page uses
+ * @property-read lesson $lesson The lesson this page belongs to
+ * @property-read int $type The type of the page [question | structure]
+ * @property-read typeid The unique identifier for the page type
+ * @property-read typestring The string that describes this page type
+ *
+ * @abstract
+ * @copyright  2009 Sam Hemelryk
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
  */
-function lesson_grade($lesson, $ntries, $userid = 0) {  
-    global $USER;
+abstract class lesson_page extends lesson_base {
 
-    if (empty($userid)) {
-        $userid = $USER->id;
+    /**
+     * A reference to the lesson this page belongs to
+     * @var lesson
+     */
+    protected $lesson = null;
+    /**
+     * Contains the answers to this lesson_page once loaded
+     * @var null|array
+     */
+    protected $answers = null;
+    /**
+     * This sets the type of the page, can be one of the constants defined below
+     * @var int
+     */
+    protected $type = 0;
+
+    /**
+     * Constants used to identify the type of the page
+     */
+    const TYPE_QUESTION = 0;
+    const TYPE_STRUCTURE = 1;
+
+    /**
+     * This method should return the integer used to identify the page type within
+     * the database and throughout code. This maps back to the defines used in 1.x
+     * @abstract
+     * @return int
+     */
+    abstract protected function get_typeid();
+    /**
+     * This method should return the string that describes the pagetype
+     * @abstract
+     * @return string
+     */
+    abstract protected function get_typestring();
+
+    /**
+     * This method gets called to display the page to the user taking the lesson
+     * @abstract
+     * @param object $renderer
+     * @param object $attempt
+     * @return string
+     */
+    abstract public function display($renderer, $attempt);
+
+    /**
+     * Creates a new lesson_page within the database and returns the correct pagetype
+     * object to use to interact with the new lesson
+     *
+     * @final
+     * @static
+     * @param object $properties
+     * @param lesson $lesson
+     * @return lesson_page Specialised object that extends lesson_page
+     */
+    final public static function create($properties, lesson $lesson, $context, $maxbytes) {
+        global $DB;
+        $newpage = new stdClass;
+        $newpage->title = $properties->title;
+        $newpage->contents = $properties->contents_editor['text'];
+        $newpage->contentsformat = $properties->contents_editor['format'];
+        $newpage->lessonid = $lesson->id;
+        $newpage->timecreated = time();
+        $newpage->qtype = $properties->qtype;
+        $newpage->qoption = (isset($properties->qoption))?1:0;
+        $newpage->layout = (isset($properties->layout))?1:0;
+        $newpage->display = (isset($properties->display))?1:0;
+        $newpage->prevpageid = 0; // this is a first page
+        $newpage->nextpageid = 0; // this is the only page
+
+        if ($properties->pageid) {
+            $prevpage = $DB->get_record("lesson_pages", array("id" => $properties->pageid), 'id, nextpageid');
+            if (!$prevpage) {
+                print_error('cannotfindpages', 'lesson');
+            }
+            $newpage->prevpageid = $prevpage->id;
+            $newpage->nextpageid = $prevpage->nextpageid;
+        } else {
+            $nextpage = $DB->get_record('lesson_pages', array('lessonid'=>$lesson->id, 'prevpageid'=>0), 'id');
+            if ($nextpage) {
+                // This is the first page, there are existing pages put this at the start
+                $newpage->nextpageid = $nextpage->id;
+            }
     }
     
-    // Zero out everything
-    $ncorrect     = 0;
-    $nviewed      = 0;
-    $score        = 0;
-    $nmanual      = 0;
-    $manualpoints = 0;
-    $thegrade     = 0;
-    $nquestions   = 0;
-    $total        = 0;
-    $earned       = 0;
+        $newpage->id = $DB->insert_record("lesson_pages", $newpage);
 
-    if ($useranswers = get_records_select("lesson_attempts",  "lessonid = $lesson->id AND 
-            userid = $userid AND retry = $ntries", "timeseen")) {
-        // group each try with its page
-        $attemptset = array();
-        foreach ($useranswers as $useranswer) {
-            $attemptset[$useranswer->pageid][] = $useranswer;                                
+        $editor = new stdClass;
+        $editor->id = $newpage->id;
+        $editor->contents_editor = $properties->contents_editor;
+        $editor = file_postupdate_standard_editor($editor, 'contents', array('noclean'=>true, 'maxfiles'=>EDITOR_UNLIMITED_FILES, 'maxbytes'=>$maxbytes), $context, 'mod_lesson', 'page_contents', $editor->id);
+        $DB->update_record("lesson_pages", $editor);
+
+        if ($newpage->prevpageid > 0) {
+            $DB->set_field("lesson_pages", "nextpageid", $newpage->id, array("id" => $newpage->prevpageid));
+        }
+        if ($newpage->nextpageid > 0) {
+            $DB->set_field("lesson_pages", "prevpageid", $newpage->id, array("id" => $newpage->nextpageid));
         }
         
-        // Drop all attempts that go beyond max attempts for the lesson
-        foreach ($attemptset as $key => $set) {
-            $attemptset[$key] = array_slice($set, 0, $lesson->maxattempts);
+        $page = lesson_page::load($newpage, $lesson);
+        $page->create_answers($properties);
+
+        $lesson->add_message(get_string('insertedpage', 'lesson').': '.format_string($newpage->title, true), 'notifysuccess');
+
+        return $page;
         }
         
-        $pageids = implode(",", array_keys($attemptset));
+    /**
+     * This method loads a page object from the database and returns it as a
+     * specialised object that extends lesson_page
+     *
+     * @final
+     * @static
+     * @param int $id
+     * @param lesson $lesson
+     * @return lesson_page Specialised lesson_page object
+     */
+    final public static function load($id, lesson $lesson) {
+        global $DB;
         
-        // get only the pages and their answers that the user answered
-        $pages = get_records_select("lesson_pages", "lessonid = $lesson->id AND id IN($pageids)");
-        $answers = get_records_select("lesson_answers", "lessonid = $lesson->id AND pageid IN($pageids)");
+        if (is_object($id) && !empty($id->qtype)) {
+            $page = $id;
+        } else {
+            $page = $DB->get_record("lesson_pages", array("id" => $id));
+            if (!$page) {
+                print_error('cannotfindpages', 'lesson');
+            }
+        }
+        $manager = lesson_page_type_manager::get($lesson);
         
-        // Number of pages answered
-        $nquestions = count($pages);
+        $class = 'lesson_page_type_'.$manager->get_page_type_idstring($page->qtype);
+        if (!class_exists($class)) {
+            $class = 'lesson_page';
+        }
 
-        foreach ($attemptset as $attempts) {
-            if ($lesson->custom) {
-                $attempt = end($attempts);
-                // If essay question, handle it, otherwise add to score
-                if ($pages[$attempt->pageid]->qtype == LESSON_ESSAY) {
-                    $essayinfo = unserialize($attempt->useranswer);
-                    $earned += $essayinfo->score;
-                    $nmanual++;
-                    $manualpoints += $answers[$attempt->answerid]->score;
-                } else if (!empty($attempt->answerid)) {
-                    $earned += $answers[$attempt->answerid]->score;
+        return new $class($page, $lesson);
+    }
+
+    /**
+     * Deletes a lesson_page from the database as well as any associated records.
+     * @final
+     * @return bool
+     */
+    final public function delete() {
+        global $DB;
+        // first delete all the associated records...
+        $DB->delete_records("lesson_attempts", array("pageid" => $this->properties->id));
+        // ...now delete the answers...
+        $DB->delete_records("lesson_answers", array("pageid" => $this->properties->id));
+        // ..and the page itself
+        $DB->delete_records("lesson_pages", array("id" => $this->properties->id));
+
+        // repair the hole in the linkage
+        if (!$this->properties->prevpageid && !$this->properties->nextpageid) {
+            //This is the only page, no repair needed
+        } elseif (!$this->properties->prevpageid) {
+            // this is the first page...
+            $page = $this->lesson->load_page($this->properties->nextpageid);
+            $page->move(null, 0);
+        } elseif (!$this->properties->nextpageid) {
+            // this is the last page...
+            $page = $this->lesson->load_page($this->properties->prevpageid);
+            $page->move(0);
+        } else {
+            // page is in the middle...
+            $prevpage = $this->lesson->load_page($this->properties->prevpageid);
+            $nextpage = $this->lesson->load_page($this->properties->nextpageid);
+
+            $prevpage->move($nextpage->id);
+            $nextpage->move(null, $prevpage->id);
+        }
+        return true;
+    }
+
+    /**
+     * Moves a page by updating its nextpageid and prevpageid values within
+     * the database
+     *
+     * @final
+     * @param int $nextpageid
+     * @param int $prevpageid
+     */
+    final public function move($nextpageid=null, $prevpageid=null) {
+        global $DB;
+        if ($nextpageid === null) {
+            $nextpageid = $this->properties->nextpageid;
+        }
+        if ($prevpageid === null) {
+            $prevpageid = $this->properties->prevpageid;
+        }
+        $obj = new stdClass;
+        $obj->id = $this->properties->id;
+        $obj->prevpageid = $prevpageid;
+        $obj->nextpageid = $nextpageid;
+        $DB->update_record('lesson_pages', $obj);
+    }
+
+    /**
+     * Returns the answers that are associated with this page in the database
+     *
+     * @final
+     * @return array
+     */
+    final public function get_answers() {
+        global $DB;
+        if ($this->answers === null) {
+            $this->answers = array();
+            $answers = $DB->get_records('lesson_answers', array('pageid'=>$this->properties->id, 'lessonid'=>$this->lesson->id), 'id');
+            if (!$answers) {
+                // It is possible that a lesson upgraded from Moodle 1.9 still
+                // contains questions without any answers [MDL-25632].
+                // debugging(get_string('cannotfindanswer', 'lesson'));
+                return array();
+            }
+            foreach ($answers as $answer) {
+                $this->answers[count($this->answers)] = new lesson_page_answer($answer);
+            }
+        }
+        return $this->answers;
+    }
+
+    /**
+     * Returns the lesson this page is associated with
+     * @final
+     * @return lesson
+     */
+    final protected function get_lesson() {
+        return $this->lesson;
+    }
+
+    /**
+     * Returns the type of page this is. Not to be confused with page type
+     * @final
+     * @return int
+     */
+    final protected function get_type() {
+        return $this->type;
+    }
+
+    /**
+     * Records an attempt at this page
+     *
+     * @final
+     * @global moodle_database $DB
+     * @param stdClass $context
+     * @return stdClass Returns the result of the attempt
+     */
+    final public function record_attempt($context) {
+        global $DB, $USER, $OUTPUT;
+
+        /**
+         * This should be overridden by each page type to actually check the response
+         * against what ever custom criteria they have defined
+         */
+        $result = $this->check_answer();
+
+        $result->attemptsremaining  = 0;
+        $result->maxattemptsreached = false;
+
+        if ($result->noanswer) {
+            $result->newpageid = $this->properties->id; // display same page again
+            $result->feedback  = get_string('noanswer', 'lesson');
+        } else {
+            if (!has_capability('mod/lesson:manage', $context)) {
+                $nretakes = $DB->count_records("lesson_grades", array("lessonid"=>$this->lesson->id, "userid"=>$USER->id));
+                // record student's attempt
+                $attempt = new stdClass;
+                $attempt->lessonid = $this->lesson->id;
+                $attempt->pageid = $this->properties->id;
+                $attempt->userid = $USER->id;
+                $attempt->answerid = $result->answerid;
+                $attempt->retry = $nretakes;
+                $attempt->correct = $result->correctanswer;
+                if($result->userresponse !== null) {
+                    $attempt->useranswer = $result->userresponse;
+                }
+
+                $attempt->timeseen = time();
+                // if allow modattempts, then update the old attempt record, otherwise, insert new answer record
+                if (isset($USER->modattempts[$this->lesson->id])) {
+                    $attempt->retry = $nretakes - 1; // they are going through on review, $nretakes will be too high
+                }
+
+                if ($this->lesson->retake || (!$this->lesson->retake && $nretakes == 0)) {
+                    $DB->insert_record("lesson_attempts", $attempt);
+                }
+                // "number of attempts remaining" message if $this->lesson->maxattempts > 1
+                // displaying of message(s) is at the end of page for more ergonomic display
+                if (!$result->correctanswer && ($result->newpageid == 0)) {
+                    // wrong answer and student is stuck on this page - check how many attempts
+                    // the student has had at this page/question
+                    $nattempts = $DB->count_records("lesson_attempts", array("pageid"=>$this->properties->id, "userid"=>$USER->id, "retry" => $attempt->retry));
+                    // retreive the number of attempts left counter for displaying at bottom of feedback page
+                    if ($nattempts >= $this->lesson->maxattempts) {
+                        if ($this->lesson->maxattempts > 1) { // don't bother with message if only one attempt
+                            $result->maxattemptsreached = true;
+                        }
+                        $result->newpageid = LESSON_NEXTPAGE;
+                    } else if ($this->lesson->maxattempts > 1) { // don't bother with message if only one attempt
+                        $result->attemptsremaining = $this->lesson->maxattempts - $nattempts;
+                    }
+                }
+            }
+            // TODO: merge this code with the jump code below.  Convert jumpto page into a proper page id
+            if ($result->newpageid == 0) {
+                $result->newpageid = $this->properties->id;
+            } elseif ($result->newpageid == LESSON_NEXTPAGE) {
+                $result->newpageid = $this->lesson->get_next_page($this->properties->nextpageid);
+            }
+
+            // Determine default feedback if necessary
+            if (empty($result->response)) {
+                if (!$this->lesson->feedback && !$result->noanswer && !($this->lesson->review & !$result->correctanswer && !$result->isessayquestion)) {
+                    // These conditions have been met:
+                    //  1. The lesson manager has not supplied feedback to the student
+                    //  2. Not displaying default feedback
+                    //  3. The user did provide an answer
+                    //  4. We are not reviewing with an incorrect answer (and not reviewing an essay question)
+
+                    $result->nodefaultresponse = true;  // This will cause a redirect below
+                } else if ($result->isessayquestion) {
+                    $result->response = get_string('defaultessayresponse', 'lesson');
+                } else if ($result->correctanswer) {
+                    $result->response = get_string('thatsthecorrectanswer', 'lesson');
+                } else {
+                    $result->response = get_string('thatsthewronganswer', 'lesson');
+                }
+            }
+
+            if ($result->response) {
+                if ($this->lesson->review && !$result->correctanswer && !$result->isessayquestion) {
+                    $nretakes = $DB->count_records("lesson_grades", array("lessonid"=>$this->lesson->id, "userid"=>$USER->id));
+                    $qattempts = $DB->count_records("lesson_attempts", array("userid"=>$USER->id, "retry"=>$nretakes, "pageid"=>$this->properties->id));
+                    if ($qattempts == 1) {
+                        $result->feedback = $OUTPUT->box(get_string("firstwrong", "lesson"), 'feedback');
+                    } else {
+                        $result->feedback = $OUTPUT->BOX(get_string("secondpluswrong", "lesson"), 'feedback');
+                    }
+                } else {
+                    $class = 'response';
+                    if ($result->correctanswer) {
+                        $class .= ' correct'; //CSS over-ride this if they exist (!important)
+                    } else if (!$result->isessayquestion) {
+                        $class .= ' incorrect'; //CSS over-ride this if they exist (!important)
+                    }
+                    $options = new stdClass;
+                    $options->noclean = true;
+                    $options->para = true;
+                    $options->overflowdiv = true;
+                    $result->feedback = $OUTPUT->box(format_text($this->get_contents(), $this->properties->contentsformat, $options), 'generalbox boxaligncenter');
+                    $result->feedback .= '<div class="correctanswer generalbox"><em>'.get_string("youranswer", "lesson").'</em> : '.$result->studentanswer; // already in clean html
+                    $result->feedback .= $OUTPUT->box($result->response, $class); // already conerted to HTML
+                    $result->feedback .= '</div>';
+                }
+            }
+        }
+
+        return $result;
+    }
+
+    /**
+     * Returns the string for a jump name
+     *
+     * @final
+     * @param int $jumpto Jump code or page ID
+     * @return string
+     **/
+    final protected function get_jump_name($jumpto) {
+        global $DB;
+        static $jumpnames = array();
+
+        if (!array_key_exists($jumpto, $jumpnames)) {
+            if ($jumpto == LESSON_THISPAGE) {
+                $jumptitle = get_string('thispage', 'lesson');
+            } elseif ($jumpto == LESSON_NEXTPAGE) {
+                $jumptitle = get_string('nextpage', 'lesson');
+            } elseif ($jumpto == LESSON_EOL) {
+                $jumptitle = get_string('endoflesson', 'lesson');
+            } elseif ($jumpto == LESSON_UNSEENBRANCHPAGE) {
+                $jumptitle = get_string('unseenpageinbranch', 'lesson');
+            } elseif ($jumpto == LESSON_PREVIOUSPAGE) {
+                $jumptitle = get_string('previouspage', 'lesson');
+            } elseif ($jumpto == LESSON_RANDOMPAGE) {
+                $jumptitle = get_string('randompageinbranch', 'lesson');
+            } elseif ($jumpto == LESSON_RANDOMBRANCH) {
+                $jumptitle = get_string('randombranch', 'lesson');
+            } elseif ($jumpto == LESSON_CLUSTERJUMP) {
+                $jumptitle = get_string('clusterjump', 'lesson');
+            } else {
+                if (!$jumptitle = $DB->get_field('lesson_pages', 'title', array('id' => $jumpto))) {
+                    $jumptitle = '<strong>'.get_string('notdefined', 'lesson').'</strong>';
+                }
+            }
+            $jumpnames[$jumpto] = format_string($jumptitle,true);
+        }
+
+        return $jumpnames[$jumpto];
+    }
+
+    /**
+     * Constructor method
+     * @param object $properties
+     * @param lesson $lesson
+     */
+    public function __construct($properties, lesson $lesson) {
+        parent::__construct($properties);
+        $this->lesson = $lesson;
+    }
+
+    /**
+     * Returns the score for the attempt
+     * This may be overridden by page types that require manual grading
+     * @param array $answers
+     * @param object $attempt
+     * @return int
+     */
+    public function earned_score($answers, $attempt) {
+        return $answers[$attempt->answerid]->score;
+    }
+
+    /**
+     * This is a callback method that can be override and gets called when ever a page
+     * is viewed
+     *
+     * @param bool $canmanage True if the user has the manage cap
+     * @return mixed
+     */
+    public function callback_on_view($canmanage) {
+        return true;
+    }
+
+    /**
+     * Updates a lesson page and its answers within the database
+     *
+     * @param object $properties
+     * @return bool
+     */
+    public function update($properties, $context = null, $maxbytes = null) {
+        global $DB, $PAGE;
+        $answers  = $this->get_answers();
+        $properties->id = $this->properties->id;
+        $properties->lessonid = $this->lesson->id;
+        if (empty($properties->qoption)) {
+            $properties->qoption = '0';
                 }
-            } else {
-                foreach ($attempts as $attempt) {
-                    $earned += $attempt->correct;
+        if (empty($context)) {
+            $context = $PAGE->context;
                 }
-                $attempt = end($attempts); // doesn't matter which one
-                // If essay question, increase numbers
-                if ($pages[$attempt->pageid]->qtype == LESSON_ESSAY) {
-                    $nmanual++;
-                    $manualpoints++;
+        if ($maxbytes === null) {
+            $maxbytes =get_max_upload_file_size();
                 }
+        $properties = file_postupdate_standard_editor($properties, 'contents', array('noclean'=>true, 'maxfiles'=>EDITOR_UNLIMITED_FILES, 'maxbytes'=>$maxbytes), $context, 'mod_lesson', 'page_contents', $properties->id);
+        $DB->update_record("lesson_pages", $properties);
+
+        for ($i = 0; $i < $this->lesson->maxanswers; $i++) {
+            if (!array_key_exists($i, $this->answers)) {
+                $this->answers[$i] = new stdClass;
+                $this->answers[$i]->lessonid = $this->lesson->id;
+                $this->answers[$i]->pageid = $this->id;
+                $this->answers[$i]->timecreated = $this->timecreated;
             }
-            // Number of times answered
-            $nviewed += count($attempts);
+
+            if (!empty($properties->answer_editor[$i]) && is_array($properties->answer_editor[$i])) {
+                $this->answers[$i]->answer = $properties->answer_editor[$i]['text'];
+                $this->answers[$i]->answerformat = $properties->answer_editor[$i]['format'];
+            }
+            if (!empty($properties->response_editor[$i]) && is_array($properties->response_editor[$i])) {
+                $this->answers[$i]->response = $properties->response_editor[$i]['text'];
+                $this->answers[$i]->responseformat = $properties->response_editor[$i]['format'];
         }
         
-        if ($lesson->custom) {
-            $bestscores = array();
-            // Find the highest possible score per page to get our total
-            foreach ($answers as $answer) {
-                if(!isset($bestscores[$answer->pageid])) {
-                    $bestscores[$answer->pageid] = $answer->score;
-                } else if ($bestscores[$answer->pageid] < $answer->score) {
-                    $bestscores[$answer->pageid] = $answer->score;
+            // we don't need to check for isset here because properties called it's own isset method.
+            if ($this->answers[$i]->answer != '') {
+                if (isset($properties->jumpto[$i])) {
+                    $this->answers[$i]->jumpto = $properties->jumpto[$i];
                 }
+                if ($this->lesson->custom && isset($properties->score[$i])) {
+                    $this->answers[$i]->score = $properties->score[$i];
             }
-            $total = array_sum($bestscores);
+                if (!isset($this->answers[$i]->id)) {
+                    $this->answers[$i]->id =  $DB->insert_record("lesson_answers", $this->answers[$i]);
         } else {
-            // Check to make sure the student has answered the minimum questions
-            if ($lesson->minquestions and $nquestions < $lesson->minquestions) {
-                // Nope, increase number viewed by the amount of unanswered questions
-                $total =  $nviewed + ($lesson->minquestions - $nquestions);
+                    $DB->update_record("lesson_answers", $this->answers[$i]->properties());
+                }
+
+            } else if (isset($this->answers[$i]->id)) {
+                $DB->delete_records('lesson_answers', array('id'=>$this->answers[$i]->id));
+                unset($this->answers[$i]);
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Can be set to true if the page requires a static link to create a new instance
+     * instead of simply being included in the dropdown
+     * @param int $previd
+     * @return bool
+     */
+    public function add_page_link($previd) {
+        return false;
+    }
+
+    /**
+     * Returns true if a page has been viewed before
+     *
+     * @param array|int $param Either an array of pages that have been seen or the
+     *                   number of retakes a user has had
+     * @return bool
+     */
+    public function is_unseen($param) {
+        global $USER, $DB;
+        if (is_array($param)) {
+            $seenpages = $param;
+            return (!array_key_exists($this->properties->id, $seenpages));
             } else {
-                $total = $nviewed;
+            $nretakes = $param;
+            if (!$DB->count_records("lesson_attempts", array("pageid"=>$this->properties->id, "userid"=>$USER->id, "retry"=>$nretakes))) {
+                return true;
             }
         }
+        return false;
     }
     
-    if ($total) { // not zero
-        $thegrade = round(100 * $earned / $total, 5);
+    /**
+     * Checks to see if a page has been answered previously
+     * @param int $nretakes
+     * @return bool
+     */
+    public function is_unanswered($nretakes) {
+        global $DB, $USER;
+        if (!$DB->count_records("lesson_attempts", array('pageid'=>$this->properties->id, 'userid'=>$USER->id, 'correct'=>1, 'retry'=>$nretakes))) {
+            return true;
+        }
+        return false;
     }
     
-    // Build the grade information object
-    $gradeinfo               = new stdClass;
-    $gradeinfo->nquestions   = $nquestions;
-    $gradeinfo->attempts     = $nviewed;
-    $gradeinfo->total        = $total;
-    $gradeinfo->earned       = $earned;
-    $gradeinfo->grade        = $thegrade;
-    $gradeinfo->nmanual      = $nmanual;
-    $gradeinfo->manualpoints = $manualpoints;
+    /**
+     * Creates answers within the database for this lesson_page. Usually only ever
+     * called when creating a new page instance
+     * @param object $properties
+     * @return array
+     */
+    public function create_answers($properties) {
+        global $DB;
+        // now add the answers
+        $newanswer = new stdClass;
+        $newanswer->lessonid = $this->lesson->id;
+        $newanswer->pageid = $this->properties->id;
+        $newanswer->timecreated = $this->properties->timecreated;
     
-    return $gradeinfo;
-}
+        $answers = array();
 
-/**
- * Prints the on going message to the user.
- *
- * With custom grading On, displays points 
- * earned out of total points possible thus far.
- * With custom grading Off, displays number of correct
- * answers out of total attempted.
- *
- * @param object $lesson The lesson that the user is taking.
- * @return void
- **/
-function lesson_print_ongoing_score($lesson) {
-    global $USER;
-    $cm = get_coursemodule_from_instance('lesson', $lesson->id);
-    $context = get_context_instance(CONTEXT_MODULE, $cm->id);
+        for ($i = 0; $i < $this->lesson->maxanswers; $i++) {
+            $answer = clone($newanswer);
 
-    if (has_capability('mod/lesson:manage', $context)) {
-        echo "<p align=\"center\">".get_string('teacherongoingwarning', 'lesson').'</p>';
-    } else {
-        $ntries = count_records("lesson_grades", "lessonid", $lesson->id, "userid", $USER->id);
-        if (isset($USER->modattempts[$lesson->id])) {
-            $ntries--;
+            if (!empty($properties->answer_editor[$i]) && is_array($properties->answer_editor[$i])) {
+                $answer->answer = $properties->answer_editor[$i]['text'];
+                $answer->answerformat = $properties->answer_editor[$i]['format'];
+            }
+            if (!empty($properties->response_editor[$i]) && is_array($properties->response_editor[$i])) {
+                $answer->response = $properties->response_editor[$i]['text'];
+                $answer->responseformat = $properties->response_editor[$i]['format'];
         }
-        $gradeinfo = lesson_grade($lesson, $ntries);
         
-        $a = new stdClass;
-        if ($lesson->custom) {
-            $a->score = $gradeinfo->earned;
-            $a->currenthigh = $gradeinfo->total;
-            print_simple_box(get_string("ongoingcustom", "lesson", $a), "center");
+            if (isset($answer->answer) && $answer->answer != '') {
+                if (isset($properties->jumpto[$i])) {
+                    $answer->jumpto = $properties->jumpto[$i];
+                }
+                if ($this->lesson->custom && isset($properties->score[$i])) {
+                    $answer->score = $properties->score[$i];
+                }
+                $answer->id = $DB->insert_record("lesson_answers", $answer);
+                $answers[$answer->id] = new lesson_page_answer($answer);
         } else {
-            $a->correct = $gradeinfo->earned;
-            $a->viewed = $gradeinfo->attempts;
-            print_simple_box(get_string("ongoingnormal", "lesson", $a), "center");
+                break;
         }
     }
-}
 
-/**
- * Prints tabs for the editing and adding pages.  Each tab is a question type.
+        $this->answers = $answers;
+        return $answers;
+    }
+
+    /**
+     * This method MUST be overridden by all question page types, or page types that
+     * wish to score a page.
  *  
- * @param array $qtypes The question types array (may not need to pass this because it is defined in this file)
- * @param string $selected Current selected tab
- * @param string $link The base href value of the link for the tab
- * @param string $onclick Javascript for the tab link
- * @return void
+     * The structure of result should always be the same so it is a good idea when
+     * overriding this method on a page type to call
+     * <code>
+     * $result = parent::check_answer();
+     * </code>
+     * before modifying it as required.
+     *
+     * @return stdClass
  */
-function lesson_qtype_menu($qtypes, $selected="", $link="", $onclick="") {
-    $tabs = array();
-    $tabrows = array();
-
-    foreach ($qtypes as $qtype => $qtypename) {
-        $tabrows[] = new tabobject($qtype, "$link&amp;qtype=$qtype\" onclick=\"$onclick", $qtypename);
+    public function check_answer() {
+        $result = new stdClass;
+        $result->answerid        = 0;
+        $result->noanswer        = false;
+        $result->correctanswer   = false;
+        $result->isessayquestion = false;   // use this to turn off review button on essay questions
+        $result->response        = '';
+        $result->newpageid       = 0;       // stay on the page
+        $result->studentanswer   = '';      // use this to store student's answer(s) in order to display it on feedback page
+        $result->userresponse    = null;
+        $result->feedback        = '';
+        $result->nodefaultresponse  = false; // Flag for redirecting when default feedback is turned off
+        return $result;
     }
-    $tabs[] = $tabrows;
-    print_tabs($tabs, $selected);
-    echo "<input type=\"hidden\" name=\"qtype\" value=\"$selected\" /> \n";
-
-}
 
-/**
- * Prints out a Progress Bar which depicts a user's progress within a lesson.
+    /**
+     * True if the page uses a custom option
  *
- * Currently works best with a linear lesson.  Clusters are counted as a single page.
- * Also, only viewed branch tables and questions that have been answered correctly count
- * toward lesson completion (or progress).  Only Students can see the Progress bar as well.
+     * Should be override and set to true if the page uses a custom option.
  *
- * @param object $lesson The lesson that the user is currently taking.
- * @param object $course The course that the to which the lesson belongs.
- * @return boolean The return is not significant as of yet.  Will return true/false.
- **/
-function lesson_print_progress_bar($lesson, $course) {
-    global $CFG, $USER;
-    $cm = get_coursemodule_from_instance('lesson', $lesson->id);
-    $context = get_context_instance(CONTEXT_MODULE, $cm->id);
-
-    // lesson setting to turn progress bar on or off
-    if (!$lesson->progressbar) {
+     * @return bool
+     */
+    public function has_option() {
         return false;
     }
     
-    // catch teachers
-    if (has_capability('mod/lesson:manage', $context)) {
-        notify(get_string('progressbarteacherwarning', 'lesson', $course->teachers));
-        return false;
+    /**
+     * Returns the maximum number of answers for this page given the maximum number
+     * of answers permitted by the lesson.
+     *
+     * @param int $default
+     * @return int
+     */
+    public function max_answers($default) {
+        return $default;
     }
-    if (!isset($USER->modattempts[$lesson->id])) {
-        // all of the lesson pages
-        if (!$pages = get_records('lesson_pages', 'lessonid', $lesson->id)) {
-            return false;
+
+    /**
+     * Returns the properties of this lesson page as an object
+     * @return stdClass;
+     */
+    public function properties() {
+        $properties = clone($this->properties);
+        if ($this->answers === null) {
+            $this->get_answers();
+        }
+        if (count($this->answers)>0) {
+            $count = 0;
+            foreach ($this->answers as $answer) {
+                $properties->{'answer_editor['.$count.']'} = array('text'=>$answer->answer, 'format'=>$answer->answerformat);
+                $properties->{'response_editor['.$count.']'} = array('text'=>$answer->response, 'format'=>$answer->responseformat);
+                $properties->{'jumpto['.$count.']'} = $answer->jumpto;
+                $properties->{'score['.$count.']'} = $answer->score;
+                $count++;
+            }
+        }
+        return $properties;
+    }
+
+    /**
+     * Returns an array of options to display when choosing the jumpto for a page/answer
+     * @static
+     * @param int $pageid
+     * @param lesson $lesson
+     * @return array
+     */
+    public static function get_jumptooptions($pageid, lesson $lesson) {
+        global $DB;
+        $jump = array();
+        $jump[0] = get_string("thispage", "lesson");
+        $jump[LESSON_NEXTPAGE] = get_string("nextpage", "lesson");
+        $jump[LESSON_PREVIOUSPAGE] = get_string("previouspage", "lesson");
+        $jump[LESSON_EOL] = get_string("endoflesson", "lesson");
+
+        if ($pageid == 0) {
+            return $jump;
+        }
+
+        $pages = $lesson->load_all_pages();
+        if ($pages[$pageid]->qtype == LESSON_PAGE_BRANCHTABLE || $lesson->is_sub_page_of_type($pageid, array(LESSON_PAGE_BRANCHTABLE), array(LESSON_PAGE_ENDOFBRANCH, LESSON_PAGE_CLUSTER))) {
+            $jump[LESSON_UNSEENBRANCHPAGE] = get_string("unseenpageinbranch", "lesson");
+            $jump[LESSON_RANDOMPAGE] = get_string("randompageinbranch", "lesson");
+        }
+        if($pages[$pageid]->qtype == LESSON_PAGE_CLUSTER || $lesson->is_sub_page_of_type($pageid, array(LESSON_PAGE_CLUSTER), array(LESSON_PAGE_ENDOFCLUSTER))) {
+            $jump[LESSON_CLUSTERJUMP] = get_string("clusterjump", "lesson");
+        }
+        if (!optional_param('firstpage', 0, PARAM_INT)) {
+            $apageid = $DB->get_field("lesson_pages", "id", array("lessonid" => $lesson->id, "prevpageid" => 0));
+            while (true) {
+                if ($apageid) {
+                    $title = $DB->get_field("lesson_pages", "title", array("id" => $apageid));
+                    $jump[$apageid] = strip_tags(format_string($title,true));
+                    $apageid = $DB->get_field("lesson_pages", "nextpageid", array("id" => $apageid));
         } else {
-            foreach ($pages as $page) {
-                if ($page->prevpageid == 0) {
-                    $pageid = $page->id;  // find the first page id
+                    // last page reached
                     break;
                 }
             }
         }
+        return $jump;
+    }
+    /**
+     * Returns the contents field for the page properly formatted and with plugin
+     * file url's converted
+     * @return string
+     */
+    public function get_contents() {
+        global $PAGE;
+        if (!empty($this->properties->contents)) {
+            if (!isset($this->properties->contentsformat)) {
+                $this->properties->contentsformat = FORMAT_HTML;
+            }
+            $context = get_context_instance(CONTEXT_MODULE, $PAGE->cm->id);
+            $contents = file_rewrite_pluginfile_urls($this->properties->contents, 'pluginfile.php', $context->id, 'mod_lesson', 'page_contents', $this->properties->id); // must do this BEFORE format_text()!!!!!!
+            return format_text($contents, $this->properties->contentsformat, array('context'=>$context, 'noclean'=>true)); // page edit is marked with XSS, we want all content here
+        } else {
+            return '';
+        }
+    }
     
-        // current attempt number
-        if (!$ntries = count_records("lesson_grades", "lessonid", $lesson->id, "userid", $USER->id)) {
-            $ntries = 0;  // may not be necessary
+    /**
+     * Set to true if this page should display in the menu block
+     * @return bool
+     */
+    protected function get_displayinmenublock() {
+        return false;
         }
     
-        $viewedpageids = array();
+    /**
+     * Get the string that describes the options of this page type
+     * @return string
+     */
+    public function option_description_string() {
+        return '';
+    }
     
-        // collect all of the correctly answered questions
-        if ($viewedpages = get_records_select("lesson_attempts", "lessonid = $lesson->id AND userid = $USER->id AND retry = $ntries AND correct = 1", 'timeseen DESC', 'pageid, id')) {
-            $viewedpageids = array_keys($viewedpages);
+    /**
+     * Updates a table with the answers for this page
+     * @param html_table $table
+     * @return html_table
+     */
+    public function display_answers(html_table $table) {
+        $answers = $this->get_answers();
+        $i = 1;
+        foreach ($answers as $answer) {
+            $cells = array();
+            $cells[] = "<span class=\"label\">".get_string("jump", "lesson")." $i<span>: ";
+            $cells[] = $this->get_jump_name($answer->jumpto);
+            $table->data[] = new html_table_row($cells);
+            if ($i === 1){
+                $table->data[count($table->data)-1]->cells[0]->style = 'width:20%;';
         }
-        // collect all of the branch tables viewed
-        if ($viewedbranches = get_records_select("lesson_branch", "lessonid = $lesson->id AND userid = $USER->id AND retry = $ntries", 'timeseen DESC', 'pageid, id')) {
-            $viewedpageids = array_merge($viewedpageids, array_keys($viewedbranches));
+            $i++;
+        }
+        return $table;
         }
 
-        // Filter out the following pages:
-        //      End of Cluster
-        //      End of Branch
-        //      Pages found inside of Clusters
-        // Do not filter out Cluster Page(s) because we count a cluster as one.
-        // By keeping the cluster page, we get our 1
-        $validpages = array(); 
-        while ($pageid != 0) {
-            if ($pages[$pageid]->qtype == LESSON_CLUSTER) {
-                $clusterpageid = $pageid; // copy it
-                $validpages[$clusterpageid] = 1;  // add the cluster page as a valid page
-                $pageid = $pages[$pageid]->nextpageid;  // get next page
+    /**
+     * Determines if this page should be grayed out on the management/report screens
+     * @return int 0 or 1
+     */
+    protected function get_grayout() {
+        return 0;
+    }
+
+    /**
+     * Adds stats for this page to the &pagestats object. This should be defined
+     * for all page types that grade
+     * @param array $pagestats
+     * @param int $tries
+     * @return bool
+     */
+    public function stats(array &$pagestats, $tries) {
+        return true;
+    }
             
-                // now, remove all necessary viewed paged ids from the viewedpageids array.
-                while ($pages[$pageid]->qtype != LESSON_ENDOFCLUSTER and $pageid != 0) {
-                    if (in_array($pageid, $viewedpageids)) {
-                        unset($viewedpageids[array_search($pageid, $viewedpageids)]);  // remove it
-                        // since the user did see one page in the cluster, add the cluster pageid to the viewedpageids
-                        if (!in_array($clusterpageid, $viewedpageids)) { 
-                            $viewedpageids[] = $clusterpageid;
+    /**
+     * Formats the answers of this page for a report
+     *
+     * @param object $answerpage
+     * @param object $answerdata
+     * @param object $useranswer
+     * @param array $pagestats
+     * @param int $i Count of first level answers
+     * @param int $n Count of second level answers
+     * @return object The answer page for this
+     */
+    public function report_answers($answerpage, $answerdata, $useranswer, $pagestats, &$i, &$n) {
+        $answers = $this->get_answers();
+        $formattextdefoptions = new stdClass;
+        $formattextdefoptions->para = false;  //I'll use it widely in this page
+        foreach ($answers as $answer) {
+            $data = get_string('jumpsto', 'lesson', $this->get_jump_name($answer->jumpto));
+            $answerdata->answers[] = array($data, "");
+            $answerpage->answerdata = $answerdata;
                         }
+        return $answerpage;
                     }
-                    $pageid = $pages[$pageid]->nextpageid;
+
+    /**
+     * Gets an array of the jumps used by the answers of this page
+     *
+     * @return array
+     */
+    public function get_jumps() {
+        global $DB;
+        $jumps = array();
+        $params = array ("lessonid" => $this->lesson->id, "pageid" => $this->properties->id);
+        if ($answers = $this->get_answers()) {
+            foreach ($answers as $answer) {
+                $jumps[] = $this->get_jump_name($answer->jumpto);
                 }
-            } elseif ($pages[$pageid]->qtype == LESSON_ENDOFCLUSTER or $pages[$pageid]->qtype == LESSON_ENDOFBRANCH) {
-                // dont count these, just go to next
-                $pageid = $pages[$pageid]->nextpageid;
             } else {
-                // a counted page
-                $validpages[$pageid] = 1;
-                $pageid = $pages[$pageid]->nextpageid;
+            $jumps[] = $this->get_jump_name($this->properties->nextpageid);
             }
+        return $jumps;
         }    
-    
-        // progress calculation as a percent
-        $progress = round(count($viewedpageids)/count($validpages), 2) * 100; 
-    } else {
-        $progress = 100;
+    /**
+     * Informs whether this page type require manual grading or not
+     * @return bool
+     */
+    public function requires_manual_grading() {
+        return false;
     }
 
-    // print out the Progress Bar.  Attempted to put as much as possible in the style sheets.
-    echo '<div class="progress_bar" align="center">';
-    echo '<table class="progress_bar_table"><tr>';
-    if ($progress != 0) {  // some browsers do not repsect the 0 width.
-        echo '<td style="width:'.$progress.'%;" class="progress_bar_completed">';
-        echo '</td>';
+    /**
+     * A callback method that allows a page to override the next page a user will
+     * see during when this page is being completed.
+     * @return false|int
+     */
+    public function override_next_page() {
+        return false;
     }
-    echo '<td class="progress_bar_todo">';
-    echo '<div class="progress_bar_token"></div>';
-    echo '</td>';
-    echo '</tr></table>';
-    echo '</div>';
     
-    return true;
+    /**
+     * This method is used to determine if this page is a valid page
+     *
+     * @param array $validpages
+     * @param array $pageviews
+     * @return int The next page id to check
+     */
+    public function valid_page_and_view(&$validpages, &$pageviews) {
+        $validpages[$this->properties->id] = 1;
+        return $this->properties->nextpageid;
+    }
 }
 
+
+
 /**
- * Determines if a user can view the left menu.  The determining factor
- * is whether a user has a grade greater than or equal to the lesson setting
- * of displayleftif
+ * Class used to represent an answer to a page
  *
- * @param object $lesson Lesson object of the current lesson
- * @return boolean 0 if the user cannot see, or $lesson->displayleft to keep displayleft unchanged
- **/
-function lesson_displayleftif($lesson) {
-    global $CFG, $USER;
+ * @property int $id The ID of this answer in the database
+ * @property int $lessonid The ID of the lesson this answer belongs to
+ * @property int $pageid The ID of the page this answer belongs to
+ * @property int $jumpto Identifies where the user goes upon completing a page with this answer
+ * @property int $grade The grade this answer is worth
+ * @property int $score The score this answer will give
+ * @property int $flags Used to store options for the answer
+ * @property int $timecreated A timestamp of when the answer was created
+ * @property int $timemodified A timestamp of when the answer was modified
+ * @property string $answer The answer itself
+ * @property string $response The response the user sees if selecting this answer
+ *
+ * @copyright  2009 Sam Hemelryk
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class lesson_page_answer extends lesson_base {
     
-    if (!empty($lesson->displayleftif)) {
-        // get the current user's max grade for this lesson
-        if ($maxgrade = get_record_sql('SELECT userid, MAX(grade) AS maxgrade FROM '.$CFG->prefix.'lesson_grades WHERE userid = '.$USER->id.' AND lessonid = '.$lesson->id.' GROUP BY userid')) {
-            if ($maxgrade->maxgrade < $lesson->displayleftif) {
-                return 0;  // turn off the displayleft
-            }
-        } else {
-            return 0; // no grades
+    /**
+     * Loads an page answer from the DB
+     *
+     * @param int $id
+     * @return lesson_page_answer
+     */
+    public static function load($id) {
+        global $DB;
+        $answer = $DB->get_record("lesson_answers", array("id" => $id));
+        return new lesson_page_answer($answer);
         }
+
+    /**
+     * Given an object of properties and a page created answer(s) and saves them
+     * in the database.
+     *
+     * @param stdClass $properties
+     * @param lesson_page $page
+     * @return array
+     */
+    public static function create($properties, lesson_page $page) {
+        return $page->create_answers($properties);
     }
     
-    // if we get to here, keep the original state of displayleft lesson setting
-    return $lesson->displayleft;
 }
 
 /**
- * If there is a media file associated with this 
- * lesson, then print it in a block.
+ * A management class for page types
  *
- * @param int $cmid Course Module ID for this lesson
- * @param object $lesson Full lesson record object
- * @return void
- **/
-function lesson_print_mediafile_block($cmid, $lesson) {
-    if (!empty($lesson->mediafile)) {
-        $url      = '/mod/lesson/mediafile.php?id='.$cmid;
-        $options  = 'menubar=0,location=0,left=5,top=5,scrollbars,resizable,width='. $lesson->mediawidth .',height='. $lesson->mediaheight;
-        $name     = 'lessonmediafile';
+ * This class is responsible for managing the different pages. A manager object can
+ * be retrieved by calling the following line of code:
+ * <code>
+ * $manager  = lesson_page_type_manager::get($lesson);
+ * </code>
+ * The first time the page type manager is retrieved the it includes all of the
+ * different page types located in mod/lesson/pagetypes.
+ *
+ * @copyright  2009 Sam Hemelryk
+ * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
+ */
+class lesson_page_type_manager {
 
-        $content  = link_to_popup_window ($url, $name, get_string('mediafilepopup', 'lesson'), '', '', get_string('mediafilepopup', 'lesson'), $options, true);
-        $content .= helpbutton("mediafilestudent", get_string("mediafile", "lesson"), "lesson", true, false, '', true);
+    /**
+     * An array of different page type classes
+     * @var array
+     */
+    protected $types = array();
         
-        print_side_block(get_string('linkedmedia', 'lesson'), $content, NULL, NULL, '', array('class' => 'mediafile'), get_string('linkedmedia', 'lesson'));
+    /**
+     * Retrieves the lesson page type manager object
+     *
+     * If the object hasn't yet been created it is created here.
+     *
+     * @staticvar lesson_page_type_manager $pagetypemanager
+     * @param lesson $lesson
+     * @return lesson_page_type_manager
+     */
+    public static function get(lesson $lesson) {
+        static $pagetypemanager;
+        if (!($pagetypemanager instanceof lesson_page_type_manager)) {
+            $pagetypemanager = new lesson_page_type_manager();
+            $pagetypemanager->load_lesson_types($lesson);
+        }
+        return $pagetypemanager;
     }
-}
 
-/**
- * If a timed lesson and not a teacher, then
- * print the clock
+    /**
+     * Finds and loads all lesson page types in mod/lesson/pagetypes
  *
- * @param int $cmid Course Module ID for this lesson
- * @param object $lesson Full lesson record object
- * @param object $timer Full timer record object
- * @return void
- **/
-function lesson_print_clock_block($cmid, $lesson, $timer) {
+     * @param lesson $lesson
+     */
+    public function load_lesson_types(lesson $lesson) {
     global $CFG;
+        $basedir = $CFG->dirroot.'/mod/lesson/pagetypes/';
+        $dir = dir($basedir);
+        while (false !== ($entry = $dir->read())) {
+            if (strpos($entry, '.')===0 || !preg_match('#^[a-zA-Z]+\.php#i', $entry)) {
+                continue;
+            }
+            require_once($basedir.$entry);
+            $class = 'lesson_page_type_'.strtok($entry,'.');
+            if (class_exists($class)) {
+                $pagetype = new $class(new stdClass, $lesson);
+                $this->types[$pagetype->typeid] = $pagetype;
+            }
+        }
 
-    $context = get_context_instance(CONTEXT_MODULE, $cmid);
+    }
 
-    // Display for timed lessons and for students only
-    if($lesson->timed and !has_capability('mod/lesson:manage', $context) and !empty($timer)) {
-        $content  = '<script type="text/javascript" charset="utf-8">'."\n";
-        $content .= "<!--\n";
-        $content .= '    var starttime  = '.$timer->starttime.";\n";
-        $content .= '    var servertime = '.time().";\n";
-        $content .= '    var testlength = '.($lesson->maxtime * 60).";\n";
-        $content .= '    document.write(\'<script type="text/javascript" src="'.$CFG->wwwroot.'/mod/lesson/timer.js" charset="utf-8"><\/script>\');'."\n";
-        $content .= "    window.onload = function () { show_clock(); };\n";
-        $content .= "// -->\n";
-        $content .= "</script>\n";
-        $content .= "<noscript>\n";
-        $content .= lesson_print_time_remaining($timer->starttime, $lesson->maxtime, true)."\n";
-        $content .= "</noscript>\n";
-    
-        print_side_block(get_string('timeremaining', 'lesson'), $content, NULL, NULL, '', array('class' => 'clock'), get_string('timeremaining', 'lesson'));
+    /**
+     * Returns an array of strings to describe the loaded page types
+     *
+     * @param int $type Can be used to return JUST the string for the requested type
+     * @return array
+     */
+    public function get_page_type_strings($type=null, $special=true) {
+        $types = array();
+        foreach ($this->types as $pagetype) {
+            if (($type===null || $pagetype->type===$type) && ($special===true || $pagetype->is_standard())) {
+                $types[$pagetype->typeid] = $pagetype->typestring;
+            }
+        }
+        return $types;
     }
-}
 
-/**
- * If left menu is turned on, then this will
- * print the menu in a block
+    /**
+     * Returns the basic string used to identify a page type provided with an id
  *
- * @param int $cmid Course Module ID for this lesson
- * @param object $lesson Full lesson record object
- * @return void
- **/
-function lesson_print_menu_block($cmid, $lesson) {
-    global $CFG;
+     * This string can be used to instantiate or identify the page type class.
+     * If the page type id is unknown then 'unknown' is returned
+     *
+     * @param int $id
+     * @return string
+     */
+    public function get_page_type_idstring($id) {
+        foreach ($this->types as $pagetype) {
+            if ((int)$pagetype->typeid === (int)$id) {
+                return $pagetype->idstring;
+            }
+        }
+        return 'unknown';
+    }
 
-    if ($lesson->displayleft) {
-        $pageid = get_field('lesson_pages', 'id', 'lessonid', $lesson->id, 'prevpageid', 0);
-        $pages  = get_records_select('lesson_pages', "lessonid = $lesson->id");
-        $currentpageid = optional_param('pageid', $pageid, PARAM_INT);
+    /**
+     * Loads a page for the provided lesson given it's id
+     *
+     * This function loads a page from the lesson when given both the lesson it belongs
+     * to as well as the page's id.
+     * If the page doesn't exist an error is thrown
+     *
+     * @param int $pageid The id of the page to load
+     * @param lesson $lesson The lesson the page belongs to
+     * @return lesson_page A class that extends lesson_page
+     */
+    public function load_page($pageid, lesson $lesson) {
+        global $DB;
+        if (!($page =$DB->get_record('lesson_pages', array('id'=>$pageid, 'lessonid'=>$lesson->id)))) {
+            print_error('cannotfindpages', 'lesson');
+        }
+        $pagetype = get_class($this->types[$page->qtype]);
+        $page = new $pagetype($page, $lesson);
+        return $page;
+    }
 
-        if ($pageid and $pages) {
-            $content = '<a href="#maincontent" class="skip">'.get_string('skip', 'lesson')."</a>\n<div class=\"menuwrapper\">\n<ul>\n";
+    /**
+     * This function loads ALL pages that belong to the lesson.
+     *
+     * @param lesson $lesson
+     * @return array An array of lesson_page_type_*
+     */
+    public function load_all_pages(lesson $lesson) {
+        global $DB;
+        if (!($pages =$DB->get_records('lesson_pages', array('lessonid'=>$lesson->id)))) {
+            print_error('cannotfindpages', 'lesson');
+        }
+        foreach ($pages as $key=>$page) {
+            $pagetype = get_class($this->types[$page->qtype]);
+            $pages[$key] = new $pagetype($page, $lesson);
+        }
 
-            while ($pageid != 0) {
-                $page = $pages[$pageid];
+        $orderedpages = array();
+        $lastpageid = 0;
 
-                // Only process branch tables with display turned on
-                if ($page->qtype == LESSON_BRANCHTABLE and $page->display) {
-                    if ($page->id == $currentpageid) { 
-                        $content .= '<li class="selected">'.format_string($page->title,true)."</a></li>\n";
+        while (true) {
+            foreach ($pages as $page) {
+                if ((int)$page->prevpageid === (int)$lastpageid) {
+                    $orderedpages[$page->id] = $page;
+                    unset($pages[$page->id]);
+                    $lastpageid = $page->id;
+                    if ((int)$page->nextpageid===0) {
+                        break 2;
                     } else {
-                        $content .= "<li class=\"notselected\"><a href=\"$CFG->wwwroot/mod/lesson/view.php?id=$cmid&amp;pageid=$page->id\">".format_string($page->title,true)."</a></li>\n";
+                        break 1;
                     }
-                    
                 }
-                $pageid = $page->nextpageid;
             }
-            $content .= "</ul>\n</div>\n";
-            print_side_block(get_string('lessonmenu', 'lesson'), $content, NULL, NULL, '', array('class' => 'menu'), get_string('lessonmenu', 'lesson'));
         }
+
+        return $orderedpages;
     }
-}
 
-/**
- * This is not ideal, but checks to see if a
- * column has "block" content.
- *
- * In the future, it would be nice if the lesson
- * media file, timer and navigation were blocks
- * then this would be unnecessary.
+    /**
+     * Fetches an mform that can be used to create/edit an page
  *
- * @uses $CFG
- * @uses $PAGE
- * @param object $lesson Full lesson record object
- * @param array $pageblocks An array of block instances organized by left and right columns
- * @param string $column Pass either BLOCK_POS_RIGHT or BLOCK_POS_LEFT constants
- * @return boolean
- **/
-function lesson_blocks_have_content($lesson, $pageblocks, $column) {
-    global $CFG, $PAGE;
-
-    // First check lesson conditions
-    if ($column == BLOCK_POS_RIGHT) {
-        $managecap = false;
-        if ($cm = get_coursemodule_from_instance('lesson', $lesson->id, $lesson->course)) {
-            $managecap = has_capability('mod/lesson:manage', get_context_instance(CONTEXT_MODULE, $cm->id));
-        }
-        if (($lesson->timed and !$managecap) or !empty($lesson->mediafile)) {
-            return true;
-        }
-    } else if ($column == BLOCK_POS_LEFT) {
-        if ($lesson->displayleft) {
-            return true;
+     * @param int $type The id for the page type
+     * @param array $arguments Any arguments to pass to the mform
+     * @return lesson_add_page_form_base
+     */
+    public function get_page_form($type, $arguments) {
+        $class = 'lesson_add_page_form_'.$this->get_page_type_idstring($type);
+        if (!class_exists($class) || get_parent_class($class)!=='lesson_add_page_form_base') {
+            debugging('Lesson page type unknown class requested '.$class, DEBUG_DEVELOPER);
+            $class = 'lesson_add_page_form_selection';
+        } else if ($class === 'lesson_add_page_form_unknown') {
+            $class = 'lesson_add_page_form_selection';
         }
+        return new $class(null, $arguments);
     }
-    if (!empty($CFG->showblocksonmodpages)) {
-        if ((blocks_have_content($pageblocks, $column) || $PAGE->user_is_editing())) {
-            return true;
+
+    /**
+     * Returns an array of links to use as add page links
+     * @param int $previd The id of the previous page
+     * @return array
+     */
+    public function get_add_page_type_links($previd) {
+        global $OUTPUT;
+
+        $links = array();
+
+        foreach ($this->types as $key=>$type) {
+            if ($link = $type->add_page_link($previd)) {
+                $links[$key] = $link;
         }
     }
 
-    return false;
+        return $links;
+    }
 }
-
-?>
