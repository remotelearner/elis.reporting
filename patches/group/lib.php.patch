diff --git a/group/lib.php b/group/lib.php
index cc72f61..6c9e52c 100644
--- a/group/lib.php
+++ b/group/lib.php
@@ -15,13 +15,32 @@
 
 /**
  * Adds a specified user to a group
- * @param int $userid   The user id
- * @param int $groupid  The group id
+ * @param mixed $groupid  The group id or group object
+ * @param mixed $userid   The user id or user object
  * @return boolean True if user added successfully or the user is already a
  * member of the group, false otherwise.
  */
-function groups_add_member($groupid, $userid) {
-    if (!groups_group_exists($groupid)) {
+function groups_add_member($grouporid, $userorid) {
+    global $DB;
+
+    if (is_object($userorid)) {
+        $userid = $userorid->id;
+        $user   = $userorid;
+    } else {
+        $userid = $userorid;
+        $user = $DB->get_record('user', array('id'=>$userid), '*', MUST_EXIST);
+    }
+
+    if (is_object($grouporid)) {
+        $groupid = $grouporid->id;
+        $group   = $grouporid;
+    } else {
+        $groupid = $grouporid;
+        $group = $DB->get_record('groups', array('id'=>$groupid), '*', MUST_EXIST);
+    }
+
+    //check if the user a participant of the group course
+    if (!is_enrolled(get_context_instance(CONTEXT_COURSE, $group->courseid), $userid)) {
         return false;
     }
 
@@ -29,20 +48,18 @@ function groups_add_member($groupid, $userid) {
         return true;
     }
 
-    $member = new object();
+    $member = new stdClass();
     $member->groupid   = $groupid;
     $member->userid    = $userid;
     $member->timeadded = time();
 
-    if (!insert_record('groups_members', $member)) {
-        return false;
-    }
+    $DB->insert_record('groups_members', $member);
 
     //update group info
-    set_field('groups', 'timemodified', $member->timeadded, 'id', $groupid);
+    $DB->set_field('groups', 'timemodified', $member->timeadded, array('id'=>$groupid));
 
     //trigger groups events
-    $eventdata = new object();
+    $eventdata = new stdClass();
     $eventdata->groupid = $groupid;
     $eventdata->userid  = $userid;
     events_trigger('groups_member_added', $eventdata);
@@ -52,27 +69,40 @@ function groups_add_member($groupid, $userid) {
 
 /**
  * Deletes the link between the specified user and group.
- * @param int $groupid The group to delete the user from
- * @param int $userid The user to delete
+ * @param mixed $groupid  The group id or group object
+ * @param mixed $userid   The user id or user object
  * @return boolean True if deletion was successful, false otherwise
  */
-function groups_remove_member($groupid, $userid) {
-    if (!groups_group_exists($groupid)) {
-        return false;
+function groups_remove_member($grouporid, $userorid) {
+    global $DB;
+
+    if (is_object($userorid)) {
+        $userid = $userorid->id;
+        $user   = $userorid;
+    } else {
+        $userid = $userorid;
+        $user = $DB->get_record('user', array('id'=>$userid), '*', MUST_EXIST);
+    }
+
+    if (is_object($grouporid)) {
+        $groupid = $grouporid->id;
+        $group   = $grouporid;
+    } else {
+        $groupid = $grouporid;
+        $group = $DB->get_record('groups', array('id'=>$groupid), '*', MUST_EXIST);
     }
 
     if (!groups_is_member($groupid, $userid)) {
         return true;
     }
 
-    if (!delete_records('groups_members', 'groupid', $groupid, 'userid', $userid)) {
-        return false;
-    }
+    $DB->delete_records('groups_members', array('groupid'=>$groupid, 'userid'=>$userid));
+
     //update group info
-    set_field('groups', 'timemodified', time(), 'id', $groupid);
+    $DB->set_field('groups', 'timemodified', time(), array('id'=>$groupid));
 
     //trigger groups events
-    $eventdata = new object();
+    $eventdata = new stdClass();
     $eventdata->groupid = $groupid;
     $eventdata->userid  = $userid;
     events_trigger('groups_member_removed', $eventdata);
@@ -82,104 +112,164 @@ function groups_remove_member($groupid, $userid) {
 
 /**
  * Add a new group
- * @param object $data group properties (with magic quotes)
+ * @param object $data group properties
  * @param object $um upload manager with group picture
  * @return id of group or false if error
  */
-function groups_create_group($data, $um=false) {
-    global $CFG;
-    require_once("$CFG->libdir/gdlib.php");
+function groups_create_group($data, $editform = false, $editoroptions = false) {
+    global $CFG, $DB;
+
+    //check that courseid exists
+    $course = $DB->get_record('course', array('id' => $data->courseid), '*', MUST_EXIST);
+    $context = get_context_instance(CONTEXT_COURSE, $course->id);
 
     $data->timecreated = time();
     $data->timemodified = $data->timecreated;
     $data->name = trim($data->name);
-    $id = insert_record('groups', $data);
 
-    if ($id) {
-        $data->id = $id;
-        if ($um) {
-            //update image
-            if (save_profile_image($id, $um, 'groups')) {
-                set_field('groups', 'picture', 1, 'id', $id);
+    if ($editform and $editoroptions) {
+        $data->description = $data->description_editor['text'];
+        $data->descriptionformat = $data->description_editor['format'];
             }
-            $data->picture = 1;
+
+    $data->id = $DB->insert_record('groups', $data);
+
+    if ($editform and $editoroptions) {
+        // Update description from editor with fixed files
+        $data = file_postupdate_standard_editor($data, 'description', $editoroptions, $context, 'group', 'description', $data->id);
+        $upd = new stdClass();
+        $upd->id                = $data->id;
+        $upd->description       = $data->description;
+        $upd->descriptionformat = $data->descriptionformat;
+        $DB->update_record('groups', $upd);
         }
 
-        //trigger groups events
-        events_trigger('groups_group_created', stripslashes_recursive($data));
+    $group = $DB->get_record('groups', array('id'=>$data->id));
+
+    if ($editform) {
+        groups_update_group_icon($group, $data, $editform);
     }
 
-    return $id;
+    //trigger groups events
+    events_trigger('groups_group_created', $group);
+
+    return $group->id;
 }
 
 /**
  * Add a new grouping
- * @param object $data grouping properties (with magic quotes)
+ * @param object $data grouping properties
  * @return id of grouping or false if error
  */
-function groups_create_grouping($data) {
-    global $CFG;
+function groups_create_grouping($data, $editoroptions=null) {
+    global $DB;
 
     $data->timecreated = time();
     $data->timemodified = $data->timecreated;
     $data->name = trim($data->name);
 
-    $id = insert_record('groupings', $data);
+    if ($editoroptions !== null) {
+        $data->description = $data->description_editor['text'];
+        $data->descriptionformat = $data->description_editor['format'];
+    }
+
+    $id = $DB->insert_record('groupings', $data);
     
-    if ($id) {
         //trigger groups events
         $data->id = $id;
-        events_trigger('groups_grouping_created', stripslashes_recursive($data));
+
+    if ($editoroptions !== null) {
+        $description = new stdClass;
+        $description->id = $data->id;
+        $description->description_editor = $data->description_editor;
+        $description = file_postupdate_standard_editor($description, 'description', $editoroptions, $editoroptions['context'], 'grouping', 'description', $description->id);
+        $DB->update_record('groupings', $description);
     }
 
+    events_trigger('groups_grouping_created', $data);
+
     return $id;
 }
 
 /**
+ * Update the group icon from form data
+ * @param $group
+ * @param $data
+ * @param $editform
+ */
+function groups_update_group_icon($group, $data, $editform) {
+    global $CFG, $DB;
+    require_once("$CFG->libdir/gdlib.php");
+
+    $fs = get_file_storage();
+    $context = get_context_instance(CONTEXT_COURSE, $group->courseid, MUST_EXIST);
+
+    //TODO: it would make sense to allow picture deleting too (skodak)
+
+    if ($iconfile = $editform->save_temp_file('imagefile')) {
+        if (process_new_icon($context, 'group', 'icon', $group->id, $iconfile)) {
+            $DB->set_field('groups', 'picture', 1, array('id'=>$group->id));
+            $group->picture = 1;
+        } else {
+            $fs->delete_area_files($context->id, 'group', 'icon', $group->id);
+            $DB->set_field('groups', 'picture', 0, array('id'=>$group->id));
+            $group->picture = 0;
+        }
+        @unlink($iconfile);
+    }
+}
+
+/**
  * Update group
  * @param object $data group properties (with magic quotes)
- * @param object $um upload manager with group picture
- * @return boolean success
+ * @param object $editform
+ * @param array $editoroptions
+ * @return boolean true or exception
  */
-function groups_update_group($data, $um=false) {
-    global $CFG;
-    require_once("$CFG->libdir/gdlib.php");
+function groups_update_group($data, $editform = false, $editoroptions = false) {
+    global $CFG, $DB;
+
+    $context = get_context_instance(CONTEXT_COURSE, $data->courseid);
 
     $data->timemodified = time();
     $data->name = trim($data->name);
-    $result = update_record('groups', $data);
 
-    if ($result) {
-        if ($um) {
-            //update image
-            if (save_profile_image($data->id, $um, 'groups')) {
-                set_field('groups', 'picture', 1, 'id', $data->id);
-                $data->picture = 1;
+    if ($editform and $editoroptions) {
+        $data = file_postupdate_standard_editor($data, 'description', $editoroptions, $context, 'group', 'description', $data->id);
             }
+
+    $DB->update_record('groups', $data);
+
+    $group = $DB->get_record('groups', array('id'=>$data->id));
+
+    if ($editform) {
+        groups_update_group_icon($group, $data, $editform);
         }
 
         //trigger groups events
-        events_trigger('groups_group_updated', stripslashes_recursive($data));
-    }
+    events_trigger('groups_group_updated', $group);
+
 
-    return $result;
+    return true;
 }
 
 /**
  * Update grouping
  * @param object $data grouping properties (with magic quotes)
- * @return boolean success
+ * @return boolean true or exception
  */
-function groups_update_grouping($data) {
-    global $CFG;
+function groups_update_grouping($data, $editoroptions=null) {
+    global $DB;
     $data->timemodified = time();
     $data->name = trim($data->name);
-    $result = update_record('groupings', $data);
-    if ($result) {
-        //trigger groups events
-        events_trigger('groups_grouping_updated', stripslashes_recursive($data));
+    if ($editoroptions !== null) {
+        $data = file_postupdate_standard_editor($data, 'description', $editoroptions, $editoroptions['context'], 'grouping', 'description', $data->id);
     }
-    return $result;
+    $DB->update_record('groupings', $data);
+    //trigger groups events
+    events_trigger('groups_grouping_updated', $data);
+
+    return true;
 }
 
 /**
@@ -189,36 +279,39 @@ function groups_update_grouping($data) {
  * @return boolean True if deletion was successful, false otherwise
  */
 function groups_delete_group($grouporid) {
-    global $CFG;
-    require_once($CFG->libdir.'/gdlib.php');
+    global $CFG, $DB;
+    require_once("$CFG->libdir/gdlib.php");
 
     if (is_object($grouporid)) {
         $groupid = $grouporid->id;
         $group   = $grouporid;
     } else {
         $groupid = $grouporid;
-        if (!$group = get_record('groups', 'id', $groupid)) {
-            return false;
+        if (!$group = $DB->get_record('groups', array('id'=>$groupid))) {
+            //silently ignore attempts to delete missing already deleted groups ;-)
+            return true;
         }
     }
 
     // delete group calendar events
-    delete_records('event', 'groupid', $groupid);
+    $DB->delete_records('event', array('groupid'=>$groupid));
     //first delete usage in groupings_groups
-    delete_records('groupings_groups', 'groupid', $groupid);
+    $DB->delete_records('groupings_groups', array('groupid'=>$groupid));
     //delete members
-    delete_records('groups_members', 'groupid', $groupid);
-    //then imge
-    delete_profile_image($groupid, 'groups');
+    $DB->delete_records('groups_members', array('groupid'=>$groupid));
     //group itself last
-    $result = delete_records('groups', 'id', $groupid);
+    $DB->delete_records('groups', array('id'=>$groupid));
+
+    // Delete all files associated with this group
+    $context = get_context_instance(CONTEXT_COURSE, $group->courseid);
+    $fs = get_file_storage();
+    $fs->delete_area_files($context->id, 'group', 'description', $groupid);
+    $fs->delete_area_files($context->id, 'group', 'icon', $groupid);
 
-    if ($result) {
         //trigger groups events
         events_trigger('groups_group_deleted', $group);
-    }
 
-    return $result;
+    return true;
 }
 
 /**
@@ -227,31 +320,39 @@ function groups_delete_group($grouporid) {
  * @return bool success
  */
 function groups_delete_grouping($groupingorid) {
+    global $DB;
+
     if (is_object($groupingorid)) {
         $groupingid = $groupingorid->id;
         $grouping   = $groupingorid;
     } else {
         $groupingid = $groupingorid;
-        if (!$grouping = get_record('groupings', 'id', $groupingorid)) {
-            return false;
+        if (!$grouping = $DB->get_record('groupings', array('id'=>$groupingorid))) {
+            //silently ignore attempts to delete missing already deleted groupings ;-)
+            return true;
         }
     }
 
     //first delete usage in groupings_groups
-    delete_records('groupings_groups', 'groupingid', $groupingid);
+    $DB->delete_records('groupings_groups', array('groupingid'=>$groupingid));
     // remove the default groupingid from course
-    set_field('course', 'defaultgroupingid', 0, 'defaultgroupingid', $groupingid);
+    $DB->set_field('course', 'defaultgroupingid', 0, array('defaultgroupingid'=>$groupingid));
     // remove the groupingid from all course modules
-    set_field('course_modules', 'groupingid', 0, 'groupingid', $groupingid);
+    $DB->set_field('course_modules', 'groupingid', 0, array('groupingid'=>$groupingid));
     //group itself last
-    $result = delete_records('groupings', 'id', $groupingid);
+    $DB->delete_records('groupings', array('id'=>$groupingid));
+
+    $context = get_context_instance(CONTEXT_COURSE, $grouping->courseid);
+    $fs = get_file_storage();
+    $files = $fs->get_area_files($context->id, 'grouping', 'description', $groupingid);
+    foreach ($files as $file) {
+        $file->delete();
+    }
 
-    if ($result) {
         //trigger groups events
         events_trigger('groups_grouping_deleted', $grouping);
-    }
 
-    return $result;
+    return true;
 }
 
 /**
@@ -262,30 +363,33 @@ function groups_delete_grouping($groupingorid) {
  * @return bool success
  */
 function groups_delete_group_members($courseid, $userid=0, $showfeedback=false) {
-    global $CFG;
+    global $DB, $OUTPUT;
 
     if (is_bool($userid)) {
         debugging('Incorrect userid function parameter');
         return false;
     }
 
+    $params = array('courseid'=>$courseid);
+
     if ($userid) {
-        $usersql = "AND userid = $userid";
+        $usersql = "AND userid = :userid";
+        $params['userid'] = $userid;
     } else {
         $usersql = "";
     }
 
-    $groupssql = "SELECT id FROM {$CFG->prefix}groups g WHERE g.courseid = $courseid";
-    delete_records_select('groups_members', "groupid IN ($groupssql) $usersql");
+    $groupssql = "SELECT id FROM {groups} g WHERE g.courseid = :courseid";
+    $DB->delete_records_select('groups_members', "groupid IN ($groupssql) $usersql", $params);
 
     //trigger groups events
-    $eventdata = new object();
+    $eventdata = new stdClass();
     $eventdata->courseid = $courseid;
     $eventdata->userid   = $userid;
     events_trigger('groups_members_removed', $eventdata);
 
     if ($showfeedback) {
-        notify(get_string('deleted').' groups_members');
+        echo $OUTPUT->notification(get_string('deleted').' groups_members');
     }
 
     return true;
@@ -298,16 +402,19 @@ function groups_delete_group_members($courseid, $userid=0, $showfeedback=false)
  * @return bool success
  */
 function groups_delete_groupings_groups($courseid, $showfeedback=false) {
-    global $CFG;
+    global $DB, $OUTPUT;
+
+    $groupssql = "SELECT id FROM {groups} g WHERE g.courseid = ?";
+    $DB->delete_records_select('groupings_groups', "groupid IN ($groupssql)", array($courseid));
 
-    $groupssql = "SELECT id FROM {$CFG->prefix}groups g WHERE g.courseid = $courseid";
-    delete_records_select('groupings_groups', "groupid IN ($groupssql)");
+    // Delete all files associated with groupings for this course
+    $context = get_context_instance(CONTEXT_COURSE, $courseid);
 
     //trigger groups events
     events_trigger('groups_groupings_groups_removed', $courseid);
 
     if ($showfeedback) {
-        notify(get_string('deleted').' groupings_groups');
+        echo $OUTPUT->notification(get_string('deleted').' groupings_groups');
     }
 
     return true;
@@ -320,32 +427,33 @@ function groups_delete_groupings_groups($courseid, $showfeedback=false) {
  * @return bool success
  */
 function groups_delete_groups($courseid, $showfeedback=false) {
-    global $CFG;
-    require_once($CFG->libdir.'/gdlib.php');
-
-    $groupssql = "SELECT id FROM {$CFG->prefix}groups g WHERE g.courseid = $courseid";
+    global $CFG, $DB, $OUTPUT;
 
     // delete any uses of groups
+    // Any associated files are deleted as part of groups_delete_groupings_groups
     groups_delete_groupings_groups($courseid, $showfeedback);
     groups_delete_group_members($courseid, 0, $showfeedback);
 
-    // delete group pictures
-    if ($groups = get_records('groups', 'courseid', $courseid)) {
-        foreach($groups as $group) {
-            delete_profile_image($group->id, 'groups');
-        }
-    }
+    // delete group pictures and descriptions
+    $context = get_context_instance(CONTEXT_COURSE, $courseid);
+    $fs = get_file_storage();
+    $fs->delete_area_files($context->id, 'group');
 
     // delete group calendar events
-    delete_records_select('event', "groupid IN ($groupssql)");
+    $groupssql = "SELECT id FROM {groups} g WHERE g.courseid = ?";
+    $DB->delete_records_select('event', "groupid IN ($groupssql)", array($courseid));
 
-    delete_records('groups', 'courseid', $courseid);
+    $context = get_context_instance(CONTEXT_COURSE, $courseid);
+    $fs = get_file_storage();
+    $fs->delete_area_files($context->id, 'group');
+
+    $DB->delete_records('groups', array('courseid'=>$courseid));
 
     //trigger groups events
     events_trigger('groups_groups_deleted', $courseid);
 
     if ($showfeedback) {
-        notify(get_string('deleted').' groups');
+        echo $OUTPUT->notification(get_string('deleted').' groups');
     }
 
     return true;
@@ -358,25 +466,33 @@ function groups_delete_groups($courseid, $showfeedback=false) {
  * @return bool success
  */
 function groups_delete_groupings($courseid, $showfeedback=false) {
-    global $CFG;
+    global $DB, $OUTPUT;
+
+    $context = get_context_instance(CONTEXT_COURSE, $courseid);
+    $fs = get_file_storage();
 
     // delete any uses of groupings
-    $sql = "DELETE FROM {$CFG->prefix}groupings_groups
-             WHERE groupingid in (SELECT id FROM {$CFG->prefix}groupings g WHERE g.courseid = $courseid)";
-    execute_sql($sql, false);
+    $sql = "DELETE FROM {groupings_groups}
+             WHERE groupingid in (SELECT id FROM {groupings} g WHERE g.courseid = ?)";
+    $DB->execute($sql, array($courseid));
 
     // remove the default groupingid from course
-    set_field('course', 'defaultgroupingid', 0, 'id', $courseid);
+    $DB->set_field('course', 'defaultgroupingid', 0, array('id'=>$courseid));
     // remove the groupingid from all course modules
-    set_field('course_modules', 'groupingid', 0, 'course', $courseid);
+    $DB->set_field('course_modules', 'groupingid', 0, array('course'=>$courseid));
+
+    // Delete all files associated with groupings for this course
+    $context = get_context_instance(CONTEXT_COURSE, $courseid);
+    $fs = get_file_storage();
+    $fs->delete_area_files($context->id, 'grouping');
 
-    delete_records('groupings', 'courseid', $courseid);
+    $DB->delete_records('groupings', array('courseid'=>$courseid));
 
     //trigger groups events
     events_trigger('groups_groupings_deleted', $courseid);
 
     if ($showfeedback) {
-        notify(get_string('deleted').' groupings');
+        echo $OUTPUT->notification(get_string('deleted').' groupings');
     }
 
     return true;
@@ -387,94 +503,14 @@ function groups_delete_groupings($courseid, $showfeedback=false) {
 /* =================================== */
 
 /**
- * Gets the users for a course who are not in a specified group, and returns
- * them in an array organised by role. For the array format, see 
- * groups_get_members_by_role.
- * @param int $groupid The id of the group
- * @param string searchtext similar to searchtext in role assign, search
- * @return array An array of role id or '*' => information about that role 
- *   including a list of users
- */
-function groups_get_users_not_in_group_by_role($courseid, $groupid, $searchtext='', $sort = 'u.lastname ASC') {
-
-    global $CFG;
-    $context = get_context_instance(CONTEXT_COURSE, $courseid);
-    
-    if ($searchtext !== '') {   // Search for a subset of remaining users
-        $LIKE      = sql_ilike();
-        $FULLNAME  = sql_fullname();
-        $wheresearch = " AND u.id IN (SELECT id FROM {$CFG->prefix}user WHERE $FULLNAME $LIKE '%$searchtext%' OR email $LIKE '%$searchtext%' )";
-    } else {
-        $wheresearch = '';
-    }
-
-/// Get list of allowed roles     
-    if(!($validroleids=groups_get_possible_roles($context))) {
-        return;
-    }
-    $roleids = '('.implode(',', $validroleids).')';
-
-/// Construct the main SQL
-    $select = " SELECT r.id AS roleid,r.shortname AS roleshortname,r.name AS rolename,
-                       u.id AS userid, u.firstname, u.lastname";
-    $from   = " FROM {$CFG->prefix}user u
-                INNER JOIN {$CFG->prefix}role_assignments ra ON ra.userid = u.id
-                INNER JOIN {$CFG->prefix}role r ON r.id = ra.roleid";
-
-    $where  = " WHERE ra.contextid ".get_related_contexts_string($context)."
-                  AND u.deleted = 0
-                  AND ra.roleid in $roleids
-                  AND u.id NOT IN (SELECT userid
-                                   FROM {$CFG->prefix}groups_members
-                                   WHERE groupid = $groupid)
-                  $wheresearch";
-    $orderby = " ORDER BY $sort";
-
-    return groups_calculate_role_people(get_recordset_sql(
-        $select.$from.$where.$orderby),$context);
-}
-
-
-/**
  * Obtains a list of the possible roles that group members might come from,
- * on a course. Generally this includes all the roles who would have 
- * course:view on that course, except the doanything roles.
+ * on a course. Generally this includes only profile roles.
  * @param object $context Context of course
  * @return Array of role ID integers, or false if error/none.
  */
 function groups_get_possible_roles($context) {
-    $capability = 'moodle/course:view';
-    $doanything = false;
-
-    // find all possible "student" roles
-    if ($possibleroles = get_roles_with_capability($capability, CAP_ALLOW, $context)) {
-        if (!$doanything) {
-            if (!$sitecontext = get_context_instance(CONTEXT_SYSTEM)) {
-                return false;    // Something is seriously wrong
-            }
-            $doanythingroles = get_roles_with_capability('moodle/site:doanything', CAP_ALLOW, $sitecontext);
-        }
-
-        $validroleids = array();
-        foreach ($possibleroles as $possiblerole) {
-            if (!$doanything) {
-                if (isset($doanythingroles[$possiblerole->id])) {  // We don't want these included
-                    continue;
-                }
-            }
-            if ($caps = role_context_capabilities($possiblerole->id, $context, $capability)) { // resolved list
-                if (isset($caps[$capability]) && $caps[$capability] > 0) { // resolved capability > 0
-                    $validroleids[] = $possiblerole->id;
-                }
-            }
-        }
-        if (empty($validroleids)) {
-            return false;
-        }
-        return $validroleids;
-    } else {
-        return false;  // No need to continue, since no roles have this capability set
-    }    
+    $roles = get_profile_roles($context);
+    return array_keys($roles);
 }
 
 
@@ -482,69 +518,44 @@ function groups_get_possible_roles($context) {
  * Gets potential group members for grouping
  * @param int $courseid The id of the course
  * @param int $roleid The role to select users from
- * @param string $orderby The colum to sort users by
+ * @param int $cohortid restrict to cohort id
+ * @param string $orderby The column to sort users by
  * @return array An array of the users
  */
-function groups_get_potential_members($courseid, $roleid = null, $orderby = 'lastname,firstname') {
-	global $CFG;
+function groups_get_potential_members($courseid, $roleid = null, $cohortid = null, $orderby = 'lastname ASC, firstname ASC') {
+    global $DB;
 
     $context = get_context_instance(CONTEXT_COURSE, $courseid);
-    $sitecontext = get_context_instance(CONTEXT_SYSTEM);
-    $rolenames = array();
-    $avoidroles = array();
-
-    if ($roles = get_roles_used_in_context($context, true)) {
 
-        $canviewroles    = get_roles_with_capability('moodle/course:view', CAP_ALLOW, $context);
-        $doanythingroles = get_roles_with_capability('moodle/site:doanything', CAP_ALLOW, $sitecontext);
-
-        foreach ($roles as $role) {
-            if (!isset($canviewroles[$role->id])) {   // Avoid this role (eg course creator)
-                $avoidroles[] = $role->id;
-                unset($roles[$role->id]);
-                continue;
-            }
-            if (isset($doanythingroles[$role->id])) {   // Avoid this role (ie admin)
-                $avoidroles[] = $role->id;
-                unset($roles[$role->id]);
-                continue;
-            }
-            $rolenames[$role->id] = strip_tags(role_get_name($role, $context));   // Used in menus etc later on
-        }
-    }
-
-    $select = 'SELECT u.id, u.username, u.firstname, u.lastname, u.idnumber ';
-    $from   = "FROM {$CFG->prefix}user u INNER JOIN
-               {$CFG->prefix}role_assignments r on u.id=r.userid ";
+    // we are looking for all users with this role assigned in this context or higher
+    $listofcontexts = get_related_contexts_string($context);
 
-    if ($avoidroles) {
-        $adminroles = 'AND r.roleid NOT IN (';
-        $adminroles .= implode(',', $avoidroles);
-        $adminroles .= ')';
-    } else {
-        $adminroles = '';
-    }
+    list($esql, $params) = get_enrolled_sql($context);
 
-    // we are looking for all users with this role assigned in this context or higher
-    if ($usercontexts = get_parent_contexts($context)) {
-        $listofcontexts = '('.implode(',', $usercontexts).')';
+    if ($roleid) {
+        $params['roleid'] = $roleid;
+        $where = "WHERE u.id IN (SELECT userid
+                                   FROM {role_assignments}
+                                  WHERE roleid = :roleid AND contextid $listofcontexts)";
     } else {
-        $listofcontexts = '('.$sitecontext->id.')'; // must be site
+        $where = "";
     }
 
-    if ($roleid) {
-        $selectrole = " AND r.roleid = $roleid ";
+    if ($cohortid) {
+        $cohortjoin = "JOIN {cohort_members} cm ON (cm.userid = u.id AND cm.cohortid = :cohortid)";
+        $params['cohortid'] = $cohortid;
     } else {
-        $selectrole = " ";
+        $cohortjoin = "";
     }
 
-    $where  = "WHERE (r.contextid = $context->id OR r.contextid in $listofcontexts)
-                     AND u.deleted = 0 $selectrole
-                     AND u.username != 'guest'
-                     $adminroles ";
-    $order = "ORDER BY $orderby ";
+    $sql = "SELECT u.id, u.username, u.firstname, u.lastname, u.idnumber
+              FROM {user} u
+              JOIN ($esql) e ON e.id = u.id
+       $cohortjoin
+            $where
+          ORDER BY $orderby";
 
-    return(get_records_sql($select.$from.$where.$order));
+    return $DB->get_records_sql($sql, $params);
 
 }
 
@@ -571,17 +582,21 @@ function groups_parse_name($format, $groupnumber) {
  * Assigns group into grouping
  * @param int groupingid
  * @param int groupid
- * @return bool success
+ * @return bool true or exception
  */
 function groups_assign_grouping($groupingid, $groupid) {
-    if (record_exists('groupings_groups', 'groupingid', $groupingid, 'groupid', $groupid)) {
+    global $DB;
+
+    if ($DB->record_exists('groupings_groups', array('groupingid'=>$groupingid, 'groupid'=>$groupid))) {
         return true;
     }
-    $assign = new object();
+    $assign = new stdClass();
     $assign->groupingid = $groupingid;
     $assign->groupid = $groupid;
     $assign->timeadded = time();
-    return (bool)insert_record('groupings_groups', $assign);
+    $DB->insert_record('groupings_groups', $assign);
+
+    return true;
 }
 
 /**
@@ -591,7 +606,10 @@ function groups_assign_grouping($groupingid, $groupid) {
  * @return bool success
  */
 function groups_unassign_grouping($groupingid, $groupid) {
-    return delete_records('groupings_groups', 'groupingid', $groupingid, 'groupid', $groupid);
+    global $DB;
+    $DB->delete_records('groupings_groups', array('groupingid'=>$groupingid, 'groupid'=>$groupid));
+
+    return true;
 }
 
 /**
@@ -608,26 +626,35 @@ function groups_unassign_grouping($groupingid, $groupid) {
  * @param int $courseid Course ID (should match the group's course)
  * @param string $fields List of fields from user table prefixed with u, default 'u.*'
  * @param string $sort SQL ORDER BY clause, default 'u.lastname ASC'
+ * @param string $extrawheretest extra SQL conditions ANDed with the existing where clause.
+ * @param array $whereparams any parameters required by $extrawheretest (named parameters).
  * @return array Complex array as described above
  */
-function groups_get_members_by_role($groupid, $courseid, $fields='u.*', $sort='u.lastname ASC') {
-    global $CFG;
+function groups_get_members_by_role($groupid, $courseid, $fields='u.*',
+        $sort='u.lastname ASC', $extrawheretest='', $whereparams=array()) {
+    global $CFG, $DB;
 
     // Retrieve information about all users and their roles on the course or
     // parent ('related') contexts 
-    $context=get_context_instance(CONTEXT_COURSE,$courseid);
-    $rs=get_recordset_sql($crap="SELECT r.id AS roleid,r.shortname AS roleshortname,r.name AS rolename,
-                                        u.id AS userid,$fields
-                                  FROM {$CFG->prefix}groups_members gm
-                            INNER JOIN {$CFG->prefix}user u ON u.id = gm.userid
-                            INNER JOIN {$CFG->prefix}role_assignments ra 
-                                       ON ra.userid = u.id 
-                            INNER JOIN {$CFG->prefix}role r ON r.id = ra.roleid
-                                 WHERE gm.groupid='$groupid'
-                                   AND ra.contextid ".get_related_contexts_string($context)."
-                              ORDER BY r.sortorder,$sort");
-
-    return groups_calculate_role_people($rs,$context);
+    $context = get_context_instance(CONTEXT_COURSE, $courseid);
+
+    if ($extrawheretest) {
+        $extrawheretest = ' AND ' . $extrawheretest;
+    }
+
+    $sql = "SELECT r.id AS roleid, r.shortname AS roleshortname, r.name AS rolename,
+                   u.id AS userid, $fields
+              FROM {groups_members} gm
+              JOIN {user} u ON u.id = gm.userid
+         LEFT JOIN {role_assignments} ra ON (ra.userid = u.id AND ra.contextid ".get_related_contexts_string($context).")
+         LEFT JOIN {role} r ON r.id = ra.roleid
+             WHERE gm.groupid=:mgroupid
+                   ".$extrawheretest."
+          ORDER BY r.sortorder, $sort";
+    $whereparams['mgroupid'] = $groupid;
+    $rs = $DB->get_recordset_sql($sql, $whereparams);
+
+    return groups_calculate_role_people($rs, $context);
 }
 
 /**
@@ -636,87 +663,94 @@ function groups_get_members_by_role($groupid, $courseid, $fields='u.*', $sort='u
  * roles on a course.
  *
  * @param object $rs The record set (may be false)
- * @param object $context of course
+ * @param int $contextid ID of course context
  * @return array As described in groups_get_members_by_role 
  */
-function groups_calculate_role_people($rs,$context) {
-    global $CFG;
-    if(!$rs) {
-        return false;
+function groups_calculate_role_people($rs, $context) {
+    global $CFG, $DB;
+
+    if (!$rs) {
+        return array();
     }
     
-    $roles = get_records_menu('role', null, 'name', 'id, name');
+    $roles = $DB->get_records_menu('role', null, 'name', 'id, name');
     $aliasnames = role_fix_names($roles, $context);
 
     // Array of all involved roles
-    $roles=array();
+    $roles = array();
     // Array of all retrieved users
-    $users=array();
+    $users = array();
     // Fill arrays
-    while($rec=rs_fetch_next_record($rs)) {
+    foreach ($rs as $rec) {
         // Create information about user if this is a new one
-        if(!array_key_exists($rec->userid,$users)) {
+        if (!array_key_exists($rec->userid, $users)) {
             // User data includes all the optional fields, but not any of the
             // stuff we added to get the role details
-            $userdata=clone($rec);
+            $userdata = clone($rec);
             unset($userdata->roleid);
             unset($userdata->roleshortname);
             unset($userdata->rolename);
             unset($userdata->userid);
-            $userdata->id=$rec->userid;
+            $userdata->id = $rec->userid;
 
             // Make an array to hold the list of roles for this user
-            $userdata->roles=array();
-            $users[$rec->userid]=$userdata;
+            $userdata->roles = array();
+            $users[$rec->userid] = $userdata;
         }
         // If user has a role...
-        if(!is_null($rec->roleid)) {
+        if (!is_null($rec->roleid)) {
             // Create information about role if this is a new one
-            if(!array_key_exists($rec->roleid,$roles)) {
-                $roledata=new StdClass;
-                $roledata->id=$rec->roleid;
-                $roledata->shortname=$rec->roleshortname;
-                if(array_key_exists($rec->roleid,$aliasnames)) {
-                    $roledata->name=$aliasnames[$rec->roleid];
+            if (!array_key_exists($rec->roleid,$roles)) {
+                $roledata = new stdClass();
+                $roledata->id        = $rec->roleid;
+                $roledata->shortname = $rec->roleshortname;
+                if (array_key_exists($rec->roleid, $aliasnames)) {
+                    $roledata->name = $aliasnames[$rec->roleid];
                 } else {
-                    $roledata->name=$rec->rolename;
+                    $roledata->name = $rec->rolename;
                 }
-                $roledata->users=array();
-                $roles[$roledata->id]=$roledata;
+                $roledata->users = array();
+                $roles[$roledata->id] = $roledata;
             }
             // Record that user has role
             $users[$rec->userid]->roles[] = $roles[$rec->roleid];
         }
     }
-    rs_close($rs);
+    $rs->close();
 
     // Return false if there weren't any users
-    if(count($users)==0) {
+    if (count($users) == 0) {
         return false;
     }
 
     // Add pseudo-role for multiple roles
-    $roledata=new StdClass;
-    $roledata->name=get_string('multipleroles','role');
-    $roledata->users=array();
-    $roles['*']=$roledata;
+    $roledata = new stdClass();
+    $roledata->name = get_string('multipleroles','role');
+    $roledata->users = array();
+    $roles['*'] = $roledata;
+
+    $roledata = new stdClass();
+    $roledata->name = get_string('noroles','role');
+    $roledata->users = array();
+    $roles[0] = $roledata;
 
     // Now we rearrange the data to store users by role
-    foreach($users as $userid=>$userdata) {
-        $rolecount=count($userdata->roles);
-        if($rolecount==0) {
-            debugging("Unexpected: user $userid is missing roles");
-        } else if($rolecount>1) {
-            $roleid='*';
+    foreach ($users as $userid=>$userdata) {
+        $rolecount = count($userdata->roles);
+        if ($rolecount == 0) {
+            // does not have any roles
+            $roleid = 0;
+        } else if($rolecount > 1) {
+            $roleid = '*';
         } else {
-            $roleid=$userdata->roles[0]->id;
+            $roleid = $userdata->roles[0]->id;
         }
-        $roles[$roleid]->users[$userid]=$userdata;
+        $roles[$roleid]->users[$userid] = $userdata;
     }
 
     // Delete roles not used
-    foreach($roles as $key=>$roledata) {
-        if(count($roledata->users)===0) {
+    foreach ($roles as $key=>$roledata) {
+        if (count($roledata->users)===0) {
             unset($roles[$key]);
         }
     }
@@ -724,5 +758,3 @@ function groups_calculate_role_people($rs,$context) {
     // Return list of roles containing their users
     return $roles;
 }
-
-?>
